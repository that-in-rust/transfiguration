{
  "input": "List out all the keywords for LLM prompts to deeply research Rust Programming language end to end, each and every concept, ever idiomatic pattern, every anti-pattern, every feature, every important library, every comparison with other languages and their features for relatability, every CSE concept every thought of in relation to Rust\n\nMake a super comprehensive list so I can search them using LLMs and build my own mega Rust knowledge base, could be an esoteric cool code pattern, could be anything",
  "output": {
    "summary_of_rust_research_areas": "The Rust programming language encompasses a vast and interconnected set of domains, centered on its core principles of performance, reliability, and productivity. At its foundation lies a unique memory management model defined by ownership, borrowing, and lifetimes, which guarantees memory safety and prevents data races at compile time without a garbage collector. This model is complemented by a rich type system featuring powerful algebraic data types (structs and enums), generics, and a highly expressive trait system for abstraction and polymorphism. The language's syntax is expression-oriented, with powerful control flow constructs like pattern matching. For advanced use cases, Rust provides an 'unsafe' escape hatch for low-level systems programming, a robust Foreign Function Interface (FFI) for interoperability with languages like C, C++, and Python, and a sophisticated metaprogramming system through declarative and procedural macros. The ecosystem is supported by best-in-class tooling, including the Cargo build system and package manager, the `rustup` toolchain manager, `rust-analyzer` for IDE support, and `clippy` for linting. Rust is applied across numerous domains, from high-performance web services and networking with frameworks like Axum and Tokio, to data engineering with libraries like Polars and SQLx, and systems programming in embedded devices and operating system kernels, as seen in the Rust-for-Linux project. Its feature set invites direct comparisons with languages like C++, Go, and Python, often highlighting trade-offs between learning curve, raw performance, and safety guarantees.",
    "language_foundations_keywords": [
      {
        "category": "Keywords and Identifiers",
        "description": "The reserved words, identifier rules, and naming conventions that form the basic vocabulary of the Rust language.",
        "keywords": "Strict Keywords, Reserved Keywords, Weak Keywords, as, break, const, fn, if, let, loop, match, mod, mut, pub, return, self, Self, static, struct, super, trait, true, type, unsafe, use, where, while, async, await, dyn, abstract, become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield, try, gen, union, macro_rules, 'static, raw identifiers, r#, underscore, naming conventions, Unicode Standard Annex #31, XID_Start, XID_Continue, Normalization Form C (NFC)"
      },
      {
        "category": "Literals, Primitives, and Types",
        "description": "The basic data representations and built-in types for numbers, text, booleans, and simple compound structures.",
        "keywords": "Numeric Literals, Integer Literals, Floating-point Literals, Type Suffixes, 42u32, 3.14f64, Underscore Separators, 1_000_000, Boolean Literals, true, false, Character Literals, String Literals, &'static str, Byte String Literals, Raw String Literals, r#\"...\"#, Compound Type Literals, Tuples, Arrays, Unit Literal, (), Primitives, Scalars, Compound Types"
      },
      {
        "category": "Statements vs. Expressions",
        "description": "The crucial distinction in Rust between code that returns a value (expressions) and code that performs an action without returning a value (statements).",
        "keywords": "Statements, Expressions, Expression-based language, Semicolon, Block expressions, Final expression"
      },
      {
        "category": "Control Flow",
        "description": "Constructs for directing the flow of execution, including conditionals, loops, and powerful pattern matching.",
        "keywords": "if, else, loop, while, for, break, continue, labels, 'outer, match, exhaustive matching, Pattern Syntax, destructuring, guards, if let, while let, IntoIterator"
      },
      {
        "category": "Modules, Crates, and Packages",
        "description": "The hierarchical system for organizing Rust code into logical units, managing dependencies, and defining compilation boundaries.",
        "keywords": "Crate, Package, Module, mod, crate root, src/main.rs, src/lib.rs, Cargo.toml, Paths, ::, use, pub use, re-exporting, inline modules, file modules"
      },
      {
        "category": "Visibility and Privacy",
        "description": "Rules for controlling access to items (functions, structs, etc.) within and across modules, enforcing encapsulation.",
        "keywords": "pub, private by default, pub(crate), pub(super), pub(in path)"
      },
      {
        "category": "Attributes",
        "description": "Metadata attached to Rust code that provides instructions to the compiler, linters, and other tools.",
        "keywords": "Attributes, outer attribute, #[...], inner attribute, #![...], Conditional Compilation, #[cfg], #[cfg_attr], Testing, #[test], #[should_panic], #[ignore], Derive, #[derive], Code Generation, #[inline], #[cold], #[target_feature], #[naked], Documentation, #[doc], Linking, FFI, #[repr], #[no_mangle], Macros, #[macro_export], #[proc_macro], Diagnostics, #[allow], #[warn], #[deny], #[forbid], #[must_use], Tool Attributes, #[rustfmt::skip], #[clippy::...]"
      },
      {
        "category": "Editions",
        "description": "Rust's mechanism for introducing backward-incompatible changes to the language in an opt-in manner, ensuring stability for existing code.",
        "keywords": "Editions, Rust 2015, Rust 2018, Rust 2021, Rust 2024, cargo fix --edition, stability promise, backward compatibility, module path system changes, let chains"
      },
      {
        "category": "Standard Library and Preludes",
        "description": "The core libraries provided by Rust and the set of commonly used items that are automatically brought into scope in every module.",
        "keywords": "std, core, alloc, #[no_std], embedded systems, Prelude, #[no_implicit_prelude]"
      },
      {
        "category": "Documentation",
        "description": "The built-in system for generating professional documentation directly from source code comments.",
        "keywords": "rustdoc, Doc comments, ///, //!, Markdown, Doctests, cargo test, code examples"
      }
    ],
    "memory_management_keywords": [
      "Ownership",
      "Move Semantics",
      "Copy Trait",
      "Partial Moves",
      "Borrowing",
      "References",
      "&T",
      "&mut T",
      "Borrow Checker",
      "Shared Borrows",
      "Immutable Borrows",
      "Mutable Borrows",
      "Exclusive Borrows",
      "Reborrowing",
      "Two-Phase Borrows",
      "Lifetimes",
      "Lifetime Annotations",
      "'a",
      "Non-Lexical Lifetimes (NLL)",
      "Lifetime Elision Rules",
      "Higher-Ranked Trait Bounds (HRTB)",
      "for<'a>",
      "Variance",
      "Covariant (+T)",
      "Contravariant (-T)",
      "Invariant (!T)",
      "Subtyping",
      "Aliasing",
      "Interior Mutability",
      "Cell<T>",
      "RefCell<T>",
      "Mutex<T>",
      "RwLock<T>",
      "UnsafeCell<T>",
      "Stacked Borrows Model",
      "Miri",
      "Self-Referential Types",
      "Pin<Ptr>",
      "Unpin Trait",
      "Pin::new",
      "Pin::new_unchecked",
      "Future::poll",
      "Drop Trait",
      "Drop Order",
      "dropck",
      "#[may_dangle]",
      "std::mem::forget",
      "ManuallyDrop<T>",
      "Borrow Checker Errors",
      "E0382 (use of moved value)",
      "E0506 (cannot assign to borrowed value)",
      "E0499 (cannot borrow as mutable more than once)",
      "E0502 (cannot borrow as mutable and immutable)",
      "E0596 (cannot mutate immutable reference)",
      "E0597 (dangling reference)",
      "E0106 (missing lifetime specifier)",
      "E0515 (cannot return reference to local variable)",
      "unnecessary clone()",
      "borrowing loops",
      "'static lifetime",
      "Temporary Lifetime Extension",
      "Constant Promotion",
      "Poisoning (Mutex)"
    ],
    "traits_and_generics_keywords": [
      "trait",
      "impl Trait",
      "dyn Trait",
      "associated types",
      "trait bounds",
      "blanket implementations",
      "trait coherence",
      "orphan rules"
    ],
    "data_types_and_layout_keywords": [
      "Algebraic Data Types (ADTs)",
      "Structs",
      "Product Types",
      "Tuples",
      "Tuple-like Structs",
      "Unit-like Structs",
      "Enums",
      "Sum Types",
      "Tagged Unions",
      "C-like Enums",
      "Data-Carrying Variants",
      "Newtypes",
      "Unions",
      "Option<T>",
      "Some(T)",
      "None",
      "Result<T, E>",
      "Ok(T)",
      "Err(E)",
      "#[must_use]",
      "? operator",
      "Pattern Matching",
      "Refutability",
      "Irrefutable Patterns",
      "Refutable Patterns",
      "if let",
      "while let",
      "Exhaustive Matching",
      "#[non_exhaustive]",
      "wildcard (_)",
      "Match Ergonomics",
      "Never Type (!)",
      "Uninhabited Types",
      "Empty Enums",
      "Zero-Sized Types (ZSTs)",
      "Unit type ()",
      "Dynamically Sized Types (DSTs)",
      "Fat Pointers",
      "str",
      "[T]",
      "dyn Trait",
      "vtable",
      "Type Layout",
      "repr attributes",
      "#[repr(Rust)]",
      "#[repr(C)]",
      "#[repr(transparent)]",
      "#[repr(u*)]",
      "#[repr(i*)]",
      "#[repr(packed)]",
      "#[repr(packed(n))]",
      "#[repr(align(n))]",
      "Discriminant",
      "Niche Optimization",
      "Nullable Pointer Optimization",
      "Application Binary Interface (ABI)",
      "ABI Stability"
    ],
    "collections_and_data_structures_keywords": [
      {
        "collection_name": "Vec",
        "category": "Standard Sequential",
        "underlying_structure": "Contiguous growable array",
        "performance_characteristics": "O(1) append, O(n) random removal",
        "use_cases": "Dynamic array usage such as stack implementation."
      },
      {
        "collection_name": "HashMap",
        "category": "Concurrent Data Structures",
        "underlying_structure": "Hash table with open addressing",
        "performance_characteristics": "O(1) lookup on average, O(n) in worst case",
        "use_cases": "Key-value data storage with efficient random access."
      }
    ],
    "functional_programming_keywords": [
      "Iterator trait",
      "closure",
      "Fn",
      "FnMut",
      "FnOnce",
      "fold",
      "map",
      "filter"
    ],
    "error_handling_and_panics_keywords": [
      "Result",
      "Option",
      "? operator",
      "panic!",
      "thiserror",
      "anyhow"
    ],
    "synchronous_concurrency_keywords": [
      "std::thread",
      "thread::spawn",
      "JoinHandle",
      "scoped threads",
      "thread::scope",
      "Builder",
      "Mutex",
      "RwLock",
      "Condvar",
      "Barrier",
      "Once",
      "OnceLock",
      "LazyLock",
      "mpsc channels",
      "Sender",
      "Receiver",
      "sync_channel",
      "rendezvous channel",
      "atomics",
      "AtomicBool",
      "AtomicIsize",
      "AtomicUsize",
      "AtomicPtr",
      "Memory Ordering",
      "Ordering::Relaxed",
      "Ordering::Acquire",
      "Ordering::Release",
      "Ordering::AcqRel",
      "Ordering::SeqCst",
      "fences",
      "compiler_fence",
      "Arc",
      "Rc",
      "Weak",
      "Send trait",
      "Sync trait",
      "deadlock",
      "livelock",
      "starvation",
      "data races",
      "race conditions",
      "message passing",
      "shared-state concurrency",
      "actor model",
      "work-stealing",
      "pipelines",
      "parking_lot",
      "crossbeam",
      "crossbeam-channel",
      "crossbeam-epoch",
      "crossbeam-deque",
      "flume",
      "Rayon",
      "parallel iterators",
      "loom",
      "ThreadSanitizer",
      "TSan",
      "poisoning"
    ],
    "asynchronous_programming_keywords": [
      "async/await",
      "Future trait",
      "Stream trait",
      "poll method",
      "Poll::Ready",
      "Poll::Pending",
      "Context",
      "Waker",
      "Pin",
      "Unpin",
      "pin! macro",
      "self-referential structs",
      "async runtimes",
      "Tokio",
      "async-std",
      "smol",
      "executors",
      "multi-thread scheduler",
      "current-thread scheduler",
      "work-stealing scheduler",
      "I/O driver",
      "time driver",
      "structured concurrency",
      "tokio::task::scope",
      "backpressure",
      "bounded channels",
      "tokio::sync::mpsc",
      "Semaphore",
      "timeouts",
      "tokio::time::timeout",
      "cancellation",
      "tokio_util::sync::CancellationToken",
      "cooperative cancellation",
      "tower",
      "Service trait",
      "middleware",
      "hyper",
      "tonic",
      "axum",
      "actix-web",
      "Rocket",
      "sync-in-async",
      "blocking in async",
      "tokio::spawn_blocking",
      "holding locks across .await",
      "Send bound",
      "'static bound",
      "async fn in traits",
      "async-trait crate",
      "BoxFuture",
      "glommio",
      "io_uring",
      "embassy",
      "tokio-tungstenite",
      "quinn",
      "async-graphql",
      "tokio::select!"
    ],
    "unsafe_rust_and_ffi_keywords": [
      "unsafe block",
      "unsafe function",
      "unsafe trait",
      "raw pointers",
      "*const T",
      "*mut T",
      "dereferencing raw pointers",
      "Undefined Behavior (UB)",
      "data races",
      "dangling pointers",
      "unaligned pointers",
      "invalid values",
      "aliasing rules",
      "Stacked Borrows",
      "Tree Borrows",
      "provenance",
      "MaybeUninit",
      "mem::forget",
      "mem::replace",
      "mem::take",
      "mem::transmute",
      "std::ptr",
      "ptr::read",
      "ptr::write",
      "ptr::copy",
      "ptr::copy_nonoverlapping",
      "NonNull",
      "memory layout",
      "#[repr(C)]",
      "#[repr(transparent)]",
      "#[repr(packed)]",
      "#[repr(align)]",
      "volatile",
      "read_volatile",
      "write_volatile",
      "inline assembly",
      "asm!",
      "compiler intrinsics",
      "Miri",
      "sanitizers",
      "ASan",
      "TSan",
      "UBSan",
      "safe abstractions",
      "SAFETY comments",
      "Foreign Function Interface (FFI)",
      "extern \"C\"",
      "extern \"C-unwind\"",
      "#[no_mangle]",
      "calling conventions",
      "ABI stability",
      "bindgen",
      "cbindgen",
      "cxx",
      "autocxx",
      "pyo3",
      "maturin",
      "napi-rs",
      "Neon",
      "jni",
      "csbindgen",
      "interoptopus",
      "uniFFI",
      "The Rustonomicon",
      "union"
    ],
    "metaprogramming_and_macros_keywords": [
      "metaprogramming",
      "declarative macros",
      "macro_rules!",
      "procedural macros",
      "proc-macro",
      "derive macros",
      "#[derive]",
      "attribute macros",
      "function-like macros",
      "hygiene",
      "mixed-site hygiene",
      "$crate",
      "token tree",
      "TokenStream",
      "fragment specifiers",
      ":expr",
      ":ident",
      ":ty",
      ":pat",
      ":tt",
      "repetition",
      "$(...)*",
      "token tree munchers",
      "syn",
      "quote",
      "proc-macro2",
      "darling",
      "build scripts",
      "build.rs",
      "OUT_DIR",
      "cargo::rerun-if-changed",
      "code generation",
      "macro debugging",
      "cargo expand",
      "trybuild",
      "proc-macro-error",
      "Span",
      "paste crate",
      "inventory crate",
      "serde derive",
      "thiserror derive",
      "unhygienic macros"
    ],
    "performance_and_optimization_keywords": [
      "Zero-cost abstractions",
      "Inlining",
      "Static vs Dynamic Dispatch (Generics vs dyn Trait)",
      "Monomorphization",
      "Profile-Guided Optimization (PGO)",
      "Link-Time Optimization (LTO)",
      "Codegen units",
      "Panic strategy (panic=abort)",
      "SIMD (Single Instruction, Multiple Data)",
      "Auto-vectorization",
      "CPU-specific instructions (target-cpu=native)",
      "Cache-aware programming",
      "Cache locality",
      "Memory layout (repr attributes)",
      "Niche optimization",
      "Zero-Sized Types (ZST)",
      "Custom allocators (jemalloc, mimalloc, system allocator)",
      "Bump/arena allocators",
      "Memory pools",
      "Small string optimization (SSO)",
      "Profiling (perf, vtune, dtrace, samply)",
      "Flamegraphs",
      "Benchmarking (criterion)",
      "Micro-benchmarking pitfalls",
      "High-performance I/O (io_uring)",
      "Lazy evaluation",
      "Allocation-free iterator chains",
      "Lock-free data structures",
      "Atomics and memory ordering (Acquire/Release/SeqCst)",
      "Volatile memory access",
      "Inline assembly (asm!)",
      "Compiler intrinsics",
      "GPU Compute (wgpu, CUDA)",
      "Parallel iterators (rayon)"
    ],
    "tooling_and_ecosystem_keywords": [
      "Cargo",
      "Cargo.toml (Manifest)",
      "Workspaces (virtual, inherited properties)",
      "Features (optional dependencies, feature unification)",
      "Profiles (dev, release, test, bench, custom)",
      "Build scripts (build.rs)",
      "Cargo subcommands (nextest, outdated, udeps, bloat, expand, audit, deny, vendor)",
      "rustup (toolchain management)",
      "Toolchains (stable, beta, nightly)",
      "rust-analyzer (Language Server)",
      "clippy (Linter)",
      "rustfmt (Code Formatter)",
      "rustdoc (Documentation Generator)",
      "crates.io (Package Registry)",
      "Publishing and Yanking",
      "Versioning (SemVer)",
      "MSRV (Minimum Supported Rust Version)",
      "Cross-compilation",
      "Target triples",
      "Static linking (MUSL, CRT)",
      "Reproducible builds",
      "Cargo.lock (Lockfiles)",
      "Vendoring (cargo vendor)",
      "Source replacement and alternate registries",
      "FFI Tooling (bindgen, cbindgen, cxx, autocxx)",
      "Python packaging (maturin)",
      "Node.js packaging (napi-rs/cli)",
      "WebAssembly packaging (wasm-pack, wasm-bindgen)",
      "Build integration (cc crate, cmake crate)",
      "Verification tools (Miri, Sanitizers, cargo-geiger)",
      "Testing tools (trybuild, cargo-nextest)"
    ],
    "testing_and_qa_keywords": [
      {
        "testing_type": "Unit, Integration, and Documentation Testing",
        "description": "Covers testing individual components in isolation (unit tests), verifying interactions between components via public APIs (integration tests), and ensuring code examples in documentation are correct and up-to-date (doctests). These are the foundational testing types built into the Rust toolchain.",
        "tools_and_techniques": "`cargo test`, `#[cfg(test)]`, `tests/` directory, `///` and `//!` doc comments, `rustdoc --test`, `cargo nextest` (alternative test runner), `serial_test` (for controlling parallel execution)"
      },
      {
        "testing_type": "Property-Based Testing",
        "description": "A testing methodology where, instead of writing tests for specific inputs, the developer defines properties or invariants that should hold true for a wide range of randomly generated inputs. The framework then tries to find a counterexample that falsifies the property.",
        "tools_and_techniques": "`proptest`, `quickcheck`, deterministic seeds for reproducibility (e.g., `PROPTTEST_RNG_SEED`)"
      },
      {
        "testing_type": "Fuzz Testing (Fuzzing)",
        "description": "An automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a program. The goal is to find crashes, panics, security vulnerabilities, and other bugs that might not be found with traditional testing.",
        "tools_and_techniques": "`cargo-fuzz`, `libFuzzer`, `afl.rs` (AFLplusplus), `honggfuzz-rs`, Sanitizers (AddressSanitizer, UndefinedBehaviorSanitizer), corpus and test case minification (`cmin`, `tmin`)"
      },
      {
        "testing_type": "Snapshot and Golden Testing",
        "description": "Compares the output of a function against a stored 'snapshot' or 'golden file' of a known-good result. This is particularly useful for testing complex data structures, logs, or rendered output (like UI components or compiler error messages).",
        "tools_and_techniques": "`insta` (snapshot testing with interactive review), `expect-test`, `goldenfile` (golden file testing)"
      },
      {
        "testing_type": "Mutation Testing",
        "description": "A technique used to evaluate the quality of a test suite. It works by making small, syntactic changes (mutations) to the source code and checking if the existing tests fail. If tests continue to pass, it may indicate a gap in test coverage.",
        "tools_and_techniques": "`cargo-mutants`"
      },
      {
        "testing_type": "Code Coverage Analysis",
        "description": "Measures which lines, regions, and branches of code are executed by the test suite. This helps identify untested parts of the codebase and provides a metric for test completeness.",
        "tools_and_techniques": "`cargo-llvm-cov` (source-based coverage), `grcov`, `cargo-tarpaulin`, LCOV format, Cobertura XML format, integration with services like Codecov"
      },
      {
        "testing_type": "Security and Dependency Auditing",
        "description": "A set of practices to secure the software supply chain. This involves scanning project dependencies for known security vulnerabilities, enforcing policies on licenses, and managing audits of third-party code.",
        "tools_and_techniques": "`cargo-audit`, `cargo-deny`, `cargo-vet`, RustSec Advisory Database, SBOM (Software Bill of Materials) generation (`cyclonedx-rust-cargo`, `cargo-about`)"
      },
      {
        "testing_type": "CI/CD Quality Gates",
        "description": "A series of automated checks integrated into a Continuous Integration/Continuous Deployment pipeline to enforce code quality standards, run tests, and prevent regressions before code is merged or deployed.",
        "tools_and_techniques": "GitHub Actions, `dtolnay/rust-toolchain`, `Swatinem/rust-cache`, `taiki-e/install-action`, `cargo fmt --check`, `cargo clippy -- -D warnings`, automated security audits, automated test execution"
      }
    ],
    "web_and_network_services_keywords": [
      {
        "category": "Web Frameworks",
        "description": "Core frameworks for building web applications and APIs, offering routing, request handling, and middleware integration.",
        "key_crates_and_concepts": "axum, actix-web, Rocket, Warp, Tide, macro-free API, actor model, type-safe routing"
      },
      {
        "category": "HTTP Stack & Clients",
        "description": "Low-level and high-level libraries for handling HTTP requests and responses, for both server and client-side applications.",
        "key_crates_and_concepts": "hyper, reqwest, HTTP/1.x, HTTP/2, asynchronous client, blocking client, JSON support, multipart streams, redirect policy, cookies, WASM compatibility"
      },
      {
        "category": "Middleware & Service Architecture",
        "description": "Libraries for creating modular, reusable components that can be layered to add functionality like logging, compression, and tracing to services.",
        "key_crates_and_concepts": "tower, tower-http, Service trait, composable architecture, Trace middleware, Compression middleware, Decompression middleware"
      },
      {
        "category": "Rate Limiting",
        "description": "Tools for controlling the rate of incoming requests to prevent abuse and ensure service stability.",
        "key_crates_and_concepts": "governor, tower-governor, Generic Cell Rate Algorithm (GCRA), leaky bucket, rate limiting by IP, x-ratelimit headers"
      },
      {
        "category": "Authentication & Authorization",
        "description": "Crates for implementing security protocols like JWT, OAuth2, and OpenID Connect to secure endpoints.",
        "key_crates_and_concepts": "jsonwebtoken, oauth2, openidconnect, JSON Web Tokens (JWT), OAuth2 protocol, OpenID Connect (OIDC), single sign-on (SSO)"
      },
      {
        "category": "gRPC",
        "description": "Frameworks for building high-performance, cross-language services using the gRPC protocol.",
        "key_crates_and_concepts": "tonic, prost, Protocol Buffers, bi-directional streaming, load balancing, health checking"
      },
      {
        "category": "WebSockets",
        "description": "Libraries for enabling real-time, bi-directional communication between clients and servers over a single TCP connection.",
        "key_crates_and_concepts": "tokio-tungstenite, Tungstenite, asynchronous WebSockets, stream-based implementation"
      },
      {
        "category": "QUIC & HTTP/3",
        "description": "Implementations of the modern QUIC transport protocol, which underpins HTTP/3, offering improved performance and reduced latency.",
        "key_crates_and_concepts": "quinn, IETF QUIC, ordered/unordered streams, pluggable cryptography"
      },
      {
        "category": "GraphQL",
        "description": "Server libraries for building APIs with the GraphQL query language, allowing clients to request exactly the data they need.",
        "key_crates_and_concepts": "async-graphql, juniper, type safety, custom scalars, subscriptions, Apollo Tracing, Federation"
      },
      {
        "category": "TLS (Transport Layer Security)",
        "description": "Libraries for securing network communications with TLS encryption, focusing on safety and performance.",
        "key_crates_and_concepts": "rustls, aws-lc-rs, ring, TLS 1.2, TLS 1.3, pluggable cryptography providers"
      },
      {
        "category": "Observability",
        "description": "Tools for logging, metrics, and distributed tracing to monitor and debug applications in production.",
        "key_crates_and_concepts": "log, tracing, tracing-subscriber, opentelemetry-rust, prometheus, metrics, structured logging, spans, OpenTelemetry Protocol (OTLP)"
      },
      {
        "category": "Configuration & Secrets",
        "description": "Crates for managing application settings and securely handling sensitive information like API keys and passwords.",
        "key_crates_and_concepts": "config, figment, envy, secrecy, hierarchical configuration, secret leakage prevention"
      },
      {
        "category": "Deployment & Security",
        "description": "Strategies and tools for packaging, deploying, and securing Rust services.",
        "key_crates_and_concepts": "Docker multi-stage builds, distroless images, musl static linking, cargo-audit, cargo-deny"
      }
    ],
    "data_engineering_and_storage_keywords": [
      "ORMs and Query Layers",
      "diesel",
      "sqlx",
      "sea-orm",
      "type-safe queries",
      "compile-time query checking",
      "async database driver",
      "Database Migration Tools",
      "diesel_cli",
      "sqlx-cli",
      "refinery",
      "Flyway-like migrations",
      "reversible migrations",
      "Embedded Stores",
      "sled",
      "rocksdb",
      "lmdb",
      "transactional embedded database",
      "persistent key-value store",
      "memory-mapped database",
      "Caching",
      "redis (client)",
      "deadpool-redis",
      "moka",
      "cached",
      "connection pooling",
      "in-memory cache",
      "memoization",
      "Messaging and Streaming",
      "rdkafka (Apache Kafka)",
      "nats",
      "rumqttc (MQTT)",
      "lapin (AMQP/RabbitMQ)",
      "pulsar-rs (Apache Pulsar)",
      "librdkafka",
      "JetStream",
      "at-least-once messaging",
      "DataFrames & Analytics",
      "Polars",
      "Apache Arrow",
      "arrow (crate)",
      "columnar memory format",
      "lazy execution",
      "out-of-core processing",
      "Query Engines",
      "DataFusion",
      "Ballista",
      "extensible query engine",
      "distributed query execution",
      "Search",
      "tantivy",
      "MeiliSearch SDK",
      "meilisearch-sdk",
      "Elasticsearch client",
      "OpenSearch client",
      "full-text search",
      "Serialization",
      "Serde",
      "Serialize trait",
      "Deserialize trait",
      "bincode",
      "postcard",
      "rmp (MessagePack)",
      "ciborium (CBOR)",
      "prost (Protocol Buffers)",
      "flatbuffers",
      "capnp (Cap'n Proto)",
      "rkyv",
      "zero-copy deserialization",
      "schema evolution",
      "self-describing formats",
      "Configuration",
      "config-rs",
      "envy",
      "dotenvy",
      "layered configuration"
    ],
    "systems_and_embedded_dev_keywords": [
      "no_std development",
      "alloc crate",
      "#[global_allocator]",
      "#[alloc_error_handler]",
      "panic handlers",
      "#[panic_handler]",
      "panic-abort",
      "panic-halt",
      "panic-semihosting",
      "panic-probe",
      "panic-itm",
      "memory-mapped I/O (MMIO)",
      "volatile access",
      "core::ptr::read_volatile",
      "core::ptr::write_volatile",
      "Hardware Abstraction Layers (HAL)",
      "embedded-hal",
      "embedded-hal-async",
      "embedded-hal-nb",
      "Peripheral Access Crates (PAC)",
      "svd2rust",
      "cortex-m",
      "stm32-hal",
      "nrf-hal",
      "rp-hal",
      "esp-hal",
      "Real-Time Interrupt-driven Concurrency (RTIC)",
      "cortex-m-rtic",
      "Embassy framework",
      "async embedded",
      "real-time constraints",
      "hard real-time",
      "Worst-Case Execution Time (WCET)",
      "priority inversion",
      "critical-section",
      "probe-rs",
      "cargo-embed",
      "cargo-flash",
      "OpenOCD",
      "J-Link",
      "GDB",
      "Serial Wire Debug (SWD)",
      "JTAG",
      "Real-Time Transfer (RTT)",
      "Instrumentation Trace Macrocell (ITM)",
      "defmt",
      "cross-compilation",
      "target triples",
      "thumbv7em-none-eabihf",
      "cargo-zigbuild",
      "Linker scripts",
      "cargo-binutils",
      "bootloaders",
      "cortex-m-rt",
      "OS/Kernel Development",
      "Rust-for-Linux",
      "Redox OS",
      "Tock OS",
      "Asterinas",
      "seL4 microkernel",
      "microkernel design",
      "io_uring",
      "tokio-uring",
      "mio",
      "safety-critical systems",
      "DO-178C",
      "ISO 26262",
      "formal verification",
      "model checking",
      "miri",
      "AddressSanitizer (ASan)",
      "UndefinedBehaviorSanitizer (UBSan)"
    ],
    "desktop_mobile_and_wasm_keywords": [
      "Tauri",
      "Slint",
      "iced",
      "egui",
      "Dioxus",
      "wgpu",
      "winit",
      "Android NDK",
      "JNI (Java Native Interface)",
      "iOS FFI",
      "cbindgen",
      "uniffi",
      "flutter_rust_bridge",
      "cargo-mobile2",
      "WebAssembly (WASM)",
      "wasm32-unknown-unknown",
      "wasm32-wasi",
      "wasm-bindgen",
      "wasm-pack",
      "WebAssembly Component Model",
      "WIT (WebAssembly Interface Definition Language)",
      "wit-bindgen",
      "cargo-component",
      "wasmtime",
      "wasmer",
      "WasmEdge",
      "Fermyon Spin",
      "Cloudflare Workers",
      "Fastly Compute@Edge",
      "Serverless WASM"
    ],
    "scientific_computing_and_ml_keywords": [
      "ndarray",
      "nalgebra",
      "faer",
      "Burn",
      "Candle",
      "smartcore",
      "linfa",
      "tch-rs",
      "onnxruntime-rs",
      "wgpu",
      "rust-gpu",
      "CUDA",
      "cust",
      "rustacuda",
      "Bevy",
      "Fyrox",
      "ggez",
      "macroquad",
      "Entity-Component-System (ECS)",
      "ash (Vulkan bindings)",
      "glium (OpenGL wrapper)",
      "cpal",
      "rodio",
      "gstreamer-rs",
      "rayon",
      "SIMD",
      "plotters",
      "poloto"
    ],
    "language_comparisons_and_adoption_keywords": [
      {
        "comparison_topic": "Rust vs C++",
        "summary": "Rust offers compile-time memory and thread safety via its ownership model, preventing entire classes of bugs common in C++. While C++ has a more mature ecosystem in some domains like AAA gaming, Rust is highly competitive in performance and is rapidly gaining ground in systems programming and web services where safety is paramount.",
        "key_points": "Key points of comparison include Rust's compile-time safety guarantees versus C++'s manual memory management (RAII, smart pointers); Rust's built-in data race prevention versus C++'s library-based concurrency primitives; and Rust's integrated `Cargo` build system versus the fragmented landscape of C++ build tools (CMake, Make)."
      },
      {
        "comparison_topic": "Rust vs Go",
        "summary": "The comparison focuses on performance, memory management, and concurrency models. Rust generally offers higher raw performance and a smaller memory footprint due to the absence of a garbage collector (GC). Go provides simpler concurrency with goroutines and channels, while Rust's `async/await` offers more control but with a steeper learning curve.",
        "key_points": "TechEmpower benchmarks show top-tier Rust frameworks outperforming Go frameworks in request throughput. Rust's compile-time safety contrasts with Go's runtime data race detector. Go's built-in runtime and GC simplify development, whereas Rust requires explicit management of asynchronous runtimes."
      },
      {
        "comparison_topic": "Rust vs Java/Kotlin",
        "summary": "Rust provides significantly higher performance and lower memory usage compared to JVM languages like Java and Kotlin, primarily due to its AOT compilation to native code and lack of a heavy runtime and GC. The JVM offers a mature ecosystem and platform independence, while Rust provides low-level system control.",
        "key_points": "TechEmpower benchmarks from Feb 2025 show top Rust frameworks handling over twice the requests per second compared to top Java/Kotlin frameworks. Rust's error handling with `Result`/`Option` is compile-time enforced, contrasting with Java's runtime exceptions. Interop with Java is possible via JNI but adds complexity."
      },
      {
        "comparison_topic": "Rust vs Python",
        "summary": "Rust and Python occupy different ends of the performance spectrum. Python prioritizes developer productivity and readability, making it ideal for scripting and rapid development, while Rust prioritizes performance and memory safety for systems-level programming. A common pattern is to write performance-critical modules in Rust and call them from Python.",
        "key_points": "Web framework benchmarks show Rust to be over an order of magnitude faster than Python (e.g., Actix vs Django). Rust's static typing catches errors at compile time, whereas Python's dynamic typing catches them at runtime. The `PyO3` and `maturin` ecosystem makes Rust-Python interop seamless."
      },
      {
        "comparison_topic": "Migration Strategies",
        "summary": "The most common and effective strategy for adopting Rust in an existing organization is an incremental rewrite. This involves identifying performance-critical components or 'hot paths' in a codebase (e.g., in C++, Go, or Python) and rewriting only those specific parts in Rust.",
        "key_points": "This 'polyglot' approach allows teams to leverage Rust's performance and safety for targeted problems without the high cost and risk of a full rewrite. It relies heavily on a well-defined Foreign Function Interface (FFI) between Rust and the host language."
      },
      {
        "comparison_topic": "FFI Trade-offs",
        "summary": "While Rust's FFI is powerful, it is a significant source of complexity and risk. Interfacing with languages like C/C++ requires extensive use of `unsafe` blocks, which bypasses Rust's safety guarantees and can reintroduce memory bugs if not handled with extreme care.",
        "key_points": "Challenges include the steep learning curve of combining Rust's complex features (lifetimes, Pin) with FFI; the immaturity of some FFI tooling (`cbindgen`); Rust's unstable ABI complicating long-term compatibility; and the need to revert to manual memory management patterns (e.g., `init`/`release` functions) when exposing a C API."
      },
      {
        "comparison_topic": "Organizational Adoption",
        "summary": "Rust is being adopted by major technology companies for performance-critical and security-sensitive systems. Its use cases span from web services and infrastructure to operating system components.",
        "key_points": "Real-world adopters include Cloudflare (Pingora network framework), AWS (Firecracker VMM, Bottlerocket OS), Google (Android OS components), and Microsoft (Windows kernel components). This adoption validates Rust's suitability for large-scale, production systems."
      }
    ],
    "idiomatic_patterns_and_antipatterns": [
      {
        "type": "Idiomatic Pattern",
        "name": "Newtype Pattern",
        "description": "Wrapping an existing type in a single-field tuple struct (e.g., `struct UserId(u64);`) to create a new, distinct type. This enhances type safety by preventing accidental mixing of types (e.g., passing a `ProductId` where a `UserId` is expected) and allows implementing traits on foreign types, often with zero runtime cost using `#[repr(transparent)]`."
      },
      {
        "type": "Idiomatic Pattern",
        "name": "Builder Pattern",
        "description": "A creational pattern for constructing complex objects step-by-step. It provides a more readable alternative to constructors with many optional parameters, allowing method chaining to configure an object before finalizing it with a `build()` method."
      },
      {
        "type": "Idiomatic Pattern",
        "name": "RAII (Resource Acquisition Is Initialization)",
        "description": "A core principle in Rust where resource management is tied to object lifetime. Resources (like memory, files, or locks) are acquired in a constructor and released in the destructor (`Drop` trait). This guarantees that resources are automatically cleaned up when the object goes out of scope, preventing leaks. `MutexGuard` is a classic example."
      },
      {
        "type": "Idiomatic Pattern",
        "name": "Sealed Trait Pattern",
        "description": "A technique used by library authors to prevent downstream crates from implementing a public trait. This is typically achieved by making a private, local trait a supertrait of the public one, ensuring that only the library itself can provide implementations."
      },
      {
        "type": "Idiomatic Pattern",
        "name": "Returning `Result` for Recoverable Errors",
        "description": "Instead of panicking, functions that can fail in an expected way (e.g., I/O error, parsing failure) should return a `Result<T, E>`. This allows the caller to handle the error gracefully and is the cornerstone of robust Rust programs."
      },
      {
        "type": "Anti-pattern",
        "name": "Unnecessary Cloning",
        "description": "A common beginner anti-pattern of calling `.clone()` on a value simply to satisfy the borrow checker. While sometimes necessary, it can hide a deeper design issue related to ownership and often incurs a performance penalty. The idiomatic approach is to restructure the code to work within Rust's borrowing rules."
      },
      {
        "type": "Anti-pattern",
        "name": "Panicking in Libraries",
        "description": "Library code should not panic on recoverable errors. Panicking terminates the entire thread or process, taking control away from the application developer. Libraries should return `Result` to allow the consumer to decide how to handle the failure."
      },
      {
        "type": "Anti-pattern",
        "name": "Using `unwrap()` or `expect()` in Production Code",
        "description": "These methods are a form of implicit panic and should be avoided in production library or application code where an error is a possible outcome. They are acceptable in tests, examples, or when a condition is truly an unrecoverable logic error (an invariant that should never be broken)."
      },
      {
        "type": "Anti-pattern",
        "name": "Deref Polymorphism Pitfalls",
        "description": "Overusing the `Deref` trait to simulate inheritance can lead to confusing and un-idiomatic code. While `Deref` is useful for smart pointers, relying on it for polymorphism can obscure the actual type and make the code harder to reason about."
      },
      {
        "type": "Anti-pattern",
        "name": "Holding RAII Guards Across `.await` Points",
        "description": "In `async` code, holding a lock guard (like `MutexGuard`) across an `.await` call is a serious anti-pattern. The task may yield to the scheduler while holding the lock, preventing other tasks from making progress and often leading to deadlocks. The lock should be dropped before awaiting."
      },
      {
        "type": "Anti-pattern",
        "name": "Blocking in an Async Context",
        "description": "Calling a synchronous, blocking function (like `std::thread::sleep` or standard file I/O) within an `async` task. This stalls the executor's thread, preventing it from polling other tasks and defeating the purpose of asynchronous programming. Blocking work should be offloaded to a dedicated thread pool (e.g., using `tokio::spawn_blocking`)."
      }
    ]
  },
  "outputBasis": [
    {
      "field": "error_handling_and_panics_keywords",
      "citations": [
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s\nimplementation simpler.",
            "```",
            "}",
            "}",
            "    Err(E)",
            "    Ok(T),",
            "enum Result<T, E> {",
            "fn main() {",
            "\n#! [allow(unused)]",
            "```rust",
            "he `Result` enum is defined as having two\nvariants, `Ok` and `Err` , as follows:"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```rust"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "```",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Error handling - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/error.html",
          "excerpts": [
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ... When there is a chance that things do go wrong and the caller has to deal with the problem, use Result . You can unwrap and expect them as well (please don't do ...",
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input would ... Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ..."
          ]
        },
        {
          "title": "Result in std",
          "url": "https://doc.rust-lang.org/beta/std/result/enum.Result.html",
          "excerpts": [
            "Returns true if the result is Err and the value inside of it matches a predicate. Â§Examples. use std::io::{Error, ErrorKind}; let x: Result<u32, Error> ..."
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html).",
            "Returns the contained [`Some`](enum.Option.html.Some \"variant std::option::Option::Some\") value, consuming the `self` value. Because this function may panic, its use is generally discouraged. Panics are meant for unrecoverable errors, and\n[may abort the entire program](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html).",
            "The map method takes the self argument by value, consuming the original, so this technique uses as_ref to first take an Option to a reference to the valueÂ ... Computes a default function result (if none), or applies a different function to the contained value (if any). Â§Basic examples. let k = 21; let x = Some(\"foo\"); ..."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok\\(T\\),%0A+++++++Err\\(E\\),%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](../../std/io/index.html) .\n ... \n;\n    Ok (())\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++fn+write_message\\(\\)+-%3E+io::Result%3C\\(\\)%3E+%7B%0A++++++++let+mut+file+=+File::create\\(%22valuable_data.txt%22\\)?;%0A++++++++file.write_all\\(b%22important+message%22\\)? ;%0A++++++++Ok\\(\\(\\)\\)%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\n## [Â§]() The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark\noperator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\") , hides some of the boilerplate of propagating errors\nup the call stack. It replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude:: * ;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: & Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create( \"my_best_friends.txt\" ) {\n           Err (e) => return Err (e),\n           Ok (f) => f,\n    };\n    if let Err (e) = file.write_all( format! ( \"name: {}\\n\" , info.name).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format! ( \"age: {}\\n\" , info.age).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format!\n ... \n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides. ## [Â§]() Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI\nguarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a\ntype that qualifies for the `Option` [representation guarantees](../option/index.html \"Option Representation\") ,\nand the _other_ type must meet all of the following conditions:\n\n* Is a zero-sized type with alignment 1 (a â€œ1-ZSTâ€). * Has no fields. * Does not have the `#[non_exhaustive]` attribute. For example, `NonZeroI32` qualifies for the `Option` representation\nguarantees, and `()` is a zero-sized type with alignment 1, no fields, and\nit isnâ€™t `non_exhaustive` . This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees\nas `Option<NonZeroI32>` .\n ... \nIf the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](enum.Result.html.Ok \"variant std::result::Result::Ok\") :\n\n* [`expect_err`](enum.Result.html.expect_err \"method std::result::Result::expect\\_err\") panics with a provided custom message\n* [`unwrap_err`](enum.Result.html.unwrap_err \"method std::result::Result::unwrap\\_err\") panics with a generic message\n* [`unwrap_err_unchecked`](enum.Result.html.unwrap_err_unchecked \"method std::result::Result::unwrap\\_err\\_unchecked\") produces _[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)_\n\n### [Â§]() Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\") :\n\n* [`err`](enum.Result.html.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\") ,\n  mapping [`Err(e)`]",
            " std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides.",
            "In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](.",
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "### [Â§]() Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an\niterator that is conditionally empty.",
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n"
          ]
        },
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete."
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "Unrecoverable Errors with panic! - The Rust Programming Language",
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "oml\n[profile.release]\npanic = 'abort'\n```"
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2",
            "That is the basic gist of it. The underlying issue with cancellation safety is that all futures in the select other than the future that yields `Poll::Ready` will be dropped.",
            "If those futures own some form of state, then your future is not cancellation safe, since that owned state will be dropped when another future returns `Poll::Ready` .",
            "The easy way to avoid this is for the futures in the `select!` to not own state, but to borrow it from elsewhere; for example, if `buffered_stream` owns all the state, and the future returned by `read_msg()` mutates `buffered_stream` instead of storing its own state, you're cancellation-safe.",
            "This happens with [`recv` on Tokio channels](https://docs.rs/tokio/1.27.0/tokio/sync/mpsc/struct.Receiver.html.recv) , since all the state is in the channel, and _not_ in the future returned by `recv()` .",
            "Cancel safety is mostly not relevant for kill signals because you don't care if you lost some data from the connection if you're killing it."
          ]
        },
        {
          "title": "Rust Cancel Safety and Panics (as provided in the document)",
          "url": "https://rfd.shared.oxide.computer/rfd/400",
          "excerpts": [
            "panics\narenâ€™t part of normal control flow.",
            " runtime is\n   shut down due to a panic, then the task is cancelled. ",
            "If a Tokio runtime is shut down, all tasks running within it are cancelled at\nthe next await point."
          ]
        },
        {
          "title": "color_eyre - Rust",
          "url": "https://docs.rs/color-eyre",
          "excerpts": [
            "An error report handler for panics and the `eyre` crate for colorful, consistent, and well formatted error reports for all kinds of errors."
          ]
        },
        {
          "title": "color-eyre - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/color-eyre",
          "excerpts": [
            "color-eyre v0.6.5. An error report handler for panics and eyre::Reports for colorful, consistent, and well formatted error reports for all kinds ..."
          ]
        },
        {
          "title": "Error in anyhow - Rust",
          "url": "https://docs.rs/anyhow/latest/anyhow/struct.Error.html",
          "excerpts": [
            "The Debug format â€œ{:?}â€ includes your backtrace if one was captured. Note that this is the representation you get by default if you return an error from fn mainÂ ..."
          ]
        },
        {
          "title": "rust - How to trace the cause of an error result?",
          "url": "https://stackoverflow.com/questions/42275777/how-to-trace-the-cause-of-an-error-result",
          "excerpts": [
            "Use Result defined in easy-error as return type, then use context method to convert other Result types. Most important thing is to pass information to contextÂ ..."
          ]
        },
        {
          "title": "r/rust - miette: a fancy new diagnostics definition and ...",
          "url": "https://www.reddit.com/r/rust/comments/p9t3jh/miette_a_fancy_new_diagnostics_definition_and/",
          "excerpts": [
            "On a somewhat related note, does anyone know of any crates that assist in generating Spans (offset, length, line number, column number) from a ..."
          ]
        },
        {
          "title": "Does anyone bothered by not having backtraces in custom ...",
          "url": "https://www.reddit.com/r/rust/comments/1jebbnq/does_anyone_bothered_by_not_having_backtraces_in/",
          "excerpts": [
            "I very much like anyhow's backtrace feature, it helps me figure out the root cause in some question marks where I'm too lazy to add a contextÂ ..."
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Miette Crate Documentation",
          "url": "https://crates.io/crates/miette",
          "excerpts": [
            "### Table of Contents",
            "### Features",
            "* Generic [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html) protocol, compatible (and dependent on)",
            "`std::error::Error`.",
            "* Unique error codes on every [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html).",
            "* Custom links to get more details on error codes.",
            "* Super handy derive macro for defining diagnostic metadata.",
            "* Replacements for [`anyhow`](https://docs.rs/anyhow)/[`eyre`](https://docs.rs/eyre)\n  types [`Result`](https://docs.rs/miette/latest/miette/type.Result.html), [`Report`](https://docs.rs/miette/latest/miette/struct.Report.html) and the [`miette!`](https://docs.rs/miette/latest/miette/macro.miette.html) macro for the\n  `anyhow!`/`eyre!` macros.",
            "* Generic support for arbitrary [`SourceCode`](https://docs.rs/miette/latest/miette/trait.SourceCode.html)s for snippet data, with",
            "default support for `String`s included.",
            "This is especially",
            "useful in combination with `related`, when multiple errors should be",
            "emitted at the same time:",
            "```\nuse miette::{Diagnostic, Report, SourceSpan};\nuse thiserror::Error;\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops\")]\n#[diagnostic()]\npub struct InnerError {\n    // Note: label but no source code\n    #[label]\n    err_span: SourceSpan,\n}\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops: multiple errors\")]\n#[diagnostic()]\npub struct MultiError {\n    // Note source code by no labels\n    #[source_code]\n    source_code: String,\n    // The source code above is used for these errors\n    #[related]\n    related: Vec<InnerError>,\n}\n\nfn do_something() -> Result<(), Vec<InnerError>> {\n    Err(vec! [\n        InnerError {\n            err_span: (0..6).into(),\n        },\n        InnerError {\n            err_span: (7..11).into(),\n        },\n    ])\n}\n\nfn main() -> miette::Result<()> {\n    do_something().map_err(|err_list| MultiError {\n        source_code: \"source code\".into(),\n        related: err_list,\n    })? ;\n    Ok(())\n}\n```\n\n#### ... Diagnostic-based error sources. When one uses the `#[source]` attribute on a field, that usually comes\nfrom `thiserror`, and implements a method for\n[`std::error::Error::source`]. This works in many cases, but it's lossy:\nif the source of the diagnostic is a diagnostic itself, the source will\nsimply be treated as an `std::error::Error`.\n ... \nIt owes enormous credit to various\nother projects and their authors:\n\n* [`anyhow`](http://crates.io/crates/anyhow) and [`color-eyre`](https://crates.io/crates/color-eyre):\n  these two enormously influential error handling libraries have pushed\n  forward the experience of application-level error handling and error\n  reporting. `miette`'s `Report` type is an attempt at a very very rough\n  version of their `Report` types. * [`thiserror`](https://crates.io/crates/thiserror) for setting the standard\n  for library-level error definitions, and for being the inspiration behind\n  `miette`'s derive macro. * `rustc` and [@estebank](https://github.com/estebank) for their\n  state-of-the-art work in compiler diagnostics. * [`ariadne`](https://crates.io/crates/ariadne) for pushing forward how\n  *pretty* these diagnostics can really look! ### License\n\n`miette` is released to the Rust community under the [Apache license\n2.0](https://github.com/zkat/miette/blob/HEAD/./LICENSE). It also includes code taken from [`eyre`](https://github.com/yaahc/eyre),\nand some from [`thiserror`](https://github.com/dtolnay/thiserror), also\nunder the Apache License. Some code is taken from\n[`ariadne`](https://github.com/zesterer/ariadne), which is MIT licensed."
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "* `snafu` provides context-driven error management, appropriate for complex systems.",
            "Note: When developing, pay attention to the size of\nResult<T, E> . anyhow Error: Application-level Error Handling",
            "* thiserror : customized and rich error handling, suitable for library-level programming",
            "* snafu : finer-grained error management",
            "Conversion and unified error handling with\nanyhow::Error :",
            "* Provides a unified\nanyhow::Error type, supporting any error type that implements\nstd::error::Error",
            "* Uses the\n? operator for automatic error propagation, simplifying multi-layer nested error handling",
            "* Supports adding dynamic context (via the\ncontext() method) to enhance error readability",
            "fn get_cluster_info () -> Result < ClusterMap , anyhow :: Error > { // Error 3: Err3 let config = std :: fs :: read_to_string ( \"cluster.json\" ) ? ; // Error 1: Err1 // let config = std::fs::read_to_string(\"cluster.json\").context(\"...\")? ; // Error 1: Err1 let map : ClusterMap = serde_json :: from_str ( & config ) ?",
            "thiserror Error: Defining Library-level Errors",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Converts underlying errors into domain-specific errors through the\nSnafu macro",
            "    * Supports attaching structured context (such as file paths, input parameters) in the error chain",
            "    * Provides the\nensure!\nmacro to simplify condition checking and error throwing",
            "thiserror vs snafu",
            "Rust std::error::Error trait documentation",
            "Since the\nError trait requires implementing both\nDebug and\nDisplay :\npub trait Error : Debug + Display {",
            "Error -> println! ( \"{}/ {:?}\" , err )",
            "snafu Error: Context-driven Error Management",
            "snafu Error: Context-driven Error Management",
            "rust-ecosystem-learning",
            "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
            "anyhow ,",
            "anyhow ,",
            "thiserror ,",
            "thiserror ,",
            "snafu",
            "snafu",
            "Practical Implementation"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "anyhow = \"1.0.97\"  \nserde = { version = \"1.0.217\", features = [\"derive\"] }  \nserde_json = \"1.0.140\"  \nthiserror = \"2.0.11\"",
            "`anyhow` Error: Application-level Error Handling",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`thiserror` Error: Defining Library-level Errors",
            "Reference: [Rust std::error::Error trait documentation](https://doc.rust-lang.org/beta/core/error/trait.Error.html)",
            "```\npub trait Error: Debug + Display {\n```\n",
            "snafu` Error: Context-driven Error Management",
            "Comparison and Selection Guide",
            "Practical Implementation",
            "Add Dependencies",
            "`main.rs` File",
            "```\nuse anyhow::Context;  \nuse rust_ecosystem_learning::MyError;  \nuse std::fs;  \nuse std::mem::size_of;  \n  \nfn main() -> Result<(), anyhow::Error> {  \n    println! (\"size of anyhow::Error: {}\", size_of::<anyhow::Error>());  \n    println! (\"size of std::io::Error: {}\", size_of::<std::io::Error>());  \n    println! (  \n        \"size of std::num::ParseIntError: {}\",  \n        size_of::<std::num::ParseIntError>()  \n    );  \n    println! (  \n        \"size of serde_json::Error: {}\",  \n        size_of::<serde_json::Error>()  \n    );  \n    println! (\"size of string: {}\", size_of::<String>());  \n    println! (\"size of MyError: {}\", size_of::<MyError>());  \n  \n    let filename = \"non_existent_file.txt\";  \n    let _fd =  \n        fs::File::open(filename).with_context(|| format! (\"Cannot find file: {}\", filename))? ;  \n  \n    fail_with_error()? ;  \n    Ok(())  \n}  \n  \nfn fail_with_error() -> Result<(), MyError> {  \n    Err(MyError::Custom(\"This is a custom error\".to_string()))  \n}  \n  \n#[cfg(test)]  \nmod tests {  \n    #[test]  \n    fn it_works() {  \n        assert_eq!\n(2 + 2, 4);  \n    }  \n}\n```"
          ]
        },
        {
          "title": "The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html",
          "excerpts": [
            "Enable error handling with `longjmp` :** As mentioned above, some existing Rust libraries rely on the ability to `longjmp` across Rust frames to interoperate with Ruby, Lua, and other C\n  APIs. The behavior of `longjmp` traversing Rust frames is not specified or\n  guaranteed to be safe; in the current implementation of `rustc` ,\n  however, it [is safe](https://github.com/rust-lang/rust/pull/48572) . On Windows, `longjmp` is implemented as a\n  form of unwinding called [â€œforced unwindingâ€]() , so any\n  specification of the behavior of forced unwinding across FFI boundaries\n  should be forward-compatible with a [future RFC]() that\n  will provide a well-defined way to interoperate with longjmp-based APIs. * **Do not change the ABI of functions in the `libc` crate:** Some `libc` functions may invoke `pthread_exit` , which uses [a form of\n  unwinding]() in the GNU libc implementation. Such functions\n  must be safe to use with the existing `\"C\"` ABI, because changing the types\n  of these fu",
            "### [Enable Rust panics to traverse through foreign frames]()",
            "### [Enable foreign exceptions to propagate through Rust frame]()",
            "The behavior of `catch_unwind` when a foreign exception encounters it is\ncurrently [left undefined]() . We would like to\nprovide a well-defined behavior for this case, which will probably be either to\nlet the exception pass through uncaught or to catch some or all foreign\nexceptions."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "Unwinding through FFI after Rust 1.33 - language design",
          "url": "https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521",
          "excerpts": [
            "Feb 26, 2019 â€” It is possible to \"unwind\" over Rust code using longjmp , so you could have C call setjmp then call back into Rust for a group of operations,Â ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling - The Rust Programming Language",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features."
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to error handling and panics in Rust, specifically mentioning 'Result', 'Option', '? operator', 'panic!', 'thiserror', and 'anyhow'. The provided excerpts contain information directly relevant to these terms.\n\nSeveral excerpts discuss the `Result` enum, its variants `Ok` and `Err`, and its role in recoverable errors (e.g., excerpts 540, 543, 628, 632, 635, 941, 950, 956, 965, 972, 973, 974, 978, 986, 987, 998). The `?` operator is explained as a shorthand for error propagation with `Result` (e.g., excerpts 638, 624, 960, 970).\n\nThe `Option` enum and its variants `Some` and `None` are also discussed in the context of optional values (e.g., excerpts 539, 622, 623).\n\nThe `panic!` macro and its behavior, including unwinding and aborting, are covered in excerpts related to unrecoverable errors (e.g., excerpts 911, 912, 913, 914, 915, 924, 925, 926, 927, 928, 996).\n\nThe `thiserror` crate is mentioned as a tool for defining library-level errors and customized error types (e.g., excerpts 947, 950, 963, 964, 965, 966, 985).\n\nThe `anyhow` crate is described as suitable for application-level error handling, providing a unified error type and simplifying error propagation with the `?` operator, as well as supporting dynamic context (e.g., excerpts 949, 952, 953, 959, 960, 961, 983, 984, 999).\n\nExcerpts discussing error handling in general, including the `std::error::Error` trait, are also relevant (e.g., excerpts 972, 973, 986).",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords",
      "citations": [
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")",
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")."
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        }
      ],
      "reasoning": "The provided `finegrained_field_value` describes `Vec` and `HashMap` collections. Excerpts discuss `Vec`'s underlying structure as a contiguous growable array and its performance characteristics, including O(1) append and O(n) random removal, and its use cases like stack implementation. Excerpts also detail `HashMap`'s underlying structure as a hash table with open addressing, its average O(1) lookup performance (with O(n) worst-case), and its use cases for key-value storage with efficient random access. These excerpts directly support the information provided in the `finegrained_field_value`.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords",
      "citations": [
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\""
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n",
            "Iterators are also composable, and itâ€™s common to chain them together to do\nmore complex forms of processing. See the [Adapters]() section\nbelow for more details.\n",
            "Iterators (and iterator [adapters]() ) are _lazy_ . This means that\njust creating an iterator doesnâ€™t _do_ a whole lot. Nothing really happens\nuntil you call [`next`](trait.Iterator.html.next \"method std::iter::Iterator::next\") .",
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "pub trait DoubleEndedIterator: Iterator {",
            "    // Required method",
            "    fn next_back (&mut self) -> Option <Self:: Item >;",
            "    // Provided methods",
            "    fn advance_back_by (&mut self, n: usize ) -> Result < () , NonZero < usize >> { ... }",
            "    fn nth_back (&mut self, n: usize ) -> Option <Self:: Item > { ... }",
            "    fn try_rfold <B, F, R>(&mut self, init: B, f: F) -> R",
            "             F: FnMut (B, Self:: Item ) -> R,",
            "             R: Try <Output = B> { ... }",
            "    fn rfold <B, F>(self, init: B, f: F) -> B",
            "             F: FnMut (B, Self:: Item ) -> B { ... }",
            "    fn rfind <P>(&mut self, predicate: P) -> Option <Self:: Item >",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "             P: FnMut (&Self:: Item ) -> bool { ... }",
            "An iterator able to yield elements from both ends.",
            "Something that implements `DoubleEndedIterator` has one extra capability",
            "over something that implements [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") : the ability to also take `Item` s from the back, as well as the front.",
            "It is important to note that both back and forth work on the same range,",
            "and do not cross: iteration is over when they meet in the middle.",
            "In a similar fashion to the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") protocol, once a `DoubleEndedIterator` returns [`None`](../option/enum.Option.html#variant.None \"variant std::option::Option::None\") from a [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") , calling it",
            "again may or may not ever return [`Some`](../option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. [`next()`](trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") and [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") are interchangeable for this purpose.",
            "\n## Required Methods [Â§](#required-methods)",
            "1\\.0.0 Â· [Source](../../src/core/iter/traits/double_ended.rs.html#94)",
            "#### fn [next\\_back](#tymethod.next_back) (&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\") <Self:: [Item](trait.Iterator.html#associatedtype.Item \"type std::iter::Iterator::Item\") >",
            "Removes and returns an element from the end of the iterator.",
            "Returns `None` when there are no more elements.",
            "The [trait-level](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") docs contain more details.",
            "##### [Â§](#examples-2) Examples",
            "Basic usage:",
            "```\nlet numbers = vec! [ 1 , 2 , 3 , 4 , 5 , 6 ];\n\nlet mut iter = numbers.iter();\n\nassert_eq! ( Some ( & 1 ), iter.next());\nassert_eq! ( Some ( & 6 ), iter.next_back());\nassert_eq! ( Some ( & 5 ), iter.next_back());\nassert_eq! ( Some ( & 2 ), iter.next());\nassert_eq! ( Some ( & 3 ), iter.next());\nassert_eq! ( Some ( & 4 ), iter.next());\nassert_eq! ( None , iter.next());\nassert_eq! ( None , iter.next_back());\n```\n",
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "    // Required method",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Trait FusedIterator - std::iter (Rust std docs)",
          "url": "http://doc.rust-lang.org/std/iter/trait.FusedIterator.html",
          "excerpts": [
            "pub trait FusedIterator: Iterator { }",
            "An iterator that always continues to yield `None` when exhausted.",
            "Note: In general, you should not use `FusedIterator` in generic bounds if\nyou need a fused iterator. Instead, you should just call [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\") on the iterator. If the iterator is already fused, the additional [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper will be a no-op with no performance penalty.",
            "to return [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") again. This trait should be implemented by all iterators",
            "that behave this way because it allows optimizing [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\")."
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "FnOnce in std::ops - Rust",
            "pub trait FnOnce<Args>",
            "where\n    Args: Tuple ,",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected."
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too."
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Instances of `Fn` can be called repeatedly without mutating state.",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently)."
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "standard library. The definition of the trait looks like this:",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:",
            "pub trait Iterator {",
            "    fn next(&mut self) -> Option<Self::Item>;",
            "    // methods with default implementations elided",
            "amed `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this",
            "### [The `Iterator` Trait and the `next` Method]()",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "The `Iterator` trait only requires implementors to define one method: the",
            "`next` method, which returns one item of the iterator at a time, wrapped in",
            "`Some` and, when iteration is over, returns `None`.",
            "We can call the `next` method on iterators directly; Listing 13-12 demonstrates",
            "what values are returned from repeated calls to `next` on the iterator created",
            "from the vector.",
            "Note that we needed to make `v1_iter` mutable: calling the `next` method on an",
            "iterator changes internal state that the iterator uses to keep track of where",
            "it is in the sequence. In other words, this code *consumes*, or uses up, the",
            "iterator.",
            "Also note that the values we get from the calls to `next` are immutable",
            "references to the values in the vector. The `iter` method produces an iterator",
            "over immutable references. If we want to create an iterator that takes",
            "ownership of `v1` and returns owned values, we can call `into_iter` instead of",
            "`iter`. Similarly, if we want to iterate over mutable references, we can call",
            "`iter_mut` instead of `iter`.",
            "### [Methods That Consume the Iterator]()",
            "The `Iterator` trait has a number of different methods with default",
            "implementations provided by the standard library; you can find out about these",
            "methods by looking in the standard library API documentation for the `Iterator`",
            "trait. Some of these methods call the `next` method in their definition, which",
            "is why youâ€™re required to implement the `next` method when implementing the",
            "`Iterator` trait.",
            "Methods that call `next` are called *consuming adapters* because calling them",
            "uses up the iterator. One example is the `sum` method, which takes ownership of",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "consuming the iterator.",
            "### [Methods that Produce Other Iterators]()",
            "*Iterator adapters* are methods defined on the `Iterator` trait that donâ€™t",
            "consume the iterator. Instead, they produce different iterators by changing",
            "some aspect of the original iterator.",
            "In Listing 13-15, we collect the results of iterating over the iterator thatâ€™s",
            "returned from the call to `map` into a vector. This vector will end up",
            "containing each item from the original vector, incremented by 1.",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "on each item. This is a great example of how closures let you customize some",
            "behavior while reusing the iteration behavior that the `Iterator` trait",
            "provides.",
            "You can chain multiple calls to iterator adapters to perform complex actions in",
            "a readable way. But because all iterators are lazy, you have to call one of the",
            "consuming adapter methods to get results from calls to iterator adapters.",
            "### [Using Closures That Capture Their Environment]()",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "weâ€™ll specify as arguments to iterator adapters will be closures that capture",
            "their environment.",
            "The `shoes_in_size` function takes ownership of a vector of shoes and a shoe",
            "size as parameters. It returns a vector containing only shoes of the specified",
            "size.",
            "The closure captures the `shoe_size` parameter from the environment and",
            "compares the value with each shoeâ€™s size, keeping only shoes of the size",
            "specified. Finally, calling `collect` gathers the values returned by the",
            "adapted iterator into a vector thatâ€™s returned by the function.",
            "The test shows that when we call `shoes_in_size`, we get back only shoes",
            "that have the same size as the value we specified.",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterato",
            "    type Item;",
            "    type IntoIter: Iterator<Item = Self::Item>;\n",
            "    // Required method\n",
            "    fn into_iter(self) -> Self::IntoIter;",
            "}",
            "ion\n\nConversion into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"). By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind. One benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\"). See also: [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). [Â§]()Examples",
            "By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.",
            "\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\").",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n",
            "fn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}",
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "How does for loop implement into_iter - rust",
          "url": "https://stackoverflow.com/questions/72258925/how-does-for-loop-implement-into-iter",
          "excerpts": [
            "The iterable is transformed into an iterator by executing IntoIterator::into_iter(iterable). Each trait, including IntoIterator, has a hidden Self genericÂ ..."
          ]
        },
        {
          "title": "Passing slice as an IntoIterator - rust",
          "url": "https://stackoverflow.com/questions/35144386/passing-slice-as-an-intoiterator",
          "excerpts": [
            "Let's take a look at how IntoIterator is implemented for slices: impl<'a, T> IntoIterator for &'a [T] type Item = &'a T type IntoIter = Iter<'a, T>"
          ]
        },
        {
          "title": "Difference Between into_iter, iter() and iter_mut() in rust",
          "url": "https://blog.coolhead.in/difference-between-intoiter-iter-and-itermut-in-rust",
          "excerpts": [
            "Nov 24, 2023 â€” into_iter() transfers ownership of the collection, iter() borrows the elements immutably, and iter_mut() borrows them mutably."
          ]
        },
        {
          "title": "IntoIter in std::vec",
          "url": "https://doc.rust-lang.org/std/vec/struct.IntoIter.html",
          "excerpts": [
            "An iterator that moves out of a vector. This struct is created by the into_iter method on Vec (provided by the IntoIterator trait)."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`",
            "They preferentially capture variables by reference and only go lower when\nrequired. ```"
          ]
        },
        {
          "title": "FromIterator in std::iter - Rust",
          "url": "https://doc.rust-lang.org/std/iter/trait.FromIterator.html",
          "excerpts": [
            "pub trait FromIterator<A>: Sized {\n    // Required method\n    fn from_iter <T>(iter: T) -> Self\n       where T: IntoIterator <Item = A> ;\n}",
            "Conversion from an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") . By implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind. If you want to create a collection from the contents of an iterator, the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`](trait.FromIterator.html.from_iter \"associated function std::iter::FromIterator::from\\_iter\") can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()` ).\nSee the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") documentation for more examples of its use."
          ]
        },
        {
          "title": "What is the difference between iter and into_iter? (Stack Overflow)",
          "url": "https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter",
          "excerpts": [
            "What is the difference between `iter` and `into_iter` ? `into_iter` is a generic method to obtain an iterator, whether this iterator yields values, immutable references or mutable references **is context dependent** and can sometimes be surprising. `iter` and `iter_mut` are inherent methods. Their return type is therefore independent of the context, and will conventionally be iterators yielding immutable references and mutable references, respectively. The author of the Rust by Example post used Rust pre-1.53.0 to illustrate the surprise coming from the dependence on the context (i.e., the type) on which `into_iter` is called, and is also compounding the problem by using the fact that:\n\n1. Back then, `IntoIterator` was not implemented for `[T; N]` , only for `&[T; N]` and `&mut [T; N]` . 2",
            "* `iter()` iterates over the items by reference",
            "* `iter_mut()` iterates over the items, giving a mutable reference to each item",
            "* `into_iter()` iterates over the items, moving them into the new scope",
            "So `for x in my_vec { ... }` is essentially equivalent to `my_vec.into_iter().for_each(|x| ... )` \\- both `move` the elements of `my_vec` into the `...` scope. If you just need to _look at_ the data, use `iter` , if you need to edit/mutate it, use `iter_mut` , and if you need to give it a new owner, use `into_iter` "
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to functional programming in Rust. The provided value `['Iterator trait', 'closure', 'Fn', 'FnMut', 'FnOnce', 'fold', 'map', 'filter']` directly corresponds to concepts discussed in the excerpts. Excerpts from \"The Rust Programming Language\" (e.g., Index 782, 783, 786, 788, 790, 792, 794, 796, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847) extensively cover the `Iterator` trait, its methods like `fold`, `map`, and `filter`, and the concept of lazy evaluation. Excerpts from `std::ops` (e.g., Index 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781) discuss closures and the `Fn`, `FnMut`, and `FnOnce` traits. Excerpts from `std::iter` (e.g., Index 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763) detail the `Iterator` trait and its adapters like `fold`, `map`, and `filter`, as well as `DoubleEndedIterator`. Excerpts from `std::vec` (Index 863) and `IntoIterator` (Index 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859) also relate to iterators and closures. Excerpts from Stack Overflow (Index 860, 861, 870, 871, 872, 873, 874) discuss `into_iter`, `iter`, `iter_mut`, and their behavior with collections like `Vec`. Excerpts from `rust-by-example` (Index 866, 867) explain closure capturing. Excerpt 70 from The Rust Reference also mentions `macro_rules` and its relation to macros, which can be used to generate code that utilizes these functional programming concepts.",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.5",
      "citations": [
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "`anyhow` Error: Application-level Error Handling",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`thiserror` Error: Defining Library-level Errors"
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features."
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "* `thiserror` supports customized error types, making it suitable for library development;"
          ]
        }
      ],
      "reasoning": "The finegrained field value centers on the keyword 'anyhow' within Rust error handling. Excerpts that explicitly discuss anyhowâ€”its role as a general-purpose error type, its ability to simplify boilerplate, and its use in application-level error handlingâ€”directly support the field value. For example, excerpts that describe how anyhow provides a general-purpose error type and reduces boilerplate map directly to the concept of using anyhow for error handling. Other excerpts that compare anyhow to alternatives (such as thiserror or snafu) offer context about when you might choose anyhow, but they are secondary to the core claim about anyhow itself. Additional excerpts that discuss error handling in general (without mentioning anyhow) provide supportive background but do not confirm the specific keyword usage. The quotes from the excerpts indicate that anyhow contributes to simpler error management, central error type handling, and practical usage in Rust, which aligns with the fine-grained field value. Therefore, the most directly relevant items are those explicitly mentioning 'anyhow' and its properties, followed by close contextual or comparative discussions, and finally broader error-handling overviews that anchor the topic in the Rust ecosystem.",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.1",
      "citations": [
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html).",
            "Returns the contained [`Some`](enum.Option.html.Some \"variant std::option::Option::Some\") value, consuming the `self` value. Because this function may panic, its use is generally discouraged. Panics are meant for unrecoverable errors, and\n[may abort the entire program](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html).",
            "The map method takes the self argument by value, consuming the original, so this technique uses as_ref to first take an Option to a reference to the valueÂ ... Computes a default function result (if none), or applies a different function to the contained value (if any). Â§Basic examples. let k = 21; let x = Some(\"foo\"); ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value corresponds to the Rust language concept of an optional value type. The most direct support comes from excerpts that explicitly define Option as representing an optional value and describe its core semantics around being either Some(value) or None. This establishes the fundamental meaning of Option in Rust and directly aligns with the field. Additional excerpts reinforce this concept by mentioning the Some variant and how Option interacts with typical operations, which helps situate Option within Rustâ€™s standard library semantics and common patterns. While other excerpts discuss error handling through Result types and general error-handling patterns, they do not redefine the Option concept, so they provide contextual background but are less central to the specific field value. Overall, the core supportive content is the explicit definition of an optional value type and its Some/None behavior, with supplementary notes about Some in related contexts to strengthen understanding of Optionâ€™s role in Rust.",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.4",
      "citations": [
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "`thiserror` Error: Defining Library-level Errors",
            "`anyhow` Error: Application-level Error Handling"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explicitly states that thiserror supports customized error types and is suitable for library development, which aligns with the idea of using thiserror for library-level error definitions. This confirms a primary use case of the thiserror crate in Rust: defining library-level errors and providing macros to simplify error definitions. A following excerpt describes that thiserror is used to define library-level errors and can automate error type generation, indicating its role in project structure where library boundaries and error types matters. Additional excerpts explain that thiserror enables features such as the From attribute and structured error information, which underscores how this crate integrates with Rustâ€™s error handling ecosystem by enabling ergonomic conversions and rich error metadata. A separate excerpt explicitly labels thiserror in the context of library-level error definitions, reinforcing its intended use for libraries rather than applications. Other excerpts compare or mention related crates (anyhow, snafu) and discuss general error handling concepts, illustrating the ecosystem context in which thiserror operates, but the strongest signals are about its library-level focus, macro support, and customization capabilities. Taken together, these excerpts support the field value by confirming that thiserror is a key library-focused error-handling crate in Rust, with macro-based definitions and From-style integrations, which is exactly what the field value references. ",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.2",
      "citations": [
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s\nimplementation simpler."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n"
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)."
          ]
        }
      ],
      "reasoning": "The strongest support comes from a passage that explicitly states that the ? operator eliminates boilerplate and simplifies the functionâ€™s implementation, which directly captures the essence of how ? is used to propagate errors succinctly. A nearby excerpt shows the practical use case: the ? operator is used in functions that return Result, which is exactly the scenario where ? is applied to propagate recoverable errors. Another excerpt marks the operator with a direct label, indicating its role as the try operator for error propagation in Rust, reinforcing its semantics within standard error handling. Finally, a passage outlining error handling with the Result type provides necessary background showing how Result is used for returning and propagating errors, which frames why the ? operator is valuable in this context.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_TRAIT : `trait"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "The Rust Programming Language Blog",
          "url": "https://blog.rust-lang.org/",
          "excerpts": [
            "This is the main Rust blog. Rust teams use this blog to announce major developments in the world of Rust. See also: the \"Inside Rust\" blog,Â ..."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "```rust",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust",
            "fn main() {",
            "}",
            "}",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "# [`min_specialization`]()",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "min\\_specialization - The Rust Unstable Boo"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            " [Idea] About soundness in specialization ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... ",
            "This topic was automatically closed 90 days after the last reply. New replies are no longer allowed."
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes.",
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Rust Deep Dive: Borked Vtables and Barking Cats",
          "url": "https://geo-ant.github.io/blog/2023/rust-dyn-trait-objects-fat-pointers/",
          "excerpts": [
            "Mar 15, 2023 â€” The pointers to dyn Trait objects store both the address of the data as well as a pointer to the vtable. There is one global vtable instance forÂ ...",
            "Mar 15, 2023 â€” We'll get to the specific layout of a vtable below, but for now suffice it to say that a vtable is a contiguous piece of storage in memory thatÂ ..."
          ]
        },
        {
          "title": "Understanding Rust's Trait Objects: Vtables, Dynamic ...",
          "url": "https://www.reddit.com/r/rust/comments/1epc5g6/understanding_rusts_trait_objects_vtables_dynamic/",
          "excerpts": [
            "This article investigates how Rust handles dynamic dispatch using trait objects and vtables. It also explores how the Rust compiler can sometimes optimize tailÂ ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "# [Chalk: Orphan Check]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "## [The Orphan Rules]()",
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "The reason for this is that there are two appearances of type parameter `T` in",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117)."
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to 'traits_and_generics_keywords' in Rust. The provided value is a list of terms: ['trait', 'impl Trait', 'dyn Trait', 'associated types', 'trait bounds', 'blanket implementations', 'trait coherence', 'orphan rules'].\n\nExcerpts that discuss traits, implementations, trait objects, associated types, trait bounds, blanket implementations, trait coherence, and orphan rules are relevant.\n\nSpecifically, excerpts discussing the definition of traits (Index 39, 297, 299, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429), implementations (Index 305, 470, 471, 472, 473, 474, 475, 476, 477, 478), trait objects (Index 307, 446, 447, 448, 449, 450, 414, 415, 421, 422, 423, 424, 425, 426, 427, 428, 429, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382), trait bounds (Index 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413), blanket implementations (Index 442, 443, 444, 445), trait coherence (Index 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478), and orphan rules (Index 469, 470, 471, 473, 474, 475, 476, 477, 478).",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.0",
      "citations": [
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        }
      ],
      "reasoning": "The finegrained field value describes a Vec as a standard sequential collection with a contiguous growable underlying structure. The excerpts directly addressing Vec characteristics provide explicit support: the most directly relevant material presents a performance table for common collections, explicitly listing Vec with time complexities like fast O(1) access for get and the amortized O(1) push behavior, while also noting that certain operations incur O(n) costs (e.g., inserts/removals at arbitrary positions). This aligns with the described performance traits (O(1) append, O(n) random removal) and the underlying structure as a contiguous, growable array. Additional excerpts discuss pushing and inserting behavior relative to capacity, directly supporting the idea that Vec can reallocate when capacity is insufficient and can grow contiguously, matching the listed underlying structure and performance nuances. Another excerpt enumerates standard Rust collections and places Vec squarely in the Sequences category, reinforcing that Vec is a standard sequential collection in the Rust standard library. A further excerpt contrasts Vec with other collections (e.g., HashMap) to contextualize performance discussions, which helps corroborate the performance-focused attributes, though the HashMap content itself is not the primary target of the finegrained field. Collectively, the excerpts provide clear evidence for: Vec as a standard sequential collection, its underlying contiguous growable array structure, and its performance characteristics (fast append, potential N-cost operations like certain removals or arbitrary insertions). The most informative pieces map directly to the target field valueâ€™s components, while surrounding excerpts offer contextual support about how Vec compares to other collections and how capacity-driven reallocations occur.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.3",
      "citations": [
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too."
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Instances of `Fn` can be called repeatedly without mutating state.",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently)."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to FnMut within the context of functional programming in Rust. The most directly supportive information comes from excerpts that define FnMut as a trait and describe its behavior: FnMut is a trait, and instances of FnMut can be called repeatedly and may mutate state. This directly aligns with the idea of a function-like entity that can mutate its environment across invocations. Additional excerpts provide context by describing the relationship between function-like traits (Fn, FnMut, FnOnce) and their usage, clarifying how FnMut fits into the hierarchy and how it differs from Fn and FnOnce. Specifically, the FnMut trait section explains its place in the trait hierarchy and its mutating-call capability, which directly supports understanding a value labeled FnMut. The nearby excerpts about Fn and general closures offer helpful context about how these traits compare and interact, reinforcing why FnMut is distinct and when you would choose FnMut semantics over the other callable traits.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.2",
      "citations": [
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Instances of `Fn` can be called repeatedly without mutating state.",
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently).",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe"
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu",
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too.",
            "Instances of `FnMut` can be called repeatedly and may mutate state."
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "FnOnce in std::ops - Rust",
            "pub trait FnOnce<Args>",
            "where\n    Args: Tuple ,",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n"
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        }
      ],
      "reasoning": "The most relevant information directly identifies and describes the Fn trait and its role in Rust. One excerpt explains that Fn is a bound you can use when you want to accept a function-like type and call it repeatedly without mutating state, which is a core description of the Fn traitâ€™s purpose. Another excerpt explicitly frames Fn as a trait used in closures overview, clarifying its place alongside other callable traits. A third excerpt reiterates the Fn trait and closures relationship, reinforcing that Fn is a bound relevant to function-like parameters and how theyâ€™re intended to be used in generic contexts. Together, these excerpts establish a clear, direct link to the finegrained field value by defining Fn, its bounds usage, and its role among function-like traits. Additional excerpts extend the context by contrasting Fn with FnMut and FnOnce, which helps situate Fn in the broader ecosystem of callable traits and their respective capabilities. The remaining excerpts discuss related concepts (such as FnOnce and FnMut specifics, or broader function/closure discussions) which, while not as directly about the Fn trait alone, still support understanding of Fnâ€™s place in Rustâ€™s function-like abstractions. The combined information supports the field value as a definition and contextual usage of Fn in Rust.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.0",
      "citations": [
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "pub trait Iterator {",
            "### [The `Iterator` Trait and the `next` Method]()",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up."
          ]
        }
      ],
      "reasoning": "The most relevant excerpts directly introduce the core interface and requirements of the Iterator trait. One excerpt presents the trait's surface, showing the associated type Item and the required next method, which is central to how an iterator yields values. This directly supports the notion of the Iterator trait as the defining interface for iteration in Rust. Another excerpt presents the trait definition elements from the book, including the associated Item type and the next method signature, reinforcing that the Iterator trait is a foundational trait in Rust's standard library. Additional excerpts explicitly state that all iterators implement a trait named Iterator defined in the standard library, underscoring the canonical status and centrality of this trait. Further excerpts discuss the lazy nature of iterators and how they are used in chaining and consuming adapters, which provides context on how the Iterator trait is employed in Rust's iteration ecosystem. The excerpts that discuss the Iterator trait and its methods, as well as those that emphasize that iterators are defined by this trait in the standard library, collectively support the understanding of the Iterator trait as the core interface for Rustâ€™s iteration mechanics.",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.3",
      "citations": [
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "Unrecoverable Errors with panic! - The Rust Programming Language",
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "oml\n[profile.release]\npanic = 'abort'\n```"
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution.",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Error Handling - The Rust Programming Language"
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        }
      ],
      "reasoning": "The strongest support comes from excerpts explicitly titled or describing panic! as an unrecoverable error mechanism. These excerpts discuss panic! in the Rust programming language as a way to stop execution or unwind across frames, which directly underpins the notion of panic! as a core uncontrolled failure signal in Rust error handling. Additional excerpts confirm that panic is an unrecoverable error path, and they describe its practical implications, such as unwinding behavior through FFI boundaries and choices like aborting the process via crate configuration. Together, these excerpts establish that panic! is the canonical unrecoverable error in Rust and outline its interaction with error handling strategies and program termination. The surrounding excerpts that address error handling at a broader level (without mentioning panic!) provide contextual background but are less directly supportive of the specific keyword panic!. The combination of direct panic-focused content and its stated consequences (unrecoverable errors, potential unwinding, or abort behavior) best supports the finegrained field value.\n",
      "confidence": "high"
    },
    {
      "field": "error_handling_and_panics_keywords.0",
      "citations": [
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "he `Result` enum is defined as having two\nvariants, `Ok` and `Err` , as follows:"
          ]
        },
        {
          "title": "Error handling - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/error.html",
          "excerpts": [
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input would ... Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ...",
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ... When there is a chance that things do go wrong and the caller has to deal with the problem, use Result . You can unwrap and expect them as well (please don't do ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution.",
            "Error Handling - The Rust Programming Language",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep"
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "Unwinding through FFI after Rust 1.33 - language design",
          "url": "https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521",
          "excerpts": [
            "Feb 26, 2019 â€” It is possible to \"unwind\" over Rust code using longjmp , so you could have C call setjmp then call back into Rust for a group of operations,Â ..."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features."
          ]
        }
      ],
      "reasoning": "The core finegrained field value is the type Result, central to Rust's error handling paradigm. Direct references to the Result type, its variants (Ok and Err), and its role in returning and propagating errors provide the strongest support for the field value. Excerpts that explicitly describe Result as the type used for recovering from errors, its variants, and its use in functions and I/O establish clear alignment with the field. Excerpts that discuss patterns, such as mapping, unwrapping, and propagation of Result, further reinforce the centrality of Result in error handling. Excerpts that describe related types or patterns (Option, panic, and error-handling crates) provide useful context but are ancillary to the exact field value, so they are ranked below the direct Result-focused content. The selected excerpts therefore form a gradient of direct to contextual relevance, with the most relevant containing explicit statements about Resultâ€™s role in error handling and its behavior in success and failure cases. ",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.4",
      "citations": [
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "FnOnce in std::ops - Rust",
            "pub trait FnOnce<Args>",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`",
            "They preferentially capture variables by reference and only go lower when\nrequired. ```"
          ]
        }
      ],
      "reasoning": "The fine-grained field value corresponds to the FnOnce trait, which represents the ability to call a function-like object at least once. Direct references in the excerpts establish this relationship: one excerpt introduces FnOnce in std::ops and refers to it as a trait for function-like objects, one defines the FnOnce trait with a specific bound for the call_once method, and subsequent excerpts describe the required method (call_once) and behavior of FnOnce when invoked, including how instances of FnOnce can be called and how closures may implement FnOnce. Additional excerpts discuss how function pointers can implement FnOnce, and how FnOnce relates to closures that may move captured values, reinforcing the core concept that FnOnce is a trait governing one-time callable behavior and its place in the hierarchy of closure traits. The nearby discussions about Fn and FnMut provide context for how FnOnce differs from other callable traits, but the most pertinent content centers on the single-use callable nature and its core method. The surrounding closure-capturing material helps explain practical implications (moving captured data) that relate to FnOnce semantics, further strengthening the linkage between the field value and its explicit trait definition and usage.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.6",
      "citations": [
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "returned from the call to `map` into a vector. This vector will end up",
            "containing each item from the original vector, incremented by 1.",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "on each item. This is a great example of how closures let you customize some",
            "behavior while reusing the iteration behavior that the `Iterator` trait"
          ]
        }
      ],
      "reasoning": "The field value corresponds to the map adapter, which is a commonly used iterator adapter in Rust. The first supporting excerpt explicitly lists map as one of the common iterator adapters, establishing that map is a standard, widely-used concept in Rust iterators. A latter excerpt provides a concrete code example applying map to transform each item, demonstrating how map is used in practice to produce a new iterator by applying a function to each element. Additional excerpts reinforce this usage by describing the effect of map in common iterator workflowsâ€”such as transforming each item (e.g., incrementing each element) and collecting resultsâ€”further validating map as a core, practical tool in Rust iterators. Additional excerpts discuss map in broader context of iterators and adapters, illustrating its role among other adapters like take and filter, and in examples that show how map yields transformed outputs from an input collection. Taken together, these excerpts directly support the field value by defining map as a standard adapter, showing its syntax, and illustrating its usage in transforming data within iterators.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.3",
      "citations": [
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "Associated types"
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly points to the concept of associated types within the Rust Traits section, signaling that it is a core topic under trait definitions. The surrounding content in that excerpt shows a dedicated entry titled 'Associated types', which directly aligns with the field value being analyzed. A closely linked excerpt describes how 'Associated types' are used to improve code readability by moving inner types into a trait and using them as output types, which directly explains the purpose and role of associated types within trait definitions. A third excerpt addresses a related concept (associated constants in traits with generics), which does not discuss associated types themselves but signals that the broader area of trait-associated items includes related constructs and that these topics often appear together in trait/generics discussions. Collectively, these excerpts map a direct definition, a practical usage description, and the surrounding contextual relationship to associated types within Rust traits and generics.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.1",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "To support the finegrained field value, the most compelling excerpts are those that explicitly state the HashMap underlying structure and its performance characteristics. One excerpt clearly identifies the HashMap as using a hash table with open addressing and notes its use case as key-value storage with efficient random access, directly aligning with the field valueâ€™s description of the underlying structure and practical use. Another excerpt provides a performance snapshot for collections, including a row for HashMap with stated constant-time lookup/operations in the typical case, which corroborates the emphasis on O(1) behavior for common operations. A third excerpt lists HashMap among Rustâ€™s standard collection categories, which establishes the presence and relevance of HashMap in the overall Rust collection ecosystem, supporting contextual relevance to the field value even though it does not detail the structure or performance. The more peripheral excerpts discuss related collections or general performance comparisons (e.g., Vec and other structures) and are less directly aligned with the specific finegrained field value, but still help situate HashMap within Rustâ€™s collection landscape. The combination of explicit underlying structure, explicit performance notes, and contextual placement provides coherent support for the field valueâ€™s claims about HashMap and its behavior.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.1",
      "citations": [
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`",
            "They preferentially capture variables by reference and only go lower when\nrequired. ```"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "### [Using Closures That Capture Their Environment]()",
            "their environment.",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently)."
          ]
        }
      ],
      "reasoning": "The target field value refers to closures, a core concept in functional-style programming within Rust. Excerpts that directly illustrate closures and their behavior are most relevant. The passages that explicitly discuss capturing variables by reference, by value, or by mutable reference, as well as how closures relate to function traits like Fn, FnMut, and FnOnce, provide concrete support for understanding closures in Rust. For example, excerpts that describe closures capturing their environment, and those that explain how function pointers interact with closure traits, directly illuminate how closures work in practice. Excerpts that address the Fn family and bound parameters describe how closures can be used in a type-system context, which is relevant to functional programming patterns in Rust. Related material about iterators and closures is still pertinent, as it places closures in the broader context of Rustâ€™s iteration and functional-style utilities, though it is slightly less direct than the explicit closure-focused explanations. Taken together, the most directly relevant content covers how closures capture their environment, how they relate to Fn, FnMut, and FnOnce, and concrete examples of closure usage and behavior.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords",
      "citations": [
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "More specifically, an await expression has the following effect. 1. Create a future by calling [`IntoFuture::into_future`](../../core/future/into_future/trait.IntoFuture.html.into_future) on the future operand. 2. Evaluate the future to a [future](../../core/future/future/trait.Future.html) `tmp` ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        },
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        },
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ...",
            "This is mostly useful for writing tests that need a Context to poll some futures, but are not expecting those futures to wake the waker or do not need to doÂ ..."
          ]
        },
        {
          "title": "Rust Concurrency: Atomic Explained",
          "url": "https://leapcell.medium.com/rust-concurrency-atomic-explained-a89923ea61fd",
          "excerpts": [
            "```\npub enum Ordering {  \n    Relaxed,  \n    Release,  \n    Acquire,  \n    AcqRel,  \n    SeqCst,  \n}\n```",
            "```\npub fn fetch_add(&self, val: i32, order: Ordering) -> i32 - Performs addition (or subtraction) on the atomic type  \npub fn compare_and_swap(&self, current: i32, new: i32, order: Ordering) -> i32 - CAS (deprecated in Rust 1.50, replaced by compare_exchange)  \npub fn compare_exchange(&self, current: i32, new: i32, success: Ordering, failure: Ordering) -> Result<i32, i32> - CAS  \npub fn load(&self, order: Ordering) -> i32 - Reads the value from the atomic type  \npub fn store(&self, val: i32, order: Ordering) - Writes a value to the atomic type  \npub fn swap(&self, val: i32, order: Ordering) -> i32 - Swaps values\n```",
            "```\nAtomicBool  \nAtomicI8  \nAtomicI16  \nAtomicI32  \nAtomicI64  \nAtomicIsize  \nAtomicPtr  \nAtomicU8  \nAtomicU16  \nAtomicU32  \nAtomicU64  \nAtomicUsize\n```",
            "The documentation for this module describes atomic types as follows: Atomic types in Rust provide primitive shared-memory communication between threads and serve as the foundation for building other concurrency types. The `std::sync::atomic` module currently offers the following 12 atomic types:"
          ]
        },
        {
          "title": "Builder in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Builder.html",
          "excerpts": [
            "Spawns a new scoped thread using the settings set through this Builder . Unlike Scope::spawn , this method yields an io::Result to capture any failure to create ..."
          ]
        },
        {
          "title": "Scope in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Scope.html",
          "excerpts": [
            "Spawns a new thread within a scope, returning a ScopedJoinHandle for it. Unlike non-scoped threads, threads spawned with this function may borrow non- 'static ..."
          ]
        },
        {
          "title": "sync_channel in std::sync::mpsc",
          "url": "https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html",
          "excerpts": [
            "Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent."
          ]
        },
        {
          "title": "std::sync",
          "url": "https://doc.rust-lang.org/std/sync/",
          "excerpts": [
            "A BarrierWaitResult is returned by Barrier::wait() when all threads in the Barrier have rendezvoused. Condvar: A Condition Variable; LazyLock: A value which isÂ ..."
          ]
        },
        {
          "title": "Rust std::sync::atomic - Atomic types",
          "url": "https://doc.rust-lang.org/std/sync/atomic/",
          "excerpts": [
            "Atomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes."
          ]
        },
        {
          "title": "Crossbeam-channel Documentation",
          "url": "http://docs.rs/crossbeam-channel/latest/crossbeam_channel",
          "excerpts": [
            "Extra channels",
            "Selection",
            "Iteration",
            "Blocking operations",
            "Disconnection",
            "Sharing channels",
            "Creating an unbounded channel:",
            "Creating a bounded channel:",
            "Channels can be created using two functions:",
            "This crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.",
            "Multi-producer multi-consumer channels for message passing."
          ]
        },
        {
          "title": "Epoch-based memory reclamation.",
          "url": "http://docs.rs/crossbeam-epoch/latest/crossbeam_epoch",
          "excerpts": [
            "-------\n\nObjects that get removed from concurrent collections must be stashed away until all currently\npinned participants get unpinned. ",
            "\n:   Pins the current thread.\n",
            "Atomic\")\n:   An atomic pointer that can be safely shared between thre",
            "). If you\nwant to create your own garbage collector, use the [`Collector",
            "For majority of use cases, just use the default garbage collector by invoking [`pi",
            "Anyhow, memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "That is the general mechanism behind epoch-based memory reclamation, but the details are a bit\nmore complicated.",
            "Every time a thread accesses a collection, it checks the current\nepoch, attempts to increment it, and destructs some garbage that became so old that no thread\ncan be referencing it anymore.",
            "When an\nelement gets removed from a concurrent collection, it is inserted into a pile of garbage and\nmarked with the current epoch.",
            "crossbeam\\_epoch - Rus",
            "Epoch-based memory reclamation.",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs."
          ]
        },
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "These data structures are most commonly used in work-stealing schedulers.",
            "Summary",
            "3. Try stealing one task from another thread using the stealer list.",
            "2. Try stealing a batch of tasks from the global injector queue.",
            "1. Try popping one task from the local worker queue.",
            "Suppose a thread in a work-stealing scheduler is idle and looking for the next task to run. To\nfind an available task, it might do the following:",
            "\n\nAn implementation of this work-stealing strategy:",
            "3. [`steal_batch_and_pop()`](struct.Stealer.html.steal_batch_and_pop \"method crossbeam_deque::Stealer::steal_batch_and_pop\") - Steals a batch of tasks, moves them into another queue, and pops\n   one task from that worker.",
            "2. [`steal_batch()`](struct.Stealer.html.steal_batch \"method crossbeam_deque::Stealer::steal_batch\") - Steals a batch of tasks and moves them into another worker.",
            "1. [`steal()`](struct.Stealer.html.steal \"method crossbeam_deque::Stealer::steal\") - Steals one task.",
            "Steal operations come in three flavors:",
            "Method [`stealer()`](struct.Worker.html.stealer \"method crossbeam_deque::Worker::stealer\") creates a [`Stealer`](struct.Stealer.html \"struct crossbeam_deque::Stealer\") that may be shared among threads and can only steal\ntasks from its [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\"). Tasks are stolen from the end opposite to where they get pushed.",
            "Each [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\") is owned by a single thread and supports only push and pop operations.",
            "* [`new_lifo()`](struct.Worker.html.new_lifo \"associated function crossbeam_deque::Worker::new_lifo\") - Creates a LIFO queue, in which tasks are pushed and popped from the same\n  end.",
            "* [`new_fifo()`](struct.Worker.html.new_fifo \"associated function crossbeam_deque::Worker::new_fifo\") - Creates a FIFO queue, in which tasks are pushed and popped from opposite\n  ends.",
            "Worker\") has two constructors:",
            "[`Injector`](struct.Injector.html \"struct crossbeam_deque::Injector\") is a FIFO queue, where tasks are pushed and stolen from opposite ends.",
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            ".\n\nThese data structures are most commonly used in work-stealing schedulers. The typical setup\ninvolves a number of threads, each having its own FIFO or LIFO queue (*worker*). There is also\none global FIFO queue (*injector*) and a list of references to *worker* queues that are able to\nsteal tasks (*stealers*).",
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Ergonomic**: Powerful `select`-like interface",
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Simple**: Few dependencies, minimal codebase, fast to compile",
            "* **Capable**: Additional features like MPMC support and send timeouts/deadlines",
            "* **Familiar**: Drop-in replacement for `std::sync::mpsc`",
            "* **Flexible**: `Sender` and `Receiver` both implement `Send + Sync + Clone`",
            "* **Safe**: No `unsafe` code anywhere in the codebase!",
            "* **Fast**: Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`",
            "* **Featureful**: Unbounded, bounded and rendezvous queues",
            "\nSummary[Source](../src/flume/lib.rs.html)\n\nExpand description\n\n[Â§]()Flume\n----------------\n\nA blazingly fast multi-producer, multi-consumer channel.",
            "A blazingly fast multi-producer, multi-consumer channel.",
            "Flume\nflume - Rust"
          ]
        },
        {
          "title": "scope in std::thread - Rust",
          "url": "http://doc.rust-lang.org/std/thread/fn.scope.html",
          "excerpts": [
            "\nAll threads spawned within the scope that havenâ€™t been manually joined\nwill be automatically joined before this function returns.",
            "\nUnlike non-scoped threads, scoped threads can borrow non- `'static` data,\nas the scope guarantees all threads will be joined at the end of the scope.",
            "\nThe function passed to `scope` will be provided a [`Scope`](struct.Scope.html \"struct std::thread::Scope\") object,\nthrough which scoped threads can be [spawned](struct.Scope.html.spawn \"method std::thread::Scope::spawn\") .",
            "Creates a scope for spawning scoped threads."
          ]
        },
        {
          "title": "Welcome to Concurrency in Rust",
          "url": "https://google.github.io/comprehensive-rust/concurrency/welcome.html",
          "excerpts": [
            "Rust has full support for concurrency using OS threads with mutexes and channels. The Rust type system plays an important role in making many concurrency bugs ..."
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`",
            "ts\n\nTest cases using loom must be fully deterministic. All sources of non-determism must be via loom\ntypes so that loom can expose different possible values on each execution of the test closure.",
            "Loom provides a way to deterministically explore the various possible execution permutations\nwithout relying on random executions. This allows you to write tests that verify that your\nconcurrent code is correct under _all_ executions, not just â€œmost of the time",
            "\nLoom is a tool for testing concurrent programs. At a high level, it runs tests many times, permuting the possible concurrent executions of each\ntest according to what constitutes valid executions under the [C11 memory model]"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "hand, `fence(SeqCst)` is supported.",
            "synchronization, causing Loom to generate false alarms (not complete). See [](https://github.com/tokio-rs/loom/issues/180) for example. On the other",
            "They are regarded as `AcqRel` . That is, they impose weaker",
            "* `SeqCst` accesses (e.g. `load` , `store` , ..):",
            "Loom currently does not implement the full C11 memory model. Here is the (incomplete) list of unsupported features.",
            "assert_eq ! ( 2 , num . load ( Relaxed ) ) ;",
            "th . join ( ) . unwrap ( ) ;",
            "for th in ths {",
            ". collect ( ) ;",
            "} )",
            "} )",
            "num . store ( curr + 1 , Release ) ;",
            "let curr = num . load ( Acquire ) ;",
            "thread :: spawn ( move || {",
            "clone ( ) ;",
            "let num = num .",
            ". map ( |_| {",
            "let ths : Vec < _ > = ( 0 .. 2 )",
            "let num = Arc :: new ( AtomicUsize :: new ( 0 ) ) ;",
            "use loom :: thread ;",
            "use loom :: sync :: atomic :: Ordering :: { Acquire , Release , Relaxed } ;",
            "use loom :: sync :: atomic :: AtomicUsize ;",
            "use loom :: sync :: Arc ;",
            "Loom is a testing tool for concurrent Rust code. It runs a test many\ntimes, permuting the possible concurrent executions of that test under\nthe [C11 memory model](https://en.cppreference.com/w/cpp/atomic/memory_order) .",
            "}"
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "\npull requests, and feedback. ",
            "Crossbeam welcomes contribution from everyone in the form of suggestions, bug reports,",
            "------------",
            "Contributing",
            "version is released. Currently, the minimum supported Rust version is 1.61.",
            "and every time the minimum supported Rust version is increased, a new minor",
            "Crossbeam supports stable Rust releases going back at least six months,",
            "-------------",
            "Compatibility",
            "```\n[dependencies]\ncrossbeam = \"0.8\"\n```",
            "Add this to your `Cargo.toml`:",
            "-----",
            "Usage",
            "* [`crossbeam-skiplist`](/crossbeam-rs/crossbeam/blob/master/crossbeam-skiplist)\n  provides concurrent maps and sets based on lock-free skip lists",
            "There is one more experimental subcrate that is not yet included in `crossbeam`:",
            "* [`crossbeam-utils`](/crossbeam-rs/crossbeam/blob/master/crossbeam-utils)\n  provides atomics, synchronization primitives, scoped threads, and other utilities",
            "* [`crossbeam-queue`](/crossbeam-rs/crossbeam/blob/master/crossbeam-queue)\n  provides concurrent queues that can be shared among threads",
            "* [`crossbeam-epoch`](/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch)\n  provides epoch-based garbage collection for building concurrent data structures",
            "* [`crossbeam-deque`](/crossbeam-rs/crossbeam/blob/master/crossbeam-deque)\n  provides work-stealing deques, which are primarily intended for building task schedulers",
            "* [`crossbeam-channel`](/crossbeam-rs/crossbeam/blob/master/crossbeam-channel)\n  provides multi-producer multi-consumer channels for message passing",
            "The main `crossbeam` crate just [re-exports](/crossbeam-rs/crossbeam/blob/master/src/lib.rs) tools from\nsmaller subcrates:",
            "------",
            "crates",
            "*Features marked with (no\\_std) can be used in `no_std` environments.*  \n*Features marked with (alloc) can be used in `no_std` environments, but only if `alloc`\nfeature is enabled.",
            "* [`scope`](https://docs.rs/crossbeam/latest/crossbeam/fn.scope.html), for spawning threads that borrow local variables from the stack.",
            "* [`CachePadded`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.CachePadded.html), for padding and aligning a value to the length of a cache line.(no\\_std",
            "* [`Backoff`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.Backoff.html), for exponential backoff in spin loops.(no\\_std",
            "#### Utilities",
            "* [`WaitGroup`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.WaitGroup.html), for synchronizing the beginning or end of some computation.",
            "* [`ShardedLock`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.ShardedLock.html), a sharded reader-writer lock with fast concurrent reads.",
            "* [`Parker`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.Parker.html), a thread parking primitive.",
            "* [`channel`](https://docs.rs/crossbeam/latest/crossbeam/channel/index.html), multi-producer multi-consumer channels for message passing.",
            "#### Thread synchronization",
            "* [`epoch`](https://docs.rs/crossbeam/latest/crossbeam/epoch/index.html), an epoch-based garbage collector.(alloc)",
            "#### Memory management",
            "* [`SegQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.SegQueue.html), an unbounded MPMC queue that allocates small buffers, segments, on demand.(alloc)",
            "* [`ArrayQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.ArrayQueue.html), a bounded MPMC queue that allocates a fixed-capacity buffer on construction.(alloc)",
            "* [`deque`](https://docs.rs/crossbeam/latest/crossbeam/deque/index.html), work-stealing deques for building task schedulers.",
            "#### Data structures",
            "* [`AtomicConsume`](https://docs.rs/crossbeam/latest/crossbeam/atomic/trait.AtomicConsume.html), for reading from primitive atomic types with \"consume\" ordering.(no\\_std",
            "* [`AtomicCell`](https://docs.rs/crossbeam/latest/crossbeam/atomic/struct.AtomicCell.html), a thread-safe mutable memory location.(no\\_std",
            "#### Atomics"
          ]
        },
        {
          "title": "Mimalloc Rust",
          "url": "https://github.com/purpleprotocol/mimalloc_rust",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "cargo-fuzz 0.13.1",
          "url": "https://docs.rs/crate/cargo-fuzz/latest/source/README.md",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "rust-embedded/embedded-hal",
          "url": "https://github.com/rust-embedded/embedded-hal",
          "excerpts": [
            "crates"
          ]
        },
        {
          "title": "Crossbeam-channel (crossbeam-rs)",
          "url": "http://github.com/crossbeam-rs/crossbeam-channel",
          "excerpts": [
            "NOTE: This crate has been moved into the [crossbeam](https://github.com/crossbeam-rs/crossbeam) repository.",
            "This library is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/std/sync/mpsc/index.html) with more features and better performance.",
            "Multi-producer multi-consumer channels for message passing",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "parking_lot GitHub Repository",
          "url": "http://github.com/Amanieu/parking_lot",
          "excerpts": [
            "To enable nightly-only features, add this to your `Cargo.toml` instead:\n\n```\n[dependencies]\nparking_lot = { version = \"0.12\", features = [\"nightly\"] }\n```\n\nThe experimental deadlock detector can be enabled with the\n`deadlock_detection` Cargo feature.\n\nTo allow sending `MutexGuard`s and `RwLock*Guard`s to other threads, enable the\n`send_guard` option.\n\nNote that the `deadlock_detection` and `send_guard` features are incompatible\nand cannot be used together.\n\nHardware lock elision support for x86 can be enabled with the\n`hardware-lock-elision` feature. This requires Rust 1.59 due to the use of\ninline assembly.\n\nThe core parking lot API is provided by the `parking_lot_core` crate. It is\nseparate from the synchronization primitives in the `parking_lot` crate so that\nchanges to the core API do not cause breaking changes for users of `parking_lot`.",
            "Features\n--------\n\nThe primitives provided by this library have several advantages over those\nin the Rust standard library:\n\n1. `Mutex` and `Once` only require 1 byte of storage space, while `Condvar`\n   and `RwLock` only require 1 word of storage space. On the other hand on\n   some platforms (macOS and a few others) the standard library primitives\n   require a dynamically allocated `Box` to hold OS-specific synchronization\n   primitives. The small size of `Mutex` in particular encourages the use\n   of fine-grained locks to increase parallelism.\n2. Uncontended lock acquisition and release is done through fast inline\n   paths which only require a single atomic operation.\n3. Microcontention (a contended lock with a short critical section) is\n   efficiently handled by spinning a few times while trying to acquire a\n   lock.\n4. The locks are adaptive and will suspend a thread after a few failed spin\n   attempts. This makes the locks suitable for both long and short critical\n   sections.\n5. `Condvar`, `RwLock` and `Once` work on Windows XP, unlike the standard\n   library versions of those types.\n6. `RwLock` takes advantage of hardware lock elision on processors that\n   support it, which can lead to huge performance wins with many readers.\n   This must be enabled with the `hardware-lock-elision` feature.\n7. `RwLock` uses a task-fair locking policy, which avoids reader and writer\n   starvation, whereas the standard library version makes no guarantees.\n8. `Condvar` is guaranteed not to produce spurious wakeups. A thread will\n   only be woken up if it timed out or it was woken up by a notification.\n9. `Condvar::notify_all` will only wake up a single thread and requeue the\n   rest to wait on the associated `Mutex`. This avoids a thundering herd\n   problem where all threads try to acquire the lock at the same time.\n10. `RwLock` supports atomically downgrading a write lock into a read lock.\n11. `Mutex` and `RwLock` allow raw unlocking without a RAII guard object.\n12. `Mutex<()>` and `RwLock<()>` allow raw locking without a RAII guard\n    object.\n13. `Mutex` and `RwLock` support [eventual fairness](https://trac.webkit.org/changeset/203350)\n    which allows them to be fair on average without sacrificing performance.\n14. A `ReentrantMutex` type which supports recursive locking.\n15. An *experimental* deadlock detector that works for `Mutex`,\n    `RwLock` and `ReentrantMutex`. This feature is disabled by default and\n    can be enabled via the `deadlock_detection` feature.\n16. `RwLock` supports atomically upgrading an \"upgradable\" read lock into a\n    write lock.\n17. Optional support for [serde](https://docs.serde.rs/serde/). Enable via the\n    feature `serde`. **NOTE!** this support is for `Mutex`, `ReentrantMutex`,\n    and `RwLock` only; `Condvar` and `Once` are not currently supported.\n18. Lock guards can be sent to other threads when the `send_guard` feature is\n    enabled.\n\nThe parking lot\n---------------\n\nTo keep these primitives small, all thread queuing and suspending\nfunctionality is offloaded to the *parking lot*. The idea behind this is\nbased on the Webkit [`WTF::ParkingLot`](https://webkit.org/blog/6161/locking-in-webkit/)\nclass, which essentially consists of a hash table mapping of lock addresses\nto queues of parked (sleeping) threads. The Webkit parking lot was itself\ninspired by Linux [futexes](https://man7.org/linux/man-pages/man2/futex.2.html),\nbut it is more powerful since it allows invoking callbacks while holding a queue\nlock.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads. The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking. It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives."
          ]
        },
        {
          "title": "Epoch-based garbage collection",
          "url": "http://github.com/crossbeam-rs/crossbeam-epoch",
          "excerpts": [
            "The minimum required Rust version is 1.26.",
            "If a thread removes a node from a concurrent data structure, other threads\nmay still have pointers to that node, so it cannot be immediately destructed.\nEpoch GC allows deferring destruction until it becomes safe to do so.",
            "This crate provides epoch-based garbage collection for use in concurrent data structures.",
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "std::sync::atomic - Rust",
          "url": "http://doc.rust-lang.org/std/sync/atomic/index.html",
          "excerpts": [
            "[Atomic](type.Atomic.html \"type std::sync::atomic::Atomic\")Experimental\n:   A memory location which can be safely modified from multiple threads.",
            "Type Aliases",
            "[fence](fn.fence.html \"fn std::sync::atomic::fence\")\n:   An atomic fence.",
            "Functions",
            "[Ordering](enum.Ordering.html \"enum std::sync::atomic::Ordering\")\n:   Atomic memory orderings",
            "Enums",
            "[AtomicUsize](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU64](struct.AtomicU64.html \"struct std::sync::atomic::AtomicU64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU32](struct.AtomicU32.html \"struct std::sync::atomic::AtomicU32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU16](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU8](struct.AtomicU8.html \"struct std::sync::atomic::AtomicU8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicPtr](struct.AtomicPtr.html \"struct std::sync::atomic::AtomicPtr\")\n:   A raw pointer type which can be safely shared between threads.",
            "[AtomicIsize](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI64](struct.AtomicI64.html \"struct std::sync::atomic::AtomicI64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI32](struct.AtomicI32.html \"struct std::sync::atomic::AtomicI32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI16](struct.AtomicI16.html \"struct std::sync::atomic::AtomicI16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI8](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicBool](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\")\n:   A boolean type which can be safely shared between threads.",
            "The `#[cfg(target_has_atomic)]` attribute can be used to conditionally\ncompile based on the targetâ€™s supported bit widths. It is a key-value\noption set for each supported size, with values â€œ8â€, â€œ16â€, â€œ32â€, â€œ64â€,\nâ€œ128â€, and â€œptrâ€ for pointer-sized atomics.",
            "Each atomic access takes an [`Ordering`](enum.Ordering.html \"enum std::sync::atomic::Ordering\") which defines how the operation interacts with the\nhappens-before order. These orderings behave the same as the corresponding [C++20 atomic\norderings](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information, see the [nomicon](../../../nomicon/atomics.html).",
            "The most common way to share an atomic variable is to put it into an [`Arc`](../../../std/sync/struct.Arc.html) (an\natomically-reference-counted shared pointer).",
            "Atomic variables are safe to share between threads (they implement [`Sync`](../../marker/trait.Sync.html \"trait std::marker::Sync\"))\nbut they do not themselves provide the mechanism for sharing and follow the\n[threading model](../../../std/thread/index.html) of Rust.",
            "\nThis module defines atomic versions of a select number of primitive\ntypes, including [`AtomicBool`](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\"), [`AtomicIsize`](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\"), [`AtomicUsize`](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\"),\n[`AtomicI8`](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\"), [`AtomicU16`](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\"), etc.",
            "\n\nAtomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes.",
            "Atomic types",
            "Structs"
          ]
        },
        {
          "title": "Rust std::thread Module",
          "url": "http://doc.rust-lang.org/std/thread/index.html",
          "excerpts": [
            "This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of.",
            "* By spawning a new thread, e.g., using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function, and calling [`thread`](struct.JoinHandle.html.thread \"method std::thread::JoinHandle::thread\") on the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") .",
            "thread::Builder::new().name( \"thread1\" .to_string()).spawn( move || {\n    println! ( \"Hello, world!\" );\n});",
            "To learn when a thread completes, it is necessary to capture the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") object that is returned by the call to [`spawn`](fn.spawn.html \"fn std::thread::spawn\") , which provides\na `join` method that allows the caller to wait for the completion of the\nspawned thread:",
            "let thread_join_handle = thread::spawn( move || {\n    // some work here\n});\n// some work here\nlet res = thread_join_handle.join();",
            "The [`join`](struct.JoinHandle.html.join \"method std::thread::JoinHandle::join\") method returns a [`thread::Result`](type.Result.html \"type std::thread::Result\") containing [`Ok`](../result/enum.Result.html.Ok \"variant std::result::Result::Ok\") of the final\nvalue produced by the spawned thread, or [`Err`](../result/enum.Result.html.Err \"variant std::result::Result::Err\") of the value given to\na call to [`panic!`](../macro.panic.html \"macro std::panic\") if the thread panicked.",
            "A new thread can be spawned using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function:\n\n```\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\nIn this example, the spawned thread is â€œdetached,â€ which means that there is\nno way for the program to learn when the spawned thread completes or otherwise\nterminates.",
            "When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nthread (i.e., join).",
            ".\n\nCommunication between threads can be done through\n[channels](../sync/mpsc/index.html \"mod std::sync::mpsc\"), Rustâ€™s message-passing types, along with [other forms of thread\nsynchronization](../../std/sync/index.html) and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\")."
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "rx.recv().unwrap();",
            "    tx.send(53).unwrap();",
            "    // This will wait for the parent thread to start receiving",
            "let (tx, rx) = sync_channel::<i32>(0);",
            "assert_eq!(rx.recv().unwrap(), 10);",
            "});",
            "});",
            "    tx.send(10).unwrap();",
            "thread::spawn(move || {",
            "thread::spawn(move || {",
            "let (tx, rx) = channel();",
            "An unsuccessful operation\nis normally indicative of the other half of a channel having â€œhung upâ€ by\nbeing dropped in its corresponding thread.",
            "The send and receive operations on channels will all return a [`Result`](../../result/enum.Result.html \"enum std::result::Result\")\nindicating whether the operation succeeded or not.",
            "2. \n   A synchronous, bounded channel. The [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync\\_channel\") function will\n   return a `(SyncSender, Receiver)` tuple where the storage for pending\n   messages is a pre-allocated buffer of a fixed size. All sends will be **synchronous** by blocking until there is buffer space available. Note\n   that a bound of 0 is allowed, causing the channel to become a â€œrendezvousâ€\n   channel where each sender atomically hands off a message to a",
            "1. \n   An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function\n   will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an\n   infinite b",
            "These channels come in two flavors:",
            "A [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") . Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).",
            "* [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")",
            "* [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\")",
            "* [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\")",
            "This module provides message-based communication over channels, concretely\ndefined among three types:",
            "std::sync::mpsc - Rust[![](../../../static.files/rust-logo-9a9549ea.svg)](../../../std/index.html)",
            "Multi-producer, single-consumer FIFO queue communication primitives.",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n",
            "`Mutex`\nA mutual exclusion primitive useful for protecting shared data\n",
            "`LazyLock`\nA value which is initialized on the first access.\n",
            "`Condvar`\nA Condition Variable\n",
            "`Barrier`\nA barrier enables multiple threads to synchronize the beginning\n    of some computation.\n",
            "`Arc`\nA thread-safe reference-counting pointer. â€˜Arcâ€™ stands for â€˜Atomically\n    Reference Countedâ€™.\n",
            "Structs",
            "Modules",
            "`RwLock`\nProvides a mutual exclusion mechanism which allows\n  multiple readers at the same time, while allowing only one\n  writer at a time. In some cases, this can be more efficient than\n  a \n",
            "`LazyLock`\nUsed for thread-safe, one-time initialization of a\n  variable, using one nullary initializer function provided at creatio\n",
            "`OnceLock`\nUsed for thread-safe, one-time initialization of a\n  variable, with potentially different initializers based on the calle\n",
            "`Once`\nUsed for a thread-safe, one-time global initialization routine.\n  Mostly useful for implementing other types like `OnceLock\n",
            "`Mutex`\nMutual Exclusion mechanism, which ensures that at\n  most one thread at a time is able to access some dat\n",
            "`mpmc`\nMulti-producer, multi-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`mpsc`\nMulti-producer, single-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`Condvar`\nCondition Variable, providing the ability to block\n  a thread while waiting for an event to occu\n",
            "`Barrier`\nEnsures multiple threads will wait for each other\n  to reach a point in the program, before continuing execution all\n  toget\n",
            "`Arc`\nAtomically Reference-Counted pointer, which can be used\n  in multithreaded environments to prolong the lifetime of some\n  data until all the threads have finished using\n",
            "For efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating systemâ€™s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.",
            "These abstractions can be built out of lower-level primitives.",
            "Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.",
            "Higher-level synchronization objects",
            "[atomic operations](atomic/index.html \"mod std::sync::atomic\") to ensure simultaneous access to the same\n    memory location doesnâ€™t lead to undefined behavi",
            "[memory fences](atomic/fn.fence.html \"fn std::sync::atomic::fence\") to ensure memory accesses are made visible to\n    other CPUs in the right or",
            "A **multiprocessor** system executing multiple hardware threads\n  at the same time: In multi-threaded scenarios, you can use two\n  kinds of primitives to deal with synchronizat",
            "A **single processor** executing instructions [out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution):",
            "Use [compiler fences](atomic/fn.compiler_fence.html \"fn std::sync::atomic::compiler_fence\") to prevent this reordering.",
            "The **compiler** reordering instructions: If the compiler can issue an\n  instruction at an earlier point, it will try to do so. For example, it\n  might hoist memory loads at the top of a code block, so that the CPU can\n  start [prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) the values from m",
            "Instructions can execute in a different order from the one we define, due to\nvarious reasons:",
            "Out-of-order execution",
            "Note that thanks to Rustâ€™s safety guarantees, accessing global (static)\nvariables requires `unsafe` code, assuming we donâ€™t use any of the\nsynchronization primitives in this module.",
            "Due to the [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) involved in modern computers, assumptions\nabout the programâ€™s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, **even if**\ncompiler optimizations are disabled, and it is **still possible**\nto introduce synchronization bugs.",
            "The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.",
            "As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:",
            "Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.",
            "The need for synchronization",
            "Useful synchronization primitives."
          ]
        },
        {
          "title": "Converos: Practical Model Checking for Verifying Rust OS ...",
          "url": "https://www.usenix.org/system/files/atc25-tang.pdf",
          "excerpts": [
            "by R Tang â€” Liveness properties include absence of deadlock, livelock, and starvation. Deadlock/livelock freedom specifies whenever a process is in theÂ ..."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "An `Arc` is a smart pointer that provides shared ownership of a value across multiple threads. It uses [atomic operations](https://doc.rust-lang.org/std/sync/atomic/) and [reference counting](https://doc.rust-lang.org/std/rc/) to efficiently track the number of references to the shared data.",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:",
            "One of the most basic primitives for concurrency in Rust is threads. A thread is an independent path of execution within a program that can run concurrently with other threads."
          ]
        },
        {
          "title": "Rust's Send and Sync (Nomicon)",
          "url": "https://doc.rust-lang.org/nomicon/send-and-sync.html",
          "excerpts": [
            "This means that, unlike\nevery other trait, if a type is composed entirely of Send or Sync types, then it\nis Send or Sync.",
            "Send and Sync are also automatically derived traits.",
            "* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).",
            "* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).",
            "* raw pointers are neither Send nor Sync (because they have no safety guards).",
            "Major exceptions include:",
            "Send and Sync are fundamental to Rust's concurrency story.",
            "Not everything obeys inherited mutability, though. Some types allow you to\nhave multiple aliases of a location in memory while mutating it. Unless these types use\nsynchronization to manage this access, they are absolutely not thread-safe. Rust\ncaptures this through the `Send` and `Sync` traits. * A type is Send if it is safe to send it to another thread. * A type is Sync if it is safe to share between threads (T is Sync if and only if `&T` is Send). Send and Sync are fundamental to Rust's concurrency story.",
            "Most uses of raw pointers should be encapsulated behind a sufficient abstraction\nthat Send and Sync can be derived.",
            " Almost all primitives are Send and Sync, and as a consequence\npretty much all types you'll ever interact with are Send and Sync. Major exceptions include:\n\n* raw pointers are neither Send nor Sync (because they have no safety guards). * `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't). * `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized). `Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\nunsynchronized shared mutable state. However raw pointers are, strictly\nspeaking, marked as thread-unsafe as more of a _lint_ . Doing anything useful\nwith a raw pointer requires dereferencing it, which is already unsafe. In that\nsense, one could argue that it would be \"fine\" for them to be marked as thread\nsafe. However it's important that they aren't thread-safe to prevent types that\ncontain them from being automatically marked as thread-safe. These types have\nnon-trivial untracked ownership, and it's unlikely that their author was\nnecessarily thinking hard about thread safety. In the case of `Rc` , we have a nice\nexample of a type that contains a `*mut` that is definitely not thread-safe. Types that aren't automatically derived can simply implement them if desired:\n\n```\n```\n#!"
          ]
        },
        {
          "title": "crossbeam-epoch (Crate Page) - Crates.io",
          "url": "https://crates.io/crates/crossbeam-epoch",
          "excerpts": [
            "shared objects until no pointers to them can exist.",
            "immediately. Epoch-based GC is an efficient mechanism for deferring destruction of",
            "may be still using pointers to it at the same time, so it cannot be destroyed",
            "This crate provides epoch-based garbage collection for building concurrent data structures. When a thread removes an object from a concurrent data structure, other threads",
            "crossbeam-epoch - crates.io: Rust Package Registry",
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "Flume - Rust",
          "url": "https://docs.rs/flume",
          "excerpts": [
            "Sender` and `Receiver` both implement `Send + Sync + Clo",
            "Familiar** : Drop-in replacement for `std::sync::mps",
            "Unbounded, bounded and rendezvous queues",
            "**Familiar** : Drop-in replacement for `std::sync::mpsc`",
            "**Safe** : No `unsafe` code anywhere in the codebase!",
            "A blazingly fast multi-producer, multi-consumer channel. _â€œDo not communicate by sharing memory; instead, share memory by communicating."
          ]
        },
        {
          "title": "crossbeam_epoch - Rust",
          "url": "https://docs.rs/crossbeam-epoch",
          "excerpts": [
            "Before an [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\") can be loaded, a participant must be [`pin`](fn.pin.html \"fn crossbeam_epoch::pin\")ned.",
            "Concurrent collections are built using atomic pointers. This module provides [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\"), which\nis just a shared atomic pointer to a heap-allocated object.",
            "memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs.",
            "Epoch-based memory reclamation. An interesting problem concurrent collections deal with comes from the remove operation."
          ]
        },
        {
          "title": "parking_lot Crate Documentation",
          "url": "https://crates.io/crates/parking_lot/",
          "excerpts": [
            "The primitives provided by this library have several advantages over those\nin the Rust standard library:",
            "It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking."
          ]
        },
        {
          "title": "Rust fence and memory ordering (std::sync::atomic)",
          "url": "https://doc.rust-lang.org/std/sync/atomic/fn.fence.html",
          "excerpts": [
            "```\nuse std::sync::atomic::AtomicBool;\nuse std::sync::atomic::fence;\nuse std::sync::atomic::Ordering;\n\n// A mutual exclusion primitive based on spinlock. pub struct Mutex {\n    flag: AtomicBool,\n}\n\nimpl Mutex {\n    pub fn new() -> Mutex {\n        Mutex {\n            flag: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&self) {\n        // Wait until the old value is `false`.",
            "Note that in the example above, it is crucial that the accesses to `m` are atomic. Fences cannot\nbe used to establish synchronization among non-atomic accesses in different threads.",
            "Atomic operations with [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") or [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\") semantics can also synchronize\nwith a fence.",
            "A fence which has [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") ordering, in addition to having both [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\")\nand [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") semantics, participates in the global program order of the\nother [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") operations and/or fences."
          ]
        },
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library",
            "* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data",
            "* _Message-passing_ concurrency, where channels send messages between threads",
            "Here are the topics weâ€™ll cover in this chapter:\n\n* How to create threads to run multiple pieces of code at the same time\n* _Message-passing_ concurrency, where channels send messages between threads\n* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data\n* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Top 10 Rust Concurrency Patterns for Zero-Copy Speed",
          "url": "https://medium.com/@bhagyarana80/top-10-rust-concurrency-patterns-for-zero-copy-speed-60aac19e0d4a",
          "excerpts": [
            "Ten battle-tested Rust concurrency patterns to move data without cloning. Learn Arc, slices, IoSlice, Cow, pools, sharding, ..."
          ]
        },
        {
          "title": "Shared-State Concurrency - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch16-03-shared-state.html",
          "excerpts": [
            "Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time."
          ]
        },
        {
          "title": "std::thread",
          "url": "https://doc.rust-lang.org/std/thread/",
          "excerpts": [
            "A thread local storage (TLS) key which owns its contents. Scope: A scope to spawn scoped threads in. ScopedJoinHandle: An owned permission to join on a scoped ..."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution.",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Error Handling - The Rust Programming Language"
          ]
        },
        {
          "title": "Unwinding through FFI after Rust 1.33 - language design",
          "url": "https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521",
          "excerpts": [
            "Feb 26, 2019 â€” It is possible to \"unwind\" over Rust code using longjmp , so you could have C call setjmp then call back into Rust for a group of operations,Â ..."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html",
          "excerpts": [
            "The behavior of `catch_unwind` when a foreign exception encounters it is\ncurrently [left undefined]() . We would like to\nprovide a well-defined behavior for this case, which will probably be either to\nlet the exception pass through uncaught or to catch some or all foreign\nexceptions.",
            "### [Enable foreign exceptions to propagate through Rust frame]()",
            "### [Enable Rust panics to traverse through foreign frames]()",
            "Enable error handling with `longjmp` :** As mentioned above, some existing Rust libraries rely on the ability to `longjmp` across Rust frames to interoperate with Ruby, Lua, and other C\n  APIs. The behavior of `longjmp` traversing Rust frames is not specified or\n  guaranteed to be safe; in the current implementation of `rustc` ,\n  however, it [is safe](https://github.com/rust-lang/rust/pull/48572) . On Windows, `longjmp` is implemented as a\n  form of unwinding called [â€œforced unwindingâ€]() , so any\n  specification of the behavior of forced unwinding across FFI boundaries\n  should be forward-compatible with a [future RFC]() that\n  will provide a well-defined way to interoperate with longjmp-based APIs. * **Do not change the ABI of functions in the `libc` crate:** Some `libc` functions may invoke `pthread_exit` , which uses [a form of\n  unwinding]() in the GNU libc implementation. Such functions\n  must be safe to use with the existing `\"C\"` ABI, because changing the types\n  of these fu"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "```\nuse anyhow::Context;  \nuse rust_ecosystem_learning::MyError;  \nuse std::fs;  \nuse std::mem::size_of;  \n  \nfn main() -> Result<(), anyhow::Error> {  \n    println! (\"size of anyhow::Error: {}\", size_of::<anyhow::Error>());  \n    println! (\"size of std::io::Error: {}\", size_of::<std::io::Error>());  \n    println! (  \n        \"size of std::num::ParseIntError: {}\",  \n        size_of::<std::num::ParseIntError>()  \n    );  \n    println! (  \n        \"size of serde_json::Error: {}\",  \n        size_of::<serde_json::Error>()  \n    );  \n    println! (\"size of string: {}\", size_of::<String>());  \n    println! (\"size of MyError: {}\", size_of::<MyError>());  \n  \n    let filename = \"non_existent_file.txt\";  \n    let _fd =  \n        fs::File::open(filename).with_context(|| format! (\"Cannot find file: {}\", filename))? ;  \n  \n    fail_with_error()? ;  \n    Ok(())  \n}  \n  \nfn fail_with_error() -> Result<(), MyError> {  \n    Err(MyError::Custom(\"This is a custom error\".to_string()))  \n}  \n  \n#[cfg(test)]  \nmod tests {  \n    #[test]  \n    fn it_works() {  \n        assert_eq!\n(2 + 2, 4);  \n    }  \n}\n```",
            "`main.rs` File",
            "Add Dependencies",
            "Comparison and Selection Guide",
            "snafu` Error: Context-driven Error Management",
            "```\npub trait Error: Debug + Display {\n```\n",
            "Reference: [Rust std::error::Error trait documentation](https://doc.rust-lang.org/beta/core/error/trait.Error.html)",
            "`thiserror` Error: Defining Library-level Errors",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`anyhow` Error: Application-level Error Handling",
            "anyhow = \"1.0.97\"  \nserde = { version = \"1.0.217\", features = [\"derive\"] }  \nserde_json = \"1.0.140\"  \nthiserror = \"2.0.11\"",
            "Practical Implementation"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
            "rust-ecosystem-learning",
            "Practical Implementation",
            "Error -> println! ( \"{}/ {:?}\" , err )",
            "Since the\nError trait requires implementing both\nDebug and\nDisplay :\npub trait Error : Debug + Display {",
            "Rust std::error::Error trait documentation",
            "thiserror vs snafu",
            "    * Provides the\nensure!\nmacro to simplify condition checking and error throwing",
            "    * Supports attaching structured context (such as file paths, input parameters) in the error chain",
            "    * Converts underlying errors into domain-specific errors through the\nSnafu macro",
            "snafu Error: Context-driven Error Management",
            "snafu Error: Context-driven Error Management",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros",
            "thiserror Error: Defining Library-level Errors",
            "fn get_cluster_info () -> Result < ClusterMap , anyhow :: Error > { // Error 3: Err3 let config = std :: fs :: read_to_string ( \"cluster.json\" ) ? ; // Error 1: Err1 // let config = std::fs::read_to_string(\"cluster.json\").context(\"...\")? ; // Error 1: Err1 let map : ClusterMap = serde_json :: from_str ( & config ) ?",
            "* Supports adding dynamic context (via the\ncontext() method) to enhance error readability",
            "* Uses the\n? operator for automatic error propagation, simplifying multi-layer nested error handling",
            "* Provides a unified\nanyhow::Error type, supporting any error type that implements\nstd::error::Error",
            "Conversion and unified error handling with\nanyhow::Error :",
            "* snafu : finer-grained error management",
            "* thiserror : customized and rich error handling, suitable for library-level programming",
            "snafu",
            "snafu",
            "thiserror ,",
            "thiserror ,",
            "anyhow ,",
            "anyhow ,",
            "Note: When developing, pay attention to the size of\nResult<T, E> . anyhow Error: Application-level Error Handling",
            "* `snafu` provides context-driven error management, appropriate for complex systems.",
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:"
          ]
        },
        {
          "title": "Miette Crate Documentation",
          "url": "https://crates.io/crates/miette",
          "excerpts": [
            "```\nuse miette::{Diagnostic, Report, SourceSpan};\nuse thiserror::Error;\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops\")]\n#[diagnostic()]\npub struct InnerError {\n    // Note: label but no source code\n    #[label]\n    err_span: SourceSpan,\n}\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops: multiple errors\")]\n#[diagnostic()]\npub struct MultiError {\n    // Note source code by no labels\n    #[source_code]\n    source_code: String,\n    // The source code above is used for these errors\n    #[related]\n    related: Vec<InnerError>,\n}\n\nfn do_something() -> Result<(), Vec<InnerError>> {\n    Err(vec! [\n        InnerError {\n            err_span: (0..6).into(),\n        },\n        InnerError {\n            err_span: (7..11).into(),\n        },\n    ])\n}\n\nfn main() -> miette::Result<()> {\n    do_something().map_err(|err_list| MultiError {\n        source_code: \"source code\".into(),\n        related: err_list,\n    })? ;\n    Ok(())\n}\n```\n\n#### ... Diagnostic-based error sources. When one uses the `#[source]` attribute on a field, that usually comes\nfrom `thiserror`, and implements a method for\n[`std::error::Error::source`]. This works in many cases, but it's lossy:\nif the source of the diagnostic is a diagnostic itself, the source will\nsimply be treated as an `std::error::Error`.\n ... \nIt owes enormous credit to various\nother projects and their authors:\n\n* [`anyhow`](http://crates.io/crates/anyhow) and [`color-eyre`](https://crates.io/crates/color-eyre):\n  these two enormously influential error handling libraries have pushed\n  forward the experience of application-level error handling and error\n  reporting. `miette`'s `Report` type is an attempt at a very very rough\n  version of their `Report` types. * [`thiserror`](https://crates.io/crates/thiserror) for setting the standard\n  for library-level error definitions, and for being the inspiration behind\n  `miette`'s derive macro. * `rustc` and [@estebank](https://github.com/estebank) for their\n  state-of-the-art work in compiler diagnostics. * [`ariadne`](https://crates.io/crates/ariadne) for pushing forward how\n  *pretty* these diagnostics can really look! ### License\n\n`miette` is released to the Rust community under the [Apache license\n2.0](https://github.com/zkat/miette/blob/HEAD/./LICENSE). It also includes code taken from [`eyre`](https://github.com/yaahc/eyre),\nand some from [`thiserror`](https://github.com/dtolnay/thiserror), also\nunder the Apache License. Some code is taken from\n[`ariadne`](https://github.com/zesterer/ariadne), which is MIT licensed.",
            "emitted at the same time:",
            "useful in combination with `related`, when multiple errors should be",
            "This is especially",
            "default support for `String`s included.",
            "* Generic support for arbitrary [`SourceCode`](https://docs.rs/miette/latest/miette/trait.SourceCode.html)s for snippet data, with",
            "* Replacements for [`anyhow`](https://docs.rs/anyhow)/[`eyre`](https://docs.rs/eyre)\n  types [`Result`](https://docs.rs/miette/latest/miette/type.Result.html), [`Report`](https://docs.rs/miette/latest/miette/struct.Report.html) and the [`miette!`](https://docs.rs/miette/latest/miette/macro.miette.html) macro for the\n  `anyhow!`/`eyre!` macros.",
            "* Super handy derive macro for defining diagnostic metadata.",
            "* Custom links to get more details on error codes.",
            "* Unique error codes on every [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html).",
            "`std::error::Error`.",
            "* Generic [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html) protocol, compatible (and dependent on)",
            "### Features",
            "### Table of Contents"
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Does anyone bothered by not having backtraces in custom ...",
          "url": "https://www.reddit.com/r/rust/comments/1jebbnq/does_anyone_bothered_by_not_having_backtraces_in/",
          "excerpts": [
            "I very much like anyhow's backtrace feature, it helps me figure out the root cause in some question marks where I'm too lazy to add a contextÂ ..."
          ]
        },
        {
          "title": "r/rust - miette: a fancy new diagnostics definition and ...",
          "url": "https://www.reddit.com/r/rust/comments/p9t3jh/miette_a_fancy_new_diagnostics_definition_and/",
          "excerpts": [
            "On a somewhat related note, does anyone know of any crates that assist in generating Spans (offset, length, line number, column number) from a ..."
          ]
        },
        {
          "title": "rust - How to trace the cause of an error result?",
          "url": "https://stackoverflow.com/questions/42275777/how-to-trace-the-cause-of-an-error-result",
          "excerpts": [
            "Use Result defined in easy-error as return type, then use context method to convert other Result types. Most important thing is to pass information to contextÂ ..."
          ]
        },
        {
          "title": "Error in anyhow - Rust",
          "url": "https://docs.rs/anyhow/latest/anyhow/struct.Error.html",
          "excerpts": [
            "The Debug format â€œ{:?}â€ includes your backtrace if one was captured. Note that this is the representation you get by default if you return an error from fn mainÂ ..."
          ]
        },
        {
          "title": "color-eyre - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/color-eyre",
          "excerpts": [
            "color-eyre v0.6.5. An error report handler for panics and eyre::Reports for colorful, consistent, and well formatted error reports for all kinds ..."
          ]
        },
        {
          "title": "color_eyre - Rust",
          "url": "https://docs.rs/color-eyre",
          "excerpts": [
            "An error report handler for panics and the `eyre` crate for colorful, consistent, and well formatted error reports for all kinds of errors."
          ]
        },
        {
          "title": "Rust Cancel Safety and Panics (as provided in the document)",
          "url": "https://rfd.shared.oxide.computer/rfd/400",
          "excerpts": [
            "If a Tokio runtime is shut down, all tasks running within it are cancelled at\nthe next await point.",
            " runtime is\n   shut down due to a panic, then the task is cancelled. ",
            "panics\narenâ€™t part of normal control flow."
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "Cancel safety is mostly not relevant for kill signals because you don't care if you lost some data from the connection if you're killing it.",
            "This happens with [`recv` on Tokio channels](https://docs.rs/tokio/1.27.0/tokio/sync/mpsc/struct.Receiver.html.recv) , since all the state is in the channel, and _not_ in the future returned by `recv()` .",
            "The easy way to avoid this is for the futures in the `select!` to not own state, but to borrow it from elsewhere; for example, if `buffered_stream` owns all the state, and the future returned by `read_msg()` mutates `buffered_stream` instead of storing its own state, you're cancellation-safe.",
            "If those futures own some form of state, then your future is not cancellation safe, since that owned state will be dropped when another future returns `Poll::Ready` .",
            "That is the basic gist of it. The underlying issue with cancellation safety is that all futures in the select other than the future that yields `Poll::Ready` will be dropped.",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2",
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum"
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "oml\n[profile.release]\npanic = 'abort'\n```",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Unrecoverable Errors with panic! - The Rust Programming Language"
          ]
        },
        {
          "title": "Cargo profile panic settings",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "Profile selection\nThe profile used depends on the command, the command-line flags like\n--release or\n--profile , and the package (in the case of overrides ). The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times.",
            "opt-level\nThe\nopt-level setting controls the\n-C opt-level flag which controls the level\nof optimization. Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "debug\nThe\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary. The valid options are:\n    * 0 ,\nfalse , or\n\"none\" : no debug info at all, default for\nrelease",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic.",
            "led\n\nlto\nThe\nlto setting controls\nrustc â€™s\n-C lto ,\n-C linker-plugin-lto , and\n-C embed-bitcode options, which control LLVMâ€™s link time optimizations . LTO can produce better optimized code, using whole-program analysis, at the cost\nof longer linking time. The valid options are:\n    * false : Performs â€œthin local LTOâ€ which performs â€œthinâ€ LTO on the local\ncrate only across its codegen units . No LTO is performed\nif codegen units is 1 or opt-level is 0.\n* true or\n\"fat\" : Performs â€œfatâ€ LTO which attempts to perform\noptimizations across all crates within the dependency graph. * \"thin\" : Performs â€œthinâ€ LTO . This is similar to â€œfatâ€, but takes\nsubstantially less time to run while still achieving performance gains\nsimilar to â€œfatâ€. * \"off\" : Disables LTO.",
            "The\ncodegen-units setting controls the\n-C codegen-units flag which\ncontrols how many â€œcode generation unitsâ€ a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower cod",
            "codegen-units = 16",
            "panic = 'unwind'",
            "lto = false",
            "strip = \"none\"",
            "debug = false",
            "opt-level = 3",
            "The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "The default settings for the\nrelease profile are:\n[profile.release] opt-level = 3 debug = false split-debuginfo = '...' # Platform-specific. strip = \"none\" debug-assertions = false overflow-checks = false lto = false panic = 'unwind' incremental = false codegen-units = 16 rpath = false",
            "[profile.release] opt-level = 3",
            "release profile is intended for optimized artifacts used for releases\nand in production.",
            "The default is\n\"none\" . You can also configure this option with the boolean values\ntrue or\nfalse .",
            "Profiles\nProfiles provide a way to alter the compiler settings, influencing things like\noptimizations and debugging symbols. Cargo has 4 built-in profiles:\ndev ,\nrelease ,\ntest , and\nbench .",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic. When set to\n\"unwind\" , the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses\n\"abort\" . Tests, benchmarks, build scripts, and proc macros ignore the\npanic setting. The\nrustc test harness currently requires\nunwind behavior. See the\npanic-abort-tests unstable flag which enables\nabort behavior. Additionally, when using the\nabort strategy and building a test, all of the\ndependencies will also be forced to build with the\nunwind strategy. incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times"
          ]
        },
        {
          "title": "The Rustonomicon - Unwinding",
          "url": "https://doc.rust-lang.org/nomicon/unwinding.html",
          "excerpts": [
            "Unlike an exception in Java or C++, a panic could not be\ncaught at any time.",
            "There is an API called [`catch_unwind`](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html) that enables catching a panic\nwithout spawning a thread.",
            "Panics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.",
            "Rust has a _tiered_ error-handling scheme:\n\n* If something might reasonably be absent, Option is used. * If something goes wrong and can reasonably be handled, Result is used. * If something goes wrong and cannot reasonably be handled, the thread panics. * If something catastrophic happens, the program aborts. Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion."
          ]
        },
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        },
        {
          "title": "Unwinding -",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/nomicon/unwinding.html",
          "excerpts": [
            "As such, unwinding into Rust from another language, or unwinding into another language from Rust is Undefined Behavior. You must absolutely catch any panics ..."
          ]
        },
        {
          "title": "Rust Iterator Documentation",
          "url": "http://doc.rust-lang.org/std/iter/trait.Iterator.html",
          "excerpts": [
            "Returns [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") when iteration is finished.",
            "Advances the iterator and returns the next value.",
            "(.next)(&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\")<Self::[Item](trait.Iterator.html.Item \"type std::iter::Iterator::Item\")>",
            "The type of the elements being iterated over.",
            "This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the [module-level documentation](index.html \"mod std::iter\"). In particular, you\nmay want to know how to [implement `Iterator`](index.html \"mod std::iter\").",
            "A trait for dealing with iterators."
          ]
        },
        {
          "title": "ExactSizeIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html",
          "excerpts": [
            "this trait is a safe trait and as such does *not* and *cannot*\nguarantee that the returned length is correct. This means that `unsafe`\ncode **must not** rely on the correctness of [`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\").",
            "This function has the same safety guarantees as the\n[`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\") function.",
            "If an iterator knows how many times it can iterate, providing access to\nthat information can be useful.",
            "An iterator that knows its exact length."
          ]
        },
        {
          "title": "What is the difference between iter and into_iter? (Stack Overflow)",
          "url": "https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter",
          "excerpts": [
            "So `for x in my_vec { ... }` is essentially equivalent to `my_vec.into_iter().for_each(|x| ... )` \\- both `move` the elements of `my_vec` into the `...` scope. If you just need to _look at_ the data, use `iter` , if you need to edit/mutate it, use `iter_mut` , and if you need to give it a new owner, use `into_iter` ",
            "* `into_iter()` iterates over the items, moving them into the new scope",
            "* `iter_mut()` iterates over the items, giving a mutable reference to each item",
            "* `iter()` iterates over the items by reference",
            "What is the difference between `iter` and `into_iter` ? `into_iter` is a generic method to obtain an iterator, whether this iterator yields values, immutable references or mutable references **is context dependent** and can sometimes be surprising. `iter` and `iter_mut` are inherent methods. Their return type is therefore independent of the context, and will conventionally be iterators yielding immutable references and mutable references, respectively. The author of the Rust by Example post used Rust pre-1.53.0 to illustrate the surprise coming from the dependence on the context (i.e., the type) on which `into_iter` is called, and is also compounding the problem by using the fact that:\n\n1. Back then, `IntoIterator` was not implemented for `[T; N]` , only for `&[T; N]` and `&mut [T; N]` . 2"
          ]
        },
        {
          "title": "FromIterator in std::iter - Rust",
          "url": "https://doc.rust-lang.org/std/iter/trait.FromIterator.html",
          "excerpts": [
            "Conversion from an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") . By implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind. If you want to create a collection from the contents of an iterator, the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`](trait.FromIterator.html.from_iter \"associated function std::iter::FromIterator::from\\_iter\") can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()` ).\nSee the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") documentation for more examples of its use.",
            "pub trait FromIterator<A>: Sized {\n    // Required method\n    fn from_iter <T>(iter: T) -> Self\n       where T: IntoIterator <Item = A> ;\n}"
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "They preferentially capture variables by reference and only go lower when\nrequired. ```",
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`"
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "IntoIter in std::vec",
          "url": "https://doc.rust-lang.org/std/vec/struct.IntoIter.html",
          "excerpts": [
            "An iterator that moves out of a vector. This struct is created by the into_iter method on Vec (provided by the IntoIterator trait)."
          ]
        },
        {
          "title": "Difference Between into_iter, iter() and iter_mut() in rust",
          "url": "https://blog.coolhead.in/difference-between-intoiter-iter-and-itermut-in-rust",
          "excerpts": [
            "Nov 24, 2023 â€” into_iter() transfers ownership of the collection, iter() borrows the elements immutably, and iter_mut() borrows them mutably."
          ]
        },
        {
          "title": "Passing slice as an IntoIterator - rust",
          "url": "https://stackoverflow.com/questions/35144386/passing-slice-as-an-intoiterator",
          "excerpts": [
            "Let's take a look at how IntoIterator is implemented for slices: impl<'a, T> IntoIterator for &'a [T] type Item = &'a T type IntoIter = Iter<'a, T>"
          ]
        },
        {
          "title": "How does for loop implement into_iter - rust",
          "url": "https://stackoverflow.com/questions/72258925/how-does-for-loop-implement-into-iter",
          "excerpts": [
            "The iterable is transformed into an iterator by executing IntoIterator::into_iter(iterable). Each trait, including IntoIterator, has a hidden Self genericÂ ..."
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n",
            "fn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n",
            "\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\").",
            "By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.",
            "ion\n\nConversion into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"). By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind. One benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\"). See also: [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). [Â§]()Examples",
            "    fn into_iter(self) -> Self::IntoIter;",
            "    // Required method\n",
            "    type IntoIter: Iterator<Item = Self::Item>;\n",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterato",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "that have the same size as the value we specified.",
            "The test shows that when we call `shoes_in_size`, we get back only shoes",
            "adapted iterator into a vector thatâ€™s returned by the function.",
            "specified. Finally, calling `collect` gathers the values returned by the",
            "compares the value with each shoeâ€™s size, keeping only shoes of the size",
            "The closure captures the `shoe_size` parameter from the environment and",
            "size.",
            "size as parameters. It returns a vector containing only shoes of the specified",
            "The `shoes_in_size` function takes ownership of a vector of shoes and a shoe",
            "their environment.",
            "weâ€™ll specify as arguments to iterator adapters will be closures that capture",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "### [Using Closures That Capture Their Environment]()",
            "consuming adapter methods to get results from calls to iterator adapters.",
            "a readable way. But because all iterators are lazy, you have to call one of the",
            "You can chain multiple calls to iterator adapters to perform complex actions in",
            "provides.",
            "behavior while reusing the iteration behavior that the `Iterator` trait",
            "on each item. This is a great example of how closures let you customize some",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "containing each item from the original vector, incremented by 1.",
            "returned from the call to `map` into a vector. This vector will end up",
            "In Listing 13-15, we collect the results of iterating over the iterator thatâ€™s",
            "some aspect of the original iterator.",
            "consume the iterator. Instead, they produce different iterators by changing",
            "*Iterator adapters* are methods defined on the `Iterator` trait that donâ€™t",
            "### [Methods that Produce Other Iterators]()",
            "consuming the iterator.",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "uses up the iterator. One example is the `sum` method, which takes ownership of",
            "Methods that call `next` are called *consuming adapters* because calling them",
            "`Iterator` trait.",
            "is why youâ€™re required to implement the `next` method when implementing the",
            "trait. Some of these methods call the `next` method in their definition, which",
            "methods by looking in the standard library API documentation for the `Iterator`",
            "implementations provided by the standard library; you can find out about these",
            "The `Iterator` trait has a number of different methods with default",
            "### [Methods That Consume the Iterator]()",
            "`iter_mut` instead of `iter`.",
            "`iter`. Similarly, if we want to iterate over mutable references, we can call",
            "ownership of `v1` and returns owned values, we can call `into_iter` instead of",
            "over immutable references. If we want to create an iterator that takes",
            "references to the values in the vector. The `iter` method produces an iterator",
            "Also note that the values we get from the calls to `next` are immutable",
            "iterator.",
            "it is in the sequence. In other words, this code *consumes*, or uses up, the",
            "iterator changes internal state that the iterator uses to keep track of where",
            "Note that we needed to make `v1_iter` mutable: calling the `next` method on an",
            "from the vector.",
            "what values are returned from repeated calls to `next` on the iterator created",
            "We can call the `next` method on iterators directly; Listing 13-12 demonstrates",
            "`Some` and, when iteration is over, returns `None`.",
            "`next` method, which returns one item of the iterator at a time, wrapped in",
            "The `Iterator` trait only requires implementors to define one method: the",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "### [The `Iterator` Trait and the `next` Method]()",
            "amed `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this",
            "    // methods with default implementations elided",
            "    fn next(&mut self) -> Option<Self::Item>;",
            "    type Item;",
            "pub trait Iterator {",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:",
            "standard library. The definition of the trait looks like this:",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "    type Item;",
            "    // Required method",
            "}"
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently).",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Instances of `Fn` can be called repeatedly without mutating state."
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too.",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu"
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "where\n    Args: Tuple ,",
            "pub trait FnOnce<Args>",
            "FnOnce in std::ops - Rust"
          ]
        },
        {
          "title": "Trait FusedIterator - std::iter (Rust std docs)",
          "url": "http://doc.rust-lang.org/std/iter/trait.FusedIterator.html",
          "excerpts": [
            "that behave this way because it allows optimizing [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\").",
            "to return [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") again. This trait should be implemented by all iterators",
            "Note: In general, you should not use `FusedIterator` in generic bounds if\nyou need a fused iterator. Instead, you should just call [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\") on the iterator. If the iterator is already fused, the additional [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper will be a no-op with no performance penalty.",
            "An iterator that always continues to yield `None` when exhausted.",
            "pub trait FusedIterator: Iterator { }"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "```\nlet numbers = vec! [ 1 , 2 , 3 , 4 , 5 , 6 ];\n\nlet mut iter = numbers.iter();\n\nassert_eq! ( Some ( & 1 ), iter.next());\nassert_eq! ( Some ( & 6 ), iter.next_back());\nassert_eq! ( Some ( & 5 ), iter.next_back());\nassert_eq! ( Some ( & 2 ), iter.next());\nassert_eq! ( Some ( & 3 ), iter.next());\nassert_eq! ( Some ( & 4 ), iter.next());\nassert_eq! ( None , iter.next());\nassert_eq! ( None , iter.next_back());\n```\n",
            "Basic usage:",
            "##### [Â§](#examples-2) Examples",
            "The [trait-level](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") docs contain more details.",
            "Returns `None` when there are no more elements.",
            "Removes and returns an element from the end of the iterator.",
            "#### fn [next\\_back](#tymethod.next_back) (&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\") <Self:: [Item](trait.Iterator.html#associatedtype.Item \"type std::iter::Iterator::Item\") >",
            "1\\.0.0 Â· [Source](../../src/core/iter/traits/double_ended.rs.html#94)",
            "\n## Required Methods [Â§](#required-methods)",
            "again may or may not ever return [`Some`](../option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. [`next()`](trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") and [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") are interchangeable for this purpose.",
            "In a similar fashion to the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") protocol, once a `DoubleEndedIterator` returns [`None`](../option/enum.Option.html#variant.None \"variant std::option::Option::None\") from a [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") , calling it",
            "and do not cross: iteration is over when they meet in the middle.",
            "It is important to note that both back and forth work on the same range,",
            "over something that implements [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") : the ability to also take `Item` s from the back, as well as the front.",
            "Something that implements `DoubleEndedIterator` has one extra capability",
            "An iterator able to yield elements from both ends.",
            "             P: FnMut (&Self:: Item ) -> bool { ... }",
            "    fn rfind <P>(&mut self, predicate: P) -> Option <Self:: Item >",
            "             F: FnMut (B, Self:: Item ) -> B { ... }",
            "    fn rfold <B, F>(self, init: B, f: F) -> B",
            "             R: Try <Output = B> { ... }",
            "             F: FnMut (B, Self:: Item ) -> R,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "    fn try_rfold <B, F, R>(&mut self, init: B, f: F) -> R",
            "    fn nth_back (&mut self, n: usize ) -> Option <Self:: Item > { ... }",
            "    fn advance_back_by (&mut self, n: usize ) -> Result < () , NonZero < usize >> { ... }",
            "    // Provided methods",
            "    fn next_back (&mut self) -> Option <Self:: Item >;",
            "    // Required method",
            "pub trait DoubleEndedIterator: Iterator {",
            "}"
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n",
            "Iterators (and iterator [adapters]() ) are _lazy_ . This means that\njust creating an iterator doesnâ€™t _do_ a whole lot. Nothing really happens\nuntil you call [`next`](trait.Iterator.html.next \"method std::iter::Iterator::next\") .",
            "Iterators are also composable, and itâ€™s common to chain them together to do\nmore complex forms of processing. See the [Adapters]() section\nbelow for more details.\n",
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n"
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "-------\n\n* **Underlying structure:** Binary maxâ€‘heap in a `Vec`\n* **Time complexities:**\n\n> Push/pop: *O(log n)*\n>\n> Peek max: *O(1)*\n\n* **Memory:** Similar footprint to `Vec` plus heap invariant",
            "\n### **BTreeMap:**\n\n* **Underlying structure:** Balanced Bâ€‘tree of sorted keyâ€“value pairs\n* **Time complexities:**\n\n> Insert/remove/lookup: *O(log n)*\n\n* **Memory:** Lower perâ€‘element overhead vs. `HashMap` (no hashing), but tree nodes incur pointers",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi",
            "VecDeque:**\n\n* **Underlying structure:** Grow-able ring buffer of fixedâ€‘size blocks\n* **Time complexities:**\n\n> Push/pop front or back: Amortized *O(1)*\n>\n> Indexing: *O(1)* (slightly slower constant factor)\n>\n> Insert/remove in middle: *O(n)*\n\n* **Memory:** Slight overhead for ring buffer metadata and block poin",
            "Rustâ€™s standard library provides a rich set of collection types, each tailored to different useâ€‘cases and performance characteristics.",
            "LinkedList:**\n\n* **Underlying structure:** Doublyâ€‘linked list of heapâ€‘allocated nodes\n* **Time complexities:**\n\n> Insert/remove at known node (via cursor): *O(1)*\n>\n> Push/pop front or back: *O(1)*\n>\n> Indexing/traversal: *O(n)*\n\n* **Memory:** One heap allocation per element + two poin",
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements "
          ]
        },
        {
          "title": "How does Rust allocate more space for a vector?",
          "url": "https://stackoverflow.com/questions/62685440/how-does-rust-allocate-more-space-for-a-vector",
          "excerpts": [
            "The current strategy is to double the capacity when it must be increased. However, there is a special case: Vec::new() doesn't allocate, but pushing an element ..."
          ]
        },
        {
          "title": "evmap crate page (crates.io) - Rust Package Registry",
          "url": "https://crates.io/crates/evmap/5.0.2",
          "excerpts": [
            "pkg:cargo/evmap@5.0.2",
            "Metadata",
            "results show that `evmap` performs well under contention,\nespecially on the read side. This benchmar",
            "The benchmark\nmeasures the average number of reads and writes per second as the number of\nreaders and writers increases.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "Small Vector Optimization",
            "Small Vector Optimization",
            "The map is multi-value, meaning that every key maps to a *collection* of values. This\nintroduces some memory cost by adding a layer of indirection through a `Vec` for each value,\nbut enables more advanced use.",
            "Reads never take locks on their critical path, and neither\ndo writes assuming there is a single writer (multi-writer is possible using a `Mutex`), which\nsignificantly improves performance under contention.",
            "A lock-free, eventually consistent, concurrent multi-value map. evmap - crates.io: Rust Package Registry"
          ]
        },
        {
          "title": "expect-test - Crates.io (Rust snapshot testing library)",
          "url": "https://crates.io/crates/expect-test",
          "excerpts": [
            "Metadata"
          ]
        },
        {
          "title": "Why does vec allocate new memory and copy values when growing? - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/why-does-vec-allocate-new-memory-and-copy-values-when-growing/45291",
          "excerpts": [
            " In Rust, you can do this by calling `Vec::with_capacity(size)` instead of `Vec::new()`",
            "Vectors fit both of those requirements very well while still being conceptually simple to understand (a useful quality in a common collection type).",
            "The API of Vec doesn't change at all because of this optimization, and the overall strategy remains the same - double the size, (possibly) reallocating, every time more space is needed.",
            "Note that the _exponential_ growth is important. On each reallocation, we have to copy twice as much, but then it takes twice as long to fill up again. These factors cancel out and we get (on average) constant-time `.push()` .",
            "Vectors don't resize every time you call `insert` , they typically allocate extra space so subsequent insertions can be handled without re-allocating and usually they vary the extra space requested as the size of the vector increases. A common pattern is to allocate `2 * current capacity` on re-allocation."
          ]
        },
        {
          "title": "SwissMap: A smaller, faster Golang Hash Table",
          "url": "https://dolthub.com/blog/2023-03-28-swiss-map/",
          "excerpts": [
            "SwissMap supports a higher maximum load factor (87.5%) than the built-in map (81.25%), but this difference alone doesn't tell the whole story."
          ]
        },
        {
          "title": "How Go 1.24's Swiss Tables saved us hundreds of gigabytes",
          "url": "https://www.datadoghq.com/blog/engineering/go-swiss-tables/",
          "excerpts": [
            "Higher load factor: Swiss Tables support a higher load factor of 87.5% (versus 81.25% in Go 1.23), requiring fewer total slots. Elimination ..."
          ]
        },
        {
          "title": "Noteworthy concurrent data structures? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/myiokh/noteworthy_concurrent_data_structures/",
          "excerpts": [
            "Here are some crates with useful concurrent data structures: crossbeam. flume. parking_lot. dashmap/evmap/chashmap. arc-swap. atomic-take."
          ]
        },
        {
          "title": "aHash is a non-cryptographic hashing algorithm that uses ...",
          "url": "https://github.com/tkaitchuck/aHash",
          "excerpts": [
            "AHash is the fastest, DOS resistant hash currently available in Rust. AHash is intended exclusively for use in in-memory hashmaps."
          ]
        },
        {
          "title": "ahash - Rust",
          "url": "https://rust-lang.github.io/hashbrown/ahash/index.html",
          "excerpts": [
            "How aHash works. aHash uses the hardware AES instruction on x86 processors to provide a keyed hash function. aHash is not a cryptographically secure hash."
          ]
        },
        {
          "title": "RawVec growth strategy can be more efficient #111307",
          "url": "https://github.com/rust-lang/rust/issues/111307",
          "excerpts": [
            "May 6, 2023 â€” Currently, the RawVec implementation tries to double its internal capacity every time it has to grow, as can be seen in:Â ..."
          ]
        },
        {
          "title": "std::collections::binary_heap",
          "url": "https://doc.rust-lang.org/std/collections/binary_heap/index.html",
          "excerpts": [
            "Converting a vector to a binary heap can be done in-place, and has O(n) complexity. A binary heap can also be converted to a sorted vector in-place, allowing itÂ ..."
          ]
        },
        {
          "title": "BinaryHeap in std::collections",
          "url": "https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html",
          "excerpts": [
            "The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and theÂ ..."
          ]
        },
        {
          "title": "VecDeque in std::collections - Rust",
          "url": "https://doc.rust-lang.org/std/collections/struct.VecDeque.html",
          "excerpts": [
            "A double-ended queue implemented with a growable ring buffer. The â€œdefaultâ€ usage of this type as a queue is to use push_back to add to the queue, and ..."
          ]
        },
        {
          "title": "SmallVec::spilled() causing performance overhead on Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1g8o9a6/smallvecspilled_causing_performance_overhead/",
          "excerpts": [
            "}\n```\n\nSmallVec struct:\n\n```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= Self::inline_capacity() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use).",
            "But I have encountered this issue while benchmarking with [cargo flamegraph](https://github.com/flamegraph-rs/flamegraph): equivalance checks between `SmallVec`s take too long and almost all the time is spent on `spilled()`.",
            "I am the author of the [markov\\_str](https://github.com/Brogolem35/markov_str) library and I am trying out the [smallvec](https://github.com/servo/rust-smallvec/tree/v1) to speed up the training of my Markov Chains"
          ]
        },
        {
          "title": "bitvec - Rust",
          "url": "https://docs.rs/bitvec/latest/bitvec/",
          "excerpts": [
            "In addition, the [user guide](https://bitvecto-rs.github.io/bitvec/) explores the philosophical and academic\nconcepts behind `bitvec` â€™s construction, its goals, and the more intricate parts\nof its behavior.",
            "bitvec/latest/bitvec) explores `bitvec` â€™s usage and implementation in\ngreat detail. In particular, you should read the documentation for the [`order`](https://docs.rs/bitvec/latest/bitvec/order/index.html) , [`store`](https://docs.rs/bitvec/latest/bitvec/store/index.html) , and [`field`](https://docs.rs/bitvec/latest/bitvec/field/index.html) modules, as well as the [`BitSlice`](https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html) and [`BitArray`](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) types.",
            "`std` : This provides some `std::io::{Read,Write}` implementations, as well as `std::error::Error` for the various error types. It is otherwise unnecessary.",
            "`serde` : This enables the de/serialization of `bitvec` buffers through the `serde` system. This can be useful if you need to transmit `usize => bool` collections.",
            "`atomic` : This controls whether atomic instructions can be used for aliased\n  memor",
            "`alloc` : This links against the `alloc` distribution crate, and provides the `BitVec` and `BitBox` types. It can be used on `#! [no_std]` targets that\n  possess a dynamic allocator but not an operating syste",
            "`bitvec` has a few Cargo features that govern its API surface. The default\nfeature set is:",
            "When using `bitvec` to manage protocol buffers, you will need to select the\nexact type parameters that match your memory layout. For instance, TCP uses `<u8, Msb0>` , while IPv6 on a little-endian machine uses `<u32, Lsb0>` .",
            "Many protocols use sub-element fields in order to save space in transport; for\nexample, TCP headers have single-bit and 4-bit fields in order to pack all the\nneeded information into a desirable amount of space.",
            "If your bit-field storage buffers are never serialized for exchange between\nmachines, then you can get away with using the default type parameters and\nunadorned load/store methods.",
            "Uses of `bitvec` generally fall into three major genres. * compact, fast, `usize => bit` collections\n* truncated integer storage\n* precise control of memory layout",
            "The `bitvec` data types implement a complete replacement for their\nstandard-library counterparts, including all of the inherent methods, traits,\nand operator behaviors.",
            "While place expressions like `bits[index] = value;` are not available, `bitvec` instead provides a proxy structure that can be used as _nearly_ an `&mut bit` reference:",
            "the presence of a\ndynamic allocator enables the `BitBox` and `BitVec` buffer types, which can be\nused for more advanced buffer manipulation:",
            "Bit-slices can split anywhere.",
            "All data-types have macro\n// constructo",
            "use type aliases to make names for specific\ninstantiations of `bitvec` type parameters, and use that rather than attempting\nto remain generic over an `<T: BitStore, O: BitOrder>` pair throughout your\nproject.",
            "Note: `bitvec` supports `#! [no_std]` targets. If you do not have `std` ,\n> disable the default features, and explicitly restore any features that you do\n> h",
            "Minimum Supported Rust Version** : 1.56",
            "`BitSlice` cannot implement `IndexMut` , so `bitslice[index] = true;` does not\n  wor",
            "`BitSlice` cannot be used as a referent type in pointers, such as `Box` , `Rc` ,\n  or `Arc`",
            "A memory model accounts for element-level aliasing and is safe for concurrent\n  us",
            "Type parameters enable users to select the precise memory representation they\n  desir",
            "It leverages Rustâ€™s\npowerful reference and type systems to create a system that seamlessly bridges\nsingle-bit addressing, precise control of in-memory layout, and Rust-native\nownership and borrowing mechanisms.",
            "If you need to view memory as bit-addressed instead of byte-addressed, then `bitvec` is the fastest, most complete, and Rust-idiomatic crate for you.",
            "bitvec` provides a foundational API for bitfields in Rust. It specializes\nstandard-library data structures (slices, arrays, and vectors of `bool` ) to use\none-bit-per- `bool` storage, similar to [`std::bitset<N>`](https://en.cppreference.com/w/cpp/utility/bitset) and [`std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool) in C++",
            "bitvec - Rust"
          ]
        },
        {
          "title": "A HashMap in Rust - What's a HashMap? - Faultlore",
          "url": "https://faultlore.com/blah/robinhood-part-1/",
          "excerpts": [
            "For security, I recommend SipHash 2-4 as a reasonable *default* hashing algorithm, with some way to override the default for performance.",
            "For performance and simplicity, I recommend a robinhood hashmap, which enjoys O(1) expected time per query without the need for chaining.",
            "For all intents and purposes, weâ€™ve got constant-time searches.",
            "We hash ~ alpha\\*n elements into a table of size n where each probe is independent and uniformly distributed over the table, and alpha < 1 is a constant. Let M be the maximum search time for any of the elements in the table. We show that with probability tending to one, M is in [log2log n + a, log2log n + b] for some constants *a* and *b* depending upon alpha only. This is an exponential improvement over the maximum search time in case of the standard FCFS collision strategy. So the expected worst-case search time is O(loglog n) if we have at most some constant load factor",
            "In contrast to the [previous](../rust-btree-case/) post, which dove into Rustâ€™s BTreeMap and the idea of B-Trees in general, this post will be split up into two posts. In this post we will take a look at the general problems faced by hashtables, as well as the robin hood hashtable scheme. In the next post, we will take a high-to-mid-level look at Rustâ€™s standard HashMap implementation (surprise, itâ€™s a robin hood hashtable), and what it does to be safe and fast.",
            "This article is really old! Rust has since moved on to SwissTable (hashbrown), which I describe [in this article](../hashbrown-tldr/). That said, this article is still useful because it mostly discusses issues fundamental to any HashMap design.",
            "A HashMap in Rust: What's a HashMap?"
          ]
        },
        {
          "title": "indexmap-rs GitHub Repository",
          "url": "https://github.com/indexmap-rs/indexmap",
          "excerpts": [
            "This was inspired by Python 3.6's new dict implementation (which remembers\nthe insertion order and is fast to iterate, and is compact in memory). Some of those features were translated to Rust, and some were not. The result\nwas indexmap, a hash table that has following properties:\n\n* Order is **independent of hash function** and hash values of keys. * Fast to iterate. * Indexed in compact space. * Preserves insertion order **as long** as you don't call `.remove()` , `.swap_remove()` , or other methods that explicitly change order. The alternate `.shift_remove()` does preserve relative order. * Uses hashbrown for the inner table, just like Rust's libstd `HashMap` does. ## Performance\n\n[]()\n\n`IndexMap` derives a couple of performance facts directly from how it is constructed,\nwhich is roughly:\n\n> A raw hash table of key-value indices, and a vector of key-value pairs. * \n  Iteration is very fast since it is on the dense key-values. * \n  Removal is fast since it moves memory areas only in the table,\n  and uses a single swap in the vector."
          ]
        },
        {
          "title": "Rust HashMap Documentation",
          "url": "https://doc.rust-lang.org/std/collections/struct.HashMap.html",
          "excerpts": [
            "The behavior resulting from either logic error is not specified, but will\nbe encapsulated to the `HashMap` that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination.",
            "It is also a logic error for a key to be modified in such a way that the keyâ€™s\nhash, as determined by the [`Hash`](../hash/trait.Hash.html \"trait std::hash::Hash\") trait, or its equality, as determined by\nthe [`Eq`](../cmp/trait.Eq.html \"trait std::cmp::Eq\") trait, changes while it is in the map.",
            "The hash table implementation is a Rust port of Googleâ€™s [SwissTable](https://abseil.io/blog/20180927-swisstables) .",
            "By default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks.",
            "A [hash map](index.html \"mod std::collections\") implemented with quadratic probing and SIMD lookup."
          ]
        },
        {
          "title": "Swisstable, a Quick and Dirty Description - Faultlore",
          "url": "https://faultlore.com/blah/hashbrown-tldr/",
          "excerpts": [
            "Bit fiddling tricks will be omitted because theyâ€™re not that interesting, and I made sure they were really well documented [in hashbrown](https://github.com/rust-lang/hashbrown/tree/master/src/raw) (the Rust impl), so you can just crib the implementations from there (seriously, itâ€™s only 100 lines of code, mostly comments). So if I ever say â€œdo X in parallel (func\\_name)â€ thatâ€™s your cue to check the parallel bit tricks implementation for func\\_name and its detailed documentatio",
            "Ok hereâ€™s how to implement Swisstable as simply as possible, with a bunch of random notes. Iâ€™m assuming youâ€™re familiar with the basics of an open-addressing hashmap implementation, and will be skipping over all those details. If you want to brush up on those issues, you can read my primer on [the old Rust Robin Hood implementation](https://gankra.github.io/blah/robinhood-part-1/). High level concepts to keep in mind:\n\n* open-addressing\n* searches in parallel using SIMD\n* first-come-first-serve collision resolution\n* chunked (SIMD) triangular (quadratic-ish) probing\n* tombstones to avoid backshifts",
            "Swisstable, a Quick and Dirty Description"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "The collectionâ€™s size is denoted by `n`. * If a second collection is involved, its size is denoted by `m`. * Item indices are denoted by `i`. * Operations which have an *amortized* cost are suffixed with a `*`. * Operations with an *expected* cost are suffixed with a `~`. Calling operations that add to a collection will occasionally require a\ncollection to be resized - an extra operation that takes *O*(*n*) time.\n*Amortized* costs are calculated to account for the time cost of such resize\noperations *over a sufficiently large series of operations*. An individual\noperation may be slower or faster due to the sporadic nature of collection\nresizing, however the average cost per operation will approach the amortized\ncost. Rustâ€™s collections never automatically shrink, so removal operations arenâ€™t\namortized. [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") uses *expected* costs. It is theoretically possible, though very\nunlikely, for [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") to experience significantly worse performance than\nthe expected cost. This is due to the probabilistic nature of hashing - i.e. it is possible to generate a duplicate hash given some input key that will\nrequires extra computation to correct.",
            "Choosing the right collection for the job requires an understanding of what\neach collection is good at. Here we briefly summarize the performance of\ndifferent collections for certain important operations. For further details,\nsee each typeâ€™s documentation, and note that the names of actual methods may\ndiffer from the tables below on certain collections. Throughout the documentation, we will adhere to the following conventions\nfor operation notation:",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")",
            "Many collections provide several constructors and methods that refer to\nâ€œcapacityâ€. These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the\nelements stored in the collection, but for the collection to do this would\nbe very inefficient. If the backing array was exactly the right size at all\ntimes, then every time an element is inserted, the collection would have to\ngrow the array to fit it. Due to the way memory is allocated and managed on\nmost computers, this would almost surely require allocating an entirely new\narray and copying every single element from the old one into the new one. Hopefully you can see that this wouldnâ€™t be very efficient to do on every\noperation. Most collections therefore use an *amortized* allocation strategy. They\ngenerally let themselves have a fair amount of unoccupied space so that they\nonly have to grow on occasion.",
            "Note that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\"). For Sets, all operations have the cost of the equivalent Map operation.",
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")."
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "`smallvec-handle`: a faster small vector implementation?",
          "url": "https://www.reddit.com/r/rust/comments/1i5d856/smallvechandle_a_faster_small_vector/",
          "excerpts": [
            "How it works? Small vector optimization usually means storing items inline (without allocation) until a given (small) capacity. However, unlike ..."
          ]
        },
        {
          "title": "std::collections::vec_deque",
          "url": "https://doc.rust-lang.org/std/collections/vec_deque/index.html",
          "excerpts": [
            "A double-ended queue (deque) implemented with a growable ring buffer. This queue has O(1) amortized inserts and removals from both ends of the container."
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s\nimplementation simpler.",
            "    Err(E)",
            "    Ok(T),",
            "enum Result<T, E> {",
            "\n#! [allow(unused)]",
            "he `Result` enum is defined as having two\nvariants, `Ok` and `Err` , as follows:",
            "```",
            "}",
            "}",
            "fn main() {",
            "```rust"
          ]
        },
        {
          "title": "Error handling - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/error.html",
          "excerpts": [
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ... When there is a chance that things do go wrong and the caller has to deal with the problem, use Result . You can unwrap and expect them as well (please don't do ...",
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input would ... Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ..."
          ]
        },
        {
          "title": "Result in std",
          "url": "https://doc.rust-lang.org/beta/std/result/enum.Result.html",
          "excerpts": [
            "Returns true if the result is Err and the value inside of it matches a predicate. Â§Examples. use std::io::{Error, ErrorKind}; let x: Result<u32, Error> ..."
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html).",
            "Returns the contained [`Some`](enum.Option.html.Some \"variant std::option::Option::Some\") value, consuming the `self` value. Because this function may panic, its use is generally discouraged. Panics are meant for unrecoverable errors, and\n[may abort the entire program](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html).",
            "The map method takes the self argument by value, consuming the original, so this technique uses as_ref to first take an Option to a reference to the valueÂ ... Computes a default function result (if none), or applies a different function to the contained value (if any). Â§Basic examples. let k = 21; let x = Some(\"foo\"); ..."
          ]
        },
        {
          "title": "Pattern Syntax - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html",
          "excerpts": [
            " #### [Destructuring Enums]",
            "This example will print `The number 4 is even`. When `num` is compared to the\npattern in the first arm, it matches because `Some(4)` matches `Some(x)`. Then\nthe match guard checks whether the remainder of dividing `x` by 2 is equal to\n0, and because it is, the first arm is selected. If `num` had been `Some(5)` instead, the match guard in the first arm would\nhave been `false` because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesnâ€™t have a match guard and therefore matches any `Some` variant. There is no way to express the `if x % 2 == 0` condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesnâ€™t try to check for\nexhaustiveness when match guard expressions are involved. In Listing 19-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem.",
            "[Listing 19-26](): Adding a match guard to a pattern",
            "fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println! (\"The number {x} is even\"),\n        Some(x) => println! (\"The number {x} is odd\"),\n        None => (),\n    }\n}",
            "The condition can use variables created in the pattern. Listing 19-26 shows a\n`match` where the first arm has the pattern `Some(x)` and also has a match\nguard of `if x % 2 == 0` (which will be `true` if the number is even).",
            "This code will print `Change color to red 0, green 160, and blue 255`. Try\nchanging the value of `msg` to see the code from the other arms run. For enum variants without any data, like `Message::Quit`, we canâ€™t destructure\nthe value any further. We can only match on the literal `Message::Quit` value,\nand no variables are in that pattern. For struct-like enum variants, such as `Message::Move`, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 19-13. For tuple-like enum variants, like `Message::Write` that holds a tuple with one\nelement and `Message::ChangeColor` that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant weâ€™re\nmatching.",
            "[Listing 19-15](): Destructuring enum variants that hold different kinds of values",
            "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println! (\"The Quit variant has no data to destructure. \");\n        }\n        Message::Move { x, y } => {\n            println!\n(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println! (\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println! (\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n    }\n}",
            "Weâ€™ve destructured enums in this book (for example, Listing 6-5), but we havenâ€™t\nyet explicitly discussed that the pattern to destructure an enum corresponds to\nthe way the data stored within the enum is defined. As an example, in Listing\n19-15 we use the `Message` enum from Listing 6-2 and write a `match` with\npatterns that will destructure each inner value. Filename: src/main.rs",
            "Similarly, the second arm matches any point on the `y` axis by specifying that\nthe `x` field matches if its value is `0` and creates a variable `y` for the\nvalue of the `y` field. The third arm doesnâ€™t specify any literals, so it\nmatches any other `Point` and creates variables for both the `x` and `y` fields. In this example, the value `p` matches the second arm by virtue of `x`\ncontaining a `0`, so this code will print `On the y axis at 7`. Remember that a `match` expression stops checking arms once it has found the\nfirst matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` axis\nand the `y` axis, this code would only print `On the x axis at 0`.",
            "[Listing 19-11](): A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`",
            "fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println! (\"Got 50\"),\n        Some(y) => println! (\"Matched, y = {y}\"),\n        _ => println! (\"Default case, x = {x:? }\"),\n    }\n\n    println! (\"at the end: x = {x:? }, y = {y}\");\n}",
            "Named variables are irrefutable patterns that match any value, and weâ€™ve used\nthem many times in this book. However, there is a complication when you use\nnamed variables in `match`, `if let`, or `while let` expressions. Because each\nof these kinds of expression starts a new scope, variables declared as part of a\npattern inside the expression will shadow those with the same name outside, as\nis the case with all variables.\nIn Listing 19-11, we declare a variable named\n`x` with the value `Some(5)` and a variable `y` with the value `10`. We then\ncreate a `match` expression on the value `x`. Look at the patterns in the match\narms and `println!` at the end, and try to figure out what the code will print\nbefore running this code or reading further. Filename: src/main.rs",
            "fn main() {\n    let x = 1;\n\n    match x {\n        1 => println! (\"one\"),\n        2 => println! (\"two\"),\n        3 => println! (\"three\"),\n        _ => println! (\"anything\"),\n    }\n}",
            "In this section, we gather all the syntax that is valid in patterns and discuss\nwhy and when you might want to use each one. ### [Matching Literals]()"
          ]
        },
        {
          "title": "Match ergonomics reservations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html",
          "excerpts": [
            "```\ncargo fix --edition\n```",
            "The [`rust_2024_incompatible_pat`](../../rustc/lints/listing/allowed-by-default.html) lint flags patterns that are not allowed in Rust 2024. This lint is part of the `rust-2024-compatibility` lint group which is automatically applied when running `cargo fix --edition`. This lint will automatically convert affected patterns to fully explicit patterns that work correctly in Rust 2024 and in all prior editions. To migrate your code to be compatible with Rust 2024, run:",
            "This can be surprising because the single `&` in the pattern causes a larger than expected change in the type by removing both layers of references. To leave space to fix this, in Rust 2024 it's an error to write `&` or `&mut` in the pattern when the default binding mode is not `move`. That is, `&` or `&mut` can only be written when the pattern (leading up to that point) is fully explicit.",
            "Here, the `&` in the pattern both matches against the reference on `&()` and resets the default binding mode to `move`.",
            "### [Reference patterns restriction]()",
            "To leave space for other language possibilities, we are disallowing explicit binding modes where they are redundant in Rust 2024.",
            "Here, the `ref` explicit binding mode is redundant, as by passing the shared reference (i.e. not mentioning it in the pattern), the binding mode switches to `ref`.",
            "In Rust 2021 and earlier editions, we allow:",
            "### [`ref` / `ref mut` restriction]()",
            "But then, in these editions, writing `mut` on the binding resets the default binding mode to `move`. This can be surprising as it's not intuitive that mutability should affect the type. To leave space to fix this, in Rust 2024 it's an error to write `mut` on a binding when the default binding mode is not `move`. That is, `mut` can only be written on a binding when the pattern (leading up to that binding) is fully explicit.",
            "Here, because we pass the shared reference in the pattern, the default binding mode switches to `ref`.",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "### [`mut` restriction]()",
            "Patterns such as this are said to be using match ergonomics, originally introduced in [RFC 2005](https://github.com/rust-lang/rfcs/pull/2005). Under match ergonomics, as we incrementally match a pattern against a scrutinee, we keep track of the default binding mode. This mode can be one of `move`, `ref mut`, or `ref`, and it starts as `move`. When we reach a binding, unless an explicit binding mode is provided, the default binding mode is used to decide the binding's type.",
            "By contrast, this otherwise-equivalent pattern is not fully explicit:",
            "Such a pattern is called fully explicit because it does not elide (i.e. \"skip\" or \"pass\") any references within the scrutinee.",
            "Within `match`, `let`, and other constructs, we match a *pattern* against a *scrutinee*. E.g. :",
            "Match ergonomics reservations - The Rust Edition Guide"
          ]
        },
        {
          "title": "Enums and Pattern Matching - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-00-enums.html",
          "excerpts": [
            "tching]()\n\nIn this chapter, weâ€™ll look at _enumerations_ , also referred to as _enums_ . Enums allow you to define a type by enumerating its possible _variants_ . First\nweâ€™ll define and use an enum to show how an enum can encode meaning along with\ndata. Next, weâ€™ll explore a particularly useful enum, called `Option` , which\nexpresses that a value can be either something or nothing. Then weâ€™ll look at\nhow pattern matching in the `match` expression makes it easy to run different\ncode for different values of an enum. Finally, weâ€™ll cover how the `if let` construct is another convenient and concise idiom available to handle enums in\nyour code.",
            "Enums and Pattern Matching"
          ]
        },
        {
          "title": "The Nullable Pointer Optimization",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts\nlike vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\ninternal details.",
            "Foreign functions are assumed to be unsafe so calls to them need to be wrapped\nwith `unsafe {}` as a promise to the compiler that everything contained within\ntruly is safe.",
            "The `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \" [Foreign Calling Conventions](ffi.html) \". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.",
            "extern \"C-unwind\"",
            "If you expect Rust `panic` s or foreign (e.g. C++) exceptions to cross an FFI\nboundary, that boundary must use the appropriate `-unwind` ABI string.",
            "Certain Rust types are defined to never be `null`. This includes references (`&T`,\n`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\ninterfacing with C, pointers that might be `null` are often used, which would seem to\nrequire some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types. However, trying to construct/work with these invalid values **is undefined behavior**,\nso you should use the following workaround instead. As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\nexactly two variants, one of which contains no data and the other contains a field of one of the\nnon-nullable types listed above. This means no extra space is required for a discriminant; rather,\nthe empty variant is represented by putting a `null` value into the non-nullable field. This is\ncalled an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\ntypes. The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\nwhere `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\nto represent a nullable function pointer using the C ABI (corresponding to the C type\n`int (*)(int)`). Here is a contrived example."
          ]
        },
        {
          "title": "Type Layout - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/type-layout.html?highlight=repr",
          "excerpts": [
            "Structs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field.",
            "The `transparent` representation can only be used on a [`struct`](items/structs.html)\nor an [`enum`](items/enumerations.html) with a single variant that has:\n\n* any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`](special-types-and-traits.html)), and\n* at most one other field.",
            "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`]() by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.",
            "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (â€œthe tagâ€) and the remaining fields are the fields of that variant.",
            "For [field-less enums](items/enumerations.html), primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive.",
            "Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums](items/enumerations.html) to have a primitive representation. Combining\ntwo primitive representations together is an error.",
            "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize",
            "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a â€œtagged unionâ€ in C:",
            "For [field-less enums](items/enumerations.html), the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platformâ€™s C ABI.",
            "The size and offset of fields is determined by the following algorithm. Start with a current offset of 0 bytes. For each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the fieldâ€™s\nalignment, then add padding bytes to the current offset until it is a multiple\nof the fieldâ€™s alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field. Finally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the structâ€™s alignment.",
            "The alignment of the struct is the alignment of the most-aligned field in it.",
            "This representation can be applied to structs, unions, and enums.\nThe exception\nis [zero-variant enums](items/enumerations.html) for which the `C` representation is an error.",
            "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.",
            "There are no other guarantees of data layout made by this representation.",
            "The only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n1. The fields are properly aligned. 2. The fields do not overlap. 3. The alignment of the type is at least the maximum alignment of its fields.",
            "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.",
            "The alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.",
            "The representation of a type can be changed by applying the `repr` attribute\nto it.",
            "The possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()",
            "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.",
            "The exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.",
            "Tuples are laid out according to the [`Rust` representation]()",
            "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`.",
            "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes.",
            "Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.",
            "Pointers to sized types have the same size and alignment as `usize`.",
            "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.",
            "All values have an alignment and size.",
            "Type layout can be changed with each compilation.",
            "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.",
            "Type layout - The Rust Reference"
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok\\(T\\),%0A+++++++Err\\(E\\),%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](../../std/io/index.html) .\n ... \n;\n    Ok (())\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++fn+write_message\\(\\)+-%3E+io::Result%3C\\(\\)%3E+%7B%0A++++++++let+mut+file+=+File::create\\(%22valuable_data.txt%22\\)?;%0A++++++++file.write_all\\(b%22important+message%22\\)? ;%0A++++++++Ok\\(\\(\\)\\)%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\n## [Â§]() The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark\noperator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\") , hides some of the boilerplate of propagating errors\nup the call stack. It replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude:: * ;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: & Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create( \"my_best_friends.txt\" ) {\n           Err (e) => return Err (e),\n           Ok (f) => f,\n    };\n    if let Err (e) = file.write_all( format! ( \"name: {}\\n\" , info.name).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format! ( \"age: {}\\n\" , info.age).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format!\n ... \n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides. ## [Â§]() Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI\nguarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a\ntype that qualifies for the `Option` [representation guarantees](../option/index.html \"Option Representation\") ,\nand the _other_ type must meet all of the following conditions:\n\n* Is a zero-sized type with alignment 1 (a â€œ1-ZSTâ€). * Has no fields. * Does not have the `#[non_exhaustive]` attribute. For example, `NonZeroI32` qualifies for the `Option` representation\nguarantees, and `()` is a zero-sized type with alignment 1, no fields, and\nit isnâ€™t `non_exhaustive` . This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees\nas `Option<NonZeroI32>` .\n ... \nIf the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](enum.Result.html.Ok \"variant std::result::Result::Ok\") :\n\n* [`expect_err`](enum.Result.html.expect_err \"method std::result::Result::expect\\_err\") panics with a provided custom message\n* [`unwrap_err`](enum.Result.html.unwrap_err \"method std::result::Result::unwrap\\_err\") panics with a generic message\n* [`unwrap_err_unchecked`](enum.Result.html.unwrap_err_unchecked \"method std::result::Result::unwrap\\_err\\_unchecked\") produces _[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)_\n\n### [Â§]() Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\") :\n\n* [`err`](enum.Result.html.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\") ,\n  mapping [`Err(e)`]",
            " std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides.",
            "In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](.",
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "### [Â§]() Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an\niterator that is conditionally empty.",
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n"
          ]
        },
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "Defining an Enum - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html",
          "excerpts": [
            "This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include anotherÂ ..."
          ]
        },
        {
          "title": "Refutability: Whether a Pattern Might Fail to Match",
          "url": "https://doc.rust-lang.org/book/ch19-02-refutability.html",
          "excerpts": [
            "Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable."
          ]
        },
        {
          "title": "Rust Type Layout and ABI Details",
          "url": "https://doc.rust-lang.org/std/mem/fn.discriminant.html",
          "excerpts": [
            "\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct {",
            "\nIf an enum has opted-in to having a [primitive representation](../../reference/type-layout.html) for its discriminant,\nthen itâ€™s possible to use pointers to read the memory location storing the discriminant. That **cannot** be done for enums using the [default representation](../../reference/type-layout.html) , however, as itâ€™s\nundefined what layout the discriminant has and where itâ€™s stored â€” it might not even be\nstored at all!"
          ]
        },
        {
          "title": "Empty Source Document",
          "url": "https://doc.rust-lang.org/reference/patterns.html",
          "excerpts": [
            "wildcard\")\n\nIn a pattern whose [scrutinee](glossary.html) expression has a `struct`, `enum` or `tuple` type, a [wildcard pattern]() (`_`) stands in for a *single* data field, whereas an [et cetera]() or [rest pattern]() (`..`) stands in for *all* the remaining fields of a particular variant.",
            "Patterns can be used to *destructure* [structs](items/structs.html), [enums](items/enumerations.html), and [tuples](types/tuple.html). Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.",
            "`let` declarations\n`match` expressions\n`if let` expressions\n`while let` expressions\n`for` expressions\n",
            "Patterns are used in:",
            "**NOTE**: The provided source document is empty and does not contain any information relevant to the query about Rust's type system, algebraic data types, pattern matching, or type layout concepts."
          ]
        },
        {
          "title": "Rust Reference: Non-exhaustive Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes/type_system.html",
          "excerpts": [
            "It can be applied to [`struct`s](../items/structs.html), [`enum`s](../items/enumerations.html), and `enum` variants.",
            "The `non_exhaustive` attribute",
            "Type system attributes",
            "The Rust Reference",
            "There are limitations when matching on non-exhaustive types outside of the defining crate:",
            "Non-exhaustive types cannot be constructed outside of the defining crate:\n\n* Non-exhaustive variants ([`struct`](../items/structs.html) or [`enum` variant](../items/enumerations.html)) cannot be constructed\n  with a [StructExpression](../expressions/struct-expr.html) (including with [functional update syntax](../expressions/struct-expr.html)). * The implicitly defined same-named constant of a [unit-like struct](../items/structs.html),\n  or the same-named constructor function of a [tuple struct](../items/structs.html),\n  has a [visibility](../visibility-and-privacy.html) no greater than `pub(crate)`",
            "Outside of the defining crate, types annotated with `non_exhaustive` have limitations that\npreserve backwards compatibility when new fields or variants are added.",
            "The *`non_exhaustive` attribute* indicates that a type or variant may have\nmore fields or variants added in the future."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "The Rust Reference"
          ]
        },
        {
          "title": "Stack Overflow: Whats the difference between #[repr(Rust)], #[repr(C)] and #[repr(packed)]?",
          "url": "https://stackoverflow.com/questions/79631106/whats-the-difference-between-reprrust-reprc-and-reprpacked",
          "excerpts": [
            "the reason is that the structure needs to always have the same layout so that the `select` function can actually access its fields (it's been compiled by the OS vendors, separately from the Rust code, so will be looking at known locations for the fields and Rust needs to put the fields in the same place).",
            "`#[repr(C)]` exists to allow two sections of code to agree on how data should be represented even if they're compiled independently of each other; its purpose is to be a consistent representation that always stays the same.",
            "In summary, `#[repr(Rust)]` leaves the representation to the compiler, which will probably do a better job of optimising the representation than you would by hand, and thus it makes the most sense to use for general use (which is why it's the default â€“ it's rare to actually write `#[repr(Rust)]` explicitly)."
          ]
        },
        {
          "title": "Rust Nomicon: repr-rust (Memory layout and ABI considerations)",
          "url": "https://doc.rust-lang.org/nomicon/repr-rust.html",
          "excerpts": [
            "\n\nThere is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct A {\n    a: i32,\n    b: u64,\n}\n\nstruct B {\n    a: i32,\n    b: u64,\n}\n}\n```\n```\n\nRust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B. With A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways. For instance, consider this struct:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nstruct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}\n}\n```\n```\n\nNow consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:\n\n```\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}\n\nstruct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}\n```\n\nThe latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*. Enums make this consideration even more complicated. Naively, an enum such as:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nenum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}\n}\n```\n```\n\nmight be laid out as:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}\n}\n```\n```\n\nAnd indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`). However there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`. There are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today.",
            "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2. Primitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits). A type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of [dynamically sized types](exotic-sizes.html).\nRust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)",
            "Rust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)\n\nAn enum is said to be _field-less_ if none of its variants have associated data. By default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n}\n```\n```\n\nwill be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align \\`b\\`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n}\n```\n```\n\nor maybe:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n}\n```\n```\n\nThere is _no indirection_ for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```rust\n#!"
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "## [repr(align(n))]()",
            "## [repr(packed), repr(packed(n))]()",
            "## [repr(u\\*), repr(i\\*)]",
            "Rust allows you to specify alternative data layout strategies from the default. There's also the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** normative). ## [repr(C)]()",
            "## [repr(transparent)]()",
            "* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.",
            "[repr(C)]()",
            "\n# [Alternative representations]()",
            "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at least_ `n` . This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code). This is a modifier on `repr(C)` and `repr(Rust)` . It is incompatible with `repr(packed)` .",
            "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.",
            "* If `T` is an [FFI-safe non-nullable pointer\n  type](ffi.html),\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.",
            "The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world.",
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have `repr(C)` , as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type. We strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage your FFI\nboundaries fo",
            "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at most_ `n` . Most commonly used without an explicit `n` , `repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust Reference: Type Layout",
          "url": "https://doc.rust-lang.org/reference/type-layout.html",
          "excerpts": [
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today. Note that even types with the same layout can still differ in how they are passed\nacross function boundaries.",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.",
            "ntro\")\n\nThe layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout. [[layout .guarantees]](.guarantees",
            "The representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.",
            ")\n\nThe possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()\n\n[[layout .repr .at",
            "All user-defined composite types ( `struct` s, `enum` s, and `union` s) have a _representation_ that specifies what the layout is for the type. [[layout .repr .kinds]]"
          ]
        },
        {
          "title": "never patterns, exhaustive matching, and uninhabited types",
          "url": "https://internals.rust-lang.org/t/blog-post-never-patterns-exhaustive-matching-and-uninhabited-types/8197",
          "excerpts": [
            "Aug 14, 2018 â€” Having two traits should solve problem with obscure corner cases with recursive uninhabited types, as they will not implement any of thoseÂ ..."
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html?highlight=never",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete. [type. never .coercion]. Expressions of type ! can ..."
          ]
        },
        {
          "title": "Pre-(Pre-)RFC: niche types - language design",
          "url": "https://internals.rust-lang.org/t/pre-pre-rfc-niche-types/21810",
          "excerpts": [
            "Nov 2, 2024 â€” Niches are bit patterns within a struct or enum which can be repurposed by an enclosing enum or, in the future, an enclosing struct. While thisÂ ..."
          ]
        },
        {
          "title": "Why doesn't the niche optimization work for this enum?",
          "url": "https://users.rust-lang.org/t/why-doesnt-the-niche-optimization-work-for-this-enum/55711",
          "excerpts": [
            "Feb 16, 2021 â€” The only guaranteed niche filling optimization is if you have an enum that fits the template below exactly, and the wrapped type has a niche."
          ]
        },
        {
          "title": "Idiomatic definition of uninhabited (never) newtypes",
          "url": "https://internals.rust-lang.org/t/idiomatic-definition-of-uninhabited-never-newtypes/20877",
          "excerpts": [
            "May 20, 2024 â€” It's conventional to use an empty enum for an uninhabited type, because that's the only stable way to do it."
          ]
        },
        {
          "title": "2005-match-ergonomics - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2005-match-ergonomics.html",
          "excerpts": [
            "This RFC introduces default binding modes used when a reference value is matched by a non-reference pattern."
          ]
        },
        {
          "title": "Data Representation and Layout in Rust - OpenGuild",
          "url": "https://openguild.wtf/blog/rust/data-representation-and-layout",
          "excerpts": [
            "Nov 22, 2023 â€” Rust, with its emphasis on control and safety, provides two primary representations: repr(rust) and repr(C) . The former instructs theÂ ..."
          ]
        },
        {
          "title": "Coherence - Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/coherence.html",
          "excerpts": [
            "ses. Overlap checks always consider pairs of implementations, comparing them to each other. Overlap ",
            "the explicit negative impl check, and the implicit negative impl check. Both try to prove that an overlap is definitely impossible.",
            "but normally isn't.",
            "2. under [specializatio",
            "1. for marker traits",
            "Overlapping is sometimes partially allowed:",
            "This uses the same overlap checking code, really done as two separate analyses.",
            "Overlap checks are performed for both inherent impls, and for trait impls.",
            "Coherence checking is what detects both of trait impls and inherent impls overlapping with others."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117).",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "The reason for this is that there are two appearances of type parameter `T` in"
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type.",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc"
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "Oct. 28, 2022 Â· Jack Huey",
            "Generic associated types to be stable in Rust 1.65"
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type.",
            "## [The Orphan Rules]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "# [Chalk: Orphan Check]()",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "## [Axioms & Properties of Coherence]()",
            "# [Resources About Coherence]()",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "## [Coherence]()"
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds"
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Understanding Rust's Trait Objects: Vtables, Dynamic ...",
          "url": "https://www.reddit.com/r/rust/comments/1epc5g6/understanding_rusts_trait_objects_vtables_dynamic/",
          "excerpts": [
            "This article investigates how Rust handles dynamic dispatch using trait objects and vtables. It also explores how the Rust compiler can sometimes optimize tailÂ ..."
          ]
        },
        {
          "title": "Rust Deep Dive: Borked Vtables and Barking Cats",
          "url": "https://geo-ant.github.io/blog/2023/rust-dyn-trait-objects-fat-pointers/",
          "excerpts": [
            "Mar 15, 2023 â€” We'll get to the specific layout of a vtable below, but for now suffice it to say that a vtable is a contiguous piece of storage in memory thatÂ ...",
            "Mar 15, 2023 â€” The pointers to dyn Trait objects store both the address of the data as well as a pointer to the vtable. There is one global vtable instance forÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ...",
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ..."
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu",
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes."
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            "This topic was automatically closed 90 days after the last reply. New replies are no longer allowed.",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            " [Idea] About soundness in specialization "
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "    x",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "trait Supertrait {}",
            "trait Trait: Supertrait {}",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "min\\_specialization - The Rust Unstable Boo",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "# [`min_specialization`]()"
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            " specialization - The Rust Unstable Book"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`.",
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "Bounds on an item must be satisfied when using the item."
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "## [Parameter patterns]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Unsafe traits]()",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "## [Supertraits]()",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "impl WithSelf for S {}",
            "impl<A> Super<A> for S {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "trait Super<A> {}",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "impl TraitWithSize for S {}",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "```\n```rust\n#! [allow(unused)]",
            "```",
            "```",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "impl NonDispatchable for S {",
            "    // Generics are not compatible with vtables.",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_ref(self: &Self) {}",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "use std::pin::Pin;",
            "use std::sync::Arc;",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "> This concept was formerly known as _object safety_ . ```",
            "> ",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "                - Not have an opaque return type; that is,",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * `&Self` (i.e. `&self` )",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "```rust"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "```",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language Blog",
          "url": "https://blog.rust-lang.org/",
          "excerpts": [
            "This is the main Rust blog. Rust teams use this blog to announce major developments in the world of Rust. See also: the \"Inside Rust\" blog,Â ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker.",
            "The borrow checker operates on the MIR.",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:"
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Error codes index",
          "url": "https://doc.rust-lang.org/error-index.html",
          "excerpts": [
            "Rust error codes index - Error codes index\n\nIf you are not automatically redirected to the error code index, please [here](./error_codes/error-index.html) ."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time.",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "} ```",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "  * y = 7 ;",
            "  * x = 42 ;",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "```rust",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            " ... ",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "Aug 7, 2018",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "      + [Blog](/blog/)",
            "*     + [Projects](/projects/)",
            "* [ralfj.de](/)",
            "Stacked Borrows: An Aliasing Model For Rust"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Unfortunately, things are not so easy.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "However, before we go\nthere, I would like us to consider one more example:",
            "## 3 Retagging and Creating Raw Pointers",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "Stacked Borrows Implemented",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "Lifetime elision - The Rust Reference"
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Otherwise, it is an error to elide an output lifetime.",
            "Elision rules are as follows:",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "Lifetime positions can appear as either \"input\" or \"output\":"
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "Lifetimes - Rust By Example",
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable."
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you."
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Both values can be independently used",
            "    let y = x;",
            "// *Copy* `x` into `y` - no resources are moved",
            "creating dangling pointers. ```",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "from being freed more than once. Note that not all variables own",
            "This prevents resources",
            "resources can only have one owner",
            "Because variables are in charge of freeing their own resources,"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    ",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            "use std::sync::{Arc, Mutex};",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "This mutex will block threads waiting for the lock to become available",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "let data = Arc::new(Mutex::new( 0 ));",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ..."
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n",
            "following code:",
            "Rust's `Fn` traits are a little bit magic. For instance, we can write the",
            "Higher-Rank Trait Bounds - The Rustonomicon",
            "The Rustonomicon",
            "\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n```\n\nAlternatively:\n\n```\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,\n```\n\n(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)\n\n`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.\n\nIn summary, we can rewrite the original code more explicitly as:\n\n```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n```\n```"
          ]
        },
        {
          "title": "Preludes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/names/preludes.html",
          "excerpts": [
            "e` [attribute](../attributes.html)* may be applied at the crate level or\non a module to indicate that it should not automatically bring the [standard\nlibrary prelude](), [extern prelude](), or [tool prelude]() into scope for that\nmodule or any of its descendants.",
            "d to the crate:\n\n| Edition | `no_std` not applied | `no_std` applied |\n| --- | --- | --- |\n| 2015 | [`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) | [`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) |\n| 2018 | [`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html) | [`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html) |\n| 2021 | [`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html) | [`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html) |\n| 2024 | [`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html) | [`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html) ",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "It includes the following:\n\n* [Type namespace](namespaces.html)\n  + [Boolean type](../types/boolean.html) â€” `bool`\n  + [Textual types](../types/textual.html) â€” `char` and `str`\n  + [Integer types](../types/numeric.html) â€” `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`\n  + [Machine-dependent integer types](../types/numeric.html) â€” `usize` and `isize`\n  + [floating-point types](../types/numeric.html) â€” `f32` and `f64`",
            "The language prelude includes names of types and attributes that are built-in\nto the language. The language prelude is always in scope.",
            "* [Tool prelud",
            "* [`macro_use` prelud",
            "* [Language prelud",
            "* [Extern prelud",
            "* [Standard library prelud",
            "There are several different preludes:",
            "A *prelude* is a collection of names that are automatically brought into scope\nof every module in a crat"
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()"
          ]
        },
        {
          "title": "std - Rust",
          "url": "https://doc.rust-lang.org/std/",
          "excerpts": [
            "The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem."
          ]
        },
        {
          "title": "The Rust Reference - Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes.html?highlight=attribute",
          "excerpts": [
            "Inner attributes_ , written with a bang ( `!` ) after the hash ( `#` ), apply to the\nitem that the attribute is declared within. _Outer attributes_ , written without\nthe bang after the hash, apply to the thing that follows t"
          ]
        },
        {
          "title": "Visibility and Privacy - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/visibility-and-privacy.html",
          "excerpts": [
            "```rust\npub mod outer_mod {\n    pub mod inner_mod {\n        // This function is visible within \\`outer_mod\\`\n        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}\n        // Same as above, this is only valid in the 2015 editio",
            "> 2018 Edition differences\n> \n> Starting with the 2018 edition, paths for `pub(in path)` must start with `crate` , `self` , or `super` . The 2015 edition may also use paths starting with `::` or modules from the crate root. Hereâ€™s an example:",
            "* `pub(self)` makes an item visible to the current module. This is equivalent\n  to `pub(in self)` or not using `pub` at all.",
            "* `pub(super)` makes an item visible to the parent module. This is equivalent\n  to `pub(in super)` .",
            "* `pub(crate)` makes an item visible within the current crate.",
            "* `pub(in path)` makes an item visible within the provided `path` . `path` must be a simple path which resolves to an ancestor module of the item whose visibility is being declared.\nEach identifier in `path` must refer directly to a module (not to a name introduced by a `use` statement).",
            "## [`pub(in path)` , `pub(crate)` , `pub(super)` , and `pub(self)`]()",
            "With the notion of an item being either public or private, Rust allows item\naccesses in two cases:\n\n1. If an item is public, then it can be accessed externally from some module `m` if you can access all the itemâ€™s ancestor modules from `m` . You can\n   also potentially be able to name the item through re-exports. See below. 2. If an item is private, it may be accessed by the current module and its\n   descendants.",
            "```rust\nfn main() {}\n// Declare a private struct\nstruct Foo;\n\n// Declare a public struct with a private field\npub struct Bar {\n    field: i32,\n}\n\n// Declare a public enum with two public variants\npub enum State {\n    PubliclyAccessibleState,\n    PubliclyAccessibleState2,\n}\n```",
            "By default, everything is _private_ , with two exceptions: Associated\nitems in a `pub` Trait are public by default; Enum variants\nin a `pub` enum are also public by default. When an item is declared as `pub` ,\nit can be thought of as being accessible to the outside world. For example:",
            "Visibility and privacy - The Rust Reference"
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`.",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]()."
          ]
        },
        {
          "title": "Advanced migrations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/editions/advanced-migrations.html",
          "excerpts": [
            "The lints that cargo fix --edition apply are part of a lint group. For example, when migrating from 2018 to 2021, Cargo uses the rust-2021-compatibility group ..."
          ]
        },
        {
          "title": "Transitioning an existing project to a new edition",
          "url": "https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html",
          "excerpts": [
            "The Rust Edition Guide ... In order to help transition to the next edition, Cargo includes the cargo fix subcommand to automatically update your source code."
          ]
        },
        {
          "title": "Features - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo â€œfeaturesâ€ provide a mechanism to express conditional compilation and optional dependencies. A package defines a set of named features in the [features] ..."
          ]
        },
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        },
        {
          "title": "Literal expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/literal-expr.html",
          "excerpts": [
            "A literal expression is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it ..."
          ]
        },
        {
          "title": "Operator expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/operator-expr.html",
          "excerpts": [
            "Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in std::ops or std::cmp."
          ]
        },
        {
          "title": "Managing Growing Projects with Packages, Crates, and ...",
          "url": "https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html",
          "excerpts": [
            "Packages: A Cargo feature that lets you build, test, and share crates Â· Crates: A tree of modules that produces a library or executable Â· Modules and use: Let you ..."
          ]
        },
        {
          "title": "The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/",
          "excerpts": [
            "In this guide, we'll discuss: What editions are; Which changes are contained in each edition; How to migrate your code from one edition to another.",
            "How to migrate your code from one edition to another",
            "Which changes are contained in each edition",
            "What editions are"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "Show Railroad",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) .",
            "Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in `rustc` .",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.",
            "It is an error to use the [RESERVED\\_RAW\\_IDENTIFIER](identifiers.html) token `r` in order to avoid confusion with the [WildcardPattern](patterns.html)",
            "RAW\\_IDENTIFIER](identifiers.html) â†’ r# [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) <sub>except `crate` , `self` , `super` , `Self`</su",
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)"
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```",
            " `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers.",
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\""
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "* [strict]()\n* [reserved]()\n* [weak]()\n",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "KW\\_RAW : `raw",
            "KW\\_SAFE : `safe",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_UNION : `union",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "KW\\_DYN : `dyn",
            "KW\\_AWAIT : `await",
            "KW\\_ASYNC : `async",
            "> **<sup>Lexer 2018+</sup>**",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "KW\\_WHILE : `while",
            "KW\\_USE : `use",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_TYPE : `type",
            "KW\\_TRUE : `true",
            "KW\\_TRAIT : `trait",
            "KW\\_SUPER : `super",
            "KW\\_STRUCT : `struct",
            "KW\\_STATIC : `static",
            "KW\\_SELFTYPE : `Self",
            "KW\\_SELFVALUE : `self",
            "KW\\_RETURN : `return",
            "KW\\_REF : `ref",
            "KW\\_PUB : `pub",
            "KW\\_MUT : `mut",
            "KW\\_MOVE : `move",
            "KW\\_MOD : `mod",
            "KW\\_MATCH : `match",
            "KW\\_LOOP : `loop",
            "KW\\_LET : `let",
            "KW\\_IN : `in",
            "KW\\_IMPL : `impl",
            "KW\\_IF : `if",
            "KW\\_FOR : `for",
            "KW\\_FN : `fn",
            "KW\\_FALSE : `false",
            "KW\\_EXTERN : `extern",
            "KW\\_ENUM : `enum",
            "KW\\_ELSE : `else",
            "KW\\_CRATE : `crate",
            "KW\\_CONTINUE : `continue",
            "KW\\_CONST : `const",
            "KW\\_BREAK : `break",
            "KW\\_AS : `as",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "weak",
            "reserved",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        },
        {
          "title": "C - Derivable Traits - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-03-derivable-traits.html",
          "excerpts": [
            "The derive attribute generates code that will implement a trait with its own default implementation on the type you've annotated with the derive syntax."
          ]
        },
        {
          "title": "Introduction - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/?search=edition",
          "excerpts": [
            "The edition of a package is specified in the Cargo.toml manifest , and individual targets can specify which edition they use. See the Edition Guide for more ..."
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to asynchronous programming in Rust. The provided `finegrained_field_value` is a list of keywords and concepts. The excerpts that are relevant are those that discuss or mention these concepts. For example, excerpts discussing the `Future` trait, `Stream` trait, `async`/`await` syntax, `Poll` enum, `Context`, `Waker`, `Pin`, `Unpin`, `async runtimes` like Tokio, async-std, and smol, executors, schedulers, I/O drivers, timeouts, cancellation, middleware, and specific crates like `tower`, `hyper`, `tonic`, `axum`, `actix-web`, `Rocket`, `glommio`, `io_uring`, `embassy`, `tokio-tungstenite`, `quinn`, `async-graphql`, and `tokio::select!` are directly relevant. Excerpts discussing `tokio::task::scope`, `backpressure`, `bounded channels`, `tokio::sync::mpsc`, `Semaphore`, `holding locks across .await`, `Send` and `'static` bounds, `async fn` in traits, `BoxFuture`, `sync-in-async`, `blocking in async`, and `tokio::spawn_blocking` are also relevant to the broader topic of asynchronous programming in Rust.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.5",
      "citations": [
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type.",
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc"
          ]
        }
      ],
      "reasoning": "The concept of blanket implementations is directly addressed by a passage that explicitly asks why blanket implementations for two different traits conflict, signaling that blanket implementations can lead to coherence concerns and potential conflicts when multiple traits are involved. This directly supports the idea that blanket implementations are a topic governed by rules about when and how they can be defined without causing conflicts.\n\nThe orphan rules and coherence discussion explain the broader constraints on trait implementations, including that implementations must respect locality and coherence to avoid conflicts across crates. This context is relevant because blanket implementations are a specific case within the larger framework of coherence and orphan rules; understanding these rules helps explain why blanket implementations may be restricted or cause conflicts when extending a type with multiple traits.\n\nThere is a direct note that two trait implementations can overlap when there is a non-empty intersection of the traits they implement, which is a concrete formulation of when blanket-style implementations might conflict or be problematic. This links the idea of blanket implementations to potential overlap issues and reinforces why such patterns are subject to coherence checks.\n\nTogether, these excerpts form a coherent view: blanket implementations are subject to coherence/orphan rules to avoid conflicts and overlaps, and explicit discussions of conflicts and overlap checks illuminate the precise constraints that govern when blanket implementations are permissible.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.0",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_TRAIT : `trait"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible"
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime"
          ]
        }
      ],
      "reasoning": "The most directly relevant material is a source that explicitly identifies the trait keyword and provides its orthography and context, such as the Rust Reference page dedicated to keywords where the trait token is shown verbatim. Following that, sources that discuss how traits are defined and implementedâ€”such as how traits are implemented for specific types via separate implementations and how generic traits can be parameterizedâ€”directly tie to the core meaning and usage of trait in Rust. Additional sources that explore trait objects and the general role of traits in Rustâ€™s type system further reinforce understanding of what a trait is and how it is used in practice. Partial but useful context comes from materials addressing trait-related constructs like associated items within traits, or how trait keywords interact with references and object safety, which helps connect the keyword to its broader semantics. Collectively, these excerpts provide a coherent set of trait-centered references that support the finegrained field value being the trait keyword. The strongest support comes from explicit, title-level mentions of traits and trait-related content, while the later items extend understanding via related trait concepts (trait objects, associated items, and generic trait discussions).",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.7",
      "citations": [
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        }
      ],
      "reasoning": "To support the field value, the most direct evidence is a statement that 'Common iterator adapters include map, take, and filter.' This explicitly lists 'filter' as one of the standard iterator adapters, aligning precisely with the idea of a keyword or concept to be cataloged under functional programming keywords in Rust. The surrounding context confirms this is about iterator adapters, which further clarifies that 'filter' is a concrete example of a concept to be included in the research list. Other excerpts discuss iterators, lazy evaluation, and adapters in general, which provide useful background but do not establish the specific existence or role of the 'filter' concept beyond the explicit mention identified above.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.6",
      "citations": [
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "# [Chalk: Orphan Check]()"
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must "
          ]
        }
      ],
      "reasoning": "The fine-grained field value is trait coherence, which relates to how the Rust trait system ensures that trait implementations are unambiguous and do not lead to conflicting or overlapping implementations across crates. The most directly relevant information comes from excerpts that explicitly define and discuss coherence and its related checks. For example, a resource describing coherence introduces the concept of coherence in the trait system and outlines the goal of having a coherent set of trait implementations, including how orphan rules and world compatibility affect coherence. Additional excerpts expand on how the orphan check enforces coherence by ensuring trait implementations are unique to a crate and by describing checks that detect overlapping implementations, which are exactly the kinds of constraints coherence enforces. Further supporting evidence comes from a detailed treatment of how the orphan rules and local vs. upstream crate distinctions interact with coherence to guarantee a well-defined, non-ambiguous set of implementations. Taken together, these excerpts provide a clear, multi-faceted explanation of trait coherence, its motivation, and the mechanisms that enforce it, which aligns closely with the requested fine-grained field value. ",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.4",
      "citations": [
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        }
      ],
      "reasoning": "The most directly relevant content explicitly stating the concept is trait bounds and their role in generics and Rustâ€™s trait system. The excerpt titled Rust Reference - Trait Bounds states that bounds on an item must be satisfied when using the item, which directly defines the purpose of trait bounds in enforcing constraints. Excerpts discussing supertraits and associated type bounds (where Self::B: Copy, trait A: Shape, etc.) further illuminate how trait bounds appear in various forms and contexts. Excerpts describing where and how bounds can be expressed, including where clauses and the relationship between bounds and generic parameters, provide complementary contextual information on the syntax and usage of trait bounds in Rust. Additionally, an excerpt about bounds on an item being satisfied when used, and another explaining equivalent forms of specifying bounds (e.g., after a generic parameter or in a where clause) reinforce the core meaning of trait bounds as constraints that govern what types can be used with a given trait or generic item. Collectively, these excerpts support the understanding that trait bounds are constraints placed on generics and trait implementations to ensure correctness and coherence in Rust's type system.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.1",
      "citations": [
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`)."
          ]
        }
      ],
      "reasoning": "The target finegrained field value refers to the exact Rust syntax 'impl Trait', which is a specific construction used in function return types or in generic contexts. Among the provided excerpts, the most direct and relevant content is a statement describing a constraint: a function return type must not use an 'impl Trait' form. This explicitly mentions the concept of 'impl Trait' in the context of function return types, which is precisely the type of information implied by the field value. The excerpt thus directly supports understanding where and how 'impl Trait' can appear (or be restricted) in Rust signatures, making it the strongest and most relevant piece of evidence for the field.",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.7",
      "citations": [
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must "
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [The Orphan Rules]()",
            "# [Chalk: Orphan Check]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types"
          ]
        }
      ],
      "reasoning": "The most relevant excerpts directly state or exemplify the orphan rules themselves: one excerpt defines the orphan rule as a constraint that a trait implementation is allowed only if the trait or at least one of the types in the implementation is defined in the current crate, which is the core idea of orphan rules and central to coherence. Another excerpt lists the specific conditions that must be met for an impl to be valid (e.g., the trait is local, or a local type is involved), which directly supports understanding how orphan rules govern trait implementations. An example excerpt discusses that the orphan rule prevents conflicting trait implementations across crates and is key to coherence, reinforcing the purpose of the rules. Additional excerpts introduce the orphan check and its role in enforcing these rules within rustc, further grounding the concept in practice. Surrounding coherence-focused excerpts provide helpful background on how orphan rules interact with broader trait-implementation coherence, without diluting the focus on the orphan-rule content itself.\n",
      "confidence": "high"
    },
    {
      "field": "traits_and_generics_keywords.2",
      "citations": [
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        }
      ],
      "reasoning": "The field value refers to the syntax and concept of a trait object written with the dyn keyword, i.e., dyn Trait. Several excerpts directly define or describe trait objects and how dyn is used to express them. For example, one excerpt states that trait objects are written as the keyword dyn followed by a set of trait bounds, and another explains that trait objects are used behind pointers like &dyn SomeTrait or Box<dyn SomeTrait>, highlighting the syntactic form and its usage. Additional excerpts describe that a trait object permits late binding of methods and that calling a method on a trait object results in dynamic dispatch at runtime, which are essential characteristics of dyn Trait in Rust. Another excerpt explains that a trait object is an opaque value that implements a set of traits, which aligns with the concept of dyn Trait as a dynamic, bounds-based object. Collectively, these excerpts directly support the finegrained field value by: (1) defining the dyn Trait syntax and its placement after dyn, (2) illustrating common forms using references or boxes (e.g., &dyn Trait, Box<dyn Trait>), (3) describing the dynamic dispatch behavior and method binding semantics that dyn Trait enables, and (4) framing trait objects as opaque or dynamic constructs. Additional excerpts discuss related topics like trait upcasting and upcasting to supertraits, which, while not defining dyn Trait itself, provide context on how trait objects interact with trait hierarchies and dynamic coercions in Rust.",
      "confidence": "high"
    },
    {
      "field": "functional_programming_keywords.5",
      "citations": [
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "pub trait Iterator {",
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "uses up the iterator. One example is the `sum` method, which takes ownership of"
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        }
      ],
      "reasoning": "Fold is a higher-order operation that reduces an iterator to a single accumulated value by applying a function repeatedly. The most foundational support comes from excerpts that define the core Iterator trait and its essential method next, since any fold implementation relies on repeatedly pulling items from an iterator. Excerpts that emphasize that iterators are lazy and only produce values when consumed provide essential context for how and when a fold would actually execute. Content that notes that iterators implement the Iterator trait reinforces that fold is a standard operation on such a trait. Additionally, discussions about consuming adapters and concrete examples like sum illustrate how reduction-like patterns work in practice, which is closely aligned with the conceptual role of fold. Finally, general mentions of common iterator adapters (map, take, filter) provide peripheral context about the ecosystem of iterator operations, but do not directly address reduction semantics. Together these excerpts support understanding how a fold operation would fit into the Rust iterator model, even though the exact term \"fold\" is not present.",
      "confidence": "low"
    },
    {
      "field": "collections_and_data_structures_keywords.0.category",
      "citations": [
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        }
      ],
      "reasoning": "The finegrained field value indicates the rank/category of Rust standard library collections that are sequential/ordered, i.e., the standard sequential collections. Excerpts that explicitly describe the organization of Rust collections into categories and identify sequences such as Vec, VecDeque, and LinkedList as the sequence category directly support this value. One excerpt outlines the four major categories of Rust collections and explicitly lists Sequences as including Vec, VecDeque, and LinkedList, which aligns with the concept of a Standard Sequential category. Another excerpt describes the Rust Standard Library Collections page and begins with the groupings including Sequences and then names Vec, VecDeque, and LinkedList as part of that Sequences category, reinforcing the notion of standard sequential collections. Additional excerpts delve into the properties of a Vec, a quintessential standard sequential container: contiguous storage, O(1) indexing, and amortized push behavior, which further corroborates the idea of a standard sequential data structure. Further, a focused discussion on Vec provides concrete operational characteristics (no allocator calls when emptying and refallocations when capacity is exceeded) that illustrate typical sequential container behavior in Rust. Less directly related excerpts cover other collection categories (e.g., maps such as HashMap or BTreeMap) which are not about sequential containers and thus contribute weaker relevance to the specific field value, but they help delineate the broader collection taxonomy. Overall, the strongest support comes from the explicit categorization of sequences and the identification of Vec/VecDeque/LinkedList as standard sequential containers, with progressively narrower support from specifics about Vec behavior and implementation details.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.0.underlying_structure",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements "
          ]
        }
      ],
      "reasoning": "The target field seeks the description of the Vec's underlying structure. The excerpt describing Vec explicitly notes that its underlying structure is a contiguous array that can grow. This matches the finegrained field value, which identifies the underlying structure as a contiguous growable array. Other excerpts discuss time complexities, memory overhead, or categorize collections without providing the explicit underlying-structure description, so they are less directly supportive of the exact field value.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.1.underlying_structure",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        }
      ],
      "reasoning": "The field value asserts that a HashMap uses a Hash table with open addressing. The excerpt discussing the HashMap explicitly states: 'Underlying structure: Hash table with open addressing (or bucketed chaining)'. This directly confirms the specific underlying structure. Other excerpts mention performance metrics and list collection types, but they do not specify the underlying storage mechanism, so they provide only contextual support rather than direct evidence.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.0.collection_name",
      "citations": [
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements "
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt presents explicit details about Vec itself in Rust. It describes Vec as a contiguous array that can grow and outlines time complexities such as indexing being O(1) and amortized push at the end being O(1), which directly supports the notion of the field value being the Vec collection name and its core properties. The second excerpt provides precise statements about Vec behavior, including capacity-based allocation and memory considerations for push and insert operations, further reinforcing the exact collection type in question. The third excerpt presents a broader Rust collections overview that includes Vec among the sequences category, which confirms Vecâ€™s role within the standard library's collection ecosystem but with less direct operational detail. The fourth excerpt lists Rust standard library collections and explicitly includes Vec in a categorized context, reinforcing its presence as a primary collection type within the Rust ecosystem, though it bundles multiple collections together in a performance discussion. Taken together, these excerpts collectively validate that the field value corresponds to Vec and provide both explicit Vec-specific details and contextual placement within Rust collections.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.0.use_cases",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The fine-grained field value centers on dynamic array usage as a stack. A top-relevant excerpt directly describes Vec usage: it states that pushing at the end is an amortized O(1) operation, which is a quintessential property that makes a dynamic array an attractive stack implementation. This excerpt also notes that indexing is O(1) and that push operations typically do not reallocate unless capacity is exhausted, which aligns with common stack usage patterns where elements are pushed and popped efficiently within capacity. A closely related excerpt expands on capacity semantics and allocation behavior for Vec, explaining that push and insert will not reallocate if capacity is sufficient, and that reallocation may occur when len equals capacity, which is a critical consideration when modeling a stack with a dynamic array. Additional excerpts provide broader context about Vec as a core dynamic array in Rust, including its role among standard library collections and general performance characteristics, which supports understanding why a dynamic array is commonly used for stack-like use cases. While other excerpts discuss collections in general or other data structures, they still help situate Vec within Rustâ€™s collection ecosystem and reinforce the practical implications of using a dynamic array for stack-style workloads (e.g., push at end, growth behavior, and memory considerations).",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.1.collection_name",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The finegrained field value identifies a standard library map type by name. A direct description of HashMap is found in the first excerpt, which discusses HashMap as a hash table with open addressing (or bucketed chaining) and provides time complexity characteristics for insert, remove, and lookup operations, along with memory considerations. This directly supports the notion of HashMap as a map data structure in Rust and clarifies its core implementation details. The second excerpt contributes further by enumerating performance metrics for various collection operations and explicitly includes HashMap within the performance table, reinforcing HashMapâ€™s role as a map in Rustâ€™s collection ecosystem. The third excerpt lists HashMap under the maps category of Rust's standard library collections, establishing HashMap as one of the canonical map types alongside other map implementations like BTreeMap. Taken together, these excerpts collectively confirm HashMap as a key Rust collection type and provide essential characteristics (structure, performance, and placement within the library).",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.1.use_cases",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The most directly relevant information comes from excerpts that describe a map-like collection with fast lookups. A discussion of HashMap highlights its underlying hash-table structure and amortized O(1) insert, remove, and lookup operations, which aligns with the requirement of efficient random access to values by key. An accompanying table of costs for various collections shows HashMap achieving O(1) lookups and insertions, reinforcing its suitability for key-value storage with fast access. A broader categorization of Rust standard library collections explicitly places HashMap (and BTreeMap) in the Maps category, further supporting their role as key-value storage options. Together, these excerpts directly support the idea that a key-value data storage with efficient random access is best modeled by hash-based maps (HashMap) and, in some contexts, ordered maps (BTreeMap).",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.0.performance_characteristics",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements "
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The most directly relevant information connects the idea of appending to the end of a collection with constant-time behavior, and removal at arbitrary positions with linear-time behavior. One excerpt explicitly states that pushing at the end is amortized O(1), which aligns with the O(1) append portion of the target field value. It also notes that insert/remove at arbitrary positions is O(n), which matches the O(n) random removal portion of the field value. The other excerpts provide corroborating context about the general performance characteristics of Rustâ€™s collection types, such as the categorization of collections (Vec, VecDeque, LinkedList, HashMap, BTreeMap) and their relative performance profiles, which helps situate the exact O(1) append and O(n) removal within the broader landscape, but they do not state the precise pair as clearly. Taken together, these excerpts support the requested performance pair and place it within the Rust collectionsâ€™ performance narrative.",
      "confidence": "high"
    },
    {
      "field": "collections_and_data_structures_keywords.1.performance_characteristics",
      "citations": [
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")"
          ]
        }
      ],
      "reasoning": "The target field value captures a standard performance claim for collections: lookup operations are typically constant time on average (amortized) but can degrade to linear time in worst-case scenarios (e.g., due to hash collisions or pathological inputs). The excerpt describing a HashMap notes: 'Insert/remove/lookup: Amortized O(1); Worst-case (pathological hash collisions): O(n)'. This directly matches the required performance pattern. The performance table excerpt reinforces this theme by listing per-structure operation costs, with several entries marked as O(1) for common get/insert/remove operations, and it highlights that some operations can degenerate based on structure and circumstances, aligning with the concept of a worst-case O(n). The grouping excerpt provides broader context about major collection categories (Sequences, Maps, Sets, etc.), which supports understanding where these performance characteristics apply but is less specific to the exact O(1)/O(n) dichotomy. Taken together, the most direct evidence is the explicit amortized O(1) and worst-case O(n) statement, supported by the per-operation timing details and the general categorization for context.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.4",
      "citations": [
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        }
      ],
      "reasoning": "The field value Poll::Ready corresponds to the moment a polled future has completed and produced a final value. An excerpt from the Rust async guidance explicitly ties the await expression to a readiness outcome by referencing the Poll::Ready variant in the flow of poll-driven progression. Another excerpt describes the exact mechanism: a pinned future is polled by the Future::poll method, which is the operation that advances the state machine toward readiness. A further excerpt discusses the polling result where a pending state (Poll::Pending) causes suspension and re-polling later, which is the counterpart behavior youâ€™d expect when Poll::Ready is eventually reached. Taken together, these excerpts directly illustrate how the poll mechanism can yield Poll::Ready as the final, ready-to-use state of a future, supporting the field value in the given path.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.3",
      "citations": [
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")"
          ]
        }
      ],
      "reasoning": "The most relevant information comes from statements that identify poll as the core method of a Future and describe its behavior: that the poll method is used to drive the future to a final value and that it does not block, with the system waking the task when progress is possible. This directly aligns with the field value describing the poll method in asynchronous programming. Additional high relevance comes from passages that describe the lifecycle and outcomes of poll, such as returning Poll::Ready or Poll::Pending, which clarifies how the poll-based model progresses and suspends. Context about awaiting the value is closely linked, since awaiting is the higher-level construct that abstracts over manual polling, yet it relies on the underlying poll mechanism being driven by the executor. Finally, there are excerpts that discuss awaiting and the relationship to poll, which provide useful context but are slightly less directly about the poll method itself. Taken together, these excerpts provide direct assertions about the poll methodâ€™s role, how it advances futures, and what outcomes it yields, which supports the finegrained field value. Specifically, the parts quoted below describe: the core method poll used to resolve a future into a final value; that poll does not block but rather schedules the task to wake up; and the semantics around Poll::Ready and Poll::Pending as the progression signals. \n",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.5",
      "citations": [
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;",
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;"
          ]
        },
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet."
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ...",
            "This is mostly useful for writing tests that need a Context to poll some futures, but are not expecting those futures to wake the waker or do not need to doÂ ..."
          ]
        }
      ],
      "reasoning": "- A passage explicitly stating the scenario when a futures poll yields a Pending result matches the finegrained field value, showing that when the poll call returns Poll::Pending, the future reports Pending and the surrounding async context will re-poll later. This provides a direct link to the field value in question. - Additional passages describe how futures are driven by awaiting the value and the general polling process, which helps establish the surrounding mechanism leading to a Pending state, though they do not mention the exact Pending token. - Some excerpts discuss the broader flow of future polling and awaiting, reinforcing the context in which Poll::Pending occurs (i.e., the asynchronous execution model and waking up later). - A nearby excerpt describes that awaiting a poll result yields a final value when the poll is Ready, which complements the Pending description by contrasting the two possible outcomes. - Other related lines expand on how futures are scheduled and resumed, which helps connect the idea of Pending to the re-polling cycle, though they are slightly less direct than the explicit mention of Poll::Pending. - A few general references to Future and await semantics provide context but do not address the Pending state specifically, making them less central to the finegrained field value, though still relevant for overall understanding.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.7",
      "citations": [
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ...",
            "This is mostly useful for writing tests that need a Context to poll some futures, but are not expecting those futures to wake the waker or do not need to doÂ ..."
          ]
        }
      ],
      "reasoning": "The most relevant information comes from excerpts that explicitly describe the Waker as part of the async task lifecycle. One excerpt explains that the Waker is constructed by an executor, wrapped in a Context, and passed to Future::poll, which is central to how asynchronous tasks are driven forward. This directly ties the concept of a Waker to waking or scheduling the task, which is the core meaning of the field value. The nearby excerpts likewise discuss the relationship between polling a future, the wake-up mechanism, and the executorâ€™s role in waking the task, reinforcing the connection to Waker. These interpretations align closely with the field value, as they are both about the mechanism by which asynchronous tasks are notified to resume work. Other excerpts discuss futures, awaiting, and general async patterns but do not specifically mention the Waker, so they are considered less directly supportive.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.1",
      "citations": [
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        }
      ],
      "reasoning": "The key fine-grained field value is the Future trait, which is central to Rustâ€™s asynchronous programming model. The most directly relevant excerpts establish the core concept: a Future represents an asynchronous computation and the trait itself is the mechanism by which that computation is described and polled. Specifically, one excerpt states that a future represents an asynchronous computation and is obtained via the async keyword, which is the foundational description of what futures are and how they arise in Rust. Another excerpt explains the core method of a future, poll, and clarifies that poll does not block and instead schedules the task to be woken when progress is possible, which is essential to understanding how the Future trait is used at runtime. A third excerpt notes that futures are typically not polled directly but are awaited, tying the Future trait to the await syntax used to drive asynchronous code. Additional excerpts then cover how a future is evaluated by the runtime: the pinned future is polled through Future::poll, and the result is driven through await when it resolves, which further grounds the Future trait in the mechanism of asynchronous execution. Additional content mentions asynchronous runtimes and practical implications, such as async patterns and comparing runtimes, which expands context around how futures are executed in practice. Finally, several excerpts discuss how awaiting, blocking, and scheduling interact with futures, reinforcing the relationship between the Future trait and the asynchronous workflow in Rust. In sum, the most relevant excerpts directly define and describe the Future trait, its polling mechanism, and how async/await integrates with it, providing coherent support for the fine-grained field value. The less direct items (e.g., async runtimes or crate-level discussions) still underpin the broader async ecosystem and corroborate how the Future trait functions within that ecosystem.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.10",
      "citations": [
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")"
          ]
        },
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again."
          ]
        }
      ],
      "reasoning": "The most relevant content directly references pinning using the Pin type. The excerpt explicitly shows how to Pin a value by calling Pin::new_unchecked, which is the closest alignment to discussing a pinning mechanism in Rust and relates to the concept the pin! macro would be associated with in async contexts. The other excerpts discuss asynchronous futures and awaiting/polling semantics, which are thematically tied to asynchronous programming but do not directly address the pinning mechanism or a pin-related macro. They provide necessary background about how futures are driven (e.g., using await, poll, and context), which helps situate the pinning pattern within the larger async workflow, even though they donâ€™t mention the pin! macro itself. Overall, the sequence prioritizes direct pinning references first, followed by broader async context that is tangentially related to how pinned values interact with async executors.",
      "confidence": "low"
    },
    {
      "field": "asynchronous_programming_keywords.0",
      "citations": [
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "More specifically, an await expression has the following effect. 1. Create a future by calling [`IntoFuture::into_future`](../../core/future/into_future/trait.IntoFuture.html.into_future) on the future operand. 2. Evaluate the future to a [future](../../core/future/future/trait.Future.html) `tmp` ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        },
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        },
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ...",
            "This is mostly useful for writing tests that need a Context to poll some futures, but are not expecting those futures to wake the waker or do not need to doÂ ..."
          ]
        },
        {
          "title": "Rust Concurrency: Atomic Explained",
          "url": "https://leapcell.medium.com/rust-concurrency-atomic-explained-a89923ea61fd",
          "excerpts": [
            "```\npub enum Ordering {  \n    Relaxed,  \n    Release,  \n    Acquire,  \n    AcqRel,  \n    SeqCst,  \n}\n```",
            "```\npub fn fetch_add(&self, val: i32, order: Ordering) -> i32 - Performs addition (or subtraction) on the atomic type  \npub fn compare_and_swap(&self, current: i32, new: i32, order: Ordering) -> i32 - CAS (deprecated in Rust 1.50, replaced by compare_exchange)  \npub fn compare_exchange(&self, current: i32, new: i32, success: Ordering, failure: Ordering) -> Result<i32, i32> - CAS  \npub fn load(&self, order: Ordering) -> i32 - Reads the value from the atomic type  \npub fn store(&self, val: i32, order: Ordering) - Writes a value to the atomic type  \npub fn swap(&self, val: i32, order: Ordering) -> i32 - Swaps values\n```",
            "```\nAtomicBool  \nAtomicI8  \nAtomicI16  \nAtomicI32  \nAtomicI64  \nAtomicIsize  \nAtomicPtr  \nAtomicU8  \nAtomicU16  \nAtomicU32  \nAtomicU64  \nAtomicUsize\n```",
            "The documentation for this module describes atomic types as follows: Atomic types in Rust provide primitive shared-memory communication between threads and serve as the foundation for building other concurrency types. The `std::sync::atomic` module currently offers the following 12 atomic types:"
          ]
        },
        {
          "title": "Builder in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Builder.html",
          "excerpts": [
            "Spawns a new scoped thread using the settings set through this Builder . Unlike Scope::spawn , this method yields an io::Result to capture any failure to create ..."
          ]
        },
        {
          "title": "Scope in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Scope.html",
          "excerpts": [
            "Spawns a new thread within a scope, returning a ScopedJoinHandle for it. Unlike non-scoped threads, threads spawned with this function may borrow non- 'static ..."
          ]
        },
        {
          "title": "sync_channel in std::sync::mpsc",
          "url": "https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html",
          "excerpts": [
            "Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent."
          ]
        },
        {
          "title": "std::sync",
          "url": "https://doc.rust-lang.org/std/sync/",
          "excerpts": [
            "A BarrierWaitResult is returned by Barrier::wait() when all threads in the Barrier have rendezvoused. Condvar: A Condition Variable; LazyLock: A value which isÂ ..."
          ]
        },
        {
          "title": "Rust std::sync::atomic - Atomic types",
          "url": "https://doc.rust-lang.org/std/sync/atomic/",
          "excerpts": [
            "Atomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes."
          ]
        },
        {
          "title": "Crossbeam-channel Documentation",
          "url": "http://docs.rs/crossbeam-channel/latest/crossbeam_channel",
          "excerpts": [
            "Extra channels",
            "Selection",
            "Iteration",
            "Blocking operations",
            "Disconnection",
            "Sharing channels",
            "Creating an unbounded channel:",
            "Creating a bounded channel:",
            "Channels can be created using two functions:",
            "This crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.",
            "Multi-producer multi-consumer channels for message passing."
          ]
        },
        {
          "title": "Epoch-based memory reclamation.",
          "url": "http://docs.rs/crossbeam-epoch/latest/crossbeam_epoch",
          "excerpts": [
            "-------\n\nObjects that get removed from concurrent collections must be stashed away until all currently\npinned participants get unpinned. ",
            "\n:   Pins the current thread.\n",
            "Atomic\")\n:   An atomic pointer that can be safely shared between thre",
            "). If you\nwant to create your own garbage collector, use the [`Collector",
            "For majority of use cases, just use the default garbage collector by invoking [`pi",
            "Anyhow, memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "That is the general mechanism behind epoch-based memory reclamation, but the details are a bit\nmore complicated.",
            "Every time a thread accesses a collection, it checks the current\nepoch, attempts to increment it, and destructs some garbage that became so old that no thread\ncan be referencing it anymore.",
            "When an\nelement gets removed from a concurrent collection, it is inserted into a pile of garbage and\nmarked with the current epoch.",
            "crossbeam\\_epoch - Rus",
            "Epoch-based memory reclamation.",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs."
          ]
        },
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "These data structures are most commonly used in work-stealing schedulers.",
            "Summary",
            "3. Try stealing one task from another thread using the stealer list.",
            "2. Try stealing a batch of tasks from the global injector queue.",
            "1. Try popping one task from the local worker queue.",
            "Suppose a thread in a work-stealing scheduler is idle and looking for the next task to run. To\nfind an available task, it might do the following:",
            "\n\nAn implementation of this work-stealing strategy:",
            "3. [`steal_batch_and_pop()`](struct.Stealer.html.steal_batch_and_pop \"method crossbeam_deque::Stealer::steal_batch_and_pop\") - Steals a batch of tasks, moves them into another queue, and pops\n   one task from that worker.",
            "2. [`steal_batch()`](struct.Stealer.html.steal_batch \"method crossbeam_deque::Stealer::steal_batch\") - Steals a batch of tasks and moves them into another worker.",
            "1. [`steal()`](struct.Stealer.html.steal \"method crossbeam_deque::Stealer::steal\") - Steals one task.",
            "Steal operations come in three flavors:",
            "Method [`stealer()`](struct.Worker.html.stealer \"method crossbeam_deque::Worker::stealer\") creates a [`Stealer`](struct.Stealer.html \"struct crossbeam_deque::Stealer\") that may be shared among threads and can only steal\ntasks from its [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\"). Tasks are stolen from the end opposite to where they get pushed.",
            "Each [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\") is owned by a single thread and supports only push and pop operations.",
            "* [`new_lifo()`](struct.Worker.html.new_lifo \"associated function crossbeam_deque::Worker::new_lifo\") - Creates a LIFO queue, in which tasks are pushed and popped from the same\n  end.",
            "* [`new_fifo()`](struct.Worker.html.new_fifo \"associated function crossbeam_deque::Worker::new_fifo\") - Creates a FIFO queue, in which tasks are pushed and popped from opposite\n  ends.",
            "Worker\") has two constructors:",
            "[`Injector`](struct.Injector.html \"struct crossbeam_deque::Injector\") is a FIFO queue, where tasks are pushed and stolen from opposite ends.",
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            ".\n\nThese data structures are most commonly used in work-stealing schedulers. The typical setup\ninvolves a number of threads, each having its own FIFO or LIFO queue (*worker*). There is also\none global FIFO queue (*injector*) and a list of references to *worker* queues that are able to\nsteal tasks (*stealers*).",
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Ergonomic**: Powerful `select`-like interface",
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Simple**: Few dependencies, minimal codebase, fast to compile",
            "* **Capable**: Additional features like MPMC support and send timeouts/deadlines",
            "* **Familiar**: Drop-in replacement for `std::sync::mpsc`",
            "* **Flexible**: `Sender` and `Receiver` both implement `Send + Sync + Clone`",
            "* **Safe**: No `unsafe` code anywhere in the codebase!",
            "* **Fast**: Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`",
            "* **Featureful**: Unbounded, bounded and rendezvous queues",
            "\nSummary[Source](../src/flume/lib.rs.html)\n\nExpand description\n\n[Â§]()Flume\n----------------\n\nA blazingly fast multi-producer, multi-consumer channel.",
            "A blazingly fast multi-producer, multi-consumer channel.",
            "Flume\nflume - Rust"
          ]
        },
        {
          "title": "scope in std::thread - Rust",
          "url": "http://doc.rust-lang.org/std/thread/fn.scope.html",
          "excerpts": [
            "\nAll threads spawned within the scope that havenâ€™t been manually joined\nwill be automatically joined before this function returns.",
            "\nUnlike non-scoped threads, scoped threads can borrow non- `'static` data,\nas the scope guarantees all threads will be joined at the end of the scope.",
            "\nThe function passed to `scope` will be provided a [`Scope`](struct.Scope.html \"struct std::thread::Scope\") object,\nthrough which scoped threads can be [spawned](struct.Scope.html.spawn \"method std::thread::Scope::spawn\") .",
            "Creates a scope for spawning scoped threads."
          ]
        },
        {
          "title": "Welcome to Concurrency in Rust",
          "url": "https://google.github.io/comprehensive-rust/concurrency/welcome.html",
          "excerpts": [
            "Rust has full support for concurrency using OS threads with mutexes and channels. The Rust type system plays an important role in making many concurrency bugs ..."
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`",
            "ts\n\nTest cases using loom must be fully deterministic. All sources of non-determism must be via loom\ntypes so that loom can expose different possible values on each execution of the test closure.",
            "Loom provides a way to deterministically explore the various possible execution permutations\nwithout relying on random executions. This allows you to write tests that verify that your\nconcurrent code is correct under _all_ executions, not just â€œmost of the time",
            "\nLoom is a tool for testing concurrent programs. At a high level, it runs tests many times, permuting the possible concurrent executions of each\ntest according to what constitutes valid executions under the [C11 memory model]"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "hand, `fence(SeqCst)` is supported.",
            "synchronization, causing Loom to generate false alarms (not complete). See [](https://github.com/tokio-rs/loom/issues/180) for example. On the other",
            "They are regarded as `AcqRel` . That is, they impose weaker",
            "* `SeqCst` accesses (e.g. `load` , `store` , ..):",
            "Loom currently does not implement the full C11 memory model. Here is the (incomplete) list of unsupported features.",
            "assert_eq ! ( 2 , num . load ( Relaxed ) ) ;",
            "th . join ( ) . unwrap ( ) ;",
            "for th in ths {",
            ". collect ( ) ;",
            "} )",
            "} )",
            "num . store ( curr + 1 , Release ) ;",
            "let curr = num . load ( Acquire ) ;",
            "thread :: spawn ( move || {",
            "clone ( ) ;",
            "let num = num .",
            ". map ( |_| {",
            "let ths : Vec < _ > = ( 0 .. 2 )",
            "let num = Arc :: new ( AtomicUsize :: new ( 0 ) ) ;",
            "use loom :: thread ;",
            "use loom :: sync :: atomic :: Ordering :: { Acquire , Release , Relaxed } ;",
            "use loom :: sync :: atomic :: AtomicUsize ;",
            "use loom :: sync :: Arc ;",
            "Loom is a testing tool for concurrent Rust code. It runs a test many\ntimes, permuting the possible concurrent executions of that test under\nthe [C11 memory model](https://en.cppreference.com/w/cpp/atomic/memory_order) .",
            "}"
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "\npull requests, and feedback. ",
            "Crossbeam welcomes contribution from everyone in the form of suggestions, bug reports,",
            "------------",
            "Contributing",
            "version is released. Currently, the minimum supported Rust version is 1.61.",
            "and every time the minimum supported Rust version is increased, a new minor",
            "Crossbeam supports stable Rust releases going back at least six months,",
            "-------------",
            "Compatibility",
            "```\n[dependencies]\ncrossbeam = \"0.8\"\n```",
            "Add this to your `Cargo.toml`:",
            "-----",
            "Usage",
            "* [`crossbeam-skiplist`](/crossbeam-rs/crossbeam/blob/master/crossbeam-skiplist)\n  provides concurrent maps and sets based on lock-free skip lists",
            "There is one more experimental subcrate that is not yet included in `crossbeam`:",
            "* [`crossbeam-utils`](/crossbeam-rs/crossbeam/blob/master/crossbeam-utils)\n  provides atomics, synchronization primitives, scoped threads, and other utilities",
            "* [`crossbeam-queue`](/crossbeam-rs/crossbeam/blob/master/crossbeam-queue)\n  provides concurrent queues that can be shared among threads",
            "* [`crossbeam-epoch`](/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch)\n  provides epoch-based garbage collection for building concurrent data structures",
            "* [`crossbeam-deque`](/crossbeam-rs/crossbeam/blob/master/crossbeam-deque)\n  provides work-stealing deques, which are primarily intended for building task schedulers",
            "* [`crossbeam-channel`](/crossbeam-rs/crossbeam/blob/master/crossbeam-channel)\n  provides multi-producer multi-consumer channels for message passing",
            "The main `crossbeam` crate just [re-exports](/crossbeam-rs/crossbeam/blob/master/src/lib.rs) tools from\nsmaller subcrates:",
            "------",
            "crates",
            "*Features marked with (no\\_std) can be used in `no_std` environments.*  \n*Features marked with (alloc) can be used in `no_std` environments, but only if `alloc`\nfeature is enabled.",
            "* [`scope`](https://docs.rs/crossbeam/latest/crossbeam/fn.scope.html), for spawning threads that borrow local variables from the stack.",
            "* [`CachePadded`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.CachePadded.html), for padding and aligning a value to the length of a cache line.(no\\_std",
            "* [`Backoff`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.Backoff.html), for exponential backoff in spin loops.(no\\_std",
            "#### Utilities",
            "* [`WaitGroup`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.WaitGroup.html), for synchronizing the beginning or end of some computation.",
            "* [`ShardedLock`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.ShardedLock.html), a sharded reader-writer lock with fast concurrent reads.",
            "* [`Parker`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.Parker.html), a thread parking primitive.",
            "* [`channel`](https://docs.rs/crossbeam/latest/crossbeam/channel/index.html), multi-producer multi-consumer channels for message passing.",
            "#### Thread synchronization",
            "* [`epoch`](https://docs.rs/crossbeam/latest/crossbeam/epoch/index.html), an epoch-based garbage collector.(alloc)",
            "#### Memory management",
            "* [`SegQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.SegQueue.html), an unbounded MPMC queue that allocates small buffers, segments, on demand.(alloc)",
            "* [`ArrayQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.ArrayQueue.html), a bounded MPMC queue that allocates a fixed-capacity buffer on construction.(alloc)",
            "* [`deque`](https://docs.rs/crossbeam/latest/crossbeam/deque/index.html), work-stealing deques for building task schedulers.",
            "#### Data structures",
            "* [`AtomicConsume`](https://docs.rs/crossbeam/latest/crossbeam/atomic/trait.AtomicConsume.html), for reading from primitive atomic types with \"consume\" ordering.(no\\_std",
            "* [`AtomicCell`](https://docs.rs/crossbeam/latest/crossbeam/atomic/struct.AtomicCell.html), a thread-safe mutable memory location.(no\\_std",
            "#### Atomics"
          ]
        },
        {
          "title": "Mimalloc Rust",
          "url": "https://github.com/purpleprotocol/mimalloc_rust",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "cargo-fuzz 0.13.1",
          "url": "https://docs.rs/crate/cargo-fuzz/latest/source/README.md",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "rust-embedded/embedded-hal",
          "url": "https://github.com/rust-embedded/embedded-hal",
          "excerpts": [
            "crates"
          ]
        },
        {
          "title": "Crossbeam-channel (crossbeam-rs)",
          "url": "http://github.com/crossbeam-rs/crossbeam-channel",
          "excerpts": [
            "NOTE: This crate has been moved into the [crossbeam](https://github.com/crossbeam-rs/crossbeam) repository.",
            "This library is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/std/sync/mpsc/index.html) with more features and better performance.",
            "Multi-producer multi-consumer channels for message passing",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "parking_lot GitHub Repository",
          "url": "http://github.com/Amanieu/parking_lot",
          "excerpts": [
            "To enable nightly-only features, add this to your `Cargo.toml` instead:\n\n```\n[dependencies]\nparking_lot = { version = \"0.12\", features = [\"nightly\"] }\n```\n\nThe experimental deadlock detector can be enabled with the\n`deadlock_detection` Cargo feature.\n\nTo allow sending `MutexGuard`s and `RwLock*Guard`s to other threads, enable the\n`send_guard` option.\n\nNote that the `deadlock_detection` and `send_guard` features are incompatible\nand cannot be used together.\n\nHardware lock elision support for x86 can be enabled with the\n`hardware-lock-elision` feature. This requires Rust 1.59 due to the use of\ninline assembly.\n\nThe core parking lot API is provided by the `parking_lot_core` crate. It is\nseparate from the synchronization primitives in the `parking_lot` crate so that\nchanges to the core API do not cause breaking changes for users of `parking_lot`.",
            "Features\n--------\n\nThe primitives provided by this library have several advantages over those\nin the Rust standard library:\n\n1. `Mutex` and `Once` only require 1 byte of storage space, while `Condvar`\n   and `RwLock` only require 1 word of storage space. On the other hand on\n   some platforms (macOS and a few others) the standard library primitives\n   require a dynamically allocated `Box` to hold OS-specific synchronization\n   primitives. The small size of `Mutex` in particular encourages the use\n   of fine-grained locks to increase parallelism.\n2. Uncontended lock acquisition and release is done through fast inline\n   paths which only require a single atomic operation.\n3. Microcontention (a contended lock with a short critical section) is\n   efficiently handled by spinning a few times while trying to acquire a\n   lock.\n4. The locks are adaptive and will suspend a thread after a few failed spin\n   attempts. This makes the locks suitable for both long and short critical\n   sections.\n5. `Condvar`, `RwLock` and `Once` work on Windows XP, unlike the standard\n   library versions of those types.\n6. `RwLock` takes advantage of hardware lock elision on processors that\n   support it, which can lead to huge performance wins with many readers.\n   This must be enabled with the `hardware-lock-elision` feature.\n7. `RwLock` uses a task-fair locking policy, which avoids reader and writer\n   starvation, whereas the standard library version makes no guarantees.\n8. `Condvar` is guaranteed not to produce spurious wakeups. A thread will\n   only be woken up if it timed out or it was woken up by a notification.\n9. `Condvar::notify_all` will only wake up a single thread and requeue the\n   rest to wait on the associated `Mutex`. This avoids a thundering herd\n   problem where all threads try to acquire the lock at the same time.\n10. `RwLock` supports atomically downgrading a write lock into a read lock.\n11. `Mutex` and `RwLock` allow raw unlocking without a RAII guard object.\n12. `Mutex<()>` and `RwLock<()>` allow raw locking without a RAII guard\n    object.\n13. `Mutex` and `RwLock` support [eventual fairness](https://trac.webkit.org/changeset/203350)\n    which allows them to be fair on average without sacrificing performance.\n14. A `ReentrantMutex` type which supports recursive locking.\n15. An *experimental* deadlock detector that works for `Mutex`,\n    `RwLock` and `ReentrantMutex`. This feature is disabled by default and\n    can be enabled via the `deadlock_detection` feature.\n16. `RwLock` supports atomically upgrading an \"upgradable\" read lock into a\n    write lock.\n17. Optional support for [serde](https://docs.serde.rs/serde/). Enable via the\n    feature `serde`. **NOTE!** this support is for `Mutex`, `ReentrantMutex`,\n    and `RwLock` only; `Condvar` and `Once` are not currently supported.\n18. Lock guards can be sent to other threads when the `send_guard` feature is\n    enabled.\n\nThe parking lot\n---------------\n\nTo keep these primitives small, all thread queuing and suspending\nfunctionality is offloaded to the *parking lot*. The idea behind this is\nbased on the Webkit [`WTF::ParkingLot`](https://webkit.org/blog/6161/locking-in-webkit/)\nclass, which essentially consists of a hash table mapping of lock addresses\nto queues of parked (sleeping) threads. The Webkit parking lot was itself\ninspired by Linux [futexes](https://man7.org/linux/man-pages/man2/futex.2.html),\nbut it is more powerful since it allows invoking callbacks while holding a queue\nlock.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads. The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking. It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives."
          ]
        },
        {
          "title": "Epoch-based garbage collection",
          "url": "http://github.com/crossbeam-rs/crossbeam-epoch",
          "excerpts": [
            "The minimum required Rust version is 1.26.",
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "Rust std::thread Module",
          "url": "http://doc.rust-lang.org/std/thread/index.html",
          "excerpts": [
            "The [`join`](struct.JoinHandle.html.join \"method std::thread::JoinHandle::join\") method returns a [`thread::Result`](type.Result.html \"type std::thread::Result\") containing [`Ok`](../result/enum.Result.html.Ok \"variant std::result::Result::Ok\") of the final\nvalue produced by the spawned thread, or [`Err`](../result/enum.Result.html.Err \"variant std::result::Result::Err\") of the value given to\na call to [`panic!`](../macro.panic.html \"macro std::panic\") if the thread panicked.",
            "A new thread can be spawned using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function:\n\n```\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\nIn this example, the spawned thread is â€œdetached,â€ which means that there is\nno way for the program to learn when the spawned thread completes or otherwise\nterminates.",
            "When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nthread (i.e., join).",
            ".\n\nCommunication between threads can be done through\n[channels](../sync/mpsc/index.html \"mod std::sync::mpsc\"), Rustâ€™s message-passing types, along with [other forms of thread\nsynchronization](../../std/sync/index.html) and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\")."
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "rx.recv().unwrap();",
            "    tx.send(53).unwrap();",
            "    // This will wait for the parent thread to start receiving",
            "let (tx, rx) = sync_channel::<i32>(0);",
            "assert_eq!(rx.recv().unwrap(), 10);",
            "});",
            "});",
            "    tx.send(10).unwrap();",
            "thread::spawn(move || {",
            "thread::spawn(move || {",
            "let (tx, rx) = channel();",
            "```",
            "```",
            "```",
            "```",
            "An unsuccessful operation\nis normally indicative of the other half of a channel having â€œhung upâ€ by\nbeing dropped in its corresponding thread.",
            "The send and receive operations on channels will all return a [`Result`](../../result/enum.Result.html \"enum std::result::Result\")\nindicating whether the operation succeeded or not.",
            "2. \n   A synchronous, bounded channel. The [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync\\_channel\") function will\n   return a `(SyncSender, Receiver)` tuple where the storage for pending\n   messages is a pre-allocated buffer of a fixed size. All sends will be **synchronous** by blocking until there is buffer space available. Note\n   that a bound of 0 is allowed, causing the channel to become a â€œrendezvousâ€\n   channel where each sender atomically hands off a message to a",
            "1. \n   An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function\n   will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an\n   infinite b",
            "These channels come in two flavors:",
            "A [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") . Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).",
            "* [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")",
            "* [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\")",
            "* [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\")",
            "This module provides message-based communication over channels, concretely\ndefined among three types:",
            "std::sync::mpsc - Rust[![](../../../static.files/rust-logo-9a9549ea.svg)](../../../std/index.html)",
            "Multi-producer, single-consumer FIFO queue communication primitives."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "```",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n",
            "`Mutex`\nA mutual exclusion primitive useful for protecting shared data\n",
            "`LazyLock`\nA value which is initialized on the first access.\n",
            "`Condvar`\nA Condition Variable\n",
            "`Barrier`\nA barrier enables multiple threads to synchronize the beginning\n    of some computation.\n",
            "`Arc`\nA thread-safe reference-counting pointer. â€˜Arcâ€™ stands for â€˜Atomically\n    Reference Countedâ€™.\n",
            "Structs",
            "Modules",
            "`RwLock`\nProvides a mutual exclusion mechanism which allows\n  multiple readers at the same time, while allowing only one\n  writer at a time. In some cases, this can be more efficient than\n  a \n",
            "`LazyLock`\nUsed for thread-safe, one-time initialization of a\n  variable, using one nullary initializer function provided at creatio\n",
            "`OnceLock`\nUsed for thread-safe, one-time initialization of a\n  variable, with potentially different initializers based on the calle\n",
            "`Once`\nUsed for a thread-safe, one-time global initialization routine.\n  Mostly useful for implementing other types like `OnceLock\n",
            "`Mutex`\nMutual Exclusion mechanism, which ensures that at\n  most one thread at a time is able to access some dat\n",
            "`mpmc`\nMulti-producer, multi-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`mpsc`\nMulti-producer, single-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`Condvar`\nCondition Variable, providing the ability to block\n  a thread while waiting for an event to occu\n",
            "`Barrier`\nEnsures multiple threads will wait for each other\n  to reach a point in the program, before continuing execution all\n  toget\n",
            "`Arc`\nAtomically Reference-Counted pointer, which can be used\n  in multithreaded environments to prolong the lifetime of some\n  data until all the threads have finished using\n",
            "For efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating systemâ€™s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.",
            "These abstractions can be built out of lower-level primitives.",
            "Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.",
            "Higher-level synchronization objects",
            "[atomic operations](atomic/index.html \"mod std::sync::atomic\") to ensure simultaneous access to the same\n    memory location doesnâ€™t lead to undefined behavi",
            "[memory fences](atomic/fn.fence.html \"fn std::sync::atomic::fence\") to ensure memory accesses are made visible to\n    other CPUs in the right or",
            "A **multiprocessor** system executing multiple hardware threads\n  at the same time: In multi-threaded scenarios, you can use two\n  kinds of primitives to deal with synchronizat",
            "A **single processor** executing instructions [out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution):",
            "Use [compiler fences](atomic/fn.compiler_fence.html \"fn std::sync::atomic::compiler_fence\") to prevent this reordering.",
            "The **compiler** reordering instructions: If the compiler can issue an\n  instruction at an earlier point, it will try to do so. For example, it\n  might hoist memory loads at the top of a code block, so that the CPU can\n  start [prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) the values from m",
            "Instructions can execute in a different order from the one we define, due to\nvarious reasons:",
            "Out-of-order execution",
            "Note that thanks to Rustâ€™s safety guarantees, accessing global (static)\nvariables requires `unsafe` code, assuming we donâ€™t use any of the\nsynchronization primitives in this module.",
            "Due to the [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) involved in modern computers, assumptions\nabout the programâ€™s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, **even if**\ncompiler optimizations are disabled, and it is **still possible**\nto introduce synchronization bugs.",
            "The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.",
            "As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:",
            "Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.",
            "The need for synchronization",
            "Useful synchronization primitives."
          ]
        },
        {
          "title": "std::sync::atomic - Rust",
          "url": "http://doc.rust-lang.org/std/sync/atomic/index.html",
          "excerpts": [
            "Structs"
          ]
        },
        {
          "title": "Converos: Practical Model Checking for Verifying Rust OS ...",
          "url": "https://www.usenix.org/system/files/atc25-tang.pdf",
          "excerpts": [
            "by R Tang â€” Liveness properties include absence of deadlock, livelock, and starvation. Deadlock/livelock freedom specifies whenever a process is in theÂ ..."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "An `Arc` is a smart pointer that provides shared ownership of a value across multiple threads. It uses [atomic operations](https://doc.rust-lang.org/std/sync/atomic/) and [reference counting](https://doc.rust-lang.org/std/rc/) to efficiently track the number of references to the shared data.",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:",
            "One of the most basic primitives for concurrency in Rust is threads. A thread is an independent path of execution within a program that can run concurrently with other threads."
          ]
        },
        {
          "title": "Rust's Send and Sync (Nomicon)",
          "url": "https://doc.rust-lang.org/nomicon/send-and-sync.html",
          "excerpts": [
            "This means that, unlike\nevery other trait, if a type is composed entirely of Send or Sync types, then it\nis Send or Sync.",
            "Send and Sync are also automatically derived traits.",
            "* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).",
            "* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).",
            "* raw pointers are neither Send nor Sync (because they have no safety guards).",
            "Major exceptions include:",
            "Send and Sync are fundamental to Rust's concurrency story.",
            "Not everything obeys inherited mutability, though. Some types allow you to\nhave multiple aliases of a location in memory while mutating it. Unless these types use\nsynchronization to manage this access, they are absolutely not thread-safe. Rust\ncaptures this through the `Send` and `Sync` traits. * A type is Send if it is safe to send it to another thread. * A type is Sync if it is safe to share between threads (T is Sync if and only if `&T` is Send). Send and Sync are fundamental to Rust's concurrency story.",
            "Most uses of raw pointers should be encapsulated behind a sufficient abstraction\nthat Send and Sync can be derived.",
            " Almost all primitives are Send and Sync, and as a consequence\npretty much all types you'll ever interact with are Send and Sync. Major exceptions include:\n\n* raw pointers are neither Send nor Sync (because they have no safety guards). * `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't). * `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized). `Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\nunsynchronized shared mutable state. However raw pointers are, strictly\nspeaking, marked as thread-unsafe as more of a _lint_ . Doing anything useful\nwith a raw pointer requires dereferencing it, which is already unsafe. In that\nsense, one could argue that it would be \"fine\" for them to be marked as thread\nsafe. However it's important that they aren't thread-safe to prevent types that\ncontain them from being automatically marked as thread-safe. These types have\nnon-trivial untracked ownership, and it's unlikely that their author was\nnecessarily thinking hard about thread safety. In the case of `Rc` , we have a nice\nexample of a type that contains a `*mut` that is definitely not thread-safe. Types that aren't automatically derived can simply implement them if desired:\n\n```\n```\n#!"
          ]
        },
        {
          "title": "crossbeam-epoch (Crate Page) - Crates.io",
          "url": "https://crates.io/crates/crossbeam-epoch",
          "excerpts": [
            "shared objects until no pointers to them can exist.",
            "immediately. Epoch-based GC is an efficient mechanism for deferring destruction of",
            "may be still using pointers to it at the same time, so it cannot be destroyed",
            "This crate provides epoch-based garbage collection for building concurrent data structures. When a thread removes an object from a concurrent data structure, other threads",
            "crossbeam-epoch - crates.io: Rust Package Registry",
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "Flume - Rust",
          "url": "https://docs.rs/flume",
          "excerpts": [
            "Sender` and `Receiver` both implement `Send + Sync + Clo",
            "Familiar** : Drop-in replacement for `std::sync::mps",
            "Unbounded, bounded and rendezvous queues",
            "**Familiar** : Drop-in replacement for `std::sync::mpsc`",
            "**Safe** : No `unsafe` code anywhere in the codebase!",
            "A blazingly fast multi-producer, multi-consumer channel. _â€œDo not communicate by sharing memory; instead, share memory by communicating."
          ]
        },
        {
          "title": "crossbeam_epoch - Rust",
          "url": "https://docs.rs/crossbeam-epoch",
          "excerpts": [
            "Before an [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\") can be loaded, a participant must be [`pin`](fn.pin.html \"fn crossbeam_epoch::pin\")ned.",
            "Concurrent collections are built using atomic pointers. This module provides [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\"), which\nis just a shared atomic pointer to a heap-allocated object.",
            "memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs.",
            "Epoch-based memory reclamation. An interesting problem concurrent collections deal with comes from the remove operation."
          ]
        },
        {
          "title": "parking_lot Crate Documentation",
          "url": "https://crates.io/crates/parking_lot/",
          "excerpts": [
            "The primitives provided by this library have several advantages over those\nin the Rust standard library:",
            "It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking."
          ]
        },
        {
          "title": "Rust fence and memory ordering (std::sync::atomic)",
          "url": "https://doc.rust-lang.org/std/sync/atomic/fn.fence.html",
          "excerpts": [
            "```\nuse std::sync::atomic::AtomicBool;\nuse std::sync::atomic::fence;\nuse std::sync::atomic::Ordering;\n\n// A mutual exclusion primitive based on spinlock. pub struct Mutex {\n    flag: AtomicBool,\n}\n\nimpl Mutex {\n    pub fn new() -> Mutex {\n        Mutex {\n            flag: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&self) {\n        // Wait until the old value is `false`.",
            "Note that in the example above, it is crucial that the accesses to `m` are atomic. Fences cannot\nbe used to establish synchronization among non-atomic accesses in different threads.",
            "Atomic operations with [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") or [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\") semantics can also synchronize\nwith a fence.",
            "A fence which has [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") ordering, in addition to having both [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\")\nand [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") semantics, participates in the global program order of the\nother [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") operations and/or fences."
          ]
        },
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library",
            "* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data",
            "* _Message-passing_ concurrency, where channels send messages between threads",
            "Here are the topics weâ€™ll cover in this chapter:\n\n* How to create threads to run multiple pieces of code at the same time\n* _Message-passing_ concurrency, where channels send messages between threads\n* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data\n* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Top 10 Rust Concurrency Patterns for Zero-Copy Speed",
          "url": "https://medium.com/@bhagyarana80/top-10-rust-concurrency-patterns-for-zero-copy-speed-60aac19e0d4a",
          "excerpts": [
            "Ten battle-tested Rust concurrency patterns to move data without cloning. Learn Arc, slices, IoSlice, Cow, pools, sharding, ..."
          ]
        },
        {
          "title": "Shared-State Concurrency - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch16-03-shared-state.html",
          "excerpts": [
            "Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time."
          ]
        },
        {
          "title": "std::thread",
          "url": "https://doc.rust-lang.org/std/thread/",
          "excerpts": [
            "A thread local storage (TLS) key which owns its contents. Scope: A scope to spawn scoped threads in. ScopedJoinHandle: An owned permission to join on a scoped ..."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution.",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Error Handling - The Rust Programming Language"
          ]
        },
        {
          "title": "Unwinding through FFI after Rust 1.33 - language design",
          "url": "https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521",
          "excerpts": [
            "Feb 26, 2019 â€” It is possible to \"unwind\" over Rust code using longjmp , so you could have C call setjmp then call back into Rust for a group of operations,Â ..."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html",
          "excerpts": [
            "The behavior of `catch_unwind` when a foreign exception encounters it is\ncurrently [left undefined]() . We would like to\nprovide a well-defined behavior for this case, which will probably be either to\nlet the exception pass through uncaught or to catch some or all foreign\nexceptions.",
            "### [Enable foreign exceptions to propagate through Rust frame]()",
            "### [Enable Rust panics to traverse through foreign frames]()",
            "Enable error handling with `longjmp` :** As mentioned above, some existing Rust libraries rely on the ability to `longjmp` across Rust frames to interoperate with Ruby, Lua, and other C\n  APIs. The behavior of `longjmp` traversing Rust frames is not specified or\n  guaranteed to be safe; in the current implementation of `rustc` ,\n  however, it [is safe](https://github.com/rust-lang/rust/pull/48572) . On Windows, `longjmp` is implemented as a\n  form of unwinding called [â€œforced unwindingâ€]() , so any\n  specification of the behavior of forced unwinding across FFI boundaries\n  should be forward-compatible with a [future RFC]() that\n  will provide a well-defined way to interoperate with longjmp-based APIs. * **Do not change the ABI of functions in the `libc` crate:** Some `libc` functions may invoke `pthread_exit` , which uses [a form of\n  unwinding]() in the GNU libc implementation. Such functions\n  must be safe to use with the existing `\"C\"` ABI, because changing the types\n  of these fu"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "```\nuse anyhow::Context;  \nuse rust_ecosystem_learning::MyError;  \nuse std::fs;  \nuse std::mem::size_of;  \n  \nfn main() -> Result<(), anyhow::Error> {  \n    println! (\"size of anyhow::Error: {}\", size_of::<anyhow::Error>());  \n    println! (\"size of std::io::Error: {}\", size_of::<std::io::Error>());  \n    println! (  \n        \"size of std::num::ParseIntError: {}\",  \n        size_of::<std::num::ParseIntError>()  \n    );  \n    println! (  \n        \"size of serde_json::Error: {}\",  \n        size_of::<serde_json::Error>()  \n    );  \n    println! (\"size of string: {}\", size_of::<String>());  \n    println! (\"size of MyError: {}\", size_of::<MyError>());  \n  \n    let filename = \"non_existent_file.txt\";  \n    let _fd =  \n        fs::File::open(filename).with_context(|| format! (\"Cannot find file: {}\", filename))? ;  \n  \n    fail_with_error()? ;  \n    Ok(())  \n}  \n  \nfn fail_with_error() -> Result<(), MyError> {  \n    Err(MyError::Custom(\"This is a custom error\".to_string()))  \n}  \n  \n#[cfg(test)]  \nmod tests {  \n    #[test]  \n    fn it_works() {  \n        assert_eq!\n(2 + 2, 4);  \n    }  \n}\n```",
            "`main.rs` File",
            "Add Dependencies",
            "Comparison and Selection Guide",
            "snafu` Error: Context-driven Error Management",
            "```\npub trait Error: Debug + Display {\n```\n",
            "Reference: [Rust std::error::Error trait documentation](https://doc.rust-lang.org/beta/core/error/trait.Error.html)",
            "`thiserror` Error: Defining Library-level Errors",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`anyhow` Error: Application-level Error Handling",
            "anyhow = \"1.0.97\"  \nserde = { version = \"1.0.217\", features = [\"derive\"] }  \nserde_json = \"1.0.140\"  \nthiserror = \"2.0.11\"",
            "Practical Implementation"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
            "rust-ecosystem-learning",
            "Practical Implementation",
            "Error -> println! ( \"{}/ {:?}\" , err )",
            "Since the\nError trait requires implementing both\nDebug and\nDisplay :\npub trait Error : Debug + Display {",
            "Rust std::error::Error trait documentation",
            "thiserror vs snafu",
            "    * Provides the\nensure!\nmacro to simplify condition checking and error throwing",
            "    * Supports attaching structured context (such as file paths, input parameters) in the error chain",
            "    * Converts underlying errors into domain-specific errors through the\nSnafu macro",
            "snafu Error: Context-driven Error Management",
            "snafu Error: Context-driven Error Management",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros",
            "thiserror Error: Defining Library-level Errors",
            "fn get_cluster_info () -> Result < ClusterMap , anyhow :: Error > { // Error 3: Err3 let config = std :: fs :: read_to_string ( \"cluster.json\" ) ? ; // Error 1: Err1 // let config = std::fs::read_to_string(\"cluster.json\").context(\"...\")? ; // Error 1: Err1 let map : ClusterMap = serde_json :: from_str ( & config ) ?",
            "* Supports adding dynamic context (via the\ncontext() method) to enhance error readability",
            "* Uses the\n? operator for automatic error propagation, simplifying multi-layer nested error handling",
            "* Provides a unified\nanyhow::Error type, supporting any error type that implements\nstd::error::Error",
            "Conversion and unified error handling with\nanyhow::Error :",
            "* snafu : finer-grained error management",
            "* thiserror : customized and rich error handling, suitable for library-level programming",
            "snafu",
            "snafu",
            "thiserror ,",
            "thiserror ,",
            "anyhow ,",
            "anyhow ,",
            "Note: When developing, pay attention to the size of\nResult<T, E> . anyhow Error: Application-level Error Handling",
            "* `snafu` provides context-driven error management, appropriate for complex systems.",
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:"
          ]
        },
        {
          "title": "Miette Crate Documentation",
          "url": "https://crates.io/crates/miette",
          "excerpts": [
            "```\nuse miette::{Diagnostic, Report, SourceSpan};\nuse thiserror::Error;\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops\")]\n#[diagnostic()]\npub struct InnerError {\n    // Note: label but no source code\n    #[label]\n    err_span: SourceSpan,\n}\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops: multiple errors\")]\n#[diagnostic()]\npub struct MultiError {\n    // Note source code by no labels\n    #[source_code]\n    source_code: String,\n    // The source code above is used for these errors\n    #[related]\n    related: Vec<InnerError>,\n}\n\nfn do_something() -> Result<(), Vec<InnerError>> {\n    Err(vec! [\n        InnerError {\n            err_span: (0..6).into(),\n        },\n        InnerError {\n            err_span: (7..11).into(),\n        },\n    ])\n}\n\nfn main() -> miette::Result<()> {\n    do_something().map_err(|err_list| MultiError {\n        source_code: \"source code\".into(),\n        related: err_list,\n    })? ;\n    Ok(())\n}\n```\n\n#### ... Diagnostic-based error sources. When one uses the `#[source]` attribute on a field, that usually comes\nfrom `thiserror`, and implements a method for\n[`std::error::Error::source`]. This works in many cases, but it's lossy:\nif the source of the diagnostic is a diagnostic itself, the source will\nsimply be treated as an `std::error::Error`.\n ... \nIt owes enormous credit to various\nother projects and their authors:\n\n* [`anyhow`](http://crates.io/crates/anyhow) and [`color-eyre`](https://crates.io/crates/color-eyre):\n  these two enormously influential error handling libraries have pushed\n  forward the experience of application-level error handling and error\n  reporting. `miette`'s `Report` type is an attempt at a very very rough\n  version of their `Report` types. * [`thiserror`](https://crates.io/crates/thiserror) for setting the standard\n  for library-level error definitions, and for being the inspiration behind\n  `miette`'s derive macro. * `rustc` and [@estebank](https://github.com/estebank) for their\n  state-of-the-art work in compiler diagnostics. * [`ariadne`](https://crates.io/crates/ariadne) for pushing forward how\n  *pretty* these diagnostics can really look! ### License\n\n`miette` is released to the Rust community under the [Apache license\n2.0](https://github.com/zkat/miette/blob/HEAD/./LICENSE). It also includes code taken from [`eyre`](https://github.com/yaahc/eyre),\nand some from [`thiserror`](https://github.com/dtolnay/thiserror), also\nunder the Apache License. Some code is taken from\n[`ariadne`](https://github.com/zesterer/ariadne), which is MIT licensed.",
            "emitted at the same time:",
            "useful in combination with `related`, when multiple errors should be",
            "This is especially",
            "default support for `String`s included.",
            "* Generic support for arbitrary [`SourceCode`](https://docs.rs/miette/latest/miette/trait.SourceCode.html)s for snippet data, with",
            "* Replacements for [`anyhow`](https://docs.rs/anyhow)/[`eyre`](https://docs.rs/eyre)\n  types [`Result`](https://docs.rs/miette/latest/miette/type.Result.html), [`Report`](https://docs.rs/miette/latest/miette/struct.Report.html) and the [`miette!`](https://docs.rs/miette/latest/miette/macro.miette.html) macro for the\n  `anyhow!`/`eyre!` macros.",
            "* Super handy derive macro for defining diagnostic metadata.",
            "* Custom links to get more details on error codes.",
            "* Unique error codes on every [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html).",
            "`std::error::Error`.",
            "* Generic [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html) protocol, compatible (and dependent on)",
            "### Features",
            "### Table of Contents"
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Does anyone bothered by not having backtraces in custom ...",
          "url": "https://www.reddit.com/r/rust/comments/1jebbnq/does_anyone_bothered_by_not_having_backtraces_in/",
          "excerpts": [
            "I very much like anyhow's backtrace feature, it helps me figure out the root cause in some question marks where I'm too lazy to add a contextÂ ..."
          ]
        },
        {
          "title": "r/rust - miette: a fancy new diagnostics definition and ...",
          "url": "https://www.reddit.com/r/rust/comments/p9t3jh/miette_a_fancy_new_diagnostics_definition_and/",
          "excerpts": [
            "On a somewhat related note, does anyone know of any crates that assist in generating Spans (offset, length, line number, column number) from a ..."
          ]
        },
        {
          "title": "rust - How to trace the cause of an error result?",
          "url": "https://stackoverflow.com/questions/42275777/how-to-trace-the-cause-of-an-error-result",
          "excerpts": [
            "Use Result defined in easy-error as return type, then use context method to convert other Result types. Most important thing is to pass information to contextÂ ..."
          ]
        },
        {
          "title": "Error in anyhow - Rust",
          "url": "https://docs.rs/anyhow/latest/anyhow/struct.Error.html",
          "excerpts": [
            "The Debug format â€œ{:?}â€ includes your backtrace if one was captured. Note that this is the representation you get by default if you return an error from fn mainÂ ..."
          ]
        },
        {
          "title": "color-eyre - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/color-eyre",
          "excerpts": [
            "color-eyre v0.6.5. An error report handler for panics and eyre::Reports for colorful, consistent, and well formatted error reports for all kinds ..."
          ]
        },
        {
          "title": "color_eyre - Rust",
          "url": "https://docs.rs/color-eyre",
          "excerpts": [
            "An error report handler for panics and the `eyre` crate for colorful, consistent, and well formatted error reports for all kinds of errors."
          ]
        },
        {
          "title": "Rust Cancel Safety and Panics (as provided in the document)",
          "url": "https://rfd.shared.oxide.computer/rfd/400",
          "excerpts": [
            "If a Tokio runtime is shut down, all tasks running within it are cancelled at\nthe next await point.",
            " runtime is\n   shut down due to a panic, then the task is cancelled. ",
            "panics\narenâ€™t part of normal control flow."
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "Cancel safety is mostly not relevant for kill signals because you don't care if you lost some data from the connection if you're killing it.",
            "This happens with [`recv` on Tokio channels](https://docs.rs/tokio/1.27.0/tokio/sync/mpsc/struct.Receiver.html.recv) , since all the state is in the channel, and _not_ in the future returned by `recv()` .",
            "The easy way to avoid this is for the futures in the `select!` to not own state, but to borrow it from elsewhere; for example, if `buffered_stream` owns all the state, and the future returned by `read_msg()` mutates `buffered_stream` instead of storing its own state, you're cancellation-safe.",
            "If those futures own some form of state, then your future is not cancellation safe, since that owned state will be dropped when another future returns `Poll::Ready` .",
            "That is the basic gist of it. The underlying issue with cancellation safety is that all futures in the select other than the future that yields `Poll::Ready` will be dropped.",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2",
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum"
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "oml\n[profile.release]\npanic = 'abort'\n```",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Unrecoverable Errors with panic! - The Rust Programming Language"
          ]
        },
        {
          "title": "Cargo profile panic settings",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "Profile selection\nThe profile used depends on the command, the command-line flags like\n--release or\n--profile , and the package (in the case of overrides ). The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times.",
            "opt-level\nThe\nopt-level setting controls the\n-C opt-level flag which controls the level\nof optimization. Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "debug\nThe\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary. The valid options are:\n    * 0 ,\nfalse , or\n\"none\" : no debug info at all, default for\nrelease",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic.",
            "led\n\nlto\nThe\nlto setting controls\nrustc â€™s\n-C lto ,\n-C linker-plugin-lto , and\n-C embed-bitcode options, which control LLVMâ€™s link time optimizations . LTO can produce better optimized code, using whole-program analysis, at the cost\nof longer linking time. The valid options are:\n    * false : Performs â€œthin local LTOâ€ which performs â€œthinâ€ LTO on the local\ncrate only across its codegen units . No LTO is performed\nif codegen units is 1 or opt-level is 0.\n* true or\n\"fat\" : Performs â€œfatâ€ LTO which attempts to perform\noptimizations across all crates within the dependency graph. * \"thin\" : Performs â€œthinâ€ LTO . This is similar to â€œfatâ€, but takes\nsubstantially less time to run while still achieving performance gains\nsimilar to â€œfatâ€. * \"off\" : Disables LTO.",
            "The\ncodegen-units setting controls the\n-C codegen-units flag which\ncontrols how many â€œcode generation unitsâ€ a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower cod",
            "codegen-units = 16",
            "panic = 'unwind'",
            "lto = false",
            "strip = \"none\"",
            "debug = false",
            "opt-level = 3",
            "The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "The default settings for the\nrelease profile are:\n[profile.release] opt-level = 3 debug = false split-debuginfo = '...' # Platform-specific. strip = \"none\" debug-assertions = false overflow-checks = false lto = false panic = 'unwind' incremental = false codegen-units = 16 rpath = false",
            "[profile.release] opt-level = 3",
            "release profile is intended for optimized artifacts used for releases\nand in production.",
            "The default is\n\"none\" . You can also configure this option with the boolean values\ntrue or\nfalse .",
            "Profiles\nProfiles provide a way to alter the compiler settings, influencing things like\noptimizations and debugging symbols. Cargo has 4 built-in profiles:\ndev ,\nrelease ,\ntest , and\nbench .",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic. When set to\n\"unwind\" , the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses\n\"abort\" . Tests, benchmarks, build scripts, and proc macros ignore the\npanic setting. The\nrustc test harness currently requires\nunwind behavior. See the\npanic-abort-tests unstable flag which enables\nabort behavior. Additionally, when using the\nabort strategy and building a test, all of the\ndependencies will also be forced to build with the\nunwind strategy. incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times"
          ]
        },
        {
          "title": "The Rustonomicon - Unwinding",
          "url": "https://doc.rust-lang.org/nomicon/unwinding.html",
          "excerpts": [
            "Unlike an exception in Java or C++, a panic could not be\ncaught at any time.",
            "There is an API called [`catch_unwind`](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html) that enables catching a panic\nwithout spawning a thread.",
            "Panics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.",
            "Rust has a _tiered_ error-handling scheme:\n\n* If something might reasonably be absent, Option is used. * If something goes wrong and can reasonably be handled, Result is used. * If something goes wrong and cannot reasonably be handled, the thread panics. * If something catastrophic happens, the program aborts. Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion."
          ]
        },
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        },
        {
          "title": "Unwinding -",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/nomicon/unwinding.html",
          "excerpts": [
            "As such, unwinding into Rust from another language, or unwinding into another language from Rust is Undefined Behavior. You must absolutely catch any panics ..."
          ]
        },
        {
          "title": "Rust Iterator Documentation",
          "url": "http://doc.rust-lang.org/std/iter/trait.Iterator.html",
          "excerpts": [
            "Returns [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") when iteration is finished.",
            "Advances the iterator and returns the next value.",
            "(.next)(&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\")<Self::[Item](trait.Iterator.html.Item \"type std::iter::Iterator::Item\")>",
            "The type of the elements being iterated over.",
            "This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the [module-level documentation](index.html \"mod std::iter\"). In particular, you\nmay want to know how to [implement `Iterator`](index.html \"mod std::iter\").",
            "A trait for dealing with iterators."
          ]
        },
        {
          "title": "ExactSizeIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html",
          "excerpts": [
            "this trait is a safe trait and as such does *not* and *cannot*\nguarantee that the returned length is correct. This means that `unsafe`\ncode **must not** rely on the correctness of [`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\").",
            "This function has the same safety guarantees as the\n[`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\") function.",
            "If an iterator knows how many times it can iterate, providing access to\nthat information can be useful.",
            "An iterator that knows its exact length."
          ]
        },
        {
          "title": "What is the difference between iter and into_iter? (Stack Overflow)",
          "url": "https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter",
          "excerpts": [
            "So `for x in my_vec { ... }` is essentially equivalent to `my_vec.into_iter().for_each(|x| ... )` \\- both `move` the elements of `my_vec` into the `...` scope. If you just need to _look at_ the data, use `iter` , if you need to edit/mutate it, use `iter_mut` , and if you need to give it a new owner, use `into_iter` ",
            "* `into_iter()` iterates over the items, moving them into the new scope",
            "* `iter_mut()` iterates over the items, giving a mutable reference to each item",
            "* `iter()` iterates over the items by reference",
            "What is the difference between `iter` and `into_iter` ? `into_iter` is a generic method to obtain an iterator, whether this iterator yields values, immutable references or mutable references **is context dependent** and can sometimes be surprising. `iter` and `iter_mut` are inherent methods. Their return type is therefore independent of the context, and will conventionally be iterators yielding immutable references and mutable references, respectively. The author of the Rust by Example post used Rust pre-1.53.0 to illustrate the surprise coming from the dependence on the context (i.e., the type) on which `into_iter` is called, and is also compounding the problem by using the fact that:\n\n1. Back then, `IntoIterator` was not implemented for `[T; N]` , only for `&[T; N]` and `&mut [T; N]` . 2"
          ]
        },
        {
          "title": "FromIterator in std::iter - Rust",
          "url": "https://doc.rust-lang.org/std/iter/trait.FromIterator.html",
          "excerpts": [
            "Conversion from an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") . By implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind. If you want to create a collection from the contents of an iterator, the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`](trait.FromIterator.html.from_iter \"associated function std::iter::FromIterator::from\\_iter\") can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()` ).\nSee the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") documentation for more examples of its use.",
            "pub trait FromIterator<A>: Sized {\n    // Required method\n    fn from_iter <T>(iter: T) -> Self\n       where T: IntoIterator <Item = A> ;\n}"
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "They preferentially capture variables by reference and only go lower when\nrequired. ```",
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`"
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "IntoIter in std::vec",
          "url": "https://doc.rust-lang.org/std/vec/struct.IntoIter.html",
          "excerpts": [
            "An iterator that moves out of a vector. This struct is created by the into_iter method on Vec (provided by the IntoIterator trait)."
          ]
        },
        {
          "title": "Difference Between into_iter, iter() and iter_mut() in rust",
          "url": "https://blog.coolhead.in/difference-between-intoiter-iter-and-itermut-in-rust",
          "excerpts": [
            "Nov 24, 2023 â€” into_iter() transfers ownership of the collection, iter() borrows the elements immutably, and iter_mut() borrows them mutably."
          ]
        },
        {
          "title": "Passing slice as an IntoIterator - rust",
          "url": "https://stackoverflow.com/questions/35144386/passing-slice-as-an-intoiterator",
          "excerpts": [
            "Let's take a look at how IntoIterator is implemented for slices: impl<'a, T> IntoIterator for &'a [T] type Item = &'a T type IntoIter = Iter<'a, T>"
          ]
        },
        {
          "title": "How does for loop implement into_iter - rust",
          "url": "https://stackoverflow.com/questions/72258925/how-does-for-loop-implement-into-iter",
          "excerpts": [
            "The iterable is transformed into an iterator by executing IntoIterator::into_iter(iterable). Each trait, including IntoIterator, has a hidden Self genericÂ ..."
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n",
            "fn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n",
            "\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\").",
            "By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.",
            "ion\n\nConversion into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"). By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind. One benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\"). See also: [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). [Â§]()Examples",
            "    fn into_iter(self) -> Self::IntoIter;",
            "    // Required method\n",
            "    type IntoIter: Iterator<Item = Self::Item>;\n",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterato",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "that have the same size as the value we specified.",
            "The test shows that when we call `shoes_in_size`, we get back only shoes",
            "adapted iterator into a vector thatâ€™s returned by the function.",
            "specified. Finally, calling `collect` gathers the values returned by the",
            "compares the value with each shoeâ€™s size, keeping only shoes of the size",
            "The closure captures the `shoe_size` parameter from the environment and",
            "size.",
            "size as parameters. It returns a vector containing only shoes of the specified",
            "The `shoes_in_size` function takes ownership of a vector of shoes and a shoe",
            "their environment.",
            "weâ€™ll specify as arguments to iterator adapters will be closures that capture",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "### [Using Closures That Capture Their Environment]()",
            "consuming adapter methods to get results from calls to iterator adapters.",
            "a readable way. But because all iterators are lazy, you have to call one of the",
            "You can chain multiple calls to iterator adapters to perform complex actions in",
            "provides.",
            "behavior while reusing the iteration behavior that the `Iterator` trait",
            "on each item. This is a great example of how closures let you customize some",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "containing each item from the original vector, incremented by 1.",
            "returned from the call to `map` into a vector. This vector will end up",
            "In Listing 13-15, we collect the results of iterating over the iterator thatâ€™s",
            "some aspect of the original iterator.",
            "consume the iterator. Instead, they produce different iterators by changing",
            "*Iterator adapters* are methods defined on the `Iterator` trait that donâ€™t",
            "### [Methods that Produce Other Iterators]()",
            "consuming the iterator.",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "uses up the iterator. One example is the `sum` method, which takes ownership of",
            "Methods that call `next` are called *consuming adapters* because calling them",
            "`Iterator` trait.",
            "is why youâ€™re required to implement the `next` method when implementing the",
            "trait. Some of these methods call the `next` method in their definition, which",
            "methods by looking in the standard library API documentation for the `Iterator`",
            "implementations provided by the standard library; you can find out about these",
            "The `Iterator` trait has a number of different methods with default",
            "### [Methods That Consume the Iterator]()",
            "`iter_mut` instead of `iter`.",
            "`iter`. Similarly, if we want to iterate over mutable references, we can call",
            "ownership of `v1` and returns owned values, we can call `into_iter` instead of",
            "over immutable references. If we want to create an iterator that takes",
            "references to the values in the vector. The `iter` method produces an iterator",
            "Also note that the values we get from the calls to `next` are immutable",
            "iterator.",
            "it is in the sequence. In other words, this code *consumes*, or uses up, the",
            "iterator changes internal state that the iterator uses to keep track of where",
            "Note that we needed to make `v1_iter` mutable: calling the `next` method on an",
            "from the vector.",
            "what values are returned from repeated calls to `next` on the iterator created",
            "We can call the `next` method on iterators directly; Listing 13-12 demonstrates",
            "`Some` and, when iteration is over, returns `None`.",
            "`next` method, which returns one item of the iterator at a time, wrapped in",
            "The `Iterator` trait only requires implementors to define one method: the",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "### [The `Iterator` Trait and the `next` Method]()",
            "amed `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this",
            "    // methods with default implementations elided",
            "    fn next(&mut self) -> Option<Self::Item>;",
            "    type Item;",
            "pub trait Iterator {",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:",
            "standard library. The definition of the trait looks like this:",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "    type Item;",
            "}",
            "    // Required method"
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently).",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Instances of `Fn` can be called repeatedly without mutating state."
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too.",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu"
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "where\n    Args: Tuple ,",
            "pub trait FnOnce<Args>",
            "FnOnce in std::ops - Rust"
          ]
        },
        {
          "title": "Trait FusedIterator - std::iter (Rust std docs)",
          "url": "http://doc.rust-lang.org/std/iter/trait.FusedIterator.html",
          "excerpts": [
            "that behave this way because it allows optimizing [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\").",
            "to return [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") again. This trait should be implemented by all iterators",
            "Note: In general, you should not use `FusedIterator` in generic bounds if\nyou need a fused iterator. Instead, you should just call [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\") on the iterator. If the iterator is already fused, the additional [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper will be a no-op with no performance penalty.",
            "An iterator that always continues to yield `None` when exhausted.",
            "pub trait FusedIterator: Iterator { }"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "```\nlet numbers = vec! [ 1 , 2 , 3 , 4 , 5 , 6 ];\n\nlet mut iter = numbers.iter();\n\nassert_eq! ( Some ( & 1 ), iter.next());\nassert_eq! ( Some ( & 6 ), iter.next_back());\nassert_eq! ( Some ( & 5 ), iter.next_back());\nassert_eq! ( Some ( & 2 ), iter.next());\nassert_eq! ( Some ( & 3 ), iter.next());\nassert_eq! ( Some ( & 4 ), iter.next());\nassert_eq! ( None , iter.next());\nassert_eq! ( None , iter.next_back());\n```\n",
            "Basic usage:",
            "##### [Â§](#examples-2) Examples",
            "The [trait-level](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") docs contain more details.",
            "Returns `None` when there are no more elements.",
            "Removes and returns an element from the end of the iterator.",
            "#### fn [next\\_back](#tymethod.next_back) (&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\") <Self:: [Item](trait.Iterator.html#associatedtype.Item \"type std::iter::Iterator::Item\") >",
            "1\\.0.0 Â· [Source](../../src/core/iter/traits/double_ended.rs.html#94)",
            "\n## Required Methods [Â§](#required-methods)",
            "again may or may not ever return [`Some`](../option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. [`next()`](trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") and [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") are interchangeable for this purpose.",
            "In a similar fashion to the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") protocol, once a `DoubleEndedIterator` returns [`None`](../option/enum.Option.html#variant.None \"variant std::option::Option::None\") from a [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") , calling it",
            "and do not cross: iteration is over when they meet in the middle.",
            "It is important to note that both back and forth work on the same range,",
            "over something that implements [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") : the ability to also take `Item` s from the back, as well as the front.",
            "Something that implements `DoubleEndedIterator` has one extra capability",
            "An iterator able to yield elements from both ends.",
            "}",
            "             P: FnMut (&Self:: Item ) -> bool { ... }",
            "    fn rfind <P>(&mut self, predicate: P) -> Option <Self:: Item >",
            "             F: FnMut (B, Self:: Item ) -> B { ... }",
            "    fn rfold <B, F>(self, init: B, f: F) -> B",
            "             R: Try <Output = B> { ... }",
            "             F: FnMut (B, Self:: Item ) -> R,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "    fn try_rfold <B, F, R>(&mut self, init: B, f: F) -> R",
            "    fn nth_back (&mut self, n: usize ) -> Option <Self:: Item > { ... }",
            "    fn advance_back_by (&mut self, n: usize ) -> Result < () , NonZero < usize >> { ... }",
            "    // Provided methods",
            "    fn next_back (&mut self) -> Option <Self:: Item >;",
            "    // Required method",
            "pub trait DoubleEndedIterator: Iterator {"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n",
            "Iterators (and iterator [adapters]() ) are _lazy_ . This means that\njust creating an iterator doesnâ€™t _do_ a whole lot. Nothing really happens\nuntil you call [`next`](trait.Iterator.html.next \"method std::iter::Iterator::next\") .",
            "Iterators are also composable, and itâ€™s common to chain them together to do\nmore complex forms of processing. See the [Adapters]() section\nbelow for more details.\n",
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n"
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "-------\n\n* **Underlying structure:** Binary maxâ€‘heap in a `Vec`\n* **Time complexities:**\n\n> Push/pop: *O(log n)*\n>\n> Peek max: *O(1)*\n\n* **Memory:** Similar footprint to `Vec` plus heap invariant",
            "\n### **BTreeMap:**\n\n* **Underlying structure:** Balanced Bâ€‘tree of sorted keyâ€“value pairs\n* **Time complexities:**\n\n> Insert/remove/lookup: *O(log n)*\n\n* **Memory:** Lower perâ€‘element overhead vs. `HashMap` (no hashing), but tree nodes incur pointers",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi",
            "VecDeque:**\n\n* **Underlying structure:** Grow-able ring buffer of fixedâ€‘size blocks\n* **Time complexities:**\n\n> Push/pop front or back: Amortized *O(1)*\n>\n> Indexing: *O(1)* (slightly slower constant factor)\n>\n> Insert/remove in middle: *O(n)*\n\n* **Memory:** Slight overhead for ring buffer metadata and block poin",
            "Rustâ€™s standard library provides a rich set of collection types, each tailored to different useâ€‘cases and performance characteristics.",
            "LinkedList:**\n\n* **Underlying structure:** Doublyâ€‘linked list of heapâ€‘allocated nodes\n* **Time complexities:**\n\n> Insert/remove at known node (via cursor): *O(1)*\n>\n> Push/pop front or back: *O(1)*\n>\n> Indexing/traversal: *O(n)*\n\n* **Memory:** One heap allocation per element + two poin",
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements "
          ]
        },
        {
          "title": "How does Rust allocate more space for a vector?",
          "url": "https://stackoverflow.com/questions/62685440/how-does-rust-allocate-more-space-for-a-vector",
          "excerpts": [
            "The current strategy is to double the capacity when it must be increased. However, there is a special case: Vec::new() doesn't allocate, but pushing an element ..."
          ]
        },
        {
          "title": "evmap crate page (crates.io) - Rust Package Registry",
          "url": "https://crates.io/crates/evmap/5.0.2",
          "excerpts": [
            "pkg:cargo/evmap@5.0.2",
            "Metadata",
            "results show that `evmap` performs well under contention,\nespecially on the read side. This benchmar",
            "The benchmark\nmeasures the average number of reads and writes per second as the number of\nreaders and writers increases.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "Small Vector Optimization",
            "Small Vector Optimization",
            "The map is multi-value, meaning that every key maps to a *collection* of values. This\nintroduces some memory cost by adding a layer of indirection through a `Vec` for each value,\nbut enables more advanced use.",
            "Reads never take locks on their critical path, and neither\ndo writes assuming there is a single writer (multi-writer is possible using a `Mutex`), which\nsignificantly improves performance under contention.",
            "A lock-free, eventually consistent, concurrent multi-value map. evmap - crates.io: Rust Package Registry"
          ]
        },
        {
          "title": "expect-test - Crates.io (Rust snapshot testing library)",
          "url": "https://crates.io/crates/expect-test",
          "excerpts": [
            "Metadata"
          ]
        },
        {
          "title": "Why does vec allocate new memory and copy values when growing? - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/why-does-vec-allocate-new-memory-and-copy-values-when-growing/45291",
          "excerpts": [
            " In Rust, you can do this by calling `Vec::with_capacity(size)` instead of `Vec::new()`",
            "Vectors fit both of those requirements very well while still being conceptually simple to understand (a useful quality in a common collection type).",
            "The API of Vec doesn't change at all because of this optimization, and the overall strategy remains the same - double the size, (possibly) reallocating, every time more space is needed.",
            "Note that the _exponential_ growth is important. On each reallocation, we have to copy twice as much, but then it takes twice as long to fill up again. These factors cancel out and we get (on average) constant-time `.push()` .",
            "Vectors don't resize every time you call `insert` , they typically allocate extra space so subsequent insertions can be handled without re-allocating and usually they vary the extra space requested as the size of the vector increases. A common pattern is to allocate `2 * current capacity` on re-allocation."
          ]
        },
        {
          "title": "SwissMap: A smaller, faster Golang Hash Table",
          "url": "https://dolthub.com/blog/2023-03-28-swiss-map/",
          "excerpts": [
            "SwissMap supports a higher maximum load factor (87.5%) than the built-in map (81.25%), but this difference alone doesn't tell the whole story."
          ]
        },
        {
          "title": "How Go 1.24's Swiss Tables saved us hundreds of gigabytes",
          "url": "https://www.datadoghq.com/blog/engineering/go-swiss-tables/",
          "excerpts": [
            "Higher load factor: Swiss Tables support a higher load factor of 87.5% (versus 81.25% in Go 1.23), requiring fewer total slots. Elimination ..."
          ]
        },
        {
          "title": "Noteworthy concurrent data structures? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/myiokh/noteworthy_concurrent_data_structures/",
          "excerpts": [
            "Here are some crates with useful concurrent data structures: crossbeam. flume. parking_lot. dashmap/evmap/chashmap. arc-swap. atomic-take."
          ]
        },
        {
          "title": "aHash is a non-cryptographic hashing algorithm that uses ...",
          "url": "https://github.com/tkaitchuck/aHash",
          "excerpts": [
            "AHash is the fastest, DOS resistant hash currently available in Rust. AHash is intended exclusively for use in in-memory hashmaps."
          ]
        },
        {
          "title": "ahash - Rust",
          "url": "https://rust-lang.github.io/hashbrown/ahash/index.html",
          "excerpts": [
            "How aHash works. aHash uses the hardware AES instruction on x86 processors to provide a keyed hash function. aHash is not a cryptographically secure hash."
          ]
        },
        {
          "title": "RawVec growth strategy can be more efficient #111307",
          "url": "https://github.com/rust-lang/rust/issues/111307",
          "excerpts": [
            "May 6, 2023 â€” Currently, the RawVec implementation tries to double its internal capacity every time it has to grow, as can be seen in:Â ..."
          ]
        },
        {
          "title": "std::collections::binary_heap",
          "url": "https://doc.rust-lang.org/std/collections/binary_heap/index.html",
          "excerpts": [
            "Converting a vector to a binary heap can be done in-place, and has O(n) complexity. A binary heap can also be converted to a sorted vector in-place, allowing itÂ ..."
          ]
        },
        {
          "title": "BinaryHeap in std::collections",
          "url": "https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html",
          "excerpts": [
            "The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and theÂ ..."
          ]
        },
        {
          "title": "VecDeque in std::collections - Rust",
          "url": "https://doc.rust-lang.org/std/collections/struct.VecDeque.html",
          "excerpts": [
            "A double-ended queue implemented with a growable ring buffer. The â€œdefaultâ€ usage of this type as a queue is to use push_back to add to the queue, and ..."
          ]
        },
        {
          "title": "SmallVec::spilled() causing performance overhead on Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1g8o9a6/smallvecspilled_causing_performance_overhead/",
          "excerpts": [
            "}\n```\n\nSmallVec struct:\n\n```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= Self::inline_capacity() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use).",
            "But I have encountered this issue while benchmarking with [cargo flamegraph](https://github.com/flamegraph-rs/flamegraph): equivalance checks between `SmallVec`s take too long and almost all the time is spent on `spilled()`.",
            "I am the author of the [markov\\_str](https://github.com/Brogolem35/markov_str) library and I am trying out the [smallvec](https://github.com/servo/rust-smallvec/tree/v1) to speed up the training of my Markov Chains"
          ]
        },
        {
          "title": "bitvec - Rust",
          "url": "https://docs.rs/bitvec/latest/bitvec/",
          "excerpts": [
            "In addition, the [user guide](https://bitvecto-rs.github.io/bitvec/) explores the philosophical and academic\nconcepts behind `bitvec` â€™s construction, its goals, and the more intricate parts\nof its behavior.",
            "bitvec/latest/bitvec) explores `bitvec` â€™s usage and implementation in\ngreat detail. In particular, you should read the documentation for the [`order`](https://docs.rs/bitvec/latest/bitvec/order/index.html) , [`store`](https://docs.rs/bitvec/latest/bitvec/store/index.html) , and [`field`](https://docs.rs/bitvec/latest/bitvec/field/index.html) modules, as well as the [`BitSlice`](https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html) and [`BitArray`](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) types.",
            "`std` : This provides some `std::io::{Read,Write}` implementations, as well as `std::error::Error` for the various error types. It is otherwise unnecessary.",
            "`serde` : This enables the de/serialization of `bitvec` buffers through the `serde` system. This can be useful if you need to transmit `usize => bool` collections.",
            "`atomic` : This controls whether atomic instructions can be used for aliased\n  memor",
            "`alloc` : This links against the `alloc` distribution crate, and provides the `BitVec` and `BitBox` types. It can be used on `#! [no_std]` targets that\n  possess a dynamic allocator but not an operating syste",
            "`bitvec` has a few Cargo features that govern its API surface. The default\nfeature set is:",
            "When using `bitvec` to manage protocol buffers, you will need to select the\nexact type parameters that match your memory layout. For instance, TCP uses `<u8, Msb0>` , while IPv6 on a little-endian machine uses `<u32, Lsb0>` .",
            "Many protocols use sub-element fields in order to save space in transport; for\nexample, TCP headers have single-bit and 4-bit fields in order to pack all the\nneeded information into a desirable amount of space.",
            "If your bit-field storage buffers are never serialized for exchange between\nmachines, then you can get away with using the default type parameters and\nunadorned load/store methods.",
            "Uses of `bitvec` generally fall into three major genres. * compact, fast, `usize => bit` collections\n* truncated integer storage\n* precise control of memory layout",
            "The `bitvec` data types implement a complete replacement for their\nstandard-library counterparts, including all of the inherent methods, traits,\nand operator behaviors.",
            "While place expressions like `bits[index] = value;` are not available, `bitvec` instead provides a proxy structure that can be used as _nearly_ an `&mut bit` reference:",
            "the presence of a\ndynamic allocator enables the `BitBox` and `BitVec` buffer types, which can be\nused for more advanced buffer manipulation:",
            "Bit-slices can split anywhere.",
            "All data-types have macro\n// constructo",
            "use type aliases to make names for specific\ninstantiations of `bitvec` type parameters, and use that rather than attempting\nto remain generic over an `<T: BitStore, O: BitOrder>` pair throughout your\nproject.",
            "Note: `bitvec` supports `#! [no_std]` targets. If you do not have `std` ,\n> disable the default features, and explicitly restore any features that you do\n> h",
            "Minimum Supported Rust Version** : 1.56",
            "`BitSlice` cannot implement `IndexMut` , so `bitslice[index] = true;` does not\n  wor",
            "`BitSlice` cannot be used as a referent type in pointers, such as `Box` , `Rc` ,\n  or `Arc`",
            "A memory model accounts for element-level aliasing and is safe for concurrent\n  us",
            "Type parameters enable users to select the precise memory representation they\n  desir",
            "It leverages Rustâ€™s\npowerful reference and type systems to create a system that seamlessly bridges\nsingle-bit addressing, precise control of in-memory layout, and Rust-native\nownership and borrowing mechanisms.",
            "If you need to view memory as bit-addressed instead of byte-addressed, then `bitvec` is the fastest, most complete, and Rust-idiomatic crate for you.",
            "bitvec` provides a foundational API for bitfields in Rust. It specializes\nstandard-library data structures (slices, arrays, and vectors of `bool` ) to use\none-bit-per- `bool` storage, similar to [`std::bitset<N>`](https://en.cppreference.com/w/cpp/utility/bitset) and [`std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool) in C++",
            "bitvec - Rust"
          ]
        },
        {
          "title": "A HashMap in Rust - What's a HashMap? - Faultlore",
          "url": "https://faultlore.com/blah/robinhood-part-1/",
          "excerpts": [
            "For security, I recommend SipHash 2-4 as a reasonable *default* hashing algorithm, with some way to override the default for performance.",
            "For performance and simplicity, I recommend a robinhood hashmap, which enjoys O(1) expected time per query without the need for chaining.",
            "For all intents and purposes, weâ€™ve got constant-time searches.",
            "We hash ~ alpha\\*n elements into a table of size n where each probe is independent and uniformly distributed over the table, and alpha < 1 is a constant. Let M be the maximum search time for any of the elements in the table. We show that with probability tending to one, M is in [log2log n + a, log2log n + b] for some constants *a* and *b* depending upon alpha only. This is an exponential improvement over the maximum search time in case of the standard FCFS collision strategy. So the expected worst-case search time is O(loglog n) if we have at most some constant load factor",
            "In contrast to the [previous](../rust-btree-case/) post, which dove into Rustâ€™s BTreeMap and the idea of B-Trees in general, this post will be split up into two posts. In this post we will take a look at the general problems faced by hashtables, as well as the robin hood hashtable scheme. In the next post, we will take a high-to-mid-level look at Rustâ€™s standard HashMap implementation (surprise, itâ€™s a robin hood hashtable), and what it does to be safe and fast.",
            "This article is really old! Rust has since moved on to SwissTable (hashbrown), which I describe [in this article](../hashbrown-tldr/). That said, this article is still useful because it mostly discusses issues fundamental to any HashMap design.",
            "A HashMap in Rust: What's a HashMap?"
          ]
        },
        {
          "title": "indexmap-rs GitHub Repository",
          "url": "https://github.com/indexmap-rs/indexmap",
          "excerpts": [
            "This was inspired by Python 3.6's new dict implementation (which remembers\nthe insertion order and is fast to iterate, and is compact in memory). Some of those features were translated to Rust, and some were not. The result\nwas indexmap, a hash table that has following properties:\n\n* Order is **independent of hash function** and hash values of keys. * Fast to iterate. * Indexed in compact space. * Preserves insertion order **as long** as you don't call `.remove()` , `.swap_remove()` , or other methods that explicitly change order. The alternate `.shift_remove()` does preserve relative order. * Uses hashbrown for the inner table, just like Rust's libstd `HashMap` does. ## Performance\n\n[]()\n\n`IndexMap` derives a couple of performance facts directly from how it is constructed,\nwhich is roughly:\n\n> A raw hash table of key-value indices, and a vector of key-value pairs. * \n  Iteration is very fast since it is on the dense key-values. * \n  Removal is fast since it moves memory areas only in the table,\n  and uses a single swap in the vector."
          ]
        },
        {
          "title": "Rust HashMap Documentation",
          "url": "https://doc.rust-lang.org/std/collections/struct.HashMap.html",
          "excerpts": [
            "The behavior resulting from either logic error is not specified, but will\nbe encapsulated to the `HashMap` that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination.",
            "It is also a logic error for a key to be modified in such a way that the keyâ€™s\nhash, as determined by the [`Hash`](../hash/trait.Hash.html \"trait std::hash::Hash\") trait, or its equality, as determined by\nthe [`Eq`](../cmp/trait.Eq.html \"trait std::cmp::Eq\") trait, changes while it is in the map.",
            "The hash table implementation is a Rust port of Googleâ€™s [SwissTable](https://abseil.io/blog/20180927-swisstables) .",
            "By default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks.",
            "A [hash map](index.html \"mod std::collections\") implemented with quadratic probing and SIMD lookup."
          ]
        },
        {
          "title": "Swisstable, a Quick and Dirty Description - Faultlore",
          "url": "https://faultlore.com/blah/hashbrown-tldr/",
          "excerpts": [
            "Bit fiddling tricks will be omitted because theyâ€™re not that interesting, and I made sure they were really well documented [in hashbrown](https://github.com/rust-lang/hashbrown/tree/master/src/raw) (the Rust impl), so you can just crib the implementations from there (seriously, itâ€™s only 100 lines of code, mostly comments). So if I ever say â€œdo X in parallel (func\\_name)â€ thatâ€™s your cue to check the parallel bit tricks implementation for func\\_name and its detailed documentatio",
            "Ok hereâ€™s how to implement Swisstable as simply as possible, with a bunch of random notes. Iâ€™m assuming youâ€™re familiar with the basics of an open-addressing hashmap implementation, and will be skipping over all those details. If you want to brush up on those issues, you can read my primer on [the old Rust Robin Hood implementation](https://gankra.github.io/blah/robinhood-part-1/). High level concepts to keep in mind:\n\n* open-addressing\n* searches in parallel using SIMD\n* first-come-first-serve collision resolution\n* chunked (SIMD) triangular (quadratic-ish) probing\n* tombstones to avoid backshifts",
            "Swisstable, a Quick and Dirty Description"
          ]
        }
      ],
      "reasoning": "- The clearest direct information about async/await comes from excerpts that define the async/await workflow, including how futures are polled and awaited, and how awaiting a value typically works. For example, explanations stating that a future represents an asynchronous computation and that you generally await a value rather than polling directly directly support the field value. This directly ties to the concept of async/await as the primary mechanism for asynchronous programming in Rust.\n- Additional excerpts discuss the core await expression flow, including how a value produced by a future is retrieved via await, and references to poll and wake-up semantics, which are central to the async/await model. These details reinforce the meaning and mechanics of the async/await pattern.\n- Several excerpts extend the discussion to practical tooling and ecosystems around async in Rust, mentioning async runtimes and crates, which contextualize async/await usage in real projects. While not defining async/await itself, they support the field by illustrating how async/await interacts with the broader asynchronous ecosystem.\n- Some excerpts address related concerns like avoiding blocking in async contexts or the implications of keeping references across await points. These do not redefine async/await but provide context about its practical considerations, which is relevant to understanding how async/await is used in Rust code.\n- In sum, the most relevant content is the subset that explicitly describes the async/await mechanism (futures, poll, await) and its immediate workflow, with secondary relevance to runtime implementations and practical usage patterns.\n",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.8",
      "citations": [
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;"
          ]
        }
      ],
      "reasoning": "The field value Pin is illustrated in the most relevant passage by explicitly showing how a value is pinned with Pin::new_unchecked, which demonstrates the practical use of Pin in preparing data for a pinned context. The subsequent excerpt discusses the lifecycle of a pinned future, noting that it is pinned and then polled, which connects Pin to the typical asynchronous polling workflow. Together, these excerpts provide direct, concrete support for the notion of Pin being used in asynchronous Rust code, aligning with the field path that targets asynchronous programming concepts and Pin usage.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.15",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        }
      ],
      "reasoning": "The field value 'smol' corresponds to a Rust asynchronous runtime mentioned as a runtime option. The excerpt states that 'smol' is a lightweight tokio alternative, which directly identifies what 'smol' is and how it relates to other runtimes (as an alternative to Tokio). This information directly supports claims about what 'smol' is and its role in the asynchronous Rust ecosystem. Since there are no additional excerpts in the provided set that discuss 'smol' or its characteristics, this single excerpt provides the core evidence for the field value. The reasoning relies on the explicit mention of 'smol' as a runtime option and frames it as a lightweight alternative to Tokio, which is precisely the contextual meaning likely intended by the finegrained field.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.12",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "hand, `fence(SeqCst)` is supported."
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`",
            "ts\n\nTest cases using loom must be fully deterministic. All sources of non-determism must be via loom\ntypes so that loom can expose different possible values on each execution of the test closure.",
            "Loom provides a way to deterministically explore the various possible execution permutations\nwithout relying on random executions. This allows you to write tests that verify that your\nconcurrent code is correct under _all_ executions, not just â€œmost of the time",
            "\nLoom is a tool for testing concurrent programs. At a high level, it runs tests many times, permuting the possible concurrent executions of each\ntest according to what constitutes valid executions under the [C11 memory model]"
          ]
        }
      ],
      "reasoning": "Direct references to async runtimes provide the clearest support for the field value. The first excerpt explicitly discusses the question of the best async runtime for HTTP/networking in Rust, naming Tokio as a leading option and mentioning alternatives like smol and glommio. This aligns with the concept of runtime choices for asynchronous execution. The second excerpt discusses a modern Rust runtime testing/verification project focused on Tokio-related tooling (loom) that contributes to understanding how asynchronous runtimes behave under concurrency, which ties into practical runtime usage and verification. The next group of excerpts comes from the Loom documentation and related materials, which describe Loom as a testing tool for concurrent Rust code and discuss how it deterministically explores concurrency permutations, which is relevant to validating async runtimes and async code paths under various schedules. The subsequent Loom-related entries expand on how Loom operates, its relationship to the Rust memory model, and its role in concurrency testing, further situating runtime behavior in the ecosystem. Taken together, these excerpts address: (1) what async runtimes exist for Rust and which are recommended, (2) tooling around testing and verifying async/runtime behavior, and (3) broader concurrency tooling that interacts with asynchronous code paths. The most direct pieces (the runtime recommendations and Tokio-related tooling) provide strong, explicit support for the field value, while the Loom-specific items give supportive context about testing runtimes and their concurrency properties. The set thus provides a coherent view of async runtimes and related tooling in Rust, with the highest relevance from excerpts that name runtimes and discuss runtime choices directly, followed by excerpts focused on testing/verification tooling related to async/concurrency.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.17",
      "citations": [
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            ".\n\nThese data structures are most commonly used in work-stealing schedulers. The typical setup\ninvolves a number of threads, each having its own FIFO or LIFO queue (*worker*). There is also\none global FIFO queue (*injector*) and a list of references to *worker* queues that are able to\nsteal tasks (*stealers*).",
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        }
      ],
      "reasoning": "The most directly relevant passages describe how tasks are scheduled and executed across multiple threads, i.e., how a scheduler distributes work among worker threads. The excerpt stating that a scheduler is fed by pushing a new task onto the injector queue and that each worker thread waits in a loop to find the next task to run provides a concrete description of the multi-thread scheduling mechanism in a runtime or scheduler. The adjacent passages elaborating on the internal data structuresâ€”local worker queues, global injector, and stealersâ€”further clarify how a work-stealing scheduler coordinates work among multiple threads, which matches the concept of a multi-thread scheduler central to asynchronous runtimes. The mention that a thread pool uses a work-stealing scheduler in Rayon reinforces the general pattern of multi-thread scheduling in Rust ecosystems. Taken together, these excerpts directly support the notion of a multi-thread scheduler and its operational mechanics in async or concurrent Rust contexts, including work-stealing strategies and thread-local task queues. These excerpts collectively substantiate the target field value by detailing the scheduling model across multiple threads and the flow of work between producers (injector/queue) and multiple workers. The strongest, most direct support comes from the explicit scheduler looping over tasks and the explicit description of work-stealing deque structures. The Rayon-threadpool reference corroborates this pattern in another well-known Rust ecosystem context, strengthening the overall relevance.\n\nDirect connections:\n- The excerpt describing spawning a task onto the scheduler, and workers looping to fetch the next task, maps to the concept of a multi-thread scheduler coordinating task execution across threads.\n- The excerpts describing work-stealing deques and a global injector/stealer setup map to the concrete mechanisms by which multiple threads balance and steal work, i.e., a multi-thread scheduling strategy.\n- The Rayon ThreadPool excerpt explicitly names a work-stealing scheduler, tying the concept to a real-world Rust library that embraces multi-thread scheduling for parallel workloads.\n\nIn summary, the selected excerpts collectively provide a coherent view of a multi-thread scheduler with work-stealing characteristics, which aligns with the finegrained field value describing asynchronous scheduling across multiple threads.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.16",
      "citations": [
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ..."
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*."
          ]
        },
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "More specifically, an await expression has the following effect. 1. Create a future by calling [`IntoFuture::into_future`](../../core/future/into_future/trait.IntoFuture.html.into_future) on the future operand. 2. Evaluate the future to a [future](../../core/future/future/trait.Future.html) `tmp` ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        },
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`"
          ]
        }
      ],
      "reasoning": "- The clearest direct reference to an executor concept appears where the text states that a waker is created by an executor and is used in conjunction with a Futureâ€™s poll, which ties the executor to driving progress of asynchronous tasks. This shows the role of an executor in waking and polling futures as part of task progression. - References to runtimes such as the Tokio runtime also strongly relate to executors, since Tokio provides an async runtime that drives the execution of asynchronous tasks via its executor. This helps connect the abstract notion of an executor to concrete implementations in Rust. - Additional context about schedulers or executors is provided by discussions of how tasks are scheduled and polled in executors or schedulers (e.g., a scheduler injecting tasks and workers looping to pick next tasks). These passages tie the concept of an executor to the mechanism that schedules and runs asynchronous work, which is central to how executors function. - The excerpts about polling futures, awaiting, and structured concurrency describe the operational flow of asynchronous tasks and how the runtime progresses them; while not always naming â€œexecutor,â€ they describe the machinery an executor would manage (polling, waking, and task scheduling). - Other excerpts discuss futures, pinning, and awaiting, which are components that executors coordinate, further reinforcing how executors fit into Rustâ€™s async model. - Some sources discuss high-level concurrency runtimes (e.g., a runtime like Tokio) and their role in choosing an asynchronous executor, which aligns with the fieldâ€™s focus on executors as the execution layer for async tasks.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.19",
      "citations": [
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques.",
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            ".\n\nThese data structures are most commonly used in work-stealing schedulers. The typical setup\ninvolves a number of threads, each having its own FIFO or LIFO queue (*worker*). There is also\none global FIFO queue (*injector*) and a list of references to *worker* queues that are able to\nsteal tasks (*stealers*)."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "An `Arc` is a smart pointer that provides shared ownership of a value across multiple threads. It uses [atomic operations](https://doc.rust-lang.org/std/sync/atomic/) and [reference counting](https://doc.rust-lang.org/std/rc/) to efficiently track the number of references to the shared data.",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:"
          ]
        }
      ],
      "reasoning": "The most directly supporting excerpts describe work-stealing schedulers and their practical implementation. A passage explicitly stating that concurrent work-stealing deques are used, and that a scheduler can spawn tasks and balance work by letting workers steal from others, directly aligns with the concept of a work-stealing scheduler. Additional nearby passages describe the scheduling architecture (local worker queues, an injector, stealer queues) that underpin such schedulers, which helps connect the general idea to concrete implementations. A ThreadPool example in the Rayon crate also explicitly references a work-stealing scheduler, reinforcing the applicability of the concept across Rust concurrency ecosystems. Together, these excerpts substantiate the field value by detailing the architecture, terminology, and concrete implementations that define a work-stealing scheduler in Rust ecosystems.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.13",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Simple**: Few dependencies, minimal codebase, fast to compile"
          ]
        }
      ],
      "reasoning": "- The most directly relevant excerpt explicitly mentions Tokio in the context of async runtimes for Rust, describing Tokio as the likely default or preferred runtime for many users in the HTTP/networking domain. This provides concrete evidence that Tokio is a central async runtime option discussed in Rust literature and discourse. \n- An excerpt about asynchronous cancellation in Rust, while not naming Tokio, demonstrates broader concerns and mechanisms around asynchronous execution in Rust, which is the same domain in which Tokio operates. It supports the context that Tokio is part of the wider async Rust ecosystem, even if it doesnâ€™t name Tokio directly. \n- Other excerpts highlighting general async patterns or tooling (for example, an excerpt noting that there are async runtimes, mentioning asynchronous interfaces in libraries like Flume) help situate Tokio within the ecosystem of async I/O and runtime options, reinforcing that Tokio is part of the broader discussion around researching Rustâ€™s asynchronous programming landscape. These provide supportive, though less direct, context about Tokioâ€™s role. ",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.18",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        }
      ],
      "reasoning": "The field value points to a concept of a per-thread scheduling mechanism used in asynchronous work. Excerpts that discuss async runtimes and their scheduling behavior provide direct alignment: a discussion of an async runtime (tokio, a prominent async runtime) implicates an event loop or scheduler that drives futures on a thread pool or per-thread basis, which maps closely to the idea of a current-thread scheduler in an asynchronous setting. Excerpts that describe how scheduling is organized in a concurrent systemâ€”such as per-thread work queues, local queues, and central injectorsâ€”provide a concrete mechanism by which a current-thread scheduler could coordinate tasks and progress. In particular, an excerpt describing an async runtime and its scheduling surface (tokio) captures the notion of a per-thread scheduling entity that governs how asynchronous tasks are progressed. A subset of excerpts discuss concurrency runtimes and scheduling strategies in more concrete terms: one excerpt explicitly mentions a per-thread, possibly single-threaded, scheduling approach in the context of an async runtime; another excerpt discusses work-stealing schedulers in multi-threaded environments, which contrasts with a single-thread-per-core scheduler and thus highlights the per-thread scheduling paradigm. A separate excerpt discusses structured concurrency and task scoping, which informs scheduling discipline but is broader than a single per-thread scheduler. Finally, other excerpts discuss concurrency patterns (e.g., work-stealing deques) that imply sophisticated scheduling but do not necessarily map to a per-thread scheduler per se. Taken together, the strongest support comes from the excerpts that address per-thread or single-threaded scheduling models within async runtimes, followed by those detailing per-thread task queues and stealer-based scheduling, and then more general concurrency patterns that touch on scheduling concepts. ",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.25",
      "citations": [
        {
          "title": "sync_channel in std::sync::mpsc",
          "url": "https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html",
          "excerpts": [
            "Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent."
          ]
        },
        {
          "title": "Crossbeam-channel Documentation",
          "url": "http://docs.rs/crossbeam-channel/latest/crossbeam_channel",
          "excerpts": [
            "Creating a bounded channel:",
            "Channels can be created using two functions:"
          ]
        },
        {
          "title": "Flume - Rust",
          "url": "https://docs.rs/flume",
          "excerpts": [
            "Unbounded, bounded and rendezvous queues"
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "The main `crossbeam` crate just [re-exports](/crossbeam-rs/crossbeam/blob/master/src/lib.rs) tools from\nsmaller subcrates:",
            "* [`crossbeam-channel`](/crossbeam-rs/crossbeam/blob/master/crossbeam-channel)\n  provides multi-producer multi-consumer channels for message passing"
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "A blazingly fast multi-producer, multi-consumer channel."
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpts explicitly describe bounded channels or bounded-channel concepts. One excerpt defines a bounded channel in terms of the sync_channel pattern, noting that data sent on the SyncSender will become available on the Receiver in the same order, which is a canonical bounded-channel behavior. Another excerpt explicitly labels a bounded channel in a section about creating such a channel. Additional excerpts discuss channels with bounded characteristics or reference bounded queues in related channel crates, such as Crossbeam and Flume, which commonly expose bounded (and unbounded) channel variants. These directly support the field value by illustrating how bounded channels are created, what guarantees they provide (bounded capacity, synchronous handoff, or rendezvous semantics), and how they compare to unbounded variants. The remaining excerpts provide relevant container context (e.g., mentioning unbounded channels, MPMC channels, or general channel concepts) but do not focus on bounded-channel specifics as directly. Taken together, the strongest support comes from the explicit bounded-channel definitions and creation guidance, with supportive context from related bounded-channel discussions in other crates.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.24",
      "citations": [
        {
          "title": "sync_channel in std::sync::mpsc",
          "url": "https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html",
          "excerpts": [
            "Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Ergonomic**: Powerful `select`-like interface",
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Simple**: Few dependencies, minimal codebase, fast to compile",
            "* **Capable**: Additional features like MPMC support and send timeouts/deadlines",
            "* **Familiar**: Drop-in replacement for `std::sync::mpsc`",
            "* **Flexible**: `Sender` and `Receiver` both implement `Send + Sync + Clone`",
            "* **Safe**: No `unsafe` code anywhere in the codebase!",
            "* **Fast**: Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`",
            "* **Featureful**: Unbounded, bounded and rendezvous queues",
            "\nSummary[Source](../src/flume/lib.rs.html)\n\nExpand description\n\n[Â§]()Flume\n----------------\n\nA blazingly fast multi-producer, multi-consumer channel."
          ]
        }
      ],
      "reasoning": "Backpressure in asynchronous systems is commonly implemented via bounded or rendezvous channels that throttle producers when the consumer canâ€™t keep up. The most direct support comes from a description of a synchronous, bounded channel where sending blocks until there is space, which is a canonical backpressure mechanism. This shows how producers are slowed by backpressure when the sink canâ€™t keep up. Related entries discuss Flumeâ€™s async-channel characteristics, highlighting features like multi-producer, multi-consumer channels and the availability of bounded and rendezvous queues, which illustrate practical backpressure behavior in Rustâ€™s async ecosystem. Taken together, these excerpts illustrate how backpressure operates in practice: producers may be paused (blocked) when downstream consumers arenâ€™t ready, and channel design (bounded vs unbounded) determines whether backpressure propagates upstream. Direct mention of bounded channels and their blocking behavior provides the strongest support for the field value. The other Flume excerpts expand on the ecosystemâ€™s options for backpressure-enabled primitives (e.g., MPMC and rendezvous patterns), enriching the context for how backpressure is implemented in Rustâ€™s async tooling.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.22",
      "citations": [
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        }
      ],
      "reasoning": "Excerpts that explicitly introduce the concept of structured concurrency provide direct support for the field value. The first excerpt states structured concurrency as a programming paradigm and describes its core idea of organizing concurrent operations within defined scopes or structures, which directly matches the term and concept. The second excerpt likewise discusses structured concurrency in the Rust context, reinforcing that it is a recognized pattern for organizing concurrency with clear boundaries and scopes. The remaining excerpts discuss concurrency in Rust (e.g., structured concurrency being a design goal or related scheduling patterns) but do not explicitly name or define the structured concurrency concept, so they offer partial context rather than direct support for the exact field value. Therefore, the first two excerpts are the most relevant, with the third providing peripheral context.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.26",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "1. \n   An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function\n   will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an\n   infinite b",
            "These channels come in two flavors:",
            "A [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") . Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).",
            "* [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")",
            "Multi-producer, single-consumer FIFO queue communication primitives."
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n"
          ]
        }
      ],
      "reasoning": "The target field is tokio::sync::mpsc, which denotes the Tokio libraryâ€™s multi-producer, single-consumer channel module. The most directly relevant material is content that explicitly discusses Tokio as a primary async runtime and references tokio as the runtime to use for async networking or channels. An excerpt highlighting that tokio is the recommended runtime for asynchronous networking reinforces relevance to the field value since tokio::sync::mpsc is a Tokio-provided channel API. Related material about channels in Rust broadly (for example, std::mpsc-style channels or multi-producer/multi-consumer channels in Crossbeam) provides contextual support for how channels work in Rust, which helps situate tokio::sync::mpsc within the broader ecosystem of asynchronous message-passing utilities. Content about specific channel implementations in other crates (Crossbeam, Flume, std::sync::mpsc) is less directly applicable to the exact field value but still relevant as supporting context for channel-based communication in Rust. Therefore, I rank the excerpts as follows: the Tokio-focused runtime/excerpt is most directly supportive of the field value; excerpts describing channel concepts in Rust (including std::sync::mpsc and Crossbeam) are next in relevance because they provide necessary background; and any content referencing general async runtimes or channels without naming Tokio or tokio::sync::mpsc is considered lower relevance.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.28",
      "citations": [
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Capable**: Additional features like MPMC support and send timeouts/deadlines"
          ]
        }
      ],
      "reasoning": "The excerpt describes a Rust crate (Flume) that explicitly mentions timeouts in its feature set, stating it includes send timeouts and deadlines. This directly supports the finegrained field value 'timeouts' as a relevant keyword within asynchronous programming concepts. Other excerpts mention async features or channels but do not directly reference 'timeouts', so they provide only peripheral context rather than direct support.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.30",
      "citations": [
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2",
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum"
          ]
        },
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        }
      ],
      "reasoning": "- The most directly relevant passage explicitly discusses a specific async cancellation topic, signaling a focused treatment of cancellation within async contexts and serving as a central anchor for the field value. It frames cancellation in the context of async Rust and outlines the broader discussion around how async operations may be cancelled or aborted, which maps cleanly to the requested field value.\n- A closely related excerpt directly addresses cancel-safety in async code and the behavior of cancellation semantics inside asynchronous constructs like tokio::select. This provides a concrete technical angle on how cancellation interacts with async control flow, aligning with the fieldâ€™s focus on cancellation in asynchronous programming.\n- An adjacent excerpt expands on cancellation concerns by discussing cancellation safety in async contexts (in particular, how cancellation interacts with memory, borrows, or task lifetimes). This reinforces the cancellation theme and provides deeper grounding for the policy/semantics around cancellation.\n- Another excerpt contributes by explicitly mentioning cancellation in the context of asynchronous clean-up, i.e., how cancellation affects cleanup tasks or cleanup behavior in async workflows. This broadens the scope to include post-cancellation behavior, which is relevant to understanding cancellation in practice.\n- The remaining excerpt brings in a broad discussion of cancel-safety/panic considerations and related notes, further situating cancellation within the ecosystem of Rustâ€™s error handling and runtime semantics. Although more tangential, it still reinforces cancellation considerations within Rustâ€™s execution model.\nOverall, the collected excerpts form a coherent set that directly addresses cancellation in asynchronous Rust, from high-level cancellation concepts to concrete safety considerations and runtime patterns, supporting the finegrained field value with multiple converging sources.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.6",
      "citations": [
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ..."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;"
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly describes the role of Context in the async execution model: it states that the Waker is constructed by an executor, wrapped in a Context, and then used when calling Future::poll. This directly ties the concept of a Context to how asynchronous tasks are driven and polled, which aligns with the target field value focusing on Context within asynchronous programming. A closely related excerpt discusses polling a future with the current task context, illustrating how the runtime provides or uses a contextual environment during poll, further grounding the idea that Context (in some form) is integral to the poll cycle in async runtimes. Together, these excerpts establish Context as the contextual environment that enables waking, polling, and advancing asynchronous computations, which is exactly the concept the field value aims to capture.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.32",
      "citations": [
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "Cancel safety is mostly not relevant for kill signals because you don't care if you lost some data from the connection if you're killing it.",
            "This happens with [`recv` on Tokio channels](https://docs.rs/tokio/1.27.0/tokio/sync/mpsc/struct.Receiver.html.recv) , since all the state is in the channel, and _not_ in the future returned by `recv()` .",
            "The easy way to avoid this is for the futures in the `select!` to not own state, but to borrow it from elsewhere; for example, if `buffered_stream` owns all the state, and the future returned by `read_msg()` mutates `buffered_stream` instead of storing its own state, you're cancellation-safe.",
            "If those futures own some form of state, then your future is not cancellation safe, since that owned state will be dropped when another future returns `Poll::Ready` .",
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
            "That is the basic gist of it. The underlying issue with cancellation safety is that all futures in the select other than the future that yields `Poll::Ready` will be dropped.",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2"
          ]
        },
        {
          "title": "Rust Cancel Safety and Panics (as provided in the document)",
          "url": "https://rfd.shared.oxide.computer/rfd/400",
          "excerpts": [
            " runtime is\n   shut down due to a panic, then the task is cancelled. "
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "oml\n[profile.release]\npanic = 'abort'\n```",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:"
          ]
        }
      ],
      "reasoning": "The most relevant excerpt directly refers to cooperative cancellation in the context of asynchronous work: it discusses how cooperative cancellation can fail when a unit of work does not opt into cancellation, causing it to run to completion. This directly aligns with the idea of cooperative cancellation as a concept within asynchronous programming in Rust. Excerpt about asynchronous cancellation in a blog post provides additional context on cancellation in async Rust, including the broader notion of cancellation behavior and patterns, which helps ground the cooperative cancellation idea in practical discussion. Excerpts covering cancel safety in async environments highlight design considerations and safety guarantees when cancellation semantics interact with async runtimes like Tokio, which is closely related to cooperative cancellation in real systems. Together, these excerpts establish a gradient from a precise instance of cooperative cancellation to broader cancellation mechanisms and safety concerns that influence how cooperative cancellation is implemented and reasoned about in Rust async code. The direct and explicit reference to cooperative cancellation in the first cited excerpt is the strongest support for the finegrained field value, while the others provide broader context about cancellation semantics, safety, and practical considerations in asynchronous Rust programming.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.23",
      "citations": [
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        }
      ],
      "reasoning": "The target field value corresponds to a Tokio-based mechanism for structured concurrency, i.e., a scoped or hierarchical approach to spawning and managing asynchronous tasks. The most directly relevant excerpt discusses structured concurrency and explicitly references Tokio in its title, indicating a focus on how Tokio relates to the structured concurrency paradigm. This excerpt supports the notion that Tokio participates in or is a practical ground for implementing structured concurrency concepts like scoped tasks. A closely related excerpt introduces a Rust crate approach to structured concurrency (task_scope) and explains the idea of scoped task management in Rust, which aligns with the same design space as tokio::task::scope by providing a concrete, library-level embodiment of scoped async execution. This confirms that scoped concurrency is a recognized pattern in Rust and that there are explicit implementations or crates mirroring the same concept, which helps reason about how tokio::task::scope would fit into the ecosystem. An additional excerpt discusses tokio as a runtime and mentions tokio in the context of choosing an async runtime, reinforcing the idea that Tokio is the primary runtime in this space and that scoped concurrency features would be a natural fit or topic of interest within Tokioâ€™s design. Taken together, these excerpts collectively support the relevance of tokio::task::scope to structured concurrency in Rustâ€™s async ecosystem, with the first piece providing Tokio-specific context, the second offering concrete scoped-concurrency tooling via an alternative crate, and the third reinforcing Tokioâ€™s central role as an async runtime.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.44",
      "citations": [
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        },
        {
          "title": "keeping `Rc` across `await` should not make future `!Send` ...",
          "url": "https://users.rust-lang.org/t/controversial-opinion-keeping-rc-across-await-should-not-make-future-send-by-itself/100554",
          "excerpts": [
            "Some people dogmatically believe that keeping Rc across await inevitably makes future !Send, thus making it impossible to migrate its execution across executor ..."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")",
            "3. Pin `tmp` using [`Pin::new_unchecked`](../../core/pin/struct.Pin.html.new_unchecked) ;",
            "More specifically, an await expression has the following effect. 1. Create a future by calling [`IntoFuture::into_future`](../../core/future/into_future/trait.IntoFuture.html.into_future) on the future operand. 2. Evaluate the future to a [future](../../core/future/future/trait.Future.html) `tmp` ;",
            "4. This pinned future is then polled by calling the [`Future::poll`](../../core/future/future/trait.Future.html.poll) method and passing it the current [task context]() ;",
            "5. If the call to `poll` returns [`Poll::Pending`](../../core/task/poll/enum.Poll.html.Pending) , then the future returns `Poll::Pending` , suspending its state so that, when the surrounding async context is re-polled,execution returns to step 3;"
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        },
        {
          "title": "Waker in std::task - Rust",
          "url": "https://doc.rust-lang.org/beta/std/task/struct.Waker.html",
          "excerpts": [
            "The typical life of a Waker is that it is constructed by an executor, wrapped in a Context , then passed to Future::poll() . Then, if the future chooses to ..."
          ]
        }
      ],
      "reasoning": "The core concept of holding a lock during an await would involve how async tasks can be blocked or suspended around an await point, potentially while a lock is held. The most directly relevant items discuss blocking and blocking-related caveats in async contexts: a post warning not to ignore blocking concerns in async code highlights that async is not a cure-all for blocking scenarios, which is the closest explicit caution related to holding resources across awaits. Assertions that awaiting a future is a non-blocking operation (for example, the typical pattern of awaiting a future rather than polling explicitly) provide context for why holding a lock across an await could be problematic in practice. Other excerpts discuss the mechanics of await and poll, which are relevant to understanding when an async task can yield control and when it can continue with a protected critical section. We thus connect these excerpts to the field by: (1) referencing the guidance that blocking in async code is still a concern, (2) noting the mechanics of how futures are driven across await/poll cycles, and (3) acknowledging general cautions around cross-boundary state (locks, spans of time during awaits) in asynchronous execution. Although none of the excerpts unambiguously state a rule about holding locks across await, the combination of guidance on blocking, and the description of await/poll flow provides partial support for understanding risks involved when a lock is held across an await point.",
      "confidence": "low"
    },
    {
      "field": "asynchronous_programming_keywords.41",
      "citations": [
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")"
          ]
        },
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        }
      ],
      "reasoning": "- A direct source explains that a Future is an asynchronous computation and typically you donâ€™t call poll directly; instead you await the value. This captures a fundamental pattern in async programming: you yield control and let the runtime drive progress, which is essential when thinking about how sync operations might interleave with async work.\n- Another excerpt clarifies the core method poll itself and how it operates by scheduling wakeups rather than blocking, which highlights the non-blocking nature at the core of futures. This supports understanding how async should avoid blocking threads and how coordination with the runtime works when awaiting completion.\n- A third excerpt describes the await expression and its sequencing around poll results, reinforcing the flow of asynchronous progress and the typical path of awaiting instead of polling manually. This adds nuance to how async code progresses without blocking in the conventional sense.\n- A fourth excerpt explicitly discusses blocking in async contexts from a contrasting viewpoint: the claim that async is not meant to prevent blocking in all scenarios, especially when OS or external factors cause blocking. This directly ties to the concept of syncing between async and sync components and cautions about where blocking might occur within an otherwise asynchronous workflow.\n- A fifth excerpt addresses a practical meme about not over-worrying about blocking in async, reflecting the ongoing debate and practical considerations when balancing synchronous work inside or alongside asynchronous code. This is relevant as it contextualizes the tensions around sync/async boundaries and blocking semantics in real-world Rust code.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.47",
      "citations": [
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        }
      ],
      "reasoning": "The field value 'async fn in traits' concerns how asynchronous functions can be defined within traits. The clearest and most direct information about this topic in the provided excerpts comes from a source that explicitly documents an approach to enabling async functions inside trait definitions. It states that there is a crate which provides an attribute macro to make async fn in traits work with dyn traits, i.e., it directly addresses the core concept of async functions in trait contexts and how to implement or simulate that capability. This directly supports the field value by naming the feature (async fns in traits) and describing the tooling approach to realize it in Rust.\n\nOther excerpts discuss related asynchronous concepts (e.g., awaiting futures, async runtimes, or concurrency patterns) but they do not explicitly address the mechanism for declaring async fn inside traits. They provide useful background about async/await, futures, and concurrency, which helps situate the topic but do not directly confirm or define how async fns in traits are achieved in Rust today. Therefore, they are considered less directly relevant to the exact field value and are ranked accordingly as supporting context rather than direct evidence.\n",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.42",
      "citations": [
        {
          "title": "Do NOT stop worrying about blocking in async functions!",
          "url": "https://www.reddit.com/r/rust/comments/ebpzqx/do_not_stop_worrying_about_blocking_in_async/",
          "excerpts": [
            "Async is not meant to prevent blocking in situations where the OS forces the thread to block for reasons that are out of the program's control, ..."
          ]
        }
      ],
      "reasoning": "The fine-grained field value pertains to the phenomenon of blocking occurring in asynchronous code paths. The most directly relevant excerpt explicitly discusses this concern: it states that Async is not meant to prevent blocking in situations where the OS forces the thread to block, highlighting that blocking can still occur in async contexts and is not inherently avoided by async programming. This directly supports the idea captured by the field value about blocking behavior within asynchronous execution. Additional surrounding excerpts discuss how futures are polled, awaited, or scheduled, which provide context about the mechanics of asynchronous execution but do not directly assert blocking, so their relevance is more peripheral. The explicit note about blocking in async functions establishes a clear, primary connection to the field value, while the surrounding discussion of async mechanics offers supportive context that blocking is sometimes unavoidable due to external (OS/runtime) conditions rather than intrinsic to async primitives.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.48",
      "citations": [
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value identifies the async-trait crate as the source context. The most relevant excerpt explicitly states that this crate provides an attribute macro to make async functions in traits work with dyn traits, and it notes its presence on crates.io. This directly supports the notion that the field value is about the async-trait crate and its purpose. Related mentions of general async runtimes or unrelated async topics do not directly corroborate the specific crateâ€™s function, so they are less relevant for this field.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.50",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        }
      ],
      "reasoning": "The field value refers to an asynchronous runtime crate name used in Rust async programming. Among the provided excerpts, the one discussing â€œBest Async Runtime for HTTP/Networking?â€ explicitly lists candidate runtimes and includes a mention of glommio as a promising option, directly supporting the field value. Other excerpts discuss different runtimes or general async/concurrency topics but do not mention glommio, so they provide only peripheral context. Therefore, the cited excerpt most strongly supports the field value by directly referencing glommio as a runtime option in the context of asynchronous programming.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.45",
      "citations": [
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`."
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            "`Arc`\nA thread-safe reference-counting pointer. â€˜Arcâ€™ stands for â€˜Atomically\n    Reference Countedâ€™.\n",
            "`LazyLock`\nUsed for thread-safe, one-time initialization of a\n  variable, using one nullary initializer function provided at creatio\n"
          ]
        }
      ],
      "reasoning": "- The most directly relevant excerpt states that the Rust concurrency guarantees hinge on the Send and Sync traits, which are the fundamental bounds that allow types to be transferred or shared across threads in asynchronous or concurrent contexts. This directly supports understanding what a Send bound means in practice and why it is required for safe async concurrency.\n- A broader discussion of trait bounds and how they are expressed (where clauses, associated bounds) is relevant to how a Send bound might be specified in generic contexts. This excerpt explains that trait bounds can be written after a type or within where clauses, which is the mechanism by which Send (as a bound) would be enforced in generic API definitions used in async code.\n- An example asserting that Arc is a thread-safe, reference-counted pointer ties into Send-bound concepts, illustrating how a type being Send (and Sync) interacts with multi-threaded/asynchronous usage, via a concrete type that is safe to move across threads.\n- Additional reference to Arc being used with Mutex and other concurrency primitives reinforces how Send-bound guarantees enable safe sharing and synchronization in asynchronous patterns, making it a supportive piece for understanding practical Send bounds in async code.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.46",
      "citations": [
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) ."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``"
          ]
        }
      ],
      "reasoning": "The 'static lifetime bound is a concrete lifetime bound in Rust that denotes data with a static lifetime, i.e., data that lives for the entire duration of the program. An excerpt explicitly states that the 'static lifetime is the meaning of the static lifetime and that it cannot be used as a generic lifetime parameter, which directly supports understanding what a 'static bound means in type signatures. Another excerpt discusses default object lifetime bounds and elision rules, which contextualize how lifetimes are inferred or constrained in Rust, helping explain when a 'static bound would be enforced or assumed in a type or trait object. A third excerpt highlights that 'static is the lifetime associated with the static lifetime and provides clarity on its distinct role from other lifetimes, reinforcing why a 'static bound is a meaningful and distinct constraint in asynchronous or multi-threaded contexts where long-lived data must be referenced safely.",
      "confidence": "high"
    },
    {
      "field": "asynchronous_programming_keywords.55",
      "citations": [
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        },
        {
          "title": "Future in std::future - Rust",
          "url": "https://doc.rust-lang.org/std/future/trait.Future.html",
          "excerpts": [
            "\n\nA future represents an asynchronous computation obtained by use of [`async`](../../std/keyword.async.html) . A future is a value that might not have finished computing yet.",
            "The core method of future, `poll`, *attempts* to resolve the future into a\nfinal value. This method does not block if the value is not ready. Instead,\nthe current task is scheduled to be woken up when itâ€™s possible to make\nfurther progress by `poll`ing again.",
            ". When using a future, you generally wonâ€™t call `poll` directly, but instead `.await` the value."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")"
          ]
        },
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        }
      ],
      "reasoning": "The target field value is a specific library name used for asynchronous GraphQL in Rust. I searched the provided excerpts for any explicit reference to that library name. None of the excerpts quote or mention the exact token â€œasync-graphql.â€ However, several excerpts directly discuss asynchronous programming in Rust, including futures, awaiting, and async runtimes, which are thematically aligned with the libraryâ€™s domain (async GraphQL would be implemented on top of Rustâ€™s async ecosystem). For instance, passages describe the Future trait and its core methods, how awaiting is used to obtain results, and guidance around async runtimes and task scheduling. These pieces establish the conceptual backdrop for asynchronous GraphQL libraries but do not prove the existence or usage of the exact library in question. Additionally, one excerpt refers to an â€œasync traitâ€ crate on crates.io, which is adjacent in topic (asynchronous traits in Rust) but does not mention the exact library name. Taken together, the excerpts support the general domain (async Rust and libraries) but not the precise field value itself. Therefore, the evidence is best characterized as partial alignment rather than direct confirmation.â€",
      "confidence": "low"
    },
    {
      "field": "asynchronous_programming_keywords.56",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "Rust Reference: Expressions/await-expr",
          "url": "https://doc.rust-lang.org/reference/expressions/await-expr.html",
          "excerpts": [
            "6. Otherwise the call to `poll` must have returned [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) , in which case the value contained in the [`Poll::Ready`](../../core/task/poll/enum.Poll.html.Ready) variant is used as the result of the `await` expression itself. [[expr .await .edition2018]](.await.edition2018 \"expr.await.edition2018\")"
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Ergonomic**: Powerful `select`-like interface"
          ]
        }
      ],
      "reasoning": "tokio::select! is a macro in the Rust async ecosystem used to select between multiple asynchronous branches, similar in spirit to selecting between futures or tasks. The most directly relevant excerpt explicitly identifies tokio as the preferred Async Runtime for HTTP/Networking, which anchors the practical ecosystem in which tokio::select! is used. The excerpt also in broader terms discusses async runtimes and the async ecosystem, supporting the general context in which a select-like primitive would be employed. Another excerpt discusses await expressions in the Rust reference, which grounds understanding of how awaiting multiple futures is typically done in async code, providing adjacent conceptual support for the kind of control flow tokio::select! enables. A separate excerpt on Structured Concurrency describes organizing concurrent async tasks into scopes, which is conceptually related to the ways select-like constructs help coordinate multiple async tasks. Additional excerpts touch on the broader async/concurrency tooling landscape (e.g., loom for deterministic testing and other concurrency primitives) to provide context on the ecosystem where tokio::select! sits, even if they do not mention the macro by name.",
      "confidence": "medium"
    },
    {
      "field": "asynchronous_programming_keywords.53",
      "citations": [
        {
          "title": "Best Async Runtime for HTTP/Networking? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dhstbj/best_async_runtime_for_httpnetworking/",
          "excerpts": [
            "tokio - The way to go for most users, seems pretty heavy. ; smol - Lightweight tokio alternative. ; glommio - Uses iouring. Looks promising;."
          ]
        },
        {
          "title": "async-trait - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/async-trait",
          "excerpts": [
            "Aug 14, 2025 â€” This crate provides an attribute macro to make async fn in traits work with dyn traits. Please refer to why async fn in traits are hard for aÂ ..."
          ]
        },
        {
          "title": "Structured Concurrency Support Â· Issue #1879 Â· tokio-rs/tokio",
          "url": "https://github.com/tokio-rs/tokio/issues/1879",
          "excerpts": [
            "Structured concurrency describes programming paradigm. Concurrent tasks are structured in a fashion where there exist clean task hierarchies."
          ]
        },
        {
          "title": "task_scope - Rust",
          "url": "https://docs.rs/task_scope/latest/task_scope/",
          "excerpts": [
            "Structured Concurrency is a programming paradigm that lets asynchronous operations run only within certain scopes so that they form an operation stack like a ..."
          ]
        }
      ],
      "reasoning": "To connect the fine-grained field value to the available excerpts, consider what tokio-tungstenite represents: an asynchronous WebSocket solution built on top of Tokio, typically used in Rust for async I/O and networked applications. A first strong signal is discussion of an async runtime and Tokio in particular, which anchors the ecosystem where tokio-tungstenite would operate. The excerpt noting Tokio as the go-to runtime for many users directly situates tokio-tungstenite within the common Tokio-based async stack, making it highly relevant as contextual grounding for this field value. A closely related excerpt discusses async traits crates, which are part of the broader async ecosystem and frequently used alongside Tokio-based libraries; this is highly supportive of understanding the asynchronous tooling around tokio-tungstenite, even if it does not name the specific crate. A third excerpt frames structured concurrency and Tokio-style asynchronous patterns, which helps situate tokio-tungstenite within contemporary concurrency design in Rust, thus supporting the field value by providing architectural context. A fourth excerpt highlights the two-phase borrow model and other Rust async-related topics but is comparatively less directly connected to the tokio-tungstenite ecosystem; it remains relevant as background on async design patterns in Rust and could inform a deeper search for Tokio-based WebSocket crates. Overall, the strongest support comes from explicit references to Tokio as an async runtime and to the async ecosystem (including crates like async-trait), with progressively weaker but still pertinent context from structured concurrency and broader async discussions.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords",
      "citations": [
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(... )` . There are two ways to define new macros:",
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression.",
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument"
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) ",
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured.",
            "This crate primarily contains a [`TokenStream`](../proc_macro/struct.TokenStream.html) type. Procedural macros operate\nover _token streams_ instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target.",
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token.",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have.",
            ", procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](.",
            "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`](../core/macro.compile_error.html) macro invocation.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``",
            ") .\nThe `proc_macro` crate provides types required for\nwriting procedural macros and facilities to make it easier. [[macro .proc .proc\\_macro .to",
            "The `proc_macro` attribute defines the macro in the [macro namespace](names/namespaces.html) in the root of the crate."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation.",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site.",
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |",
            "MacroFragSpec",
            "MacroMatch",
            "MacroMatcher",
            "MacroRules",
            "MacroRulesDefinition",
            "\nLabels and local variables defined in macro expansion are not shared between invocations, so this code doesnâ€™t compile",
            "MacroRule",
            "MacroTranscriber",
            "Token",
            "MacroRepOp"
          ]
        },
        {
          "title": "12: Macro Hygiene - MacroKata - tfpk.io",
          "url": "https://tfpk.github.io/macrokata/12_README.html",
          "excerpts": [
            "To alleviate this, the $crate metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro. Refer to The Little Book Of Rust Macros for more on the considerations around macro hygiene. Exercise 12. Exercise 12 consists of a file containing multipleÂ ..."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "Hygiene",
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)"
          ]
        },
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "Code generation\nSome Cargo packages need to have code generated just before they are compiled\nfor various reasons.",
            "Code generation",
            "The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located.",
            "Thereâ€™s a couple of points of note here:\n    * The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located. It can use the processâ€™ current working\ndirectory to find where the input files should be located, but in this case we\ndonâ€™t have any input files. * In general, build scripts should not modify any files outside of\nOUT_DIR . It may seem fine on the first blush, but it does cause problems when you use\nsuch crate as a dependency, because thereâ€™s an implicit invariant that\nsources in\n.cargo/registry should be immutable. cargo wonâ€™t allow such\nscripts when packaging. * This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as\ngenerating a Rust module from a C header file or another language definition,\nfor example. * The\nrerun-if-changed instruction tells Cargo that the build script only needs to re-run if the build script\nitself changes.\nWithout this line, Cargo will automatically run the build\nscript if any file in the package changes. If your code generation uses some\ninput files, this is where you would print a list of each of those files.",
            "let out_dir = env::var_os(\"OUT_DIR\").unwrap();",
            "let dest_path = Path::new(&out_dir).join(\"hello.rs\");",
            "fs::write(",
            "        &dest_path,",
            "        \"pub fn message() -> &'static str {",
            "{\n            \\\"Hello, World!\\\"",
            "        }",
            "        \"",
            "    ).unwrap();",
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "[`include!` macro](../../std/macro.include.html) in combination with the",
            "[`concat!`](../../std/macro.concat.html) and [`env!`](../../std/macro.env.html) macros to include the",
            "generated file (`hello.rs`) into the crateâ€™s compilation."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "ipts\nSome packages need to compile third-party non-Rust code, for example C\nlibraries. Other packages need to link to C libraries which can either be\nlocated on the system or possibly need to be built from source. Others still\nneed facilities for functionality such as code generation before building (think\nparser generators). Cargo does not aim to replace other tools that are well-optimized for these\ntasks, but it does integrate with them with custom build scripts.",
            "Placing a\nfile named\nbuild.rs in the root of a package will cause Cargo to compile\nthat script and execute it just before building the package.",
            "Some example use cases of build scripts are:\n    * Building a bundled C library. * Finding a C library on the host system. * Generating a Rust module from a specification. * Performing any platform-specific configuration needed for the crate.",
            "Just before a package is built, Cargo will compile a build script into an\nexecutable (if it has not already been built). It will then run the script,\nwhich may perform any number of tasks. The script may communicate with Cargo\nby printing specially formatted commands prefixed with\ncargo:: to stdout.",
            "The build script will be rebuilt if any of its source files or dependencies\nchange. By default, Cargo will re-run the build script if any of the files in the\npackage changes. Typically it is best to use the\nrerun-if commands,\ndescribed in the change detection section below, to\nnarrow the focus of what triggers a build script to run again.",
            "Build scripts are also allowed to have dependencies on other Cargo-based crates. Dependencies are declared through the\nbuild-dependencies section of the\nmanifest.",
            "The\npackage.links key may be set in the\nCargo.toml manifest to declare\nthat the package links with the given native library.",
            "When using the\nlinks key, the package must have a build script, and the\nbuild script should use the\nrustc-link-lib instruction to\nlink the library.",
            "Build scripts can generate an arbitrary set of metadata in the form of\nkey-value pairs. This metadata is set with the\ncargo::metadata=KEY=VALUE instruction. The metadata is passed to the build scripts of dependent packages."
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "## [`format_macro_matchers`]()",
            "Format the metavariable matching patterns in macros.",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3354) )",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "    ($a:ident : $b:ty) => {",
            "    ($a:ident $b:ident $c:ident) => {",
            "See also [`format_macro_bodies`]() .",
            "## [`format_macro_bodies`]()",
            "Format the bodies of declarative macro definitions.",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3355) )",
            "    ($a: ident : $b: ty) => {",
            "    ($a: ident : $b: ty) => {",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "    ($a: ident $b: ident $c: ident) => {",
            "    ($a: ident $b: ident $c: ident) => {",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "    ($a: ident : $b: ty) => { $a(42): $b; };",
            "    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "See also [`format_macro_matchers`]() .",
            "## [`skip_macro_invocations`]()",
            "Skip formatting the bodies of macro invocations with the following names.",
            "rustfmt will not format any macro invocation for macros with names set in this list.",
            "Including the special value \"\\*\" will prevent any macro invocations from being formatted",
            "Note: This option does not have any impact on how rustfmt formats macro definitions.",
            "* **Default value** : `[]`",
            "* **Possible values** : a list of macro name idents, `[\"name_0\", \"name_1\", ..., \"*\"]`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/5346) )",
            "\n\n#### [`[]` (default):](#%5C%5B%5C%5D%5C%20%5C\\(default%5C\\)%5C%3A)",
            "rustfmt will follow its standard approach to formatting macro invocations.",
            "No macro invocations will be skipped based on their name. More information about rustfmt's standard macro invocation formatting behavior can be found in [](https://github.com/rust-lang/rustfmt/discussions/5437) .",
            "#### [`[\"lorem\"]` :](#%5C%5B%5C%22lorem%5C%22%5C%5D%5C%3A)",
            "The named macro invocations will be skipped.",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "#### [`[\"*\"]` :](#%5C%5B%5C%22%5C*%5C%22%5C%5D%5C%3A)",
            "The special selector `*` will skip all macro invocations.",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "lorem!(",
            "lorem!(",
            "lorem!(",
            "ipsum!(",
            "ipsum!(",
            "ipsum!(",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            ");",
            ");",
            ");",
            ");",
            ");",
            ");",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a `build.rs` file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is built. This can be used to generate code at compile time.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and is something\nlike `./target/debug/build/bindgen-tutorial-bzip2-sys-afc7747d7eafd720/out/` .",
            "Now, when we run `cargo build` , our bindings to `bzip2` are generated on the\nfly!"
          ]
        },
        {
          "title": "Generating a versions.rs at build time",
          "url": "https://users.rust-lang.org/t/generating-a-versions-rs-at-build-time/48976",
          "excerpts": [
            "Sep 18, 2020 â€” Set some VERSION_MAJOR, VERSION_MINOR environment variables in the build scripts. Have a build.rs pick these up and generate a versions.rs in the buildÂ ..."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/cargo/reference/build-scripts.html",
          "excerpts": [
            "The stdout output and OUT_DIR locations are also handled by the cc library. Here we can start to see some of the major benefits of farming as much functionalityÂ ..."
          ]
        },
        {
          "title": "Setting the include path with bindgen - rust",
          "url": "https://stackoverflow.com/questions/42741815/setting-the-include-path-with-bindgen",
          "excerpts": [
            "I was hoping to use the bindgen crate to generate the FFI interface without too much fuss, but it doesn't seem to have a way of setting include paths."
          ]
        },
        {
          "title": "`include!(concat!(env!(\"OUT_DIR\"), \"/bindings.rs\"))` should ...",
          "url": "https://github.com/rust-analyzer/rust-analyzer/issues/1964",
          "excerpts": [
            "Oct 7, 2019 â€” To support code-gen from build.rs , we should fully support all elements of include!(concat!(env!(\"OUT_DIR\"), \"/bindings.rs\")) incantation."
          ]
        },
        {
          "title": "function-like and derive procedural macro expansion is here!",
          "url": "https://www.reddit.com/r/rust/comments/zd4mxy/intellij_rust_changelog_184_functionlike_and/",
          "excerpts": [
            "A derive proc-macro is for situations where you want to extend the struct, enum, etc... But need to know the fields, their types, etc."
          ]
        },
        {
          "title": "Rust procedural macros step by step tutorial",
          "url": "https://dev.to/dandyvica/rust-procedural-macros-step-by-step-tutorial-36n8",
          "excerpts": [
            "Using the proc-macro2 crate for debugging and understanding procedural macros. The previous method is unwieldy to say the least, and not meant ..."
          ]
        },
        {
          "title": "proc_macro_error - Rust",
          "url": "https://docs.rs/proc-macro-error",
          "excerpts": [
            "This crate aims to make error reporting in proc-macros simple and easy to use. Migrate from panic! -based errors for as little effort as possible!"
          ]
        },
        {
          "title": "Security breach with Rust macros - compiler - Rust Internals",
          "url": "https://internals.rust-lang.org/t/security-breach-with-rust-macros/14703",
          "excerpts": [
            "**"
          ]
        },
        {
          "title": "Procedural Macros book - #8 by dtolnay - documentation",
          "url": "https://internals.rust-lang.org/t/procedural-macros-book/9113/8",
          "excerpts": [
            "Dec 30, 2018 â€” From a naive perspective this is a very simple macro â€“ it parses some simple input using syn in a simple way and generates some simple outputÂ ..."
          ]
        },
        {
          "title": "dtolnay/proc-macro-workshop: Learn to write Rust ...",
          "url": "https://github.com/dtolnay/proc-macro-workshop",
          "excerpts": [
            "This workshop covers attribute macros, derive macros, and function-like procedural macros. Be aware that the content of the workshop and the explanations inÂ ..."
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "quote in quote - Rust",
          "url": "https://docs.rs/quote/latest/quote/macro.quote.html",
          "excerpts": [
            "Alternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not ..."
          ]
        },
        {
          "title": "proc_macro2 - Rust",
          "url": "https://docs.rs/proc-macro2",
          "excerpts": [
            "By developing foundational libraries like syn and quote against proc_macro2 rather than proc_macro , the procedural macro ecosystem becomes easily applicable to ..."
          ]
        },
        {
          "title": "Rust Structs and Attribute-like and Custom Derive Macros",
          "url": "https://rareskills.io/post/rust-attribute-derive-macro",
          "excerpts": [
            "An attribute-like macro takes in a struct and can completely rewrite it. A derive macro augments a struct with additional functions. Macros ..."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_MACRO\\_RULES : `macro_rule",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "* [strict]()\n* [reserved]()\n* [weak]()\n",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "reserved",
            "weak",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "KW\\_RAW : `raw",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "> **<sup>Lexer 2018+</sup>**",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "/sup>**\n> KW\\_MACRO\\_RULES : `macro_rules`\n> KW\\_UNION : `union`\n> KW\\_STATICLIFETIME : `'static`\n> KW\\_SAFE : `safe`\n> KW\\_RAW : `raw`",
            "These keywords can only be used in their correct contexts. They cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "## [Strict keywords]()",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "## [Weak keywords]()",
            ">**\n> KW\\_ABSTRACT : `abstract`\n> KW\\_BECOME : `become`\n> KW\\_BOX : `box`\n> KW\\_DO : `do`\n> KW\\_FINAL : `final`\n> KW\\_MACRO : `macro`\n> KW\\_OVERRIDE : `override`\n> KW\\_PRIV : `priv`\n> KW\\_TYPEOF : `typeof`\n> KW\\_UNSIZED : `unsized`\n> KW\\_VIRTUAL : `virtual`\n> KW\\_YIELD : `yiel",
            "## [Reserved keywords]()",
            ">**\n> KW\\_AS : `as`\n> KW\\_BREAK : `break`\n> KW\\_CONST : `const`\n> KW\\_CONTINUE : `continue`\n> KW\\_CRATE : `crate`\n> KW\\_ELSE : `else`\n> KW\\_ENUM : `enum`\n> KW\\_EXTERN : `extern`\n> KW\\_FALSE : `false`\n> KW\\_FN : `fn`\n> KW\\_FOR : `for`\n> KW\\_IF : `if`\n> KW\\_IMPL : `impl`\n> KW\\_IN : `in`\n> KW\\_LET : `let`\n> KW\\_LOOP : `loop`\n> KW\\_MATCH : `match`\n> KW\\_MOD : `mod`\n> KW\\_MOVE : `move`\n> KW\\_MUT : `mut`\n> KW\\_PUB : `pub`\n> KW\\_REF : `ref`\n> KW\\_RETURN : `return`\n> KW\\_SELFVALUE : `self`\n> KW\\_SELFTYPE : `Self`\n> KW\\_STATIC : `static`\n> KW\\_STRUCT : `struct`\n> KW\\_SUPER : `super`\n> KW\\_TRAIT : `trait`\n> KW\\_TRUE : `true`\n> KW\\_TYPE : `type`\n> KW\\_UNSAFE : `unsafe`\n> KW\\_USE : `use`\n> KW\\_WHERE : `wher",
            "> KW\\_DYN : `dyn",
            "> KW\\_AWAIT : `await",
            "> KW\\_ASYNC : `async",
            "The following keywords were added beginning in the 2018 edition.",
            "> KW\\_WHILE : `while",
            "> KW\\_WHERE : `where",
            "> KW\\_USE : `use",
            "> KW\\_UNSAFE : `unsafe",
            "> KW\\_TYPE : `type",
            "> KW\\_TRUE : `true",
            "> KW\\_TRAIT : `trait",
            "> KW\\_SUPER : `super",
            "> KW\\_STRUCT : `struct",
            "> KW\\_STATIC : `static",
            "> KW\\_SELFTYPE : `Self",
            "> KW\\_SELFVALUE : `self",
            "> KW\\_RETURN : `return",
            "> KW\\_REF : `ref",
            "> KW\\_PUB : `pub",
            "> KW\\_MUT : `mut",
            "> KW\\_MOVE : `move",
            "> KW\\_MOD : `mod",
            "> KW\\_MATCH : `match",
            "> KW\\_LOOP : `loop",
            "> KW\\_LET : `let",
            "> KW\\_IN : `in",
            "> KW\\_IMPL : `impl",
            "> KW\\_IF : `if",
            "> KW\\_FOR : `for",
            "> KW\\_FN : `fn",
            "> KW\\_FALSE : `false",
            "> KW\\_EXTERN : `extern",
            "> KW\\_ENUM : `enum",
            "> KW\\_ELSE : `else",
            "> KW\\_CRATE : `crate",
            "> KW\\_CONTINUE : `continue",
            "> KW\\_CONST : `const",
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```rust",
            "```",
            "```"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "fn main() {",
            "}",
            "}",
            "```rust",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to metaprogramming and macros in Rust. The provided excerpts contain extensive information about Rust's macro system, including declarative macros (`macro_rules!`), procedural macros (derive, attribute, and function-like), and related tools and concepts. The keywords listed in the `finegrained_field_value` are directly supported by the content of these excerpts. For instance, the different categories of macros are explicitly defined, their hygiene properties are discussed, and the tools and mechanisms for their use and debugging are detailed. The excerpts also cover the role of build scripts in code generation, which is a related metaprogramming concept.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords",
      "citations": [
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "The Rustonomicon"
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "resources can only have one owner",
            "This prevents resources",
            "from being freed more than once. Note that not all variables own",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved",
            "    let y = x;",
            "Both values can be independently used"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid.",
            "Lifetimes - Rust By Example"
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "```rust",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i",
            "It is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled *sound*; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is *unsound*.",
            "unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is _unsound_",
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.",
            "The bytes owned by an immutable binding or immutable `static` are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html).",
            "Moreover, the bytes [pointed to]() by a shared reference, including transitively through other references (both shared and mutable) and `Box`es, are immutable; transitivity includes those references stored in fields of compound types.",
            "* Producing an [invalid value](). â€œProducingâ€ a\n  value happens any time a value is assigned to or read from a place, passed to\n  a function/primitive operation or returned from a function/primitive\n  oper",
            "The Rust compiler assumes that all values produced during program execution are\nâ€œvalidâ€, and producing an invalid value is hence immediate UB.",
            "* A `fn` pointer value must be non-null.",
            "* A `char` value must not be a surrogate (i.e., must not be in the range `0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`.",
            "* A `!` value must never exist.",
            "* An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be\n  initialized, i.e., must not be obtained from uninitialized memor",
            "* A `str` value is treated like `[u8]`, i.e. it must be initialized.",
            "* An `enum` must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.",
            "* A `struct`, tuple, and array requires all fields/elements to be valid at their respective type.",
            "* For a `union`, the exact validity requirements are not decided yet.",
            "* A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned and non-null, it cannot be [dangling](), and it must point to a valid value",
            "* The metadata of a wide reference, [`Box<T>`](../alloc/boxed/struct.Box.html), or raw pointer must match\n  the type of the unsized tai",
            "* If a type has a custom range of a valid values, then a valid value must be in that range.",
            "**Note:** Uninitialized memory is also implicitly invalid for any type that has\na restricted set of valid values. In other words, the only cases in which\nreading uninitialized memory is permitted are inside `union`s and in â€œpaddingâ€\n(the gaps between the fields of a type).",
            "Data races."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "pe in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)",
            " A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.",
            "Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.",
            "\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.",
            "Undefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program.",
            "However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
            "\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support",
            "* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple)",
            "      + a `bool` that isn't 0 or 1",
            "      + an `enum` with an invalid discriminant",
            "      + a null `fn` pointer",
            "      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]",
            "      + a `!` (all values are invalid for this type)",
            "      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` .",
            "      + a reference/ `Box` that is dangling, unaligned, or points to an invalid value.",
            "      + a wide reference, `Box` , or raw pointer that has invalid metadata:",
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)",
            "      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null.",
            "For a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) ."
          ]
        },
        {
          "title": "Working with Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat.",
            "We say that such a correct\nunsafely implemented function is _sound_ , meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).",
            "This program is now _unsound_ , Safe Rust can cause Undefined Behavior, and yet _we only modified safe code_ . This is the fundamental problem of safety: it's\nnon-local.",
            "The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.",
            "Safety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness.",
            "However\nsafety _isn't_ modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.",
            "It is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is _critical_ to the relationship between\nSafe Rust and Unsafe Rust.",
            "We have already seen that Unsafe code must trust _some_ Safe code, but shouldn't\ntrust _generic_ Safe code.",
            "Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state."
          ]
        },
        {
          "title": "Tree Borrows Explained",
          "url": "https://internals.rust-lang.org/t/tree-borrows-explained/18587",
          "excerpts": [
            "Since the `Freeze` and `Unpin` properties are not checked granularly, they are applied identically to out-of-range locations. That's a very debatable aspect of the model, but for now it's in line with TB being \"maximally permissive\" and can totally be changed if deemed problematic.",
            "[Vanille-N](https://internals.rust-lang.org/u/Vanille-N) March 29, 2023, 7:18am 10",
            "Interesting observation: because `&mut` borrows start as the two-phase reserved stated, `&mut` borrow splitting just falls out of the model without any special handling, even if it were to keep fully eager instead of delayed tag reborrowing. This is evident from the walkthrough of the disjoint fields example.",
            "[UCG #381: `&mut impl !Unpin` are not `dereferenceable`](https://github.com/rust-lang/unsafe-code-guidelines/issues/381)"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "First off, let's get some important caveats out of the way:\n\n* \n  We will be using the broadest possible definition of aliasing for the sake\n  of discussion. Rust's definition will probably be more restricted to factor\n  in mutations and liveness. * \n  We will be assuming a single-threaded, interrupt-free, execution. We will also\n  be ignoring things like memory-mapped hardware. Rust assumes these things\n  don't happen unless you tell it otherwise. For more details, see the [Concurrency Chapter](concurrency.html) . With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memory",
            "So why should we care about aliasing? Consider this simple function:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nfn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that \\`output\\` will be \\`2\\` if \\`input > 10\\`\n}\n}\n`",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model for Rust",
            "In Rust, the type system imposes a strict\n\ndiscipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias\n\ninformation for the purpose of program optimizations that reorder memory accesse",
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio",
            "Raw pointers are necessary when interfacing with C code through FFI, and also\n\nwhen implementing low-level pointer-heavy data structures in Rust that internally do not follow\n\nRustâ€™s aliasing disciplin",
            "The sinister part about this cast is that we do it twice! The type system does not stop us, as it\n\ndoes not even attempt to track what happens with raw pointers",
            "What is important is that **unsafe** code is encapsulated within a\n\nsafe abstraction ",
            "The Rust ecosystem rests on the interplay of safe code where possible and **unsafe** code\n\nwhere needed, and hence any realistic consideration of compilation for Rust programs requires\n\nproper treatment of **unsafe** cod",
            "More precisely, we will define the operational semantics in\n\nsuch a way that our example program has undefined behavior , which means the compiler is allowed\n\nto compile it in any way it choose",
            "Compared to\n\nRustBeltâ€™s semantics, we have to Å‚addÅ¾ some undefined behavior to obtain the desired optimizations",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin",
            "Raw pointers. Sometimes, the aliasing discipline for references that the borrow checker enforces\n\nis too strict",
            "In this case, one option is to not use references but instead\n\nemploy raw pointers . Raw pointers in Rust basically act like pointers in C: they are not checked by\n\nthe compiler, and there are no aliasing restriction",
            "In line 2, we cast a reference to raw pointer type.",
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        },
        {
          "title": "std::mem::MaybeUninit - Rust",
          "url": "https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html",
          "excerpts": [
            "Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an `UnsafeCell<T>` ).",
            "Ok ( unsafe { buffer.assume_init() })",
            "(mutable) reference to uninitialized memory! // This is undefined behavi",
            "let mut foo = MaybeUninit::<Foo>::uninit();",
            "ptr::write( &mut foo.assume_init_mut().a as *mut u32, 1337 );",
            "(mutable) reference to uninitialized memory! // This is undefined behavior."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "## [Rust's Unsafe Code Guidelines Reference]()",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Since last fall, [Neven](https://perso.crans.org/vanille/) has been doing an internship to develop a new aliasing model for Rust: Tree Borrows. Hang on a second, I hear you say â€“ doesnâ€™t Rust already have an aliasing model? Isnâ€™t there this â€œStacked Borrowsâ€ that Ralf keeps talking about? Indeed there is, but Stacked Borrows is just one proposal for a possible aliasing model â€“ and it [has](https://github.com/rust-lang/unsafe-code-guidelines/issues/133) [its](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) [fair](https://github.com/rust-lang/unsafe-code-guidelines/issues/256) [share](https://github.com/rust-lang/unsafe-code-guidelines/issues/274) [of](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) [problems](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) .",
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines GitHub Repository",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines",
          "excerpts": [
            "The purpose of this repository is to collect and discuss all sorts of questions that come up when writing unsafe code.",
            "The [Unsafe Code Guidelines Reference \"book\"](https://rust-lang.github.io/unsafe-code-guidelines) is a past effort to systematize a consensus on some of these questions. Most of it has been archived, but the [glossary](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html) is still a useful resource.",
            "The [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/) is a draft document discussing unsafe code. It is intended to\nbe brought into agreement with the content here. It represents an organized\neffort to explain how to write Rust code, rather than a reference."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "Unsafe Code Guidelines Reference",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "No-Panic Rust: A Nice Technique for Systems Programming",
          "url": "https://blog.reverberate.org/2025/02/03/no-panic-rust.html",
          "excerpts": [
            "Feb 3, 2025 â€” Runtime overhead: A potential panic implies some kind of runtime check. ... For example, memory allocation failure will panic in most cases."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate.",
            "\nThis topic was automatically closed 90 days after the last reply. We invite you to open a new topic if you have further questions or comments."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Rust Embedded - awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "In 2018, the Rust community created an embedded working group to help drive adoption in the Rust ecosystem.",
            "Curated list of resources for Embedded and Low-level development in the Rust programming language",
            "The embedded parts use the nRF52840-DK and a LIS3DH breakout board. ( [github source](https://github.com/tweedegolf/rust-workshop) )"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc.",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "The work on this book is coordinated in [this repository](https://github.com/rust-embedded/book) and is mainly\ndeveloped by the [resources team](https://github.com/rust-embedded/wg).",
            "+ Cross Compilation"
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "RFL leverages **bindgen** to automatically generate Rust bindings of C kernel struct prior to use.",
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "no_std - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "[The Discovery book](https://docs.rust-embedded.org/discovery/index.html) will teach you about microcontrollers,\nperipherals, sensors and bare metal programming through a series of small, fun\nprojects that youâ€™ll develop in Rust.",
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software.",
            "ed/awesome-embedded-rust) resource includes a list of other books, blogs, and\ntraining materials for learning embedded Rust, including complete from-scratch\nproject examples and quickstart templates: [Books, blogs and training materials"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "Panicking is a core part of the Rust language. Built-in operations like indexing\nare runtime checked for memory safety. When out of bounds indexing is attempted\nthis results in a panic. In the standard library panicking has a defined behavior: it unwinds the stack\nof the panicking thread, unless the user opted for aborting the program on\npanics. In programs without standard library, however, the panicking behavior is left\nundefined. A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the panic. Given that embedded systems range from user facing to safety critical (cannot\ncrash) there's no one size fits all panicking behavior but there are plenty of\ncommonly used behaviors. These common behaviors have been packaged into crates\nthat define the `#[panic_handler]` function."
          ]
        },
        {
          "title": "The Redox Operating System",
          "url": "http://doc.redox-os.org/book",
          "excerpts": [
            "Redox OS is a general-purpose operating system written in [Rust](https://www.rust-lang.org) . Our aim is to provide a fully functioning Unix-like microkernel-based operating system, that is secure, reliable and free.",
            "Redox OS was created in 2015 before the first stable version (1.0) of the Rust compiler and was one of the first operating systems written in Rust.",
            "To achieve that, Redox was redesigned to adopt a microkernel architecture and a unified system API for resources.",
            "This book is written in a way that you doesn't require any prior knowledge of Rust or OS development."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "http://os.phil-opp.com/",
          "excerpts": [
            "\n\nThis blog series creates a small operating system in the [Rust programming language](https://www.rust-lang.org/) . Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding [Github repository](https://github.com/phil-opp/blog_os) .",
            "\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the [bare metal](https://en.wikipedia.org/wiki/Bare_machine) without an underlying operating system.",
            " [A Freestanding Rust Binary",
            "\n\nIn this post, we explore _cooperative multitasking_ and the _async/await_ feature of Rust.",
            " [Introduction to Paging",
            " [Paging Implementation"
          ]
        },
        {
          "title": "Preface - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/",
          "excerpts": [
            "You'll learn about linkers, linker scripts and about the Rust features that let you control a bit of the ABI of Rust programs. A trick to implement defaultÂ ..."
          ]
        },
        {
          "title": "Choose Your Discovery",
          "url": "https://docs.rust-embedded.org/discovery/",
          "excerpts": [
            "Discover the world of microcontrollers through Rust! There are currently three versions of this book. All of them provide an introduction to microcontrollers."
          ]
        },
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            "\n\nOwnership is Rustâ€™s most unique feature and has deep implications for the rest\nof the language. It enables Rust to make memory safety guarantees without\nneeding a garbage collector, so itâ€™s important to understand how ownership\nworks.",
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "Doing an incremental rewrite from C/C++ to Rust, we had to use a lot of raw pointers and `unsafe{}` blocks.",
            "The rewrite was done incrementally, in a stop-and-go fashion. At some point, as I expected, we had to add brand new features while the rewrite was on-going and that was very smooth with this approach.",
            "All the stringent rules of Rust still apply inside these blocks but the compiler just stops checking them for you, so you are on your own.",
            "As such, it's so easy to introduce Undefined Behavior.",
            "Pure Rust is already very complex, but add to it the whole layer that is mainly there to deal with FFI, and it really becomes a beast.",
            "Some developers in our team straight declined to work on this codebase, mentioning the real or perceived Rust complexity.",
            "Now, I think that Rust is still mostly easier to learn than C++, but admittedly not by much, especially in this FFI heavy context.",
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "The provided excerpts offer extensive coverage of Rust's memory management concepts, directly supporting almost all the requested keywords. Many excerpts explicitly define or explain 'Ownership', 'Move Semantics', 'Borrowing', 'References' (both immutable and mutable), 'Borrow Checker', 'Lifetimes', 'Lifetime Elision Rules', 'Higher-Ranked Trait Bounds (HRTB)', 'Aliasing', 'Interior Mutability' (including `Cell<T>`, `RefCell<T>`, `Mutex<T>`, `RwLock<T>`, `UnsafeCell<T>`), 'Stacked Borrows Model', 'Miri', 'Self-Referential Types', 'Pin<Ptr>', 'Unpin Trait', 'Drop Trait', 'Drop Order', 'dropck', and various 'Borrow Checker Errors'.\n\nFor instance, multiple excerpts discuss the core principles of ownership, stating that data has a single owner and is dropped when the owner goes out of scope. The concept of 'move semantics' is explained as the transfer of ownership. 'Borrowing' is detailed as a way to access data without taking ownership, with clear distinctions between immutable and mutable references and the 'one mutable reference or many immutable references' rule enforced by the borrow checker. Lifetimes are described as a compiler construct to ensure borrow validity, with rules for 'lifetime elision' and the more advanced 'Higher-Ranked Trait Bounds' being explicitly mentioned.\n\nAliasing is defined as overlapping memory regions, and Rust's strict rules against mutable aliasing are highlighted as crucial for optimizations and preventing data races. 'Interior mutability' types like `Cell`, `RefCell`, `Mutex`, and `RwLock` are presented as mechanisms to allow mutation through shared references, with `UnsafeCell` being the underlying primitive. The 'Stacked Borrows Model' is discussed as an aliasing model for Rust, particularly relevant for `unsafe` code, and `Miri` is identified as a tool for detecting undefined behavior related to memory safety.\n\n'Pin<Ptr>' and the 'Unpin' trait are explained in the context of self-referential types and ensuring data is not moved in memory. The 'Drop' trait and 'dropck' are covered in relation to resource cleanup and ensuring memory safety during dropping. Various common borrow checker errors are also explicitly listed or described, such as those related to using moved values, re-borrowing, and dangling references.\n\nWhile the excerpts provide strong support for most keywords, some are implicitly covered or are more general concepts within the broader topics. For example, 'Shared Borrows' and 'Immutable Borrows' are inherently part of the discussion on 'References' and 'Borrowing'. 'Exclusive Borrows' is synonymous with 'Mutable Borrows'. 'Reborrowing' is mentioned in the context of two-phase borrows. 'Non-Lexical Lifetimes (NLL)' is a historical development that improved the borrow checker, and while not explicitly defined, the general concept of lifetime analysis is thoroughly covered. 'Temporary Lifetime Extension' and 'Constant Promotion' are specific compiler behaviors related to lifetimes and data placement, which are implicitly handled by the borrow checker's rules. 'Poisoning (Mutex)' is directly mentioned in the context of `Mutex<T>` behavior. The 'Copy Trait' is mentioned in contrast to move semantics.\n\nThe depth and breadth of the information provided across numerous excerpts strongly support the fine-grained field value.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords",
      "citations": [
        {
          "title": "ndarray - Rust Documentation",
          "url": "https://docs.rs/ndarray/",
          "excerpts": [
            "The `ndarray` crate provides an n-dimensional container for general elements and for numerics. ndarray - Rust",
            "An n-dimensional array for general elements and for numerics. Lightweight array views and slicing; views support chunking and splitting.",
            "ndarray` provides a lot of functionality, but itâ€™s not a one-stop solution. `ndarray` includes matrix multiplication and other binary/unary operations out of the box. More advanced linear algebra routines (e.g. SVD decomposition or eigenvalue computation)\ncan be found in [`ndarray-linalg"
          ]
        },
        {
          "title": "ndarray-linalg - Rust",
          "url": "https://docs.rs/ndarray-linalg/",
          "excerpts": [
            "The `ndarray-linalg` crate provides linear algebra functionalities for `ArrayBase`, the n-dimensional array data structure provided by `ndarray`.",
            "ndarray\\_linalg - Rus",
            "* [ndarray-linalg-0.17.0](# \"Linear algebra package for rust-ndarray using LAPACK\")",
            "+ [Repository](https://github.com/rust-ndarray/ndarray-linalg)"
          ]
        },
        {
          "title": "faer - Rust Linear Algebra Library",
          "url": "https://docs.rs/faer/latest/faer/",
          "excerpts": [
            "`faer` is a general-purpose linear algebra library for rust, with a focus on high performance\nfor algebraic operations on medium/large matrices, as well as matrix decompositions",
            "`faer` is recommended for applications that handle medium to large dense matrices, and its\ndesign is not well suited for applications that operate mostly on low dimensional vectors and\nmatrices such as computer graphics or game development.",
            "enables experimental simd features such as avx512"
          ]
        },
        {
          "title": "smartcorelib/smartcore",
          "url": "https://github.com/smartcorelib/smartcore",
          "excerpts": [
            "A comprehensive library for machine learning and numerical computing. Apply Machine Learning with Rust leveraging first principles."
          ]
        },
        {
          "title": "Awesome-Rust-MachineLearning (and related Rust domains)",
          "url": "https://github.com/vaaaaanquish/Awesome-Rust-MachineLearning",
          "excerpts": [
            "ndarray-stats) \\- Statistical routines for ndarray"
          ]
        },
        {
          "title": "GitHub - e-tornike/best-of-ml-rust",
          "url": "https://github.com/e-tornike/best-of-ml-rust",
          "excerpts": [
            "- Burn is a new comprehensive dynamic Deep Learning Framework built using.. `Apache-2`"
          ]
        },
        {
          "title": "Curated List - ImplRust | Resources to Learn Rust, Rust Books",
          "url": "https://implrust.com/resources/curated-list/",
          "excerpts": [
            "Awesome-Rust-MachineLearning : a list of machine learning libraries written in Rust. It's a compilation of GitHub repositories, blogs, books, movies,Â ..."
          ]
        },
        {
          "title": "Are we learning yet? A work-in-progress to catalog the state of machine learning in Rust",
          "url": "https://www.arewelearningyet.com/",
          "excerpts": [
            "Are we learning yet? - Last updated: [2025\\-03-02](https://github.com/anowell/are-we-learning-yet",
            "Rust Machine Learning Ecosystem"
          ]
        },
        {
          "title": "ash-rs/ash: Vulkan bindings for Rust",
          "url": "https://github.com/ash-rs/ash",
          "excerpts": [
            "The Vulkan Video bindings are experimental and still seeing breaking changes in their upstream specification, and are only provided by Ash for early adopters."
          ]
        },
        {
          "title": "Vulkano: About",
          "url": "https://vulkano.rs/",
          "excerpts": [
            "Safe Rust wrapper around the Vulkan API Â· Provides a low-levelish API around Vulkan. Â· Plans to prevent all invalid API usages, even the most obscure ones. Â· Can ..."
          ]
        },
        {
          "title": "Introduction - Vulkano",
          "url": "https://vulkano.rs/01-introduction/01-introduction.html",
          "excerpts": [
            "Vulkan is a standard API whose version 1.0 was released in 2016 that lets you interface with the video card and the GPU of the machine your program is running ..."
          ]
        },
        {
          "title": "Vulkan tutorial written in Rust using Ash",
          "url": "https://github.com/adrien-ben/vulkan-tutorial-rs",
          "excerpts": [
            "Vulkan tutorials written in Rust using Ash. The extended branch contains a few more chapters that I won't merge on that branch since I want it to stay close to ..."
          ]
        },
        {
          "title": "Rust GPU Ecosystem",
          "url": "https://rust-gpu.github.io/ecosystem/",
          "excerpts": [
            "\nCompiles unmodified Rust code to [SPIR-V](https://www.khronos.org/spir/) (Vulkan) so\nthat it can run on the GPU. [rust-cuda](https://github.com/Rust-GPU/Rust-CUDA)[â€‹]( \"Direct link to rust-cu",
            "------------\n\nA source code translator written in Rust that converts between various GPU-specific\nshader languages ([WGSL](https://www.w3.org/TR/WGSL/),\n[GLSL](https://en.wikipedia.org/wiki/OpenGL_Shading_Language),\n[HLSL](https://en.wikipedia.org/wiki/High-Level_Shader_Language), and\n[MSL](https://developer.apple.com/metal/)). These shaders ultimately run on the GPU. [ZLUDA](https://github.com/vosen/ZLUDA)[â€‹]( \"Direct link to zluda\")",
            "GPU drivers partially written in Rust to add Linux support for Apple GPUs. * [rust-gpu]()\n* [rust-cuda]()\n* [nvptx backend in rustc]()\n* [amdgpu backend in rustc]()\n* [CubeCL]()\n* [krnl]()\n* [cudarc]()\n* [wgpu]()\n* [naga]()\n* [ZLUDA]()\n* [Asahi Linux GPU drivers]()",
            "Ecosystem | Rust GPU"
          ]
        },
        {
          "title": "rust-gpu GitHub Repository",
          "url": "https://github.com/EmbarkStudios/rust-gpu",
          "excerpts": [
            "ðŸ‰ðŸ‰ Making Rust a first-class language and ecosystem for GPU shaders ðŸš§ðŸš§",
            "**Rust as a first-class language and ecosystem for GPU graphics & compute shaders**",
            "Our hope with this project is that we push the industry forward by bringing an existing, low-level, safe, and high performance language to the GPU; namely [Rust](https://rust-lang.org) . And with it come some additional benefits that can't be overlooked: a package/module system that's one of the industry's best, built in safety against race-conditions or out of bounds memory access, a wide range of tools and utilities to improve programmer workflows, and many others!"
          ]
        },
        {
          "title": "Rust GPU",
          "url": "https://rust-gpu.github.io/",
          "excerpts": [
            "Rust GPU makes it possible to write and run GPU software in Rust, leveraging the language's powerful safety and concurrency features to enhance performance and reliability.",
            "With Rust GPU, you can seamlessly develop for both CPU and GPU using a unified codebase while benefiting from Rust's existing ecosystem.",
            "The Rust GPU compiler backend emits code compatible with [Vulkan](https://www.vulkan.org) , ensuring your code runs across a [wide range of devices and vendors](https://vulkan.gpuinfo.org/) .",
            "If instead you wish to stick to the NVIDIA-only ecosystem, stay tuned as the [Rust CUDA](https://github.com/rust-gpu/rust-cuda) project is in the process of being rebooted and possibly integrated with Rust GPU.",
            "There is no longer a need to learn a GPU-specific programming language. You can write both CPU and GPU code in Rust, leveraging your existing Rust knowledge and maintaining a consistent development experience.",
            "Furthermore, the _same code can run on both the CPU and GPU_ , with divergent behavior gated behind `cfg` attributes and macros where necessary.",
            "Rust's ownership model and type system guarantee memory safety, minimizing bugs and undefined behavior.",
            "Rust's borrow checker also enables fearless concurrency, which is essential for maximizing performance on massively parallel GPUs.",
            "Rust has an expressive type system and zero-cost abstractions that enable writing high-level, reusable code without sacrificing performance.",
            "The state-of-the-art for sharing GPU code is copy and pasting. With Rust GPU we are excited to bring the excellent `cargo` and crates.io ecosystem to GPU programming and provide some sanity.",
            "Rust's `no_std` ecosystem offers a wide array of libraries that can be used in environments without the standard library.",
            "As a consequence, you can reuse [existing `no_std` libraries from crates.io](https://crates.io/categories/no-std::no-alloc) in your GPU code _without the authors explicitly adding GPU support_ ."
          ]
        },
        {
          "title": "Exploring the Theory and Practice of Concurrency in the Entity-Component-System Pattern",
          "url": "https://users.soe.ucsc.edu/~lkuper/papers/core-ecs-draft.pdf",
          "excerpts": [
            "The Entity-Component-System (ECS) software design pattern, long used in game development and similar\ndomains, encourages a clean separation of identity (entities), data (components), and computation (systems). Programs written in the ECS pattern are naturally concurrent, and the ECS pattern offers modularity, flexibility,\nand performance benefits that have led to a proliferation of ECS frameworks.",
            "The five frameworks we survey (in order of popularity8) are: Bevy ECS [Anderson and Bevy\nContributors 2024], a Rust ECS framework developed for the Bevy game engine; EnTT [Caini\n2024d], an ECS framework for C++, known for its use in Minecraft [Mojang AB and Microsoft\nCorporation 2024]; Flecs [Mertens 2024a], an ECS framework for C and C++; Specs [Schaller 2023], a\nRust ECS framework developed for the Amethyst game engine [Kalderon 2021]; and apecs [Carpay\n2018a], an ECS framework for Haskell.",
            "Our purpose in this section, however,\nis not a quantitative performance assessment, but rather a qualitative comparison of design and\nimplementation decisions made in the interest of performance."
          ]
        },
        {
          "title": "5 popular Rust game engines",
          "url": "https://dev.to/logrocket/5-rust-game-engines-to-consider-for-your-next-project-1l0c",
          "excerpts": [
            "Amethyst",
            "methyst.rs/) is a data-driven and data-oriented game engine written in R",
            "The core principles of Amethyst include:\n\n* Massively parallel architecture\n* Follows the [Entity Component System (ECS)](https://en.wikipedia.org/wiki/Entity_component_system) paradigm to organize game logic",
            "ECS makes Amethyst entirely thread-safe and avoids memory-locking of any sort.",
            "Amethyst is mainly used to develop 2D and 3D games."
          ]
        },
        {
          "title": "Rust Game Engines: The Complete Guide for Modern Game Development",
          "url": "https://www.rapidinnovation.io/post/rust-game-engines-the-complete-guide-for-modern-game-development",
          "excerpts": [
            "Rust offers several advantages that make it particularly suitable for game development:\n\n* **Performance** :\n      + Rust's zero-cost abstractions allow developers to write high-level code without sacrificing performance. + The language's ability to optimize for speed means that games can run smoothly, even on lower-end hardware. + According to benchmarks, Rust often outperforms languages like C++ in certain scenarios, making it a competitive choice for game engines, including those developed in rust gamedev. * **Safety** :\n      + Rust's strict compile-time checks prevent many common programming errors, reducing the likelihood of crashes and undefined behavior during gameplay. + The borrow checker enforces rules that ensure memory safety without needing a garbage collector, which can introduce latency in game loops. * **Concurrency** :\n      + Rust's approach to concurrency allows developers to write safe multi-threaded code, which is essential for modern game engines that need to handle multiple tasks simultaneously. + The language's ownership model ensures that data races are caught at compile time, leading to more stable and reliable game performance.",
            "Several game engines have emerged in the Rust ecosystem, each offering unique features and capabilities. Here are some of the most popular ones:\n\n* **Bevy** : A data-driven game engine that emphasizes simplicity and performance. It uses an Entity-Component-System (ECS) architecture, allowing developers to create complex game logic with ease. * **Amethyst** : A powerful game engine that also utilizes the ECS pattern. It is designed for high-performance games and provides a wide range of features, including 2D and 3D rendering, audio, and input handling. * **ggez** : A lightweight game framework for making 2D games. It is designed to be easy to use and is suitable for beginners and experienced developers alike, making it a great choice for those interested in rust 2D game development. * **Piston** : A modular game engine that allows developers to pick and choose components as needed. It is flexible and can be used for both 2D and 3D games, appealing to those exploring game dev with Rust.",
            "Amethyst is a data-driven game engine built in Rust, designed to facilitate the development of high-performance games, similar to other popular engines like the unreal engine game engine and unity game engine.\nIts architecture is modular, allowing developers to pick and choose components that suit their needs. Key concepts include:\n\n* **Modularity** : Amethyst is designed with a modular architecture, enabling developers to use only the components they need, which enhances efficiency and reduces development time, much like the modularity found in unity game development. * **Data-driven design** : The engine emphasizes data-driven development, allowing for easier adjustments and optimizations, which can lead to quicker iterations and improved game performance, akin to the data-driven approaches in unity video game development. * **Concurrency** : Amethyst leverages Rust's ownership model to ensure safe concurrency, enabling multiple systems to run in parallel without data races. This capability is crucial for maximizing performance in complex game environments, similar to the concurrency features in graphics engines like the unreal development kit. * **Game loop** : The engine follows a traditional game loop structure, managing the update and render cycles efficiently, ensuring a smooth gaming experience for users, comparable to the game loop management in unity game engine games.",
            "The Entity-Component-System (ECS) architecture is a core concept in Amethyst, promoting a clean separation of data and behavior. This design pattern consists of three main components:\n\n* **Entities** : These are unique identifiers for game objects.\nThey do not contain data or behavior themselves but serve as containers for components, allowing for a flexible and organized structure, similar to entities in unity game dev. * **Components** : These are plain data structures that hold the state of an entity. For example, a `Position` component might store an entity's coordinates, while a `Velocity` component could store its speed and direction. This separation allows for easy modifications and enhancements, much like the component-based design in unity software development. * **Systems** : These are responsible for processing entities with specific components. A system might update the position of all entities with both `Position` and `Velocity` components based on the game loop's delta time, ensuring that game logic is executed efficiently, similar to systems in the gameplay engine of unity.",
            "Bevy is an open-source game engine that has gained traction for its unique features and capabilities. It is designed to be simple yet powerful, making it an excellent choice for both beginners and experienced developers. Here are some key aspects of Bevy:\n\n* **Rust-based** : Bevy is built using the Rust programming language, which is known for its performance and safety. This choice allows developers to create high-performance games while minimizing common programming errors. * **Entity-Component-System (ECS) architecture** : Bevy employs an ECS architecture, which separates data (components) from behavior (systems). This design promotes:\n      + Flexibility in game design, allowing developers to easily add or modify game features. + Improved performance by optimizing how data is processed.",
            "Piston is a highly modular game engine designed for flexibility and ease of use. It allows developers to create games by combining various components, making it suitable for both beginners and experienced developers. * **Modular Architecture** : Piston's design encourages the use of separate libraries for different functionalities, such as graphics, input handling, and audio. This modularity allows developers to pick and choose the components they need for their projects, making it a great choice for those exploring rust game engines. * **Cross-Platform Support** : Piston supports multiple platforms, including Windows, macOS, and Linux. This makes it easier for developers to reach a wider audience without needing to rewrite their code for different operating systems. * **2D and 3D Graphics** : While primarily focused on 2D game development, Piston also has capabilities for 3D graphics. This versatility allows developers to experiment with different game styles and genres, making it suitable for both 2d and 3d game engine rust applications.",
            "Parallel computation is essential for modern game engines, allowing them to utilize multi-core processors effectively. Rust's concurrency model, built on its ownership and type system, makes it easier to write safe concurrent code. * **Data Parallelism** : Rust's ownership model allows for safe data sharing across threads. This is crucial for game logic, where multiple entities may need to be updated simultaneously, enhancing the overall gaming experience. * **Ray Tracing and Physics Calculations** : These computationally intensive tasks can be parallelized to improve performance. Rust's `rayon` crate simplifies parallel processing, allowing developers to focus on game logic rather than thread management, thus increasing productivity. * **Asynchronous Tasks** : Rust's async/await syntax enables non-blocking operations, which is beneficial for I/O-bound tasks like loading assets or network communication, ensuring that gameplay remains uninterrupted. To implement parallel computation in game logic, we suggest:\n\n* Identifying independent tasks that can be executed concurrently. * Using the `rayon` crate for easy parallel iteration over collections. * Implementing async functions for tasks that involve waiting, such as loading resources."
          ]
        },
        {
          "title": "Bevy Archetypes",
          "url": "https://taintedcoders.com/bevy/archetypes",
          "excerpts": [
            "Bevy is an archetypal ECS. Archetypes enable efficient storage and processing of entities with similar behavior by grouping them based on their component ..."
          ]
        },
        {
          "title": "Are we game yet? Ecosystem - Engines (Rust game development ecosystem)",
          "url": "https://arewegameyet.rs/ecosystem/engines/",
          "excerpts": [
            "* ### [bevy](https://crates.io/crates/bevy)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A refreshingly simple data-driven game engine and app framework\n\n  + Latest version:\n\n    0.16.1\n  + Downloads:\n\n    2,972,526\n  + Recent downloads:\n\n    488,498\n  + License:\n\n    MIT OR Apache-2.0\n  + Stars:\n\n    41,804\n  + Last activity:\n\n    2025-09-0",
            "* ### [ggez](https://crates.io/crates/ggez)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A lightweight game framework for making 2D games with minimum friction, inspired by Love2D. + Latest version:\n\n    0.9.3\n  + Downloads:\n\n    483,884\n  + Recent downloads:\n\n    51,162\n  + License:\n\n    MIT\n  + Stars:\n\n    4,487\n  + Last activity:\n\n    2025-08-14"
          ]
        },
        {
          "title": "wgpu-rs resources for computing purposes only : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/11nsgsl/wgpurs_resources_for_computing_purposes_only/",
          "excerpts": [
            "I'm writing some software that benefits highly from GPU computing, but while it does a lot of computing, it doesn't do stuff like fragment or vertex shader ..."
          ]
        },
        {
          "title": "Creating writing and reading from buffer wgpu",
          "url": "https://stackoverflow.com/questions/76839881/creating-writing-and-reading-from-buffer-wgpu",
          "excerpts": [
            "I have just recently started learning about how to compute on a GPU and I have decided to start with WGPU as I'm familiar with rust and it can ..."
          ]
        },
        {
          "title": "Bevy vs Fyrox/macroquad/ggez/etc. : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/190arcn/bevy_vs_fyroxmacroquadggezetc/",
          "excerpts": [
            "By the industry standards, it is at the bottom of the list of preferrable game engines, Fyrox is there too, but a few orders of magnitude better ..."
          ]
        },
        {
          "title": "Polars: DataFrames in Rust",
          "url": "https://docs.rs/polars/latest/polars/",
          "excerpts": [
            "Polars: DataFrames in Rust",
            "Polars is a DataFrame library for Rust. It is based on [Apache Arrow](https://arrow.apache.org/)â€™s memory model. Apache Arrow provides very cache efficient columnar data structures and is becoming the defacto\nstandard for columnar data.",
            "Polars is a DataFrame library for Rust.",
            "The base data structures provided by polars are [`DataFrame`](prelude/struct.DataFrame.html \"struct polars::prelude::DataFrame\"), [`Series`](prelude/struct.Series.html \"struct polars::prelude::Series\"), and [`ChunkedArray<T>`](prelude/struct.ChunkedArray.html \"struct polars::prelude::ChunkedArray\").",
            "We recommend building queries directly with [polars-lazy](https://docs.rs/polars-lazy/0.50.0/x86_64-unknown-linux-gnu/polars_lazy/index.html \"mod polars_lazy\"). This allows you to combine\nexpressions into powerful aggregations and column selections. All expressions are evaluated\nin parallel and queries are optimized just in time.",
            "This means that Polars data structures can be shared zero copy with processes in many different\nlanguages.",
            "* `POLARS_TABLE_WIDTH` -> width of the tables used during DataFrame formatting.",
            "* `POLARS_MAX_THREADS` -> maximum number of threads used to initialize thread pool (on startup).",
            "* `POLARS_VERBOSE` -> print logging info to stderr.",
            "* `POLARS_NO_PARTITION` -> polars may choose to partition the group\\_by operation, based on data\n  cardinality. Setting this env var will turn partitioned group\\_byâ€™s of",
            "* `POLARS_PARTITION_UNIQUE_COUNT` -> at which (estimated) key count a partitioned group\\_by should run. defaults to `1000`, any higher cardinality will run default group\\_by.",
            "* `POLARS_FORCE_PARTITION` -> force partitioned group\\_by if the keys and aggregations allow it.",
            "* `POLARS_ALLOW_EXTENSION` -> allows for [`ObjectChunked<T>`](prelude/type.ObjectChunked.html \"type polars::prelude::ObjectChunked\") to be used in arrow, opening up possibilities like using\n  `T` in complex lazy expressions. However this does require `unsafe` code allow thi",
            "* `POLARS_NO_PARQUET_STATISTICS` -> if set, statistics in parquet files are ignored.",
            "* `POLARS_PANIC_ON_ERR` -> panic instead of returning an Error.",
            "* `POLARS_BACKTRACE_IN_ERR` -> include a Rust backtrace in Error messages.",
            "* `POLARS_NO_CHUNKED_JOIN` -> force rechunk before join",
            "If you want to read more, check the [user guide](https://docs.pola.rs/)."
          ]
        },
        {
          "title": "Polars: Blazingly Fast DataFrame Library",
          "url": "https://docs.pola.rs/",
          "excerpts": [
            "Polars is a blazingly fast DataFrame library for manipulating structured data. The core is written\nin Rust, and available for Python, R and NodeJS. ## Key features",
            "Fast** : Written from scratch in Rust, designed close to the machine and without external\n   dependencie",
            "I/O** : First class support for all common data storage layers: local, cloud storage & database",
            "Intuitive API** : Write your queries the way they were intended. Polars, internally, will\n   determine the most efficient way to execute using its query optimize",
            "Out of Core** : The streaming API allows you to process your results without requiring all your\n   data to be in memory at the same tim",
            "Parallel** : Utilises the power of your machine by dividing the workload among the available CPU\n   cores without any additional configuratio"
          ]
        },
        {
          "title": "Using SIMD for Parallel Processing in Rust",
          "url": "https://nrempel.com/blog/using-simd-for-parallel-processing-in-rust/",
          "excerpts": [
            " SIMD (Single Instruction, Multiple Data) is a powerful tool for accelerating data-intensive operations in high-performance computing. ",
            ". As of mid-2024, Rust offers multiple avenues for SIMD development.",
            ".\nWhile the standard library's experimental SIMD module ([`std::simd`](https://doc.rust-lang.org/std/simd/index.html?ref=learnrust.blog)) is confined to the nightly channel, stable Rust provides several options for leveraging SIMD in production environments:",
            "\n\n1. Rust compiler's auto-vectorization capabilities",
            "s\n2. Platform-specific intrinsics through the [`std::arch`](https://doc.rust-lang.org/std/arch/?ref=learnrust.blog) module",
            "e\n3. Rust's experimental SIMD implementation in `std::simd`",
            "\n\nThe key idea behind `std::simd` is to provide SIMD vector types and operations that work across different architectures.",
            ". To use `std::simd`, I needed to switch to the nightly channel:"
          ]
        },
        {
          "title": "The Rust portable SIMD repository",
          "url": "https://github.com/rust-lang/portable-simd",
          "excerpts": [
            "The testing ground for the future of portable SIMD in Rust",
            "\n\nNow we're gonna dip our toes into this world with a small SIMD \"Hello, World!\" example. Make sure your compiler is up to date and using `nightly` . We can do that by running",
            "#! [ feature ( portable_simd ) ]",
            "use std :: simd :: f32x4 ;",
            "The Rust standard library's portable SIMD API",
            "Currently, vectors may have up to 64 elements, but aliases are provided only up to 512-bit vectors. Depending on the size of the primitive type, the number of lanes the vector will have varies. For example, 128-bit vectors have four `f32` lanes and two `f64` lanes."
          ]
        },
        {
          "title": "PythonSpeed - Using portable SIMD in stable Rust",
          "url": "https://pythonspeed.com/articles/simd-stable-rust/",
          "excerpts": [
            "Using portable SIMD in stable Rust",
            "==================================",
            "The code is quite similar, with only minor differences:",
            "--------\n\nThe biggest benefit of using `wide` is that it runs on stable Rust, you donâ€™t need an unstable (â€œnightlyâ€) version of the compiler.",
            "The main downside I see to using `wide` is the limited API documentation.",
            "The [`wide`](https://docs.rs/wide) crate implements a portable SIMD abstraction that then gets compiled to x86-64 or ARM SIMD instructions.",
            "Using SIMD can make your code faster, in a completely different and complementary way to other optimizations. Portable SIMD libraries allow you to write more abstract, portable code, so you can take advantage of SIMD across CPU models and architectures."
          ]
        }
      ],
      "reasoning": "The provided excerpts contain numerous keywords relevant to scientific computing and machine learning in Rust. Several excerpts directly mention `ndarray` as an n-dimensional array container for general elements and numerics, and `ndarray-linalg` for linear algebra functionalities using `ndarray`. `faer` is highlighted as a general-purpose linear algebra library focusing on high performance for medium/large matrices and matrix decompositions, with experimental SIMD features. `smartcore` and `linfa` are identified as comprehensive libraries for machine learning and numerical computing, and a list of machine learning libraries written in Rust is provided. `Burn` is mentioned as a comprehensive dynamic Deep Learning Framework. For GPU computing, `wgpu` is noted for GPU computing resources, and `rust-gpu` is described as making Rust a first-class language for GPU shaders, compiling Rust code to SPIR-V (Vulkan) to run on the GPU. `ash` and `Vulkano` are mentioned as Vulkan bindings and a safe Rust wrapper around the Vulkan API, respectively. Game engines like `Bevy`, `Fyrox`, `ggez`, and `macroquad` are listed, with `Bevy` and `Amethyst` (which uses `Specs` ECS) explicitly using the Entity-Component-System (ECS) pattern for game logic and concurrency. `cpal` and `rodio` are mentioned for audio processing, and `gstreamer-rs` for multimedia. `rayon` is identified as a library for data parallelism, and SIMD (Single Instruction, Multiple Data) is discussed as a tool for accelerating data-intensive operations, with `std::simd` and the `wide` crate providing portable SIMD abstractions. `Polars` is described as a DataFrame library for Rust based on Apache Arrow's memory model, designed for fast, out-of-core, and parallel data manipulation. `plotters` and `poloto` are not explicitly mentioned in the provided excerpts.",
      "confidence": "medium"
    },
    {
      "field": "language_foundations_keywords",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "KW\\_TRY : `try",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "KW\\_RAW : `raw",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "* [strict]()\n* [reserved]()\n* [weak]()\n",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\"",
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers."
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "It is an error to use the [RESERVED\\_RAW\\_IDENTIFIER](identifiers.html) token `r` in order to avoid confusion with the [WildcardPattern](patterns.html)",
            "Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in `rustc` .",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) ."
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]().",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`."
          ]
        },
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        }
      ],
      "reasoning": "The excerpts provide a comprehensive overview of Rust's keywords and identifier rules. Several excerpts explicitly categorize keywords into 'strict', 'reserved', and 'weak' categories, detailing their usage and restrictions. Many excerpts list specific keywords for each category, including those added in different Rust editions (2018, 2024). The concept of 'raw identifiers' is well-covered, explaining their purpose and syntax, particularly in relation to using keywords as identifiers. Additionally, the excerpts touch upon general identifier rules, such as allowed characters, Unicode normalization, and the significance of underscores, providing a solid foundation for understanding Rust's lexical structure.",
      "confidence": "high"
    },
    {
      "field": "data_engineering_and_storage_keywords",
      "citations": [
        {
          "title": "Diesel GitHub Repository",
          "url": "https://github.com/diesel-rs/diesel",
          "excerpts": [
            "A safe, extensible ORM and Query Builder for Rust",
            "Diesel gets rid of the boilerplate for database interaction and eliminates\nruntime errors without sacrificing performance. It takes full advantage of\nRust's type system to create a low overhead query builder that \"feels like\nRust.\" Supported databases:"
          ]
        },
        {
          "title": "Diesel: Safe, Extensible ORM and Query Builder for Rust",
          "url": "https://diesel.rs/",
          "excerpts": [
            "Diesel is a Safe, Extensible ORM and Query Builder for Rust",
            "Diesel is the most productive way to interact with databases in Rust\nbecause of its safe and composable abstractions over queries.",
            "Preventing Runtime Errors",
            "We donâ€™t want to waste time tracking down runtime errors. We achieve\nthis by having Diesel eliminate the possibility of incorrect database\ninteractions at compile time.",
            "Built for Performance",
            "Diesel offers a high level query builder and lets you think about\nyour problems in Rust, not SQL. Our focus on zero-cost abstractions\nallows Diesel to run your query and load your data even faster than\nC.",
            "Productive and Extensible"
          ]
        },
        {
          "title": "Getting Started with Diesel",
          "url": "https://diesel.rs/guides/getting-started",
          "excerpts": [
            "Diesel requires Rust 1.78 or later. If you're following along with this ... The diesel GitHub repository contains modified examples for all supported backends."
          ]
        },
        {
          "title": "diesel 2.2.12",
          "url": "https://docs.rs/crate/diesel/latest",
          "excerpts": [
            "Diesel codegen generates boilerplate for you. It lets you focus on your business logic, not mapping to and from SQL rows. That means you can write this ..."
          ]
        },
        {
          "title": "Configuring Diesel CLI",
          "url": "https://diesel.rs/guides/configuring-diesel-cli.html",
          "excerpts": [
            "Diesel CLI is an optional tool Diesel provides to manage your database schema. Its main two roles are to run database migrations, and to create a Rust file."
          ]
        },
        {
          "title": "diesel_cli - crates.io",
          "url": "https://crates.io/crates/diesel_cli",
          "excerpts": [
            "diesel_cli v2.2.12",
            "Provides the CLI for the Diesel crate",
            "Install\ncargo install diesel_cli"
          ]
        },
        {
          "title": "Refinery - Rust",
          "url": "https://docs.rs/refinery/",
          "excerpts": [
            "on\n\nPowerful SQL migration toolkit for Rust. `refinery` makes running migrations for different databases as easy as possible. It works by running your migrations on a provided database connection, either by embedding them on your Rust code, or via `refinery_cli`. Currently, [`Postgres`](https://crates.io/crate"
          ]
        },
        {
          "title": "Crate rocksdb - Rust",
          "url": "https://docs.rs/rocksdb",
          "excerpts": [
            "A standard Rust Iterator over a database or column family. DBPath: Represents a path where sst files can be put into; DBPinnableSlice: Wrapper around RocksDBÂ ...",
            "rocksdb 0.24.0"
          ]
        },
        {
          "title": "Embedded Key-value database - 2024. : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/1dsmj9d/embedded_keyvalue_database_2024/",
          "excerpts": [
            "RocksDB is still king for raw key-value storage. The LSM architecture gives you low write amplification compared to BTree, and easily allows forÂ ..."
          ]
        },
        {
          "title": "rust-rocksdb",
          "url": "https://crates.io/crates/rust-rocksdb",
          "excerpts": [
            "crates.io: Rust Package Registry For full functionality of this site it is necessary to enable JavaScript."
          ]
        },
        {
          "title": "RocksDB - crates.io",
          "url": "https://crates.io/crates/rocksdb",
          "excerpts": [
            "rocksdb v0.24.0",
            "Rust wrapper for Facebook's RocksDB embeddable database",
            "cargo add rocksdb",
            "rocksdb = \"0.24.0\""
          ]
        },
        {
          "title": "Sled Crate Documentation",
          "url": "https://docs.rs/sled",
          "excerpts": [
            "Modules Â§",
            "    * doc",
            "    * what is sled? * transaction",
            "    * Fully serializable (ACID) multi-\nTree transactions",
            "Structs Â§",
            "or. * Config",
            "    * Top-level configuration for the system.",
            "em. * Db",
            "ystem. * Db\n    * The\nsled embedded database! Implements\nDeref<Target = sled::Tree> to refer to\na default keyspace / namespace / bucket.",
            "    * Tree",
            "    * A flash-sympathetic persistent lock-free B+ tree.",
            "Traits Â§",
            "    * Merge\nOperator",
            "    * A function that may be configured on a particular shared\nTree that will be applied as a kind of read-modify-write operator\nto any values that are written using the\nTree::merge method.",
            "Functions Â§",
            "    * open",
            " * open\n    * Opens a\nDb with a default configuration at the\nspecified path."
          ]
        },
        {
          "title": "sled 0.34.7 - Docs.rs",
          "url": "https://docs.rs/crate/sled/latest",
          "excerpts": [
            "\nsled - ~~it's all downhill from here!! !~~\n=========================================\n\nA lightweight pure-rust high-performance transactional embedded database. ```\nlet tree = sled::open(\"/tmp/welcome-to-sled\").expect(\"open\");\n\n// insert and get, similar to std's BTreeMap\ntree.insert(\"KEY1\", \"VAL1\");\nassert_eq! (tree.get(&\"KEY1\"), Ok(Some(sled::IVec::from(\"VAL1\"))));\n\n// range queries\nfor kv in tree.range(\"KEY1\"..\"KEY9\") {}\n\n// deletion\ntree.remove(&\"KEY1\");\n\n// atomic compare and swap\ntree.compare_and_swap(\"KEY1\", Some(\"VAL1\"), Some(\"VAL2\"));\n\n// block until all operations are stable on disk\n// (flush_async also available to get a Future)\ntree.flush();\n```\n\nIf you would like to work with structured data without paying expensive deserialization costs, check out the [structured](examples/structured.rs) example! performance\n===========\n\n* [LSM tree](https://en.wikipedia.org/wiki/Log-structured_merge-tree)-like write performance\n  with [traditional B+ tree](https://en.wikipedia.org/wiki/B%2B_tree)-like read performance\n* over a billion operations in under a minute at 95% read 5% writes on 16 cores on a small dataset\n* measure your own workloads rather than relying on some marketing for contrived workloads\n\nwhat's the trade-off? sled uses too much disk space sometimes.\nthis will improve significantly before 1.0.\n\nfeatures\n========\n\n* [API](https://docs.rs/sled) similar to a threadsafe `BTreeMap<[u8], [u8]>`\n* serializable multi-key and multi-Tree interactive [transactions](https://docs.rs/sled/latest/sled/struct.Tree.html.transaction)\n* fully atomic single-key operations, supports [compare and swap](https://docs.rs/sled/latest/sled/struct.Tree.html.compare_and_swap)\n* zero-copy reads\n* [write batch support](https://docs.rs/sled/latest/sled/struct.Tree.html.apply_batch)\n* [subscriber/watch semantics on key prefixes](https://github.com/spacejam/sled/wiki/reactive-semantics)\n* [multiple keyspace/Tree support](https://docs.rs/sled/latest/sled/struct.Db.html.open_tree)\n* [merge operators](https://github.com/spacejam/sled/wiki/merge-operators)\n* forward and reverse iterators\n* a crash-safe monotonic [ID generator](https://docs.rs/sled/latest/sled/struct.Db.html.generate_id) capable of generating 75-125 million unique ID's per second\n* [zstd](https://github.com/facebook/zstd) compression (use the `compression` build feature)\n* cpu-scalable lock-free implementation\n* flash-optimized log-structured storage\n* uses modern b-tree techniques such as prefix encoding and suffix truncation for reducing the storage costs of long keys\n\na note on lexicographic ordering and endianness\n===============================================\n\nIf you want to store numerical keys in a way that will play nicely with sled's iterators and ordered operations, please remember\n ... \nWe support async subscription to events that happen on key prefixes, because the\n`Subscriber` struct implements `Future<Output=Option<Event>>`:\n\n```\nlet sled = sled::open(\"my_db\").unwrap();\nlet mut sub = sled.watch_prefix(\"\");\n\nsled.insert(b\"a\", b\"a\").unwrap();\nsled.insert(b\"a\", b\"a\").unwrap();\n\ndrop(sled);\n\nextreme::run(async move {\n    while let Some(event) = (&mut sub).await {\n        println! (\"got event {:? }\", event);\n    }\n});\n```\n\nminimum supported Rust version (MSRV)\n=====================================\n\nWe support Rust 1.39.0 and up. architecture\n============\n\nlock-free tree on a lock-free pagecache on a lock-free log. the pagecache scatters\npartial page fragments across the log, rather than rewriting entire pages at a time\nas B+ trees for spinning disks historically have. on page reads, we concurrently\nscatter-gather reads across the log to materialize the page from its fragments. check out the [architectural outlook](https://github.com/spacejam/sled/wiki/sled-architectural-outlook)\nfor a more detailed overview of where we're at and where we see things going! philosophy\n==========\n\n1. don't make the user think. the interface should be obvious. 2. don't surprise users with performance traps. 3. don't wake up operators. bring reliability techniques from academia into real-world practice. 4. don't use so much electricity. our data structures should play to modern hardware's strengths.\nknown issues, warnings\n======================\n\n* if reliability is your primary constraint, use SQLite. sled is beta. * if storage price performance is your primary constraint, use RocksDB. sled uses too much space sometimes. * quite young, should be considered unstable for the time being. * the on-disk format is going to change in ways that require [manual migrations](https://docs.rs/sled/latest/sled/struct.Db.html.export) before the `1.0.0` release! priorities\n==========\n\n* rework the transaction API to eliminate surprises and limitations\n* reduce space and memory usage\n* the 1.0.0 release date is January 19, 2021 (sled's 5th birthday)\n* combine merge operators with subscribers in a way that plays nicely with transactions\n* typed trees for low-friction serialization\n* replication support for both strongly and eventually consistent systems\n* continue to improve testing and make certain bug classes impossible through construction\n* continue to optimize the hell out of everything\n* continue to improve documentation and examples\n* continue to reduce compilation latency\n\nfund feature development\n========================\n\nLike what we're doing? Help us out via [GitHub Sponsors](https://github.com/sponsors/spacejam)! special thanks\n==============\n\nSpecial thanks to [Meili](https://www.meilisearch.com/) for providing engineering effort and other support to the sled project."
          ]
        },
        {
          "title": "sled v1.0.0-alpha.1 - Lightweight high-performance pure-rust transactional embedded database",
          "url": "https://crates.io/crates/sled/1.0.0-alpha.1",
          "excerpts": [
            "sled - crates.io: Rust Package Registry",
            "sled",
            "v1.0.0-alpha.1",
            "Lightweight high-performance pure-rust transactional embedded database.",
            "Lightweight high-performance pure-rust transactional embedded database.",
            "An embedded database.",
            "sled - ~~it's all downhill from here!! !~~",
            "features",
            "d) similar to a threadsafe `BTreeMap<[u8], [u8]>`\n* ",
            "* serializable (ACID) [transactions](https://docs.rs/sled/latest/sled/struct.Tree.html.transaction)",
            "* fully atomic single-key operations, including [compare and swap](https://docs.rs/sled/latest/sled/struct.Tree.html.compare_and_swap)",
            "* zero-copy reads",
            "* [write batches](https://docs.rs/sled/latest/sled/struct.Tree.html.apply_batch)",
            "* [subscribe to changes on key\n  prefixes](https://docs.rs/sled/latest/sled/struct.Tree.html.watch_prefix)",
            "* [multiple keyspaces](https://docs.rs/sled/latest/sled/struct.Db.html.open_tree)",
            "* [merge operators](https://docs.rs/sled/latest/sled/doc/merge_operators/index.html)",
            "* forward and reverse iterators over ranges of items",
            "* a crash-safe monotonic [ID generator](https://docs.rs/sled/latest/sled/struct.Db.html.generate_id)",
            "* [zstd](https://github.com/facebook/zstd) compression (use the\n  `compression` build feature, disabled by default)",
            "* cpu-scalable lock-free implementation",
            "* flash-optimized log-structured storage",
            "\n* uses modern b-tree techniques such as prefix encoding and suffix\n  truncation for reducing the storage costs of long keys with shared\n  prefixes. If keys are the same length and sequential then the\n  system can avoid storing 99%+ of the key data in most cases,\n  essentially acting like a learned index",
            "known issues, warnings",
            "* if reliability is your primary constraint, use SQLite. sled is beta.",
            "* if storage price performance is your primary constraint, use RocksDB. sled uses too much space sometimes.",
            "* if you have a multi-process workload that rarely writes, use LMDB. sled is architected for use with long-running, highly-concurrent workloads such as stateful services or higher-level databases.",
            "* quite young, should be considered unstable for the time being.",
            "* the on-disk format is going to change in ways that require [manual migrations](https://docs.rs/sled/latest/sled/struct.Db.html.export) before the `1.0.0` release!",
            "priorities",
            "1.\nA full rewrite of sled's storage subsystem is happening on a modular basis as part of the [komora project](https://github.com/komora-io), in particular the marble storage engine. This will dramatically lower both the disk space usage (space amplification) and garbage collection overhead (write amplification) of sled.",
            "minimum supported Rust version (MSRV)",
            "We support Rust 1.62 and up.",
            "Install",
            "Run the following Cargo command in your project directory:",
            "cargo add sled@=1.0.0-alpha.1",
            "Or add the following line to your Cargo.toml:",
            "sled = \"=1.0.0-alpha.1\"",
            "documentation",
            "[docs.rs/sled/1.0.0-alpha.1](https://docs.rs/sled/1.0.0-alpha.1)",
            "Repository",
            "[github.com/spacejam/sled](https://github.com/spacejam/sled)"
          ]
        },
        {
          "title": "lmdb-rs - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/lmdb-rs",
          "excerpts": [
            "Run the following Cargo command in your project directory: cargo add lmdb-rs Or add the following line to your Cargo.toml: lmdb-rs = \"0.7.6\""
          ]
        },
        {
          "title": "lmdb 0.8.0",
          "url": "https://docs.rs/crate/lmdb/latest",
          "excerpts": [
            "... Documentation Â· Crate. lmdb-rs. Idiomatic and safe APIs for interacting with the Symas Lightning Memory-Mapped Database (LMDB). Building from Source. git clone ..."
          ]
        },
        {
          "title": "Up to date Rust bindings for LMDB",
          "url": "https://news.ycombinator.com/item?id=41678228",
          "excerpts": [
            "LMDB is an extraordinarily fast, memory-efficient database we developed for the OpenLDAP Project. With memory-mapped files, LMDB has the read performance of aÂ ... LMDB is an extraordinarily fast, memory-efficient database we developed for the OpenLDAP Project. With memory-mapped files, LMDB has the read performance of a ..."
          ]
        },
        {
          "title": "moka - Rust",
          "url": "https://docs.rs/moka/latest/moka/",
          "excerpts": [
            "Moka is a fast, concurrent cache library for Rust. Moka is inspired by the Caffeine library for Java. Moka provides in-memory concurrent cache implementations."
          ]
        },
        {
          "title": "deadpool_redis - Rust",
          "url": "https://docs.rs/deadpool-redis/latest/deadpool_redis/",
          "excerpts": [
            "Deadpool is a dead simple async pool for connections and objects of any type. This crate implements a deadpool manager for redis."
          ]
        },
        {
          "title": "cached - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cached",
          "excerpts": [
            "cached provides implementations of several caching structures as well as a handy macros for defining memoized functions."
          ]
        },
        {
          "title": "moka-rs/moka: A high performance concurrent caching ...",
          "url": "https://github.com/moka-rs/moka",
          "excerpts": [
            "Moka is a fast, concurrent cache library for Rust. Moka is inspired by the Caffeine library for Java. Moka provides cache implementations on top of hash maps."
          ]
        },
        {
          "title": "async_nats - Rust",
          "url": "https://docs.rs/async-nats",
          "excerpts": [
            "NATS.io is a simple, secure, and high-performance open-source messaging system designed for cloud-native applications, IoT messaging, and microservicesÂ ..."
          ]
        },
        {
          "title": "NATS Rust Client (docs.rs)",
          "url": "https://docs.rs/nats",
          "excerpts": [
            "Async-enabled NATS client. An async Rust client for the NATS.io ecosystem.",
            " Modules\n ",
            "    * asynk",
            "em. * header",
            "es. * jetstream",
            "JetStream stream management and consumers. Support for the",
            "JetStream at-least-once messaging system.",
            "em. * kv unstable",
            "Support for Key Value Store. This feature is experimental and the API may change.",
            "ge. * object_store unstable",
            "Support for Object Store. This feature is experimental and the API may change.",
            " Structs\n  ",
            "    * Connection",
            "on. * Handler",
            "ad. * Message",
            "ct. * Options",
            "ns. * ServerAddress"
          ]
        },
        {
          "title": "streamnative/pulsar-rs: Rust Client library for Apache Pulsar",
          "url": "https://github.com/streamnative/pulsar-rs",
          "excerpts": [
            "A pure Rust client for Apache Pulsar that does not depend on the C++ Pulsar library. It provides an async/await based API, compatible with Tokio and async-std. A pure Rust client for Apache Pulsar that does not depend on the C++ Pulsar library. It provides an async/await based API, compatible with Tokio and async-std."
          ]
        },
        {
          "title": "bk-rs/pulsar-rs: Apache Pulsar Rust Client",
          "url": "https://github.com/bk-rs/pulsar-rs",
          "excerpts": [
            "Apache Pulsar Rust Client. Contribute to bk-rs/pulsar-rs development by creating an account on GitHub. Apache Pulsar Rust Client. Contribute to bk-rs/pulsar-rs development by creating an account on GitHub."
          ]
        },
        {
          "title": "rdkafka crate documentation (docs.rs/crate/rdkafka/0.8.1)",
          "url": "https://docs.rs/crate/rdkafka/0.8.1",
          "excerpts": [
            "rdkafka 0.8.1",
            "Rust wrapper for librdkafka",
            "Kafka client library for Rust based on librdkafka",
            "The main features provided at the moment are:",
            "* Support for Kafka 0.8.x, 0.9.x and 0.10.x (timestamp support coming soon).",
            "Consume from single or multiple topics.",
            "Automatic consumer rebalancing.",
            "Customizable rebalance, with pre and post rebalance callbacks.",
            "Offset commit.",
            "Message production.",
            "Access to cluster metadata (list of topic-partitions, replicas, active brokers etc).",
            "Access to group metadata (list groups, list members of groups, hostnames etc).",
            "Access to producer and consumer metrics and statistics.",
            "Client types",
            "rust-rdkafka provides low level and high level consumers and producers.",
            "High level:",
            "    * StreamConsumer : it returns a\nstream of messages and takes care of polling the consumer internally.",
            "ly. * FutureProducer : it returns a\nfuture that will be completed once the message is delivered to Kafka (or failed).",
            "To compile from sources, you'll have to update the submodule containing librdkafka:",
            "git submodule update -- init",
            "To compile librdkafka you'll need:",
            "* the GNU toolchain",
            "* GNU\nmake",
            "* pthreads",
            "* zlib",
            "* libssl-dev : optional, not included by default (feature:\nssl ).",
            "* libsasl2-dev : optional, not included by default (feature:\nsasl ).",
            "Example:",
            "cargo build -- features \" ssl sasl \"",
            "examples",
            "You can find examples in the\nexamples folder."
          ]
        },
        {
          "title": "Polars: DataFrames in Rust",
          "url": "https://docs.rs/polars/latest/polars/",
          "excerpts": [
            "Polars: DataFrames in Rust",
            "Polars is a DataFrame library for Rust. It is based on [Apache Arrow](https://arrow.apache.org/)â€™s memory model. Apache Arrow provides very cache efficient columnar data structures and is becoming the defacto\nstandard for columnar data.",
            "Polars is a DataFrame library for Rust.",
            "The base data structures provided by polars are [`DataFrame`](prelude/struct.DataFrame.html \"struct polars::prelude::DataFrame\"), [`Series`](prelude/struct.Series.html \"struct polars::prelude::Series\"), and [`ChunkedArray<T>`](prelude/struct.ChunkedArray.html \"struct polars::prelude::ChunkedArray\").",
            "We recommend building queries directly with [polars-lazy](https://docs.rs/polars-lazy/0.50.0/x86_64-unknown-linux-gnu/polars_lazy/index.html \"mod polars_lazy\"). This allows you to combine\nexpressions into powerful aggregations and column selections. All expressions are evaluated\nin parallel and queries are optimized just in time.",
            "This means that Polars data structures can be shared zero copy with processes in many different\nlanguages.",
            "* `POLARS_TABLE_WIDTH` -> width of the tables used during DataFrame formatting.",
            "* `POLARS_MAX_THREADS` -> maximum number of threads used to initialize thread pool (on startup).",
            "* `POLARS_VERBOSE` -> print logging info to stderr.",
            "* `POLARS_NO_PARTITION` -> polars may choose to partition the group\\_by operation, based on data\n  cardinality. Setting this env var will turn partitioned group\\_byâ€™s of",
            "* `POLARS_PARTITION_UNIQUE_COUNT` -> at which (estimated) key count a partitioned group\\_by should run. defaults to `1000`, any higher cardinality will run default group\\_by.",
            "* `POLARS_FORCE_PARTITION` -> force partitioned group\\_by if the keys and aggregations allow it.",
            "* `POLARS_ALLOW_EXTENSION` -> allows for [`ObjectChunked<T>`](prelude/type.ObjectChunked.html \"type polars::prelude::ObjectChunked\") to be used in arrow, opening up possibilities like using\n  `T` in complex lazy expressions. However this does require `unsafe` code allow thi",
            "* `POLARS_NO_PARQUET_STATISTICS` -> if set, statistics in parquet files are ignored.",
            "* `POLARS_PANIC_ON_ERR` -> panic instead of returning an Error.",
            "* `POLARS_BACKTRACE_IN_ERR` -> include a Rust backtrace in Error messages.",
            "* `POLARS_NO_CHUNKED_JOIN` -> force rechunk before join",
            "If you want to read more, check the [user guide](https://docs.pola.rs/)."
          ]
        },
        {
          "title": "Polars: Blazingly Fast DataFrame Library",
          "url": "https://docs.pola.rs/",
          "excerpts": [
            "Polars is a blazingly fast DataFrame library for manipulating structured data. The core is written\nin Rust, and available for Python, R and NodeJS. ## Key features",
            "Fast** : Written from scratch in Rust, designed close to the machine and without external\n   dependencie",
            "I/O** : First class support for all common data storage layers: local, cloud storage & database",
            "Intuitive API** : Write your queries the way they were intended. Polars, internally, will\n   determine the most efficient way to execute using its query optimize",
            "Out of Core** : The streaming API allows you to process your results without requiring all your\n   data to be in memory at the same tim",
            "Parallel** : Utilises the power of your machine by dividing the workload among the available CPU\n   cores without any additional configuratio"
          ]
        },
        {
          "title": "ballista - Rust",
          "url": "https://docs.rs/ballista",
          "excerpts": [
            "Ballista is a distributed query execution engine that enhances Apache DataFusion by enabling the parallelized execution of workloads across multiple nodes."
          ]
        },
        {
          "title": "Apache DataFusion â€” Apache DataFusion documentation",
          "url": "https://datafusion.apache.org/",
          "excerpts": [
            "DataFusion is an extensible query engine written in Rust that uses Apache Arrow as its in-memory format."
          ]
        },
        {
          "title": "Apache DataFusion SQL Query Engine",
          "url": "https://github.com/apache/datafusion",
          "excerpts": [
            "DataFusion is an extensible query engine written in Rust that uses Apache Arrow as its in-memory format. This crate provides libraries and binaries for ..."
          ]
        },
        {
          "title": "Apache Arrow Official Native Rust Implementation",
          "url": "https://crates.io/crates/arrow",
          "excerpts": [
            "This crate contains the official Native Rust implementation of Apache Arrow in memory format, governed by the Apache Software Foundation."
          ]
        },
        {
          "title": "arrow - Rust",
          "url": "https://arrow.apache.org/rust/arrow/index.html",
          "excerpts": [
            "A complete, safe, native Rust implementation of Apache Arrow, a cross-language development platform for in-memory data. Please see the arrow crates.io page ..."
          ]
        },
        {
          "title": "meilisearch-sdk | Cargo",
          "url": "https://deps.dev/cargo/meilisearch-sdk/0.24.3",
          "excerpts": [
            "Nov 2, 2023 â€” Description. Rust wrapper for the Meilisearch API. Meilisearch is a powerful, fast, open-source, easy to use and deploy search engine."
          ]
        },
        {
          "title": "Rust client",
          "url": "https://docs.opensearch.org/latest/clients/rust/",
          "excerpts": [
            "The OpenSearch Rust client lets you connect your Rust application with the data in your OpenSearch cluster. For the client's complete API documentation and ..."
          ]
        },
        {
          "title": "OpenSearch Rust Client",
          "url": "https://github.com/opensearch-project/opensearch-rs",
          "excerpts": [
            "The opensearch-rs client is a community-driven, open source fork of elasticsearch-rs, licensed under the Apache v2.0 License."
          ]
        },
        {
          "title": "opensearch - Rust",
          "url": "https://docs.rs/opensearch/",
          "excerpts": [
            "OpenSearch is an official Rust client for OpenSearch, providing an efficient asynchronous client for all stable OpenSearch APIs that's easy to use."
          ]
        },
        {
          "title": "elasticsearch - Rust",
          "url": "https://docs.rs/elasticsearch/",
          "excerpts": [
            "Jan 8, 2020 â€” Elasticsearch is an official Rust client for Elasticsearch, providing an efficient asynchronous client for all stable Elasticsearch APIs that's easy to use."
          ]
        },
        {
          "title": "Meilisearch SDK (Docs.rs)",
          "url": "https://docs.rs/meilisearch-sdk",
          "excerpts": [
            "meilisearch\\_sdk - Rus",
            "meilisearch-sdk 0.29.1",
            "Meilisearch is a powerful, fast, open-source, easy to use and deploy search engine.",
            "Repository](https://github.com/meilisearch/meilisearch-sdk",
            "crates.io](https://crates.io/crates/meilisearch-sdk"
          ]
        },
        {
          "title": "Serde Documentation / Crate serde",
          "url": "https://docs.rs/serde",
          "excerpts": [
            "Serde is a framework for _**ser**_ ializing and _**de**_ serializing Rust data\nstructures efficiently and generically.",
            "The Serde ecosystem consists of data structures that know how to serialize\nand deserialize themselves along with data formats that know how to\nserialize and deserialize other things.",
            ")\n\n# Crate serde Copy item path",
            "Summary [Source](../src/serde/lib.rs.html)",
            "Serde provides the layer by which\nthese two groups interact with each other, allowing any supported data\nstructure to be serialized and deserialized using any supported data format.",
            "The following is a partial list of data formats that have been implemented\nfor Serde by the community. * [JSON](https://github.com/serde-rs/json) , the ubiquitous JavaScript Object Notation used by many HTTP APIs.",
            "* [Postcard](https://github.com/jamesmunns/postcard) , a no\\_std and embedded-systems friendly compact binary format",
            "* [CBOR](https://github.com/enarx/ciborium) , a Concise Binary Object Representation designed for small message\n  size without the need for version negotiatio",
            "* [YAML](https://github.com/dtolnay/serde-yaml) , a self-proclaimed human-friendly configuration language that ainâ€™t\n  markup languag",
            "* [MessagePack](https://github.com/3Hren/msgpack-rust) , an efficient binary format that resembles a compact JSON.",
            "* [TOML](https://docs.rs/toml) , a minimal configuration format used by [Cargo",
            "* [Pickle](https://github.com/birkenfeld/serde-pickle) , a format common in the Python world.",
            "* [RON](https://github.com/ron-rs/ron) , a Rusty Object Notation.",
            "* [BSON](https://github.com/mongodb/bson-rust) , the data storage and network transfer format used by MongoDB.",
            "* [Avro](https://docs.rs/apache-avro) , a binary format used within Apache Hadoop, with support for schema\n  definitio",
            "* [JSON5](https://github.com/callum-oakley/json5-rs) , a superset of JSON including some productions from ES5.",
            "* [URL](https://docs.rs/serde_qs) query strings, in the x-www-form-urlencoded format.",
            "* [Starlark](https://github.com/dtolnay/serde-starlark) , the format used for describing build targets by the Bazel and\n  Buck build system"
          ]
        },
        {
          "title": "postcard - Rust",
          "url": "https://docs.rs/postcard/latest/postcard/",
          "excerpts": [
            "Postcard is a #![no_std] focused serializer and deserializer for Serde. Postcard aims to be convenient for developers in constrained environments."
          ]
        },
        {
          "title": "sqlx-cli - crates.io",
          "url": "https://crates.io/crates/sqlx-cli",
          "excerpts": [
            "sqlx-cli v0.8.6"
          ]
        },
        {
          "title": "envy - Rust",
          "url": "https://docs.rs/envy",
          "excerpts": [
            "Envy is a library for deserializing environment variables into typesafe structs. Â§Examples. A typical usecase for envy is deserializing configuration store ..."
          ]
        },
        {
          "title": "envy - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/envy",
          "excerpts": [
            "Envy also supports deserializing Vecs from comma separated env var values. Because envy is built on top of serde, you can use all of serde's ..."
          ]
        },
        {
          "title": "dotenvy - Rust",
          "url": "https://docs.rs/dotenvy/latest/dotenvy/",
          "excerpts": [
            "This library loads environment variables from a .env file. This is convenient for dev environments. StructsÂ§. Iter. EnumsÂ§. Error. FunctionsÂ§."
          ]
        },
        {
          "title": "dotenvy - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/dotenvy",
          "excerpts": [
            "Install cargo install dotenvy Running the above command will globally install the dotenvy binary. Install as library Run the following Cargo command in your ..."
          ]
        },
        {
          "title": "Config - Rust crate (docs.rs)",
          "url": "https://docs.rs/config/latest/config/",
          "excerpts": [
            "`Config` organizes hierarchical or layered configurations for Rust applications.",
            "Config\") lets you set a set of [default parameters](builder/struct.ConfigBuilder.html.set_default \"method config::builder::ConfigBuilder::set_default\") and then extend them via merging in\nconfiguration from a variety of sources:",
            "Additionally, [`Config`](struct.Config.html \"struct config::Config\") supports:",
            "Live watching and re-reading of configuration files",
            "Deserialization via `serde` of the configuration or any subset defined via a path"
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to data engineering and storage in Rust, specifically covering ORMs, database migration tools, embedded stores, caching, messaging/streaming, dataframes/analytics, query engines, search, serialization, and configuration. The provided excerpts contain direct mentions and descriptions of various libraries and concepts within these categories.\n\nFor 'ORMs and Query Layers', the excerpts discuss Diesel as a safe, extensible ORM and Query Builder for Rust, highlighting its type-safe queries and compile-time error prevention. It also mentions its support for PostgreSQL, MySQL, and SQLite. SQLx is mentioned as an async SQL toolkit. SeaORM is described as an async and dynamic ORM.\n\nFor 'Database Migration Tools', Diesel CLI is identified as a tool for managing database schemas and migrations. SQLx CLI is also mentioned for managing databases, migrations, and enabling 'offline' mode. Refinery is presented as a powerful SQL migration toolkit.\n\nFor 'Embedded Stores', RocksDB is described as a Rust wrapper for Facebook's RocksDB embeddable database. Sled is detailed as a lightweight, pure-Rust, high-performance transactional embedded database with features like B+ tree-like read performance, ACID transactions, zero-copy reads, and multiple keyspaces. LMDB is also mentioned as an extraordinarily fast, memory-efficient database.\n\nFor 'Caching', Moka is described as a fast, concurrent cache library. Deadpool-redis is mentioned as an async pool for Redis connections. Cached provides implementations of several caching structures and macros for memoized functions.\n\nFor 'Messaging and Streaming', `async-nats` and `nats` are identified as async Rust clients for the NATS.io ecosystem, supporting JetStream and at-least-once messaging. `rdkafka` is presented as a Kafka client library for Rust based on `librdkafka`, offering features like consumer rebalancing and message production. `pulsar-rs` is mentioned as a pure Rust client for Apache Pulsar.\n\nFor 'DataFrames & Analytics', Polars is highlighted as a DataFrame library for Rust based on Apache Arrow's memory model, emphasizing its speed, parallel execution, and out-of-core processing. The `arrow` crate is noted as the official native Rust implementation of Apache Arrow.\n\nFor 'Query Engines', DataFusion is described as an extensible query engine written in Rust that uses Apache Arrow. Ballista is mentioned as a distributed query execution engine that enhances DataFusion.\n\nFor 'Search', `meilisearch-sdk` is identified as a Rust wrapper for the Meilisearch API. `opensearch` and `elasticsearch` are mentioned as official Rust clients for their respective search engines. Tantivy is also listed as a full-text search engine library.\n\nFor 'Serialization', Serde is extensively covered as a framework for serializing and deserializing Rust data structures, with mentions of various data formats it supports, including Postcard (no_std friendly), MessagePack, CBOR, Protocol Buffers (prost), Flatbuffers, Cap'n Proto, and rkyv (zero-copy deserialization). The concepts of `Serialize` and `Deserialize` traits are central to Serde.\n\nFor 'Configuration', `config-rs` is described as a library for organizing hierarchical or layered configurations, supporting various sources and deserialization via Serde. Envy is mentioned for deserializing environment variables into type-safe structs, and `dotenvy` for loading environment variables from `.env` files.",
      "confidence": "high"
    },
    {
      "field": "data_types_and_layout_keywords",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_STRUCT : `struct",
            "KW\\_UNION : `union",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio"
          ]
        },
        {
          "title": "The Rust Reference - Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes.html?highlight=attribute",
          "excerpts": [
            "Inner attributes_ , written with a bang ( `!` ) after the hash ( `#` ), apply to the\nitem that the attribute is declared within. _Outer attributes_ , written without\nthe bang after the hash, apply to the thing that follows t"
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "Preludes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/names/preludes.html",
          "excerpts": [
            "* [Language prelud",
            "It includes the following:\n\n* [Type namespace](namespaces.html)\n  + [Boolean type](../types/boolean.html) â€” `bool`\n  + [Textual types](../types/textual.html) â€” `char` and `str`\n  + [Integer types](../types/numeric.html) â€” `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`\n  + [Machine-dependent integer types](../types/numeric.html) â€” `usize` and `isize`\n  + [floating-point types](../types/numeric.html) â€” `f32` and `f64`"
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "following code:",
            "```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n",
            "The Rustonomicon"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time.",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Error codes index",
          "url": "https://doc.rust-lang.org/error-index.html",
          "excerpts": [
            "Rust error codes index - Error codes index\n\nIf you are not automatically redirected to the error code index, please [here](./error_codes/error-index.html) ."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "The Rust Programming Language Blog",
          "url": "https://blog.rust-lang.org/",
          "excerpts": [
            "This is the main Rust blog. Rust teams use this blog to announce major developments in the world of Rust. See also: the \"Inside Rust\" blog,Â ..."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "```rust",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust",
            "fn main() {",
            "}",
            "}",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "# [`min_specialization`]()",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "min\\_specialization - The Rust Unstable Boo"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            " [Idea] About soundness in specialization ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... ",
            "This topic was automatically closed 90 days after the last reply. New replies are no longer allowed."
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes.",
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Rust Deep Dive: Borked Vtables and Barking Cats",
          "url": "https://geo-ant.github.io/blog/2023/rust-dyn-trait-objects-fat-pointers/",
          "excerpts": [
            "Mar 15, 2023 â€” The pointers to dyn Trait objects store both the address of the data as well as a pointer to the vtable. There is one global vtable instance forÂ ...",
            "Mar 15, 2023 â€” We'll get to the specific layout of a vtable below, but for now suffice it to say that a vtable is a contiguous piece of storage in memory thatÂ ..."
          ]
        },
        {
          "title": "Understanding Rust's Trait Objects: Vtables, Dynamic ...",
          "url": "https://www.reddit.com/r/rust/comments/1epc5g6/understanding_rusts_trait_objects_vtables_dynamic/",
          "excerpts": [
            "This article investigates how Rust handles dynamic dispatch using trait objects and vtables. It also explores how the Rust compiler can sometimes optimize tailÂ ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "# [Chalk: Orphan Check]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "## [The Orphan Rules]()",
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "The reason for this is that there are two appearances of type parameter `T` in",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117)."
          ]
        },
        {
          "title": "Coherence - Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/coherence.html",
          "excerpts": [
            "Coherence checking is what detects both of trait impls and inherent impls overlapping with others.",
            "Overlap checks are performed for both inherent impls, and for trait impls.",
            "This uses the same overlap checking code, really done as two separate analyses.",
            "Overlapping is sometimes partially allowed:",
            "1. for marker traits",
            "2. under [specializatio",
            "but normally isn't.",
            "the explicit negative impl check, and the implicit negative impl check. Both try to prove that an overlap is definitely impossible.",
            "ses. Overlap checks always consider pairs of implementations, comparing them to each other. Overlap "
          ]
        },
        {
          "title": "Data Representation and Layout in Rust - OpenGuild",
          "url": "https://openguild.wtf/blog/rust/data-representation-and-layout",
          "excerpts": [
            "Nov 22, 2023 â€” Rust, with its emphasis on control and safety, provides two primary representations: repr(rust) and repr(C) . The former instructs theÂ ..."
          ]
        },
        {
          "title": "2005-match-ergonomics - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2005-match-ergonomics.html",
          "excerpts": [
            "This RFC introduces default binding modes used when a reference value is matched by a non-reference pattern."
          ]
        },
        {
          "title": "Idiomatic definition of uninhabited (never) newtypes",
          "url": "https://internals.rust-lang.org/t/idiomatic-definition-of-uninhabited-never-newtypes/20877",
          "excerpts": [
            "May 20, 2024 â€” It's conventional to use an empty enum for an uninhabited type, because that's the only stable way to do it."
          ]
        },
        {
          "title": "Why doesn't the niche optimization work for this enum?",
          "url": "https://users.rust-lang.org/t/why-doesnt-the-niche-optimization-work-for-this-enum/55711",
          "excerpts": [
            "Feb 16, 2021 â€” The only guaranteed niche filling optimization is if you have an enum that fits the template below exactly, and the wrapped type has a niche."
          ]
        },
        {
          "title": "Pre-(Pre-)RFC: niche types - language design",
          "url": "https://internals.rust-lang.org/t/pre-pre-rfc-niche-types/21810",
          "excerpts": [
            "Nov 2, 2024 â€” Niches are bit patterns within a struct or enum which can be repurposed by an enclosing enum or, in the future, an enclosing struct. While thisÂ ..."
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html?highlight=never",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete. [type. never .coercion]. Expressions of type ! can ..."
          ]
        },
        {
          "title": "never patterns, exhaustive matching, and uninhabited types",
          "url": "https://internals.rust-lang.org/t/blog-post-never-patterns-exhaustive-matching-and-uninhabited-types/8197",
          "excerpts": [
            "Aug 14, 2018 â€” Having two traits should solve problem with obscure corner cases with recursive uninhabited types, as they will not implement any of thoseÂ ..."
          ]
        },
        {
          "title": "Rust Reference: Type Layout",
          "url": "https://doc.rust-lang.org/reference/type-layout.html",
          "excerpts": [
            "All user-defined composite types ( `struct` s, `enum` s, and `union` s) have a _representation_ that specifies what the layout is for the type. [[layout .repr .kinds]]",
            ")\n\nThe possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()\n\n[[layout .repr .at",
            "The representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.",
            "ntro\")\n\nThe layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout. [[layout .guarantees]](.guarantees",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today. Note that even types with the same layout can still differ in how they are passed\nacross function boundaries."
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at most_ `n` . Most commonly used without an explicit `n` , `repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.",
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have `repr(C)` , as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type. We strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage your FFI\nboundaries fo",
            "The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world.",
            "* If `T` is an [FFI-safe non-nullable pointer\n  type](ffi.html),\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.",
            "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.",
            "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at least_ `n` . This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code). This is a modifier on `repr(C)` and `repr(Rust)` . It is incompatible with `repr(packed)` .",
            "The Rustonomicon",
            "\n# [Alternative representations]()",
            "[repr(C)]()",
            "* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.",
            "## [repr(transparent)]()",
            "Rust allows you to specify alternative data layout strategies from the default. There's also the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** normative). ## [repr(C)]()",
            "## [repr(u\\*), repr(i\\*)]",
            "## [repr(packed), repr(packed(n))]()",
            "## [repr(align(n))]()"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust Nomicon: repr-rust (Memory layout and ABI considerations)",
          "url": "https://doc.rust-lang.org/nomicon/repr-rust.html",
          "excerpts": [
            "Rust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)\n\nAn enum is said to be _field-less_ if none of its variants have associated data. By default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n}\n```\n```\n\nwill be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align \\`b\\`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n}\n```\n```\n\nor maybe:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n}\n```\n```\n\nThere is _no indirection_ for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```rust\n#!",
            "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2. Primitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits). A type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of [dynamically sized types](exotic-sizes.html).\nRust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)",
            "\n\nThere is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct A {\n    a: i32,\n    b: u64,\n}\n\nstruct B {\n    a: i32,\n    b: u64,\n}\n}\n```\n```\n\nRust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B. With A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways. For instance, consider this struct:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nstruct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}\n}\n```\n```\n\nNow consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:\n\n```\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}\n\nstruct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}\n```\n\nThe latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*. Enums make this consideration even more complicated. Naively, an enum such as:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nenum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}\n}\n```\n```\n\nmight be laid out as:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}\n}\n```\n```\n\nAnd indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`). However there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`. There are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today."
          ]
        },
        {
          "title": "Stack Overflow: Whats the difference between #[repr(Rust)], #[repr(C)] and #[repr(packed)]?",
          "url": "https://stackoverflow.com/questions/79631106/whats-the-difference-between-reprrust-reprc-and-reprpacked",
          "excerpts": [
            "In summary, `#[repr(Rust)]` leaves the representation to the compiler, which will probably do a better job of optimising the representation than you would by hand, and thus it makes the most sense to use for general use (which is why it's the default â€“ it's rare to actually write `#[repr(Rust)]` explicitly).",
            "`#[repr(C)]` exists to allow two sections of code to agree on how data should be represented even if they're compiled independently of each other; its purpose is to be a consistent representation that always stays the same.",
            "the reason is that the structure needs to always have the same layout so that the `select` function can actually access its fields (it's been compiled by the OS vendors, separately from the Rust code, so will be looking at known locations for the fields and Rust needs to put the fields in the same place)."
          ]
        },
        {
          "title": "Rust Reference: Non-exhaustive Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes/type_system.html",
          "excerpts": [
            "The *`non_exhaustive` attribute* indicates that a type or variant may have\nmore fields or variants added in the future.",
            "Outside of the defining crate, types annotated with `non_exhaustive` have limitations that\npreserve backwards compatibility when new fields or variants are added.",
            "Non-exhaustive types cannot be constructed outside of the defining crate:\n\n* Non-exhaustive variants ([`struct`](../items/structs.html) or [`enum` variant](../items/enumerations.html)) cannot be constructed\n  with a [StructExpression](../expressions/struct-expr.html) (including with [functional update syntax](../expressions/struct-expr.html)). * The implicitly defined same-named constant of a [unit-like struct](../items/structs.html),\n  or the same-named constructor function of a [tuple struct](../items/structs.html),\n  has a [visibility](../visibility-and-privacy.html) no greater than `pub(crate)`",
            "There are limitations when matching on non-exhaustive types outside of the defining crate:",
            "The Rust Reference",
            "Type system attributes",
            "The `non_exhaustive` attribute",
            "It can be applied to [`struct`s](../items/structs.html), [`enum`s](../items/enumerations.html), and `enum` variants."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "The Rust Reference"
          ]
        },
        {
          "title": "Empty Source Document",
          "url": "https://doc.rust-lang.org/reference/patterns.html",
          "excerpts": [
            "**NOTE**: The provided source document is empty and does not contain any information relevant to the query about Rust's type system, algebraic data types, pattern matching, or type layout concepts.",
            "Patterns are used in:",
            "`let` declarations\n`match` expressions\n`if let` expressions\n`while let` expressions\n`for` expressions\n",
            "Patterns can be used to *destructure* [structs](items/structs.html), [enums](items/enumerations.html), and [tuples](types/tuple.html). Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.",
            "wildcard\")\n\nIn a pattern whose [scrutinee](glossary.html) expression has a `struct`, `enum` or `tuple` type, a [wildcard pattern]() (`_`) stands in for a *single* data field, whereas an [et cetera]() or [rest pattern]() (`..`) stands in for *all* the remaining fields of a particular variant."
          ]
        },
        {
          "title": "Rust Type Layout and ABI Details",
          "url": "https://doc.rust-lang.org/std/mem/fn.discriminant.html",
          "excerpts": [
            "\nIf an enum has opted-in to having a [primitive representation](../../reference/type-layout.html) for its discriminant,\nthen itâ€™s possible to use pointers to read the memory location storing the discriminant. That **cannot** be done for enums using the [default representation](../../reference/type-layout.html) , however, as itâ€™s\nundefined what layout the discriminant has and where itâ€™s stored â€” it might not even be\nstored at all!",
            "\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct {"
          ]
        },
        {
          "title": "Refutability: Whether a Pattern Might Fail to Match",
          "url": "https://doc.rust-lang.org/book/ch19-02-refutability.html",
          "excerpts": [
            "Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable."
          ]
        },
        {
          "title": "Defining an Enum - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html",
          "excerpts": [
            "This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include anotherÂ ..."
          ]
        },
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n",
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "### [Â§]() Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an\niterator that is conditionally empty.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](.",
            " std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok\\(T\\),%0A+++++++Err\\(E\\),%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](../../std/io/index.html) .\n ... \n;\n    Ok (())\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++fn+write_message\\(\\)+-%3E+io::Result%3C\\(\\)%3E+%7B%0A++++++++let+mut+file+=+File::create\\(%22valuable_data.txt%22\\)?;%0A++++++++file.write_all\\(b%22important+message%22\\)? ;%0A++++++++Ok\\(\\(\\)\\)%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\n## [Â§]() The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark\noperator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\") , hides some of the boilerplate of propagating errors\nup the call stack. It replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude:: * ;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: & Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create( \"my_best_friends.txt\" ) {\n           Err (e) => return Err (e),\n           Ok (f) => f,\n    };\n    if let Err (e) = file.write_all( format! ( \"name: {}\\n\" , info.name).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format! ( \"age: {}\\n\" , info.age).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format!\n ... \n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides. ## [Â§]() Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI\nguarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a\ntype that qualifies for the `Option` [representation guarantees](../option/index.html \"Option Representation\") ,\nand the _other_ type must meet all of the following conditions:\n\n* Is a zero-sized type with alignment 1 (a â€œ1-ZSTâ€). * Has no fields. * Does not have the `#[non_exhaustive]` attribute. For example, `NonZeroI32` qualifies for the `Option` representation\nguarantees, and `()` is a zero-sized type with alignment 1, no fields, and\nit isnâ€™t `non_exhaustive` . This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees\nas `Option<NonZeroI32>` .\n ... \nIf the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](enum.Result.html.Ok \"variant std::result::Result::Ok\") :\n\n* [`expect_err`](enum.Result.html.expect_err \"method std::result::Result::expect\\_err\") panics with a provided custom message\n* [`unwrap_err`](enum.Result.html.unwrap_err \"method std::result::Result::unwrap\\_err\") panics with a generic message\n* [`unwrap_err_unchecked`](enum.Result.html.unwrap_err_unchecked \"method std::result::Result::unwrap\\_err\\_unchecked\") produces _[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)_\n\n### [Â§]() Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\") :\n\n* [`err`](enum.Result.html.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\") ,\n  mapping [`Err(e)`]"
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete."
          ]
        },
        {
          "title": "Type Layout - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/type-layout.html?highlight=repr",
          "excerpts": [
            "Type layout - The Rust Reference",
            "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.",
            "Type layout can be changed with each compilation.",
            "All values have an alignment and size.",
            "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.",
            "Pointers to sized types have the same size and alignment as `usize`.",
            "Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.",
            "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes.",
            "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`.",
            "Tuples are laid out according to the [`Rust` representation]()",
            "The exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.",
            "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.",
            "The possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()",
            "The representation of a type can be changed by applying the `repr` attribute\nto it.",
            "The alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.",
            "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.",
            "The only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n1. The fields are properly aligned. 2. The fields do not overlap. 3. The alignment of the type is at least the maximum alignment of its fields.",
            "There are no other guarantees of data layout made by this representation.",
            "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.",
            "This representation can be applied to structs, unions, and enums.\nThe exception\nis [zero-variant enums](items/enumerations.html) for which the `C` representation is an error.",
            "The alignment of the struct is the alignment of the most-aligned field in it.",
            "The size and offset of fields is determined by the following algorithm. Start with a current offset of 0 bytes. For each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the fieldâ€™s\nalignment, then add padding bytes to the current offset until it is a multiple\nof the fieldâ€™s alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field. Finally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the structâ€™s alignment.",
            "For [field-less enums](items/enumerations.html), the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platformâ€™s C ABI.",
            "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a â€œtagged unionâ€ in C:",
            "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize",
            "Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums](items/enumerations.html) to have a primitive representation. Combining\ntwo primitive representations together is an error.",
            "For [field-less enums](items/enumerations.html), primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive.",
            "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (â€œthe tagâ€) and the remaining fields are the fields of that variant.",
            "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`]() by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.",
            "The `transparent` representation can only be used on a [`struct`](items/structs.html)\nor an [`enum`](items/enumerations.html) with a single variant that has:\n\n* any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`](special-types-and-traits.html)), and\n* at most one other field.",
            "Structs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field."
          ]
        },
        {
          "title": "The Nullable Pointer Optimization",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "Certain Rust types are defined to never be `null`. This includes references (`&T`,\n`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\ninterfacing with C, pointers that might be `null` are often used, which would seem to\nrequire some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types. However, trying to construct/work with these invalid values **is undefined behavior**,\nso you should use the following workaround instead. As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\nexactly two variants, one of which contains no data and the other contains a field of one of the\nnon-nullable types listed above. This means no extra space is required for a discriminant; rather,\nthe empty variant is represented by putting a `null` value into the non-nullable field. This is\ncalled an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\ntypes. The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\nwhere `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\nto represent a nullable function pointer using the C ABI (corresponding to the C type\n`int (*)(int)`). Here is a contrived example.",
            "If you expect Rust `panic` s or foreign (e.g. C++) exceptions to cross an FFI\nboundary, that boundary must use the appropriate `-unwind` ABI string."
          ]
        }
      ],
      "reasoning": "The user is asking for keywords related to 'Algebraic Data Types (ADTs)' and other related data types and layout concepts in Rust. The provided excerpts cover a wide range of topics that are relevant to this query.\n\nSeveral excerpts directly discuss Rust's fundamental data types, including:\n\n*   **Enums and Structs:** Excerpts like Index 17, 37, 57, 64, 18, 17, 37, 57, 64, 108, 111, 112, 117, 121, 130, 131, 157, 158, 162, 163, 164, 165, 166, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581. These excerpts discuss structs, enums, tuples, unions, Option, Result, and their associated concepts like variants, fields, discriminants, and representations. \n\nExcerpts related to pattern matching, refutability, and exhaustive matching are also relevant:\n\n*   Excerpts 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581. These discuss pattern matching, refutability, exhaustive matching, `if let`, `while let`, `match` expressions, and the `!` (never) type. \n\nExcerpts discussing type layout, `repr` attributes, and ABI are also relevant:\n\n*   Excerpts 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 526, 527, 528, 529, 530, 535, 536, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577. These discuss type layout, `repr` attributes (`Rust`, `C`, `transparent`, `packed`, `align`), discriminants, niche optimization, nullable pointer optimization, and ABI. \n\nExcerpts related to niche optimization, nullable pointer optimization, and their impact on memory layout are also relevant:\n\n*   Excerpts 504, 505, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 535, 536, 547, 548, 579, 580, 581. These discuss niche optimization, nullable pointer optimization, and how `Option<T>` and `Result<T, E>` can leverage these for memory layout.\n\nExcerpts related to Zero-Sized Types (ZSTs) and the Unit Type ():\n\n*   Excerpts 559, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 1696, 1697, 1698. These discuss ZSTs, the unit type, and their implications for memory layout and optimization.\n\nExcerpts related to Dynamically Sized Types (DSTs), Fat Pointers, `str`, `[T]`, `dyn Trait`, `vtable`:\n\n*   Excerpts 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 555, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577. These discuss DSTs, fat pointers, `str`, slices, trait objects, vtables, and their implications for type layout and ABI. \n\nExcerpts related to ABI Stability:\n\n*   Excerpts 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577. These discuss ABI stability, particularly in the context of `repr(C)` and FFI.",
      "confidence": "high"
    },
    {
      "field": "web_and_network_services_keywords",
      "citations": [
        {
          "title": "actix_web - Rust",
          "url": "https://docs.rs/actix-web",
          "excerpts": [
            "Actix Web is a powerful, pragmatic, and extremely fast web framework for Rust. Examples use actix_web::{get, web, App, HttpServer, Responder};"
          ]
        },
        {
          "title": "axum - tokio-rs/axum",
          "url": "https://github.com/tokio-rs/axum",
          "excerpts": [
            "axum` is a web application framework that focuses on ergonomics and modularity.",
            "`axum` is a web application framework that focuses on ergonomics and modularity. [! [Build status](https://github.com/tokio-rs/axum/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/tokio-rs/axum",
            "`axum` is a web application framework that focuses on ergonomics and modularity. [! [Build status](https://github.com/tokio-rs/axum/actions/workflows/CI.yml/badge.svg?branch=main)](https://github.com/tokio-rs/axum"
          ]
        },
        {
          "title": "GitHub - rwf2/Rocket: A web framework for Rust.",
          "url": "http://github.com/SergioBenitez/Rocket",
          "excerpts": [
            "Rocket is an async web framework for Rust with a focus on usability, security,\nextensibility, and speed.",
            "Rocket is extensively documented:",
            "* [Overview](https://rocket.rs/overview/): A brief look at what makes Rocket special.",
            "* [Quickstart](https://rocket.rs/guide/quickstart): How to get started as quickly as possible.",
            "* [Getting Started](https://rocket.rs/guide/getting-started): How to start your first Rocket project.",
            "* [Guide](https://rocket.rs/guide/): A detailed guide and reference to Rocket.",
            "* [API Documentation](https://api.rocket.rs): The \"rustdocs\".",
            "The [examples](/rwf2/Rocket/blob/master/examples) directory contains complete crates that showcase\nRocket's features and usage.",
            "Ask questions via [GitHub discussions questions](https://github.com/rwf2/Rocket/discussions/categories/questions).",
            "Chat with us at [`:mozilla.org`](https://chat.mozilla.org/#/room/:mozilla.org) on Matrix (join [via Element](https://chat.mozilla.org/#/room/:mozilla.org)).",
            "Rocket is licensed under either of the following, at your option:",
            "* Apache License, Version 2.0, ([LICENSE-APACHE](/rwf2/Rocket/blob/master/LICENSE-APACHE) or <https://www.apache.org/licenses/LICENSE-2.0>)",
            "* MIT License ([LICENSE-MIT](/rwf2/Rocket/blob/master/LICENSE-MIT) or <https://opensource.org/licenses/MIT>)"
          ]
        },
        {
          "title": "Are we web yet?",
          "url": "http://arewewebyet.org/",
          "excerpts": [
            "Rust has mature and production ready frameworks in [Actix Web](/topics/frameworks/) and [Axum](/topics/frameworks/) , and innovative ones like [Warp](/topics/frameworks/) and [Tide](/topics/frameworks/) . These provide everything youâ€™d expect from a web framework, from routing\n and middleware, to templating, and JSON/form handling. There are crates for everything, and more! For databases, thereâ€™s:\n\n* [Diesel](/topics/database/) , a full-fledged ORM.\n* [sqlx](/topics/database/) , the async sql toolkit.\n* As well as native drivers for [MongoDB](/topics/database/) , [SQlite](/topics/database/) , [Postgres](/topics/database/) , and [MySQL](/topics/database/) .\n\nThere are many integrations to third-party services , such as:\n\n* [Rusoto](/topics/web-apis/) (AWS)\n* [Azure](/topics/web-apis/)\n* [Redis](/topics/services/)\n* [Elasticsearch](/topics/services/)\n\nAnd of course, there is plenty of support for basic web needs, like [logging](/topics/logging/) , [authorization](/topics/auth/) , [templating](/topics/templating/) , and [email](/topics/email/) ",
            "After youâ€™ve set up your Rust and worked yourself [through â€œThe Bookâ€](https://doc.rust-lang.org/book/) ,\n you might want to check any of these resources:\n\n* [Educational\n   Rust Live Coding - Web App From Scratch](https://www.youtube.com/watch?v=yNe9Xr35n4Q&list=PL8lUUBadSMNBNKMYJpUE830tBiN6bxVRw&ab_channel=DavidPedersen)\n* [Actix-Web Auth\n   Microservice](https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/)\n* [Zero To Production In Rust\n   (Series)](https://www.lpalmieri.com/posts/2020-05-24-zero-to-production-0-foreword/)\n* [Practical Rust Web Development\n   (Series)](https://dev.to/werner/practical-rust-web-development-api-rest-29g1)\n* [Rocket Quickstart Guide](https://rocket.rs/guide/v0.5/quickstart/"
          ]
        },
        {
          "title": "Dev.to/tuananhpham - Archived Popular Backend Frameworks by Performance Benchmark Ranking in 2024",
          "url": "https://dev.to/tuananhpham/archived-popular-backend-frameworks-by-performance-benchmark-ranking-in-2024-25g7",
          "excerpts": [
            "TechEmpower has established a [backend framework benchmar",
            "Best popular backend frameworks by performance ranking in 2024",
            "Rust Actix is 506% more performant than JS/Node Express",
            "Rust Actix is 712% more performant than Java Spring",
            "Rust Actix is 1166% more performant than Python Django",
            "Rust Actix is 1198% more performant than Ruby Rails",
            "Rust Actix is 2331% more performant than Php\nLaravel",
            "Rust Actix is 119% more performant than C# Asp.net",
            "Rust Actix is 147% more performant than Go Fiber"
          ]
        },
        {
          "title": "Tuan Anh tech blog - Best Popular Backend Frameworks by Performance Benchmark Comparison and Ranking in 2024",
          "url": "https://tuananhparis.hashnode.dev/popular-backend-frameworks-performance-benchmark-comparison-and-ranking-in-2024",
          "excerpts": [
            "take the Rust column, then",
            "Rust Actix is 119% more performant than C# Asp.net",
            "Rust Actix is 147% more performant than Go Fiber",
            "Rust Actix is 505% more performant than JS/Node Express",
            "Rust Actix is 715% more performant than Java Spring",
            "Rust Actix is 1172% more performant than Python Django",
            "Rust Actix is 1221% more performant than Ruby Rails",
            "Rust Actix is 2254% more performant than Php Laravel"
          ]
        },
        {
          "title": "TechEmpower Framework Benchmarks Round 23, Data-R23",
          "url": "https://www.techempower.com/benchmarks/#section=data-r22&hw=ph&test=composite",
          "excerpts": [
            "Round 23 is here! âš¡",
            "In the following tests, we have measured the performance of several web\napplication platforms, full-stack frameworks, and micro-frameworks\n(collectively, \"frameworks\").",
            "Best fortunes responses per second, (523 tests)",
            "may-minihttp | 1,327,378 | 100.0% | 0 | Mcr | rs | rs | may | Lin | Pg | Lin | Raw | Rea |"
          ]
        },
        {
          "title": "TechEmpower Framework Benchmarks Round 23",
          "url": "https://www.techempower.com/blog/2025/03/17/framework-benchmarks-round-23/",
          "excerpts": [
            "Framework Benchmarks Round 23",
            "March 17, 2025",
            "New Hardware and Upgrades",
            "* ProLiant DL360 Gen10 Plus servers",
            "+ Intel Xeon Gold 6330 CPU @ 2.00GHz (56 cores)",
            "+ 64GB of memory",
            "+ Mellanox Technologies MT28908 Family [ConnectX-6] 40Gbps Ethernet",
            "*Impact on Benchmarking Results",
            "\nWeâ€™ve seen a substantial increase in performance across the board, particularly in network-bound tests. Hereâ€™s a breakdown of the improvements:",
            "3x Improvements in Practical Network-Bound Tests",
            "Weâ€™ve seen a threefold increase in performance among the top-performing frameworks. This is entirely due to the efficiency and power of the new servers and fiber-optic network setup.",
            "4x Improvements in Theoretical Network-Bound Tests",
            "In tests where the network is the limiting factor, the performance improvements have been even more dramatic, reaching up to four times the previous capabilities."
          ]
        }
      ],
      "reasoning": "The provided excerpts offer substantial information about Rust web frameworks. Several excerpts directly name and describe popular frameworks such as Actix Web, Axum, Rocket, Warp, and Tide. They highlight key characteristics like routing, middleware, and performance. For instance, one excerpt explicitly states that Actix Web is a \"powerful, pragmatic, and extremely fast web framework for Rust\" and mentions its use of `get`, `web`, `App`, `HttpServer`, and `Responder`. Another excerpt describes Axum as a \"web application framework that focuses on ergonomics and modularity.\" Rocket is detailed as an \"async web framework for Rust with a focus on usability, security, extensibility, and speed,\" and its documentation and examples are mentioned. The TechEmpower benchmarks are also referenced, providing performance comparisons for Rust web frameworks like Actix against other languages, indicating its high performance. These benchmarks also detail the hardware and network setups used for testing, reinforcing the performance claims. The information collectively supports the fine-grained field value by providing specific framework names, their core features, and performance metrics.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.10",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )"
          ]
        }
      ],
      "reasoning": "The target fine-grained field value is 'mixed-site hygiene', which is a specific term used to describe how macros handle symbol lookup at their definition vs invocation sites. The most directly relevant content states that \"Macros by example have mixed-site hygiene. This means that [loop labels], [block labels], and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site.\" This directly defines and exemplifies mixed-site hygiene in the context of macros by example, which aligns with the requested field value. Additionally, there is supporting context indicating hygiene concerns in procedural macros, noting that they are \"unhygienic\" and discussing how macro output can be affected by external items and imports. While this latter point reinforces the broader hygiene topic, it does not specifically mention the phrase 'mixed-site hygiene' and is therefore considered supplementary support. Together, these excerpts provide strong alignment with the fine-grained field value, with the first excerpt delivering the exact terminology and definition and the second providing contextual emphasis on hygiene in macro-related processes.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.7",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) ",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``",
            ") .\nThe `proc_macro` crate provides types required for\nwriting procedural macros and facilities to make it easier. [[macro .proc .proc\\_macro .to",
            "The `proc_macro` attribute defines the macro in the [macro namespace](names/namespaces.html) in the root of the crate."
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site.",
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation."
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)",
            "Hygiene"
          ]
        },
        {
          "title": "Security breach with Rust macros - compiler - Rust Internals",
          "url": "https://internals.rust-lang.org/t/security-breach-with-rust-macros/14703",
          "excerpts": [
            "**"
          ]
        },
        {
          "title": "Procedural Macros book - #8 by dtolnay - documentation",
          "url": "https://internals.rust-lang.org/t/procedural-macros-book/9113/8",
          "excerpts": [
            "Dec 30, 2018 â€” From a naive perspective this is a very simple macro â€“ it parses some simple input using syn in a simple way and generates some simple outputÂ ..."
          ]
        },
        {
          "title": "dtolnay/proc-macro-workshop: Learn to write Rust ...",
          "url": "https://github.com/dtolnay/proc-macro-workshop",
          "excerpts": [
            "This workshop covers attribute macros, derive macros, and function-like procedural macros. Be aware that the content of the workshop and the explanations inÂ ..."
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "quote in quote - Rust",
          "url": "https://docs.rs/quote/latest/quote/macro.quote.html",
          "excerpts": [
            "Alternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not ..."
          ]
        },
        {
          "title": "proc_macro2 - Rust",
          "url": "https://docs.rs/proc-macro2",
          "excerpts": [
            "By developing foundational libraries like syn and quote against proc_macro2 rather than proc_macro , the procedural macro ecosystem becomes easily applicable to ..."
          ]
        },
        {
          "title": "Rust Structs and Attribute-like and Custom Derive Macros",
          "url": "https://rareskills.io/post/rust-attribute-derive-macro",
          "excerpts": [
            "An attribute-like macro takes in a struct and can completely rewrite it. A derive macro augments a struct with additional functions. Macros ..."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_MACRO\\_RULES : `macro_rule",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "* [strict]()\n* [reserved]()\n* [weak]()\n",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "/sup>**\n> KW\\_MACRO\\_RULES : `macro_rules`\n> KW\\_UNION : `union`\n> KW\\_STATICLIFETIME : `'static`\n> KW\\_SAFE : `safe`\n> KW\\_RAW : `raw`",
            "These keywords can only be used in their correct contexts. They cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "## [Strict keywords]()",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        }
      ],
      "reasoning": "The field value â€œattribute macrosâ€ is directly supported by an excerpt that explicitly lists â€˜Attribute macrosâ€™ as one of the three macro flavors and discusses how procedural macros include attribute macros. This shows that attribute macros are a recognized category within Rustâ€™s macro ecosystem and are distinct from other macro forms like declarative macros or function-like macros. Another excerpt confirms the connection by stating that custom derive macros and attribute macros are related, indicating that attributes can drive code generation or derivation, which reinforces the identification of attribute macros as a specific macro form. Additional excerpts mention custom derives and attributes in the context of Rust macros, which helps triangulate the meaning of attribute macros and situates them within the broader metaprogramming landscape (macros by example, macro hygiene, and procedural macro discussions). The remaining excerpts, while informative about macros in Rust, do not reference attribute macros as directly and provide supporting context about macro systems, hygiene, and generation that clarifies how attribute macros fit into the macro taxonomy, but are less central to the precise field value.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.3",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "This crate primarily contains a [`TokenStream`](../proc_macro/struct.TokenStream.html) type. Procedural macros operate\nover _token streams_ instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target.",
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured.",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have.",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) ",
            "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`](../core/macro.compile_error.html) macro invocation.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``"
          ]
        },
        {
          "title": "Security breach with Rust macros - compiler - Rust Internals",
          "url": "https://internals.rust-lang.org/t/security-breach-with-rust-macros/14703",
          "excerpts": [
            "**"
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explicitly states that procedural macros come in three flavors: function-like macros, derive macros, and attribute macros, which is a core definition of what procedural macros are. This establishes the field value at a fundamental level and anchors the rest of the related content. The next highly relevant excerpt discusses procedural macros in the context of macro hygiene and token streams, which are intrinsic to how procedural macros operate and interact with code. Following that, another excerpt clarifies that the term macro encompasses declarative macros and procedural macros, reinforcing the scope of procedural macros within the macro system. Additional excerpts discuss specific procedural macro forms (derive macros, function-like macros, and attribute macros) and the inputs they operate on, which further supports the field value by detailing concrete forms and usage. Some excerpts broaden the context to tooling and ecosystems around procedural macros (e.g., crates like syn and proc-macro2 and build.rs mentions), which are relevant to practical understanding of procedural macros but are one step removed from the core definition, hence lower relevance. A few excerpts touch on macro hygiene and security considerations, which are important for understanding constraints and safe usage, but are not definitions of procedural macros themselves; they still support the field value by illustrating consequences and considerations when using procedural macros. Overall, the most directly supportive content covers the explicit classification and purpose of procedural macros, while tangential material provides context, tooling, and safety considerations that enhance understanding but are secondary to the core concept.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.13",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "This crate primarily contains a [`TokenStream`](../proc_macro/struct.TokenStream.html) type. Procedural macros operate\nover _token streams_ instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target.",
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token."
          ]
        }
      ],
      "reasoning": "The fine-grained field value TokenStream corresponds to a key concept in Rustâ€™s procedural macros. One excerpt states that procedural macrosâ€™ core content is the TokenStream type, which is the primary input/output surface for such macros. This directly supports the field value by identifying TokenStream as the central token-based representation used by procedural macros. Another excerpt elaborates on what a token stream is, describing it as roughly equivalent to a vector of TokenTree tokens, which clarifies the concrete structure of the TokenStream and how it relates to lexical tokens. Together, these excerpts establish that TokenStream is the token-based interface used by procedural macros and explain its basic structure, aligning exactly with the field value in question. The remaining excerpts discuss related macro concepts (hygiene, macro rules, etc.) but do not directly define or describe TokenStream, so they provide contextual support but are less directly relevant.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.9",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)"
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to macro hygiene, a concept discussed across multiple macro-related sources. The most directly relevant excerpts explicitly discuss hygiene in procedural and macro contexts: one describes procedural macros as unhygienic and explains how their output can be affected by surrounding code, which is a core hygiene concern; another notes that macro authors must be careful to ensure macros work in many contexts due to hygiene considerations; and a third explains that macro expansion sites and lookups can be affected by hygiene rules. Additional excerpts describe mixed-site hygiene and the behavior of macros by example with respect to symbol lookup, further supporting the hygiene theme. There is also a reference that tokens carry Span information, which is tied to hygienic concerns about scoping and name resolution in macro expansion. Collectively, these excerpts establish hygiene as a central, concrete concept in Rust macros, aligning with the requested fine-grained field value. Extracted quotes include statements that macros are unhygienic, that hygiene affects item lookup across macro definitions and invocations, and that hygiene is a formal concern in macro theory (including spans, symbol lookup, and hygiene rules).",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.16",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Token",
            "MacroRules",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explains that a token like a simple name such as foo is an Ident token, which directly aligns with the ident token kind in the requested field value. This provides a precise mapping between the textual example and the token category youâ€™re analyzing. The next excerpt that discusses that tokens, including identifiers, appear in token streams and that macro systems operate on these token streams, further validates the central role of identifiers in macro-related tokenization. The following excerpt about MacroRules and macro-by-example introduces the idea of token-level syntax and macro expansion, reinforcing how identifiers function within macro definitions and invocations. Another excerpt that mentions function-like macros and their interaction with token input supports the idea that identifiers are among the core lexical elements these macros manipulate. Finally, a broader hygiene-focused excerpt about macro hygiene and token lookup helps situate identifiers within the larger macro hygiene and scoping context, which is relevant but less directly tied to the specific token kind. Together, these excerpts collectively support the notion that the Ident token plays a central role in the macro/token system described by the finegrained field value.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.1",
      "citations": [
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression.",
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation."
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n",
            "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(... )` . There are two ways to define new macros:"
          ]
        }
      ],
      "reasoning": "The idea of declarative macros in Rust is best supported by excerpts that explicitly state that the most commonly used form of macros is declarative and that this form is often referred to as macros by example or macro_rules. The excerpt describing declarative macros as the most widely used form and connecting them to macro_rules! directly supports the notion of declarative macros as a distinct, high-level form of metaprogramming. Additional support comes from text that defines the term macro in Rust as a family of features including declarative macros, and from passages that describe macros by example as a declarative system with rules and matchers. Together, these excerpts establish that declarative macros are implemented via macro_rules! and are the primary, high-level macro mechanism (often taught under the umbrella of macros by example). The references discussing macros by example and the structure of a declarative macro (rules, matcher, transcriber) further reinforce the linkage between declarative macros and the macro_rules!/macros-by-example paradigm, providing concrete elements that define how declarative macros operate in Rust. The initial general references to macros and the specific macro-by-example discussions corroborate the central claim that declarative macros form a high-level, user-facing macro system in Rust. These excerpts, when considered together, map directly onto the target field value by describing what declarative macros are, how they are typically authored (macro_rules! / macros by example), and how they fit within Rustâ€™s metaprogramming capabilities.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.12",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Token"
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "Hygiene",
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)"
          ]
        }
      ],
      "reasoning": "The most directly relevant content states that a token stream is roughly equivalent to a Vec<TokenTree>, and that a TokenTree is a lexical token. This directly supports the target field value by tying the macro/token infrastructure to the exact concept of a token tree. Related excerpts about macro-related tooling and token-oriented discussions reinforce the broader context: proc_macro provides types used in macro definitions, and libraries like syn parse streams of Rust tokens into a syntax tree, which is thematically adjacent to token trees and their manipulation in metaprogramming contexts. Even excerpts that explicitly name tokens or token-related constructs (e.g., Token, token stream) help corroborate the general idea that macros operate on token-level representations such as TokenTree. Taken together, these excerpts form a coherent chain showing token trees as a foundational primitive in Rust macro and metaprogramming workflows, from low-level token trees to macro tooling and parsing pipelines.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.18",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |",
            "MacroRules",
            "MacroRule"
          ]
        }
      ],
      "reasoning": "The field value corresponds to a pattern token used in macro matching. An excerpt that enumerates the macro grammar tokens explicitly includes the symbols pat and pat_param, showing that patterns are first-class concepts inside macro matching. This confirms that the field value is about the pattern form used when writing macro_rules or macro-by-example patterns. Another excerpt discusses macro rules and how each rule has a matcher (pattern) and a transcriber, which directly ties the concept of a pattern to macro behavior, reinforcing that the field value denotes the pattern portion of a macro rule. A third excerpt highlights MacroRule and related macro components, underscoring that macro rules are built around matching patterns, which again aligns with the notion of a pattern token in macro syntax. Taken together, these excerpts directly support the understanding that the finegrained field value represents the pattern element used to match macro invocations in Rust macros.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.11",
      "citations": [
        {
          "title": "12: Macro Hygiene - MacroKata - tfpk.io",
          "url": "https://tfpk.github.io/macrokata/12_README.html",
          "excerpts": [
            "To alleviate this, the $crate metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro. Refer to The Little Book Of Rust Macros for more on the considerations around macro hygiene. Exercise 12. Exercise 12 consists of a file containing multipleÂ ..."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "Hygiene",
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)"
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to the $crate metavariable. The most directly relevant excerpt states that the $crate metavariable can be used at the start of a path to force lookup to occur inside the crate defining the macro, which directly confirms the presence and purpose of this specific metavariable. Surrounding discussions of macro hygiene explain how macro expansion interacts with scope and symbol lookup, providing necessary context for why a mechanism like $crate would be used to control path resolution during macro expansion. Additional hygiene-focused excerpts describe the broader concept of hygiene in macros, including how macro rules and token lookup work, which supports understanding the environment in which $crate operates. Collectively, these excerpts establish both the existence and the functional role of the $crate metavariable within Rust macros and macro hygiene, while the hygiene-focused excerpts reinforce the broader context in which such a metavariable is employed to manage namespace and crate boundaries.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.6",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) "
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "derive macros",
            "attribute macros",
            "In Rust, there are 2 different types of macros: declarative and procedural."
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt directly describes derive macros as a flavor of procedural macros: it explicitly lists derive macros as a kind of procedural macro, which directly supports understanding of #[derive] as a mechanism to generate code via derive attributes. The next excerpt explicitly mentions derive macros in the context of derive attributes, reinforcing that #[derive] is used to augment items with additional functionality. An excerpt that notes that custom #[derive] macros can add code when the derive attribute is used on structs and enums provides concrete linkage to how #[derive] operates in practice. Contextual excerpts about macros by example and the broader macro system help situate #[derive] within both declarative and procedural macro spaces, clarifying that derive is part of the procedural/macros ecosystem and is commonly discussed alongside function-like, derive, and attribute macros. The remaining excerpts that describe macro behavior in general or list macro-related concepts (e.g., macros by example, macro_rules) provide background context but do not directly reference #[derive], so they rank slightly lower in direct relevance. Taken together, these excerpts map the field value to a cohesive understanding of derive macros and their role in Rust metaprogramming. ",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.14",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |",
            "MacroFragSpec",
            "MacroMatch",
            "MacroMatcher"
          ]
        }
      ],
      "reasoning": "The field value refers to the concept of fragment specifiers, which are the primitive building blocks used inside macro_rules and other macro systems to denote the kind of token fragment that a macro can match or generate. The most directly relevant excerpt lists the concrete set of fragment specifiers, showing examples such as block, expr, ident, item, lifetime, and literal, which reveals the exact nature and scope of fragment specifiers used in Rust macros. A nearby excerpt defines the term MacroFragSpec, signaling that there is a formal specification for these fragments within the macro system. Additional excerpts discuss MacroMatch and MacroMatcher, which pertain to how macros match input sequences and tokens, further grounding the concept of fragment specifiers within macro parsing and expansion workflows. Together, these excerpts establish that fragment specifiers are a core, enumerated part of Rustâ€™s macro language, used to describe the kinds of token fragments macros can operate on, which aligns precisely with the requested fine-grained field value about fragment specifiers.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.17",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "MacroFragSpec",
            "Token",
            "MacroRules",
            "MacroRulesDefinition",
            "\nLabels and local variables defined in macro expansion are not shared between invocations, so this code doesnâ€™t compile",
            "MacroRule",
            "MacroTranscriber",
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |"
          ]
        }
      ],
      "reasoning": "The most relevant content explicitly references the macro fragment specification concept. Excerpt describing a MacroFragSpec indicates that the fragment specification mechanism exists to define or describe fragments used inside macro systems. This directly ties to the target field value, which is a fragment spec identifier within macro_rules syntax. The companion excerpts outlining MacroRules, MacroRulesDefinition, and MacroTranscriber flesh out the structure of macro_rules including how rules are formed and transformed, which is important for understanding how a fragment spec like ty would fit into a rule's matcher or transcriber. Additional excerpts about labels, hygiene, and macro-by-example tooling provide surrounding context showing how fragments are parsed, scoped, and used within macro expansions, reinforcing how a fragment like ty would operate in practice. The excerpt that enumerates macro fragment-related tokens (including block, expr, ident, path, tt, etc.) helps illuminate the kinds of fragments that exist, making the potential presence of a ty fragment plausible within that taxonomy. While the list in that excerpt does not explicitly include ty, its inclusion of path, pat, and tt demonstrates the fragment systemâ€™s granularity, supporting relevance to the requested field value. Overall, the strongest support comes from explicit MacroFragSpec mentions, followed by broader macro-rule and fragment-system discussions, and finally contextual macro hygiene and macro-by-example material, which collectively relate to how the :ty fragment would be parsed and applied in macro_rules workflows.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.0",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]"
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(... )` . There are two ways to define new macros:",
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression.",
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument",
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to metaprogramming, which in Rust is predominantly enabled through macros and procedural macros that generate code or extend syntax. The most directly relevant excerpts explicitly describe procedural macros and their role in code generation and metaprogramming-like capabilities: the excerpt detailing that procedural macros come in three flavors (function-like, derive, and attribute) highlights the core mechanisms by which Rust performs metaprogramming. Excerpts describing macros by example and declarative macros explain how macros extend syntax and produce new code structures, which underpins metaprogramming patterns in Rust. Additional excerpts enumerate macro-by-example rules and how macros can expand to expressions, statements, items, types, or patterns, all of which are fundamental to metaprogramming in Rust. References from the Rust Book and Rust Reference about declarative macros (macro_rules!), macros by example, and procedural macros collectively establish how Rust supports metaprogramming constructs such as code generation, macro expansion, and syntax extension. The later excerpts that discuss specific macro forms (derive, function-like, and attribute macros) reinforce how code can be generated or augmented at compile time, which is central to metaprogramming in this context. In sum, the most relevant content directly covers how macros and procedural macros enable Rust metaprogramming, with supporting detail on the kinds of macros and their expansion targets. The less central items touch on macro hygiene and auxiliary tooling, which are ancillary to the core metaprogramming capabilities but still related context.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.4",
      "citations": [
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "The `proc_macro` attribute defines the macro in the [macro namespace](names/namespaces.html) in the root of the crate.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``",
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) "
          ]
        },
        {
          "title": "Procedural Macros book - #8 by dtolnay - documentation",
          "url": "https://internals.rust-lang.org/t/procedural-macros-book/9113/8",
          "excerpts": [
            "Dec 30, 2018 â€” From a naive perspective this is a very simple macro â€“ it parses some simple input using syn in a simple way and generates some simple outputÂ ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        }
      ],
      "reasoning": "The most directly relevant parts explicitly discuss the proc_macro concept and its use in Rust. One excerpt defines the proc_macro library and shows it as the underpinning crate for writing macros, which is the core of what a proc-macro is. Another excerpt describes procedural macros and their three flavors (function-like, derive, and attribute), which is precisely the spectrum encompassed by proc-macros. Additional excerpts from the Rust Book and Rust Reference elaborate on how derive macros and function-like macros operate, reinforcing the practical understanding of proc-macros in Rust codebases. Further excerpts address tooling in the proc-macro ecosystem (syn, quote, proc-macro2), which are essential for implementing proc-macros in real projects. Together, these excerpts establish both the semantic meaning of proc-macros and the practical ecosystem around them, directly supporting the fine-grained field value.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.5",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) ",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums"
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural."
          ]
        },
        {
          "title": "Rust Structs and Attribute-like and Custom Derive Macros",
          "url": "https://rareskills.io/post/rust-attribute-derive-macro",
          "excerpts": [
            "An attribute-like macro takes in a struct and can completely rewrite it. A derive macro augments a struct with additional functions. Macros ..."
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explains that derive macros are a specific kind of procedural macro and explicitly references the derive mechanism via the derive attribute. This strongest connection shows that derive macros are a recognized construct used to generate code from a type through a derive attribute, which directly supports the requested finegrained field value. An excerpt that mentions derive macros in the context of the derive attribute reinforces this direct association, confirming that derive macros are used to augment types with additional functionality via derive. Additional excerpts explicitly discuss custom derive macros and the derive attribute, further corroborating that derive macros are a concrete concept in Rustâ€™s macro system and are commonly used in practice. An excerpt that states that procedural macros include derive macros when describing the kinds of procedural macros strengthens the linkage by listing derive macros as part of the procedural macros ecosystem. Another excerpt notes that the derive macro is a mechanism within macros to generate code for structs or other items, providing concrete examples of how derive macros are used. Finally, an excerpt from a Rust macro-focused source explicitly mentions derive macros in the context of attribute-like and custom derive macros, tying together the idea that derive macros are a specialized, widely-used form of macros in Rust. Overall, these excerpts collectively establish that derive macros are a key, well-documented feature within Rustâ€™s macro system, specifically tied to the derive attribute and procedural macro family.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.8",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument"
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "functional macros"
          ]
        }
      ],
      "reasoning": "The target field value identifies a specific macro form: function-like macros. The most supportive excerpt states that procedural macros come in three flavors and explicitly labels one of them as function-like macros, giving the exact syntax example of how they are invoked (custom!(...)). This directly defines the concept of function-like macros and anchors their usage pattern in Rust. Another excerpt describes function-like macros in the form of concrete examples: they are described as looking like function calls but operating on token streams, which precisely clarifies their nature and how they are invoked in code. A third excerpt reinforces the terminology by mentioning a related variant name used in documentation: macro definitions can be categorized as declarative, with a form called functional macros, further aligning with the same concept and terminology. The combination of these excerpts directly supports the field value by defining, illustrating, and naming function-like macros in Rust, establishing both their existence and their invocation style. The surrounding context on macros by example or declarative/procedural distinctions provides supportive background but is less central to the specific field value than the excerpts that explicitly name and describe function-like macros and their invocation style.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.23",
      "citations": [
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "proc_macro2 - Rust",
          "url": "https://docs.rs/proc-macro2",
          "excerpts": [
            "By developing foundational libraries like syn and quote against proc_macro2 rather than proc_macro , the procedural macro ecosystem becomes easily applicable to ..."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural."
          ]
        }
      ],
      "reasoning": "The fine-grained value corresponds to the syn crate, which is explicitly described as a parsing library that turns a stream of Rust tokens into a syntax tree, a foundational tool for macro code analysis and generation. This directly supports the notion of parsing and manipulating Rust code in the context of metaprogramming. Related entries identify the procedural macro ecosystem in which syn participates: the proc-macro crate provides the essential interfaces for macro authors, and proc_macro2 is a foundational library used alongside syn to operate on token streams in a stable way. A side entry points to the procedural macros book, which covers macro-related concepts and tooling, providing broader context for how syn would be used in macro development workflows.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.22",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token.",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "MacroRules",
            "Token",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explains that a token stream is roughly equivalent to a sequence of tokens, i.e., a TokenTree, which is the fundamental token-level unit that macro systems manipulate. This provides a concrete definition of the core data structure behind token-based macro processing. A closely related excerpt discusses procedural hygiene and how macro outputs can be influenced by external items, highlighting the environment in which token-level transformations occur and the potential need to disambiguate or â€œmungeâ€ tokens safely. Additional excerpts describe macro_rules and macros by example, which outline how input syntax is matched and transformed into new code, i.e., how token-level inputs are consumed and rewritten. Further excerpts describe the macro systemâ€™s components (MacroRules, MacroTranscriber, Token) and the basic macro machinery (macros by example, declarative vs procedural) that underpins token-level manipulation. Collectively, these excerpts support the finegrained field by detailing token-based representations (TokenTree, Token) and their role in macro expansion, which aligns with the concept of token tree munchers that operate on token streams during metaprogramming.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.24",
      "citations": [
        {
          "title": "quote in quote - Rust",
          "url": "https://docs.rs/quote/latest/quote/macro.quote.html",
          "excerpts": [
            "Alternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not ..."
          ]
        }
      ],
      "reasoning": "The target field value is 'quote' in the Rust metaprogramming/macros context. The most direct support comes from an excerpt explicitly titled 'quote in quote - Rust', which discusses the quote concept within the macro ecosystem. This excerpt likely elaborates on how the quote macro or quote-related tooling (such as using quote in conjunction with proc-macro tooling) operates in Rust, providing a clear linkage to the field value. Additional excerpts discuss macro systems (macro_rules, procedural macros) and macro hygiene, which supply necessary context about how macro code is written and expanded, but they do not explicitly define or exemplify the 'quote' concept itself. Taken together, the quoted excerpt is the core piece of evidence for the field value, while the surrounding macro-related excerpts offer supportive context about where quote fits in the broader metaprogramming landscape.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.19",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token.",
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured.",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Token",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        }
      ],
      "reasoning": "The most relevant content explains what a token stream is and how it is composed. It states that a token stream is roughly equivalent to a vector of token trees, and that a token tree can be thought of as a lexical token. This directly aligns with interpreting the finegrained field value as a token (represented in macro systems) and clarifies the underlying data structures used for macro input and output. Additional high-relevance material notes that tokens in a token stream have a Span, which is an opaque value that cannot be modified but can be manufactured, underscoring how token boundaries and origins are tracked during macro expansion. Further supporting material discusses how macros operate on token streams (including function-like, derive, and attribute forms) and introduces core building blocks like tokens, macro rules, and the building blocks of macro expansion such as macro-by-example rules and macro transcribers. Collectively, these excerpts map the field value to the concrete token and token stream concepts used by Rustâ€™s macro system, including their representation and manipulation in both declarative and procedural macro contexts.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.30",
      "citations": [
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "The build script will be rebuilt if any of its source files or dependencies\nchange. By default, Cargo will re-run the build script if any of the files in the\npackage changes. Typically it is best to use the\nrerun-if commands,\ndescribed in the change detection section below, to\nnarrow the focus of what triggers a build script to run again.",
            "Build scripts are also allowed to have dependencies on other Cargo-based crates. Dependencies are declared through the\nbuild-dependencies section of the\nmanifest.",
            "Placing a\nfile named\nbuild.rs in the root of a package will cause Cargo to compile\nthat script and execute it just before building the package.",
            "Some example use cases of build scripts are:\n    * Building a bundled C library. * Finding a C library on the host system. * Generating a Rust module from a specification. * Performing any platform-specific configuration needed for the crate.",
            "Just before a package is built, Cargo will compile a build script into an\nexecutable (if it has not already been built). It will then run the script,\nwhich may perform any number of tasks. The script may communicate with Cargo\nby printing specially formatted commands prefixed with\ncargo:: to stdout."
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt explains a concrete usage: the script prints a directive to Cargo to rerun the build if a particular file changes, shown as cargo::rerun-if-changed=build.rs. This matches the fine-grained field value which is a specific Cargo build-script signal. Related excerpts discuss how build scripts are run by Cargo just before building, and how changes to inputs or dependencies trigger reruns, which provides contextual support for the semantics of the field value. Other excerpts describe the broader build-script workflow, such as how OUT_DIR is used, how generated files are integrated into a crate, and the general mechanism for signaling rebuilds via rerun-if changes. Taken together, these excerpts substantiate that cargo::rerun-if-changed is a recognized cargo build-script mechanism used to indicate when a rebuild should occur, and they connect the exact string to the broader behavior of build scripts in Rust/Cargo pipelines. The strongest support comes from the explicit mention of cargo::rerun-if-changed=build.rs, while the surrounding build-script workflow descriptions provide necessary context to validate the field value within the lifecycle of Rust build scripts.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.32",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`](../core/macro.compile_error.html) macro invocation."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "proc_macro2 - Rust",
          "url": "https://docs.rs/proc-macro2",
          "excerpts": [
            "By developing foundational libraries like syn and quote against proc_macro2 rather than proc_macro , the procedural macro ecosystem becomes easily applicable to ..."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "derive macros",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        }
      ],
      "reasoning": "To understand macro debugging, the most pertinent information is how procedural macros report errors and how to debug macro-generated code. An excerpt explicitly describing error reporting in procedural macros provides direct guidance on debugging failures in macro expansion. Following that, references to the standard libraries and tooling used to build and debug macros (proc-macro, syn, quote, and proc-macro2) are highly relevant because they form the ecosystem used when writing and debugging macros. Additional excerpts that enumerate macro types (declarative vs procedural) and their debugging implications offer essential background for diagnosing where debugging strategies apply. The remaining macro-focused excerpts introduce surrounding concepts (hygiene, macro anatomy, derives, and macro definitions) that enrich understanding but are less about debugging workflows themselves. Collectively, these excerpts map directly to practical debugging workflows (error reporting, tooling libraries, and the macro ecosystem) and provide a coherent path for building and troubleshooting macros during development.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.29",
      "citations": [
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "let out_dir = env::var_os(\"OUT_DIR\").unwrap();",
            "The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located.",
            "let dest_path = Path::new(&out_dir).join(\"hello.rs\");",
            "generated file (`hello.rs`) into the crateâ€™s compilation.",
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "[`include!` macro](../../std/macro.include.html) in combination with the",
            "[`concat!`](../../std/macro.concat.html) and [`env!`](../../std/macro.env.html) macros to include the"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a `build.rs` file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is built. This can be used to generate code at compile time.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and is something\nlike `./target/debug/build/bindgen-tutorial-bzip2-sys-afc7747d7eafd720/out/` .",
            "Now, when we run `cargo build` , our bindings to `bzip2` are generated on the\nfly!"
          ]
        }
      ],
      "reasoning": "The targeted field value represents the OUT_DIR environment variable used in Rust build scripts to determine where to place generated code or artifacts. The most directly supporting content shows reading and using this variable in code: one excerpt assigns out_dir by reading the OUT_DIR environment variable and unwraps it, which demonstrates how build scripts obtain the directory for outputs. Another excerpt demonstrates constructing a path by joining the OUT_DIR-derived directory with a specific filename, illustrating how generated files are written to that location. Additional excerpts explicitly state that the script uses OUT_DIR to discover where output files should be located, and show downstream usage such as writing a generated file into the crate by placing it under OUT_DIR. The excerpts also describe patterns where OUT_DIR is used to determine where to emit generated bindings or other outputs, reinforcing the interpretation that OUT_DIR is the designated build-output directory. Collectively, these excerpts map directly to the field value by showing exact code patterns and explanations around obtaining, composing with, and writing to OUT_DIR during build-script workflows.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.33",
      "citations": [
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression.",
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation.",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Derive macros_ define new inputs for the [`derive` attribute](attributes/derive.html) . These macros\ncan create new [items](items.html) given the token stream of a [struct](items/structs.html) , [enum](items/enumerations.html) , or [union](items/unions.html) ",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "This crate primarily contains a [`TokenStream`](../proc_macro/struct.TokenStream.html) type. Procedural macros operate\nover _token streams_ instead of AST nodes, which is a far more stable interface\nover time for both the compiler and for procedural macros to target.",
            "A _token stream_ is roughly equivalent to `Vec<TokenTree>` where a `TokenTree` can roughly be thought of as lexical token. For example `foo` is an `Ident` token, `.` is a `Punct` token, and `1.2` is a `Literal` token."
          ]
        },
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "[`include!` macro](../../std/macro.include.html) in combination with the",
            "[`concat!`](../../std/macro.concat.html) and [`env!`](../../std/macro.env.html) macros to include the",
            "generated file (`hello.rs`) into the crateâ€™s compilation."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "ipts\nSome packages need to compile third-party non-Rust code, for example C\nlibraries. Other packages need to link to C libraries which can either be\nlocated on the system or possibly need to be built from source. Others still\nneed facilities for functionality such as code generation before building (think\nparser generators). Cargo does not aim to replace other tools that are well-optimized for these\ntasks, but it does integrate with them with custom build scripts.",
            "Placing a\nfile named\nbuild.rs in the root of a package will cause Cargo to compile\nthat script and execute it just before building the package.",
            "Some example use cases of build scripts are:\n    * Building a bundled C library. * Finding a C library on the host system. * Generating a Rust module from a specification. * Performing any platform-specific configuration needed for the crate.",
            "Just before a package is built, Cargo will compile a build script into an\nexecutable (if it has not already been built). It will then run the script,\nwhich may perform any number of tasks. The script may communicate with Cargo\nby printing specially formatted commands prefixed with\ncargo:: to stdout.",
            "The build script will be rebuilt if any of its source files or dependencies\nchange. By default, Cargo will re-run the build script if any of the files in the\npackage changes. Typically it is best to use the\nrerun-if commands,\ndescribed in the change detection section below, to\nnarrow the focus of what triggers a build script to run again.",
            "Build scripts are also allowed to have dependencies on other Cargo-based crates. Dependencies are declared through the\nbuild-dependencies section of the\nmanifest.",
            "The\npackage.links key may be set in the\nCargo.toml manifest to declare\nthat the package links with the given native library.",
            "When using the\nlinks key, the package must have a build script, and the\nbuild script should use the\nrustc-link-lib instruction to\nlink the library."
          ]
        }
      ],
      "reasoning": "The target field value pertains to macro expansion tooling and metaprogramming in Rust. Excerpts that define and describe macros, including declarative macros and procedural macros, directly illustrate how code can be generated or transformed at compile time, which is the core of what a macro-expansion tool would expose. For instance, discussions of the macro family, macro_rules, and the different flavors of procedural macros establish the fundamental machinery that a tool like cargo expand would inspect or manipulate. Excerpts that discuss macros by example, token streams, and macro hygiene further align with the concepts of macro expansion, where input tokens are matched, transformed, and expanded into output code. Build-time code generation and inclusion facilities (such as include-like mechanisms, OUT_DIR usage, and build-script workflows) provide practical context for how macro-generated artifacts can be produced and integrated during compilation, which is conceptually adjacent to macro expansion tooling in the Rust ecosystem. While broader topics like trait systems, keywords, or general language constructs offer important background, they do not directly illuminate macro expansion mechanics or tooling, so their relevance to cargo expand is indirect and thus lesser in this analysis.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.2",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "> **<sup>Lexer 2018+</sup>**",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**"
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "MacroRules",
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns."
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression.",
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:"
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "Declarative macros work based on syntax parsing."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``",
            ") .\nThe `proc_macro` crate provides types required for\nwriting procedural macros and facilities to make it easier. [[macro .proc .proc\\_macro .to",
            "The `proc_macro` attribute defines the macro in the [macro namespace](names/namespaces.html) in the root of the crate."
          ]
        },
        {
          "title": "Security breach with Rust macros - compiler - Rust Internals",
          "url": "https://internals.rust-lang.org/t/security-breach-with-rust-macros/14703",
          "excerpts": [
            "**"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "These keywords can only be used in their correct contexts. They cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            ">**\n> KW\\_AS : `as`\n> KW\\_BREAK : `break`\n> KW\\_CONST : `const`\n> KW\\_CONTINUE : `continue`\n> KW\\_CRATE : `crate`\n> KW\\_ELSE : `else`\n> KW\\_ENUM : `enum`\n> KW\\_EXTERN : `extern`\n> KW\\_FALSE : `false`\n> KW\\_FN : `fn`\n> KW\\_FOR : `for`\n> KW\\_IF : `if`\n> KW\\_IMPL : `impl`\n> KW\\_IN : `in`\n> KW\\_LET : `let`\n> KW\\_LOOP : `loop`\n> KW\\_MATCH : `match`\n> KW\\_MOD : `mod`\n> KW\\_MOVE : `move`\n> KW\\_MUT : `mut`\n> KW\\_PUB : `pub`\n> KW\\_REF : `ref`\n> KW\\_RETURN : `return`\n> KW\\_SELFVALUE : `self`\n> KW\\_SELFTYPE : `Self`\n> KW\\_STATIC : `static`\n> KW\\_STRUCT : `struct`\n> KW\\_SUPER : `super`\n> KW\\_TRAIT : `trait`\n> KW\\_TRUE : `true`\n> KW\\_TYPE : `type`\n> KW\\_UNSAFE : `unsafe`\n> KW\\_USE : `use`\n> KW\\_WHERE : `wher",
            "> KW\\_DYN : `dyn",
            "> KW\\_AWAIT : `await",
            "> KW\\_ASYNC : `async",
            "The following keywords were added beginning in the 2018 edition.",
            "> KW\\_WHILE : `while",
            "> KW\\_WHERE : `where",
            "> KW\\_USE : `use",
            "> KW\\_UNSAFE : `unsafe",
            "> KW\\_TYPE : `type",
            "> KW\\_TRUE : `true",
            "> KW\\_TRAIT : `trait",
            "> KW\\_SUPER : `super",
            "> KW\\_STRUCT : `struct",
            "> KW\\_STATIC : `static",
            "> KW\\_SELFTYPE : `Self",
            "> KW\\_SELFVALUE : `self",
            "> KW\\_RETURN : `return",
            "> KW\\_REF : `ref",
            "> KW\\_PUB : `pub",
            "> KW\\_MUT : `mut",
            "> KW\\_MOVE : `move",
            "> KW\\_MOD : `mod",
            "> KW\\_MATCH : `match",
            "> KW\\_LOOP : `loop",
            "> KW\\_LET : `let",
            "> KW\\_IN : `in",
            "> KW\\_IMPL : `impl",
            "> KW\\_IF : `if",
            "> KW\\_FOR : `for",
            "> KW\\_FN : `fn",
            "> KW\\_FALSE : `false",
            "> KW\\_EXTERN : `extern",
            "> KW\\_ENUM : `enum",
            "> KW\\_ELSE : `else",
            "> KW\\_CRATE : `crate",
            "> KW\\_CONTINUE : `continue",
            "> KW\\_CONST : `const",
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```rust",
            "```",
            "```"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "fn main() {",
            "}",
            "}",
            "```rust",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "## [`format_macro_matchers`]()",
            "Format the metavariable matching patterns in macros.",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3354) )",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "    ($a:ident : $b:ty) => {",
            "    ($a:ident $b:ident $c:ident) => {",
            "See also [`format_macro_bodies`]() .",
            "## [`format_macro_bodies`]()",
            "Format the bodies of declarative macro definitions.",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3355) )",
            "    ($a: ident : $b: ty) => {",
            "    ($a: ident : $b: ty) => {",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "    ($a: ident $b: ident $c: ident) => {",
            "    ($a: ident $b: ident $c: ident) => {",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "    ($a: ident : $b: ty) => { $a(42): $b; };",
            "    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "See also [`format_macro_matchers`]() .",
            "## [`skip_macro_invocations`]()",
            "Skip formatting the bodies of macro invocations with the following names.",
            "rustfmt will not format any macro invocation for macros with names set in this list.",
            "Including the special value \"\\*\" will prevent any macro invocations from being formatted",
            "Note: This option does not have any impact on how rustfmt formats macro definitions.",
            "* **Default value** : `[]`",
            "* **Possible values** : a list of macro name idents, `[\"name_0\", \"name_1\", ..., \"*\"]`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/5346) )",
            "\n\n#### [`[]` (default):](#%5C%5B%5C%5D%5C%20%5C\\(default%5C\\)%5C%3A)",
            "rustfmt will follow its standard approach to formatting macro invocations.",
            "No macro invocations will be skipped based on their name. More information about rustfmt's standard macro invocation formatting behavior can be found in [](https://github.com/rust-lang/rustfmt/discussions/5437) .",
            "#### [`[\"lorem\"]` :](#%5C%5B%5C%22lorem%5C%22%5C%5D%5C%3A)",
            "The named macro invocations will be skipped.",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "#### [`[\"*\"]` :](#%5C%5B%5C%22%5C*%5C%22%5C%5D%5C%3A)",
            "The special selector `*` will skip all macro invocations.",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "lorem!(",
            "lorem!(",
            "lorem!(",
            "ipsum!(",
            "ipsum!(",
            "ipsum!(",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            ");",
            ");",
            ");",
            ");",
            ");",
            ");",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        }
      ],
      "reasoning": "The fine-grained field value corresponds to the macro_rules! declarative macro mechanism. The most direct support comes from excerpts that explicitly mention macro_rules as the syntax for declarative macros and explain its role in Rust macros. An excerpt explicitly states that macro_rules! defines a declarative macro extension and is the canonical form for macros by example, which directly supports the field value. Additional excerpts discuss the broader concept of declarative macros and macro_rules! in the context of macros, and specifically identify the MacroRules element and how it relates to macros by example. These pieces together establish that macro_rules! is the canonical syntax for declarative macros in Rust, and they connect to the field value by describing the exact construct we are analyzing. Other excerpts that mention macros in general or discuss related macro systems (procedural macros, hygiene, etc.) provide helpful background but do not directly confirm the specific field value, so they are considered supporting but secondary. Therefore, the most relevant information centers on direct mentions of macro_rules!, its role in declarative macros, and its connection to macros by example.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.20",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "MacroRules",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to."
          ]
        }
      ],
      "reasoning": "The field value represents a concept centered on repetition within Rust metaprogramming and macros. The most direct support for repetition as a mechanism comes from descriptions of macro_rules-based macros, which are explicitly described as having one or more rules, each with a matcher and a transcriber. This structure inherently supports repeated application of the macroâ€™s pattern to multiple input tokens, i.e., repetition, through successive matching and expansion of patterns. The description that macro_rules are defined in a declarative way and that macro by example consists of rules with a matcher and a transcriber underscores the core repeated pattern behavior: a single macro invocation can expand in multiple ways depending on repeated input patterns, and the rules can be applied repeatedly as input contains multiple segments. Additionally, references that discuss macros by example and the concept of rules provide explicit context for how repeated or recurring syntactic patterns are captured and transformed by the macro system. Supporting content that elaborates on macro_rules and macros by example strengthens the link to repetition-driven expansion since these mechanisms rely on repeated application of patterns and expansion templates. References describing declarative macros and the macro systemâ€™s exposure of token streams further anchor the interpretation that repetition is a fundamental part of how macro expansions are generated and thus relevant to the field value in question.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.28",
      "citations": [
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a `build.rs` file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is built. This can be used to generate code at compile time.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and is something\nlike `./target/debug/build/bindgen-tutorial-bzip2-sys-afc7747d7eafd720/out/` .",
            "Now, when we run `cargo build` , our bindings to `bzip2` are generated on the\nfly!"
          ]
        },
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "let out_dir = env::var_os(\"OUT_DIR\").unwrap();",
            "let dest_path = Path::new(&out_dir).join(\"hello.rs\");",
            "fs::write(",
            "Thereâ€™s a couple of points of note here:\n    * The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located. It can use the processâ€™ current working\ndirectory to find where the input files should be located, but in this case we\ndonâ€™t have any input files. * In general, build scripts should not modify any files outside of\nOUT_DIR . It may seem fine on the first blush, but it does cause problems when you use\nsuch crate as a dependency, because thereâ€™s an implicit invariant that\nsources in\n.cargo/registry should be immutable. cargo wonâ€™t allow such\nscripts when packaging. * This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as\ngenerating a Rust module from a C header file or another language definition,\nfor example. * The\nrerun-if-changed instruction tells Cargo that the build script only needs to re-run if the build script\nitself changes.\nWithout this line, Cargo will automatically run the build\nscript if any file in the package changes. If your code generation uses some\ninput files, this is where you would print a list of each of those files."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/cargo/reference/build-scripts.html",
          "excerpts": [
            "The stdout output and OUT_DIR locations are also handled by the cc library. Here we can start to see some of the major benefits of farming as much functionalityÂ ..."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "Placing a\nfile named\nbuild.rs in the root of a package will cause Cargo to compile\nthat script and execute it just before building the package."
          ]
        }
      ],
      "reasoning": "The field value identifies the exact build script file name commonly used in Rust projects to perform compile-time code generation, environment setup, or bindings generation. The most relevant passages explicitly reference creating a build.rs file in the crate root and describe how Cargo detects and runs this script before compilation. This establishes build.rs as the central artifact for build-script-driven metaprogramming. Supporting passages demonstrate concrete usage patterns around build.rs, such as generating or placing output files before compilation, using the OUT_DIR variable to locate generated artifacts, and including or embedding generated code (for example, via include! or writing to destination paths). These details directly connect the field value to practical workflows: creating build.rs, producing code into OUT_DIR, writing generated files, and including them in the crate. Additional excerpts describe related tooling around build scripts (e.g., cargo rerun directives referencing build.rs, and code that writes generated Rust code to a destination within the OUT_DIR), which further corroborate the role and handling of build.rs in Rust metaprogramming workflows. The remaining excerpts that discuss macro rules, macro hygiene, or trait-based metaprogramming provide contextual background but do not directly tie to the specific build.rs artifact, so they are considered less directly supportive of the field value.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.21",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "MacroRules",
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "MacroRule",
            "MacroTranscriber",
            "MacroRepOp",
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |",
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site.",
            "MacroFragSpec",
            "MacroMatch",
            "MacroMatcher"
          ]
        }
      ],
      "reasoning": "The core idea behind the field value is the repetition fragment used inside macro_rules macros, specifically the pattern $(...) with a repetition operator like *. Relevant passages establish that macros by example have named macros with one or more rules, each rule having a matcher (which handles the syntax to match) and a transcriber (which handles the syntax to replace matched invocations). This directly aligns with the notion that a fragment of the macro pattern can be repeated or repeated with a multiplier, i.e., the repetition syntax inside a matcher. Additional entries define structural terms such as MacroRule (a single rule in macro_rules), MacroTranscriber (the replacement side of a rule), and MacroRepOp (the repetition operator itself). Supporting fragments that enumerate macro fragment kinds and possible token-level parts (such as block, expr, ident, item, lifetime, literal) further corroborate how macro_rules patterns are built from composable fragments that can be repeated. In sum, the most directly connected information is the description of macro_rules with rules consisting of a matcher and a transcriber, the existence of macro rules themselves, and the explicit term for repetition operators used within macro patterns. The surrounding material on macro hygiene or token streams provides useful context but does not directly define the repetition syntax that the field value names.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.25",
      "citations": [
        {
          "title": "proc_macro2 - Rust",
          "url": "https://docs.rs/proc-macro2",
          "excerpts": [
            "By developing foundational libraries like syn and quote against proc_macro2 rather than proc_macro , the procedural macro ecosystem becomes easily applicable to ..."
          ]
        },
        {
          "title": "syn - Rust",
          "url": "https://docs.rs/syn",
          "excerpts": [
            "Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. Currently this library is geared toward use in Rust ..."
          ]
        },
        {
          "title": "quote in quote - Rust",
          "url": "https://docs.rs/quote/latest/quote/macro.quote.html",
          "excerpts": [
            "Alternatively, the APIs provided by Syn and proc-macro2 can be used to directly build the identifier. This is roughly equivalent to the above, but will not ..."
          ]
        },
        {
          "title": "proc_macro",
          "url": "https://doc.rust-lang.org/proc_macro/",
          "excerpts": [
            "A support library for macro authors when defining new macros. This library, provided by the standard distribution, provides the types consumed in the ..."
          ]
        },
        {
          "title": "function-like and derive procedural macro expansion is here!",
          "url": "https://www.reddit.com/r/rust/comments/zd4mxy/intellij_rust_changelog_184_functionlike_and/",
          "excerpts": [
            "A derive proc-macro is for situations where you want to extend the struct, enum, etc... But need to know the fields, their types, etc."
          ]
        },
        {
          "title": "Rust Structs and Attribute-like and Custom Derive Macros",
          "url": "https://rareskills.io/post/rust-attribute-derive-macro",
          "excerpts": [
            "An attribute-like macro takes in a struct and can completely rewrite it. A derive macro augments a struct with additional functions. Macros ..."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`](../core/macro.compile_error.html) macro invocation.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``"
          ]
        }
      ],
      "reasoning": "To substantiate the fine-grained field value, the most directly relevant information is explicit mentions of the proc-macro2 crate, which is a foundational library for building procedural macros in Rust. This excerpt states the crate name plainly and positions it within the procedural-macro ecosystem, making it the strongest support for the field value. Closely related toolingâ€”such as the syn crate (a parsing library for Rust tokens) and the quote crate (used to generate Rust code from Rust structures)â€”is also highly relevant because proc-macro2 is commonly used in tandem with syn and quote to implement procedural macros. The syn excerpt notes that it is a parsing library for turning a token stream into a syntax tree, which is a typical workflow alongside proc-macro2 when writing procedural macros. The quote excerpt discusses a macro-related helper that complements the ecosystem by enabling code generation, which is a typical use-case alongside proc-macro2. Another excerpt mentions the proc_macro crate itself, which provides the core API for writing procedural macros in Rust; this is foundational context that underpins why proc-macro2 and related crates exist. An excerpt that discusses function-like and derive procedural macros further tightens the contextual link to how proc-macro2 is used in practice to implement procedural macros and derive capabilities. An excerpt about attribute-like and custom derive macros reinforces the practical applications of this tooling in real-world Rust macro usage. A procedural-macros-specific excerpt and general macro hygiene discussions, while not naming proc-macro2 directly, reinforce the broader macro-ecosystem context in which proc-macro2 operates. Taken together, these excerpts collectively support the field value by directly naming or strongly tying to proc-macro2 and its common companions, and by illustrating how they are used in Rust metaprogramming. ",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.36",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured."
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        }
      ],
      "reasoning": "Span is defined as an opaque value that tokens carry, and it cannot be modified but can be manufactured, which makes it a foundational concept in macro tooling and token streams. This directly answers what Span is within the context of metaprogramming and macros. Additionally, the discussion of macro hygiene references Span as the encoding used for hygiene concerns in procedural macros, noting that every token in a TokenStream has an associated Span. This provides important context for how Span is used in practice within macro expansion and hygiene checks, reinforcing its role and significance in Rust metaprogramming workflows.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.15",
      "citations": [
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "block | expr | expr\\_2021 | ident | item | lifetime | literal   \nÂ Â Â Â | meta | pat | pat\\_param | path | stmt | tt |",
            "`macro_rules` allows users to define syntax extension in a declarative way. We\ncall such extensions â€œmacros by exampleâ€ or simply â€œmacrosâ€. Each macro by example has a name, and one or more *rules*. Each rule has two\nparts: a *matcher*, describing the syntax that it matches, and a *transcriber*,\ndescribing the syntax that will replace a successfully matched invocation. Both\nthe matcher and the transcriber must be surrounded by delimiters. Macros can\nexpand to expressions, statements, items (including traits, impls, and foreign\nitems), types, or patterns.",
            "Each macro by example has a name, and one or more _rules_ . Each rule has two\nparts: a _matcher_ , describing the syntax that it matches, and a _transcriber_ ,\ndescribing the syntax that will replace a successfully matched invocation.",
            "Token",
            "MacroRules"
          ]
        },
        {
          "title": "The Rust Reference - Macros",
          "url": "https://doc.rust-lang.org/reference/macros.html",
          "excerpts": [
            "The functionality and syntax of Rust can be extended with custom definitions\ncalled macros. They are given names, and invoked through a consistent\nsyntax: `some_extension!(... )` . There are two ways to define new macros:",
            "* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom\n  attributes using functions that operate on input token\n"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            ". The term _macro_ refers to a family\nof features in Rust: _declarative_ macros with `macro_rules!` and three kinds\nof _procedural_ macros:",
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "As functions, they must either return syntax, panic, or loop endlessly. Returned\nsyntax either replaces or adds the syntax depending on the kind of procedural\nmacro. Panics are caught by the compiler and are turned into a compiler error. Endless loops are not caught by the compiler which hangs the compiler. Procedural macros run during compilation, and thus have the same resources that\nthe compiler has. For example, standard input, error, and output are the same\nthat the compiler has access to. Similarly, file access is the same. Because\nof this, procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](../cargo/reference/build-scripts.html) have.",
            ", procedural macros have the same security concerns that [Cargoâ€™s\nbuild scripts](.",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``"
          ]
        },
        {
          "title": "Security breach with Rust macros - compiler - Rust Internals",
          "url": "https://internals.rust-lang.org/t/security-breach-with-rust-macros/14703",
          "excerpts": [
            "**"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "* [strict]()\n* [reserved]()\n* [weak]()\n",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "reserved",
            "weak",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "KW\\_RAW : `raw",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "> **<sup>Lexer 2018+</sup>**",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "/sup>**\n> KW\\_MACRO\\_RULES : `macro_rules`\n> KW\\_UNION : `union`\n> KW\\_STATICLIFETIME : `'static`\n> KW\\_SAFE : `safe`\n> KW\\_RAW : `raw`",
            "These keywords can only be used in their correct contexts. They cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "## [Strict keywords]()",
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "## [Weak keywords]()",
            ">**\n> KW\\_ABSTRACT : `abstract`\n> KW\\_BECOME : `become`\n> KW\\_BOX : `box`\n> KW\\_DO : `do`\n> KW\\_FINAL : `final`\n> KW\\_MACRO : `macro`\n> KW\\_OVERRIDE : `override`\n> KW\\_PRIV : `priv`\n> KW\\_TYPEOF : `typeof`\n> KW\\_UNSIZED : `unsized`\n> KW\\_VIRTUAL : `virtual`\n> KW\\_YIELD : `yiel",
            "## [Reserved keywords]()",
            ">**\n> KW\\_AS : `as`\n> KW\\_BREAK : `break`\n> KW\\_CONST : `const`\n> KW\\_CONTINUE : `continue`\n> KW\\_CRATE : `crate`\n> KW\\_ELSE : `else`\n> KW\\_ENUM : `enum`\n> KW\\_EXTERN : `extern`\n> KW\\_FALSE : `false`\n> KW\\_FN : `fn`\n> KW\\_FOR : `for`\n> KW\\_IF : `if`\n> KW\\_IMPL : `impl`\n> KW\\_IN : `in`\n> KW\\_LET : `let`\n> KW\\_LOOP : `loop`\n> KW\\_MATCH : `match`\n> KW\\_MOD : `mod`\n> KW\\_MOVE : `move`\n> KW\\_MUT : `mut`\n> KW\\_PUB : `pub`\n> KW\\_REF : `ref`\n> KW\\_RETURN : `return`\n> KW\\_SELFVALUE : `self`\n> KW\\_SELFTYPE : `Self`\n> KW\\_STATIC : `static`\n> KW\\_STRUCT : `struct`\n> KW\\_SUPER : `super`\n> KW\\_TRAIT : `trait`\n> KW\\_TRUE : `true`\n> KW\\_TYPE : `type`\n> KW\\_UNSAFE : `unsafe`\n> KW\\_USE : `use`\n> KW\\_WHERE : `wher",
            "> KW\\_DYN : `dyn",
            "> KW\\_AWAIT : `await",
            "> KW\\_ASYNC : `async",
            "The following keywords were added beginning in the 2018 edition.",
            "> KW\\_WHILE : `while",
            "> KW\\_WHERE : `where",
            "> KW\\_USE : `use",
            "> KW\\_UNSAFE : `unsafe",
            "> KW\\_TYPE : `type",
            "> KW\\_TRUE : `true",
            "> KW\\_TRAIT : `trait",
            "> KW\\_SUPER : `super",
            "> KW\\_STRUCT : `struct",
            "> KW\\_STATIC : `static",
            "> KW\\_SELFTYPE : `Self",
            "> KW\\_SELFVALUE : `self",
            "> KW\\_RETURN : `return",
            "> KW\\_REF : `ref",
            "> KW\\_PUB : `pub",
            "> KW\\_MUT : `mut",
            "> KW\\_MOVE : `move",
            "> KW\\_MOD : `mod",
            "> KW\\_MATCH : `match",
            "> KW\\_LOOP : `loop",
            "> KW\\_LET : `let",
            "> KW\\_IN : `in",
            "> KW\\_IMPL : `impl",
            "> KW\\_IF : `if",
            "> KW\\_FOR : `for",
            "> KW\\_FN : `fn",
            "> KW\\_FALSE : `false",
            "> KW\\_EXTERN : `extern",
            "> KW\\_ENUM : `enum",
            "> KW\\_ELSE : `else",
            "> KW\\_CRATE : `crate",
            "> KW\\_CONTINUE : `continue",
            "> KW\\_CONST : `const",
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```rust",
            "```",
            "```"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "fn main() {",
            "}",
            "}",
            "```rust",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "## [`format_macro_matchers`]()",
            "Format the metavariable matching patterns in macros.",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Default value** : `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3354) )",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "\n#### [`true` :](%5C%3A)",
            "    ($a:ident : $b:ty) => {",
            "    ($a:ident $b:ident $c:ident) => {",
            "See also [`format_macro_bodies`]() .",
            "## [`format_macro_bodies`]()",
            "Format the bodies of declarative macro definitions.",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Default value** : `true`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Possible values** : `true` , `false`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/3355) )",
            "    ($a: ident : $b: ty) => {",
            "    ($a: ident : $b: ty) => {",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "        $a(42): $b;",
            "    ($a: ident $b: ident $c: ident) => {",
            "    ($a: ident $b: ident $c: ident) => {",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "        $a = $b + $c;",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "    };",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "\n#### [`false` :](%5C%3A)",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "macro_rules! foo {",
            "    ($a: ident : $b: ty) => { $a(42): $b; };",
            "    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "See also [`format_macro_matchers`]() .",
            "## [`skip_macro_invocations`]()",
            "Skip formatting the bodies of macro invocations with the following names.",
            "rustfmt will not format any macro invocation for macros with names set in this list.",
            "Including the special value \"\\*\" will prevent any macro invocations from being formatted",
            "Note: This option does not have any impact on how rustfmt formats macro definitions.",
            "* **Default value** : `[]`",
            "* **Possible values** : a list of macro name idents, `[\"name_0\", \"name_1\", ..., \"*\"]`",
            "* **Stable** : No (tracking issue: [](https://github.com/rust-lang/rustfmt/issues/5346) )",
            "\n\n#### [`[]` (default):](#%5C%5B%5C%5D%5C%20%5C\\(default%5C\\)%5C%3A)",
            "rustfmt will follow its standard approach to formatting macro invocations.",
            "No macro invocations will be skipped based on their name. More information about rustfmt's standard macro invocation formatting behavior can be found in [](https://github.com/rust-lang/rustfmt/discussions/5437) .",
            "#### [`[\"lorem\"]` :](#%5C%5B%5C%22lorem%5C%22%5C%5D%5C%3A)",
            "The named macro invocations will be skipped.",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "    const _: u8 = 0;",
            "#### [`[\"*\"]` :](#%5C%5B%5C%22%5C*%5C%22%5C%5D%5C%3A)",
            "The special selector `*` will skip all macro invocations.",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "lorem!(",
            "lorem!(",
            "lorem!(",
            "ipsum!(",
            "ipsum!(",
            "ipsum!(",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            "        const _: u8 = 0;",
            ");",
            ");",
            ");",
            ");",
            ");",
            ");",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        }
      ],
      "reasoning": "The target field is a fine-grained macro-related value representing a macro fragment category, indicated as a token-like placeholder for expressions (\":expr\"). Excerpts that explicitly mention macro fragment categories and the role of expressions within macro definitions directly support this field value. For instance, one excerpt enumerates the macro fragment kinds available in the macro system, listing block, expr, expr_2021, ident, item, lifetime, and literal as possible fragments in macro matching and expansion. This directly aligns with identifying an expression fragment within macro rules. Other excerpts discuss macro definitions and usage in Rust (macros by example, declarative macros, and procedural macros), and they describe how macros can expand to expressions among other syntactic forms, which reinforces the relevance of an expression fragment in macro grammar. Additional excerpts describe macro rules, the anatomy of macro matching and transcription (matcher and transcriber), and token-level representations such as token streams; these pieces broaden the context showing where an expression fragment (expr) fits in the macro system. Together, these excerpts provide clear, direct support for the presence and role of an expression fragment in macro-related syntax, matching the idea conveyed by the field value. The strongest alignment comes from the explicit listing of expr among macro fragment kinds, followed by discussions that macro rules can expand to expressions, and token-level concepts that relate to expression fragments in macro processing.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.4",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc"
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "Data races are prevented *mostly* through Rust's ownership system alone:"
          ]
        }
      ],
      "reasoning": "Borrowing in Rust is described as a way to access data without transferring ownership, with a reference behaving like a pointer but guaranteed to point to a valid value for the lifetime of the reference. The excerpts collectively show: a reference is an address that allows accessing data owned by someone else, but unlike a raw pointer it cannot outlive the value it references, and borrowing rules prevent mutations or moves when the data is immutably borrowed. The mutable-borrow restriction is a key part of borrowing semantics, ensuring you cannot have multiple aliases to a mutably borrowed location. Lifetimes are the compilerâ€™s mechanism to ensure borrows are valid for their usage scope. Two-phase borrows introduce a nuanced form of borrowing where a mutable borrow can start in a reserved/shared state and later become active, which still preserves borrowing guarantees. The borrow checker is the mechanism enforcing these rules during MIR analysis. Together, these excerpts establish that Borrowing is the mechanism by which Rust enables safe, memory-safe access to data while enforcing ownership and lifetime constraints, preventing data races and invalid mutations while booleans like & or &mut reflect different borrowing modes. The most directly supportive points are the definitions of references and borrowing, the guaranteed validity of the borrowed data, and the explicit restriction that mutable borrows cannot be aliased with other borrows. The two-phase borrowing excerpts further illustrate how borrowing can be extended in a controlled way to support ergonomic patterns like nested method calls while maintaining safety. The filesystem-like context around borrowing in the later excerpts reinforces that the borrow checker and lifetimes work together to prevent unsafe aliasing and ensure memory safety across the program.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.3",
      "citations": [
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        }
      ],
      "reasoning": "The fine-grained field value refers to a specific pattern in Rust memory management: a Partial Move. The excerpt explicitly defines this concept as a Partial move of the variable, meaning that parts of the variable can be moved while other parts remain. This directly supports the field value by providing a precise definition of partial moves. While other excerpts discuss ownership, borrowing, and moves in general, they do not provide a direct definition or isolated focus on partial moves, so they are less directly supportive of the exact fine-grained field value in question.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.2",
      "citations": [
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "// *Copy* `x` into `y` - no resources are moved"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        }
      ],
      "reasoning": "To connect the fine-grained field value Copy Trait to the excerpts, I first identify explicit mentions of Copy or direct implications of copying versus moving ownership. The most direct excerpt states, in the context of moving resources, the explicit case where Copy is used: copying x into y results in no resources being moved. This directly exemplifies the Copy trait concept, contrasting it with moves where ownership changes. Following that, other excerpts discuss broader memory-management patterns such as ownership-based resource management (OBRM/RAII) and smart pointer semantics (Box, Rc) which underpin when copying semantics are desirable or safe, thus providing essential context for why Copy would matter in memory-management analysis. Additional excerpts focus on ownership, borrowing, and lifetime rules, which frame the constraints around copying and moving, even if they donâ€™t name Copy explicitly. These together help corroborate how Copy interacts with Rustâ€™s memory model (ownership, moves, borrows, and resource management), supporting the identification of Copy Trait as the targeted concept. The excerpts about references, lifetimes, and two-phase borrows supply related but secondary context, showing how non-copyable borrows and references interact with ownership semantics, further clarifying why Copy is a distinct, important trait in memory management discussions. Collectively, the strongest support comes from the explicit Copy example, followed by broader ownership and memory-management discussions that contextualize Copy usage and constraints.",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.35",
      "citations": [
        {
          "title": "proc_macro_error - Rust",
          "url": "https://docs.rs/proc-macro-error",
          "excerpts": [
            "This crate aims to make error reporting in proc-macros simple and easy to use. Migrate from panic! -based errors for as little effort as possible!"
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros have two ways of reporting errors. The first is to panic. The\nsecond is to emit a [`compile_error`](../core/macro.compile_error.html) macro invocation."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly states that there is a crate named proc-macro-error whose purpose is to simplify and streamline error reporting in procedural macros. This directly confirms the existence and purpose of the proc-macro-error crate referenced by the fine-grained field value. A secondary, closely related excerpt discusses how procedural macros report errors in general, noting that errors can be signaled by panicking or by emitting a compile_error macro invocation. This provides helpful context about typical error-reporting mechanisms in proc-macros, which supports understanding of how the proc-macro-error crate fits into the broader error-reporting landscape, though it does not name the crate itself. Together, these excerpts support the field value by identifying the crate and situating its purpose within procedural macro error handling. ",
      "confidence": "medium"
    },
    {
      "field": "metaprogramming_and_macros_keywords.39",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]",
            "Procedural macros must be defined in the root of a crate with the [crate type](linkage.html) of `proc-macro` . The macros may not be used from the crate where they are defined, and can only be used when imported in another crate.\n> Note\n> \n> When using Cargo, Procedural macro crates are defined with the `proc-macro` key in your manifest:\n> \n> ```toml\n> [lib]\n> proc-macro = true\n> ``"
          ]
        },
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "derive macros",
            "In Rust, there are 2 different types of macros: declarative and procedural.",
            "Declarative macros work based on syntax parsing.",
            "attribute macros",
            "functional macros",
            "tions. These are the least restrictive type of procedural macros, as they can be used literally anywhere, as long as they output code that's valid in the context that they're used in."
          ]
        }
      ],
      "reasoning": "The serde derive scenario is a concrete instantiation of a derive macro, which Rust documents as a subset of procedural macros. A key excerpt explicitly identifies derive macros as one of three flavors of procedural macros, alongside function-like and attribute macros, and shows that derive macros are invoked via the #[derive(...)] form. Another excerpt reiterates that custom #[derive] macros specify code added with the derive attribute on structs and enums, tying the concept directly to the serde use-case where Serialize/Deserialize are generated by such derive instructions. Additional excerpts from tutorials and references discuss that derive macros are part of the broader ecosystem of procedural macros (including attributes and macro hygiene), and they mention specific examples of derive macros and attributes, confirming that serde derive is a canonical, real-world application of this mechanism. The remaining excerpts provide contextual support about macros in Rust (declarative macros like macro_rules!, hygiene, and general procedural macro guidance) which helps situate serde derive within the standard Rust macro landscape, but do not address serde directly. The combination of explicit mentions of derive macros, the derive attribute, and procedural macro categories most strongly supports the field value about serde derive as a representative use of derive macros in Rust.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.9",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization"
          ]
        }
      ],
      "reasoning": "The requested field value centers on the notion of a Shared Borrow within Rustâ€™s borrow-checking model. Excerpts that describe two-phase borrows explicitly introduce a reservation phase where the borrow is treated as a shared (read) borrow prior to activation. This directly supports the idea of a Shared Borrow as a distinct, temporary borrowing state that coexists with other borrows before a mutable borrow is engaged. In particular, passages describe how the reservation phase permits reads and shared borrows while mutation is not yet allowed, which is the essence of a shared borrow in this context. Additionally, examples of nested method calls using a two-phased approach illustrate the practical use of shared borrows before activation into a mutable borrow, further anchoring the connection between the field value and the content in these excerpts. Contextual material on aliasing models and the broader borrow-checking semantics reinforces why shared borrows matter for memory management and optimization, but the most precise support for the field value comes from the explicit treatment of reservation/shared phases and their transition to mutability. Taken together, these excerpts provide strong, targeted support for the concept of Shared Borrows as a documented phase of Rustâ€™s borrow system, prior to mutation.\n",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.40",
      "citations": [
        {
          "title": "Rust Programming Language - Macros (The Rust Book)",
          "url": "https://doc.rust-lang.org/book/ch20-05-macros.html",
          "excerpts": [
            "Custom `#[derive]` macros that specify code added with the `derive` attribute\n  used on structs and enums",
            "Function-like macros that look like function calls but operate on the tokens\n  specified as their argument",
            "The most widely used form of macros in Rust is the _declarative macro_ .\nThese\nare also sometimes referred to as â€œmacros by example,â€ â€œ `macro_rules!` macros,â€\nor just plain â€œmacros.â€ At their core, declarative macros allow you to write\nsomething similar to a Rust `match` expression."
          ]
        },
        {
          "title": "Procedural Macros in Rust â€” A Handbook for Beginners",
          "url": "https://www.freecodecamp.org/news/procedural-macros-in-rust/",
          "excerpts": [
            "derive macros",
            "attribute macros",
            "functional macros",
            "Declarative macros work based on syntax parsing.",
            "In Rust, there are 2 different types of macros: declarative and procedural."
          ]
        },
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "Procedural macros come in one of three flavors:\n\n* [Function-like macros]() \\- `custom!(... )`\n* [Derive macros]() \\- `#[derive(CustomDerive)]`\n* [Attribute macros]() \\- `#[CustomAttribute]"
          ]
        }
      ],
      "reasoning": "The field value refers to a derive-based macro usage (the derive attribute on types) which is central to crates like thiserror that generate code via derive macros. An excerpt explicitly noting that custom #[derive] macros add code via the derive attribute on structs and enums directly supports the idea of a derive-based macro value. Additional excerpts discuss the concept of derive macros themselves, the existence of multiple macro flavors including derive and attribute macros, and the general distinction between declarative macros and procedural macros that can implement derive-like behavior. Quotes indicate that derive macros are a recognized mechanism, including the idea that derive macros augment types with generated code, and that attribute macros (which commonly accompany derive usage) are a related mechanism. Function-like macros and declarative macros are mentioned to provide broader context about how macro systems operate in Rust, which underpins how derive-based code generation is integrated into crates like thiserror. Collectively, these excerpts establish that derive-based code generation is a supported and documented pattern in Rust, which is relevant to understanding the meaning and potential usage of a thiserror derive in a knowledge base. However, none of the excerpts explicitly mention the thiserror crate or its derive macro implementations, so the evidence is indirect and primarily contextual.",
      "confidence": "low"
    },
    {
      "field": "memory_management_keywords.0",
      "citations": [
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent."
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "resources can only have one owner",
            "This prevents resources",
            "from being freed more than once. Note that not all variables own",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved",
            "    let y = x;",
            "Both values can be independently used"
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete"
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "Interior mutability makes this more complicated, which is largely why"
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "Ownership is Rustâ€™s central memory-management concept that enables safety without a garbage collector. Excerpts that state ownership is the breakout feature and that it enables memory-safety and efficiency without GC provide direct support for the Ownership keyword. Phrases describing ownership solving problems the C compiler cannot catch, or describing the one-owner rule and the idea that the resource is released when the owner goes out of scope, directly connect to the Ownership field value. Descriptions of move semantics â€” where ownership of resources is transferred rather than copied, and where the previous owner cannot be used after a move â€” further substantiate ownership as a core concept and are highly relevant. Excerpts that discuss Resource Acquisition Is Initialization (RAII) and OBMR (ownership-based resource management) illustrate how ownership governs resource lifetimes and cleanup, reinforcing Ownership as the foundational term. Related excerpts on references and borrowing provide essential context for ownership (they explain how borrowing interacts with ownership and lifetimes), but are slightly less directly about the ownership keyword itself; they nonetheless underpin the concept and are valuable for a comprehensive knowledge base. The combination of direct ownership definitions, move semantics, and RAII/OBRM discussions offers strong, coherent support for treating Ownership as the primary finegrained field, with related borrowing/reference material enriching the context. Overall, the selected excerpts collectively support that Ownership is a central, well-supported concept in Rustâ€™s memory model, with high confidence given the volume and clarity of direct ownership-related statements.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.41",
      "citations": [
        {
          "title": "Procedural Macros - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/procedural-macros.html",
          "excerpts": [
            "\n\n## [Procedural macro hygiene]()\n\nProcedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.",
            "Procedural macros are _unhygienic_ . This means they behave as if the output\ntoken stream was simply written inline to the code itâ€™s next to.\nThis means that\nitâ€™s affected by external items and also affects external imports. Macro authors need to be careful to ensure their macros work in as many contexts\nas possible given this limitation. This often includes using absolute paths to\nitems in libraries (for example, `::std::option::Option` instead of `Option` ) or\nby ensuring that generated functions have names that are unlikely to clash with\nother functions (like `__internal_foo` instead of `foo` )",
            "All tokens have an associated `Span` . A `Span` is an opaque value that cannot\nbe modified but can be manufactured."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "Macros by example have _mixed-site hygiene_ . This means that [loop labels](expressions/loop-expr.html) , [block labels](expressions/loop-expr.html) , and local variables are looked up at the macro definition site while other symbols are looked up at the macro invocation site."
          ]
        },
        {
          "title": "Hygiene and Spans - The Little Book of Rust Macros",
          "url": "https://lukaswirth.dev/tlborm/proc-macros/hygiene.html",
          "excerpts": [
            "This chapter talks about procedural macro hygiene and the type that encodes it, Span. Every token in a TokenStream has an associated Span holding some ..."
          ]
        },
        {
          "title": "Hygiene â€” TL; Boehm Macro Education Resource",
          "url": "https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html",
          "excerpts": [
            "Hygiene",
            "                - [**2\\.3.2. ** Hygiene](mbe-min-hygiene.html)"
          ]
        }
      ],
      "reasoning": "The most directly relevant content explicitly states that procedural macros are unhygienic, indicating a core aspect of macro hygiene. This directly supports the field value by naming the property of macro systems that the field highlights. Related content reinforces this: one excerpt explains macro hygiene in the context of macro expansion and its interaction with external items and imports, which provides a concrete mechanism for why hygiene matters for macro authors. Additional material discusses mixed-site hygiene, where symbol lookup differs between macro definition and invocation sites, further grounding the concept of hygiene in practical macro usage. An education-focused excerpt on hygiene concepts in macro tooling and a TL;Boise resource on hygiene and spans extend the justification by illustrating how hygiene is defined and discussed in the Rust macro ecosystem. One excerpt notes that tokens have spans and that hygiene considerations affect how macro code is written, which ties into the broader hygiene narrative. Overall, the strongest signals come from explicit statements about unhygienic macros, followed by related explanations of macro hygiene effects and definitions. The connection to the finegrained field value is therefore strong, with multiple corroborating statements that align with the concept of unhygienic macros.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.8",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference."
          ]
        }
      ],
      "reasoning": "The most relevant content directly describes two-phase borrows and the borrow-checking process. Excerpts outlining two-phase borrows explain how a mutable borrow can be reserved and later activated, which is a concrete mechanism used by the borrow checker to ensure safety during method calls and reborrows. This directly supports the finegrained field value of Borrow Checker because it exemplifies how the borrow checker enforces safe borrowing through phased states and activation points.\n\nExcerpts that discuss the borrow checker at a higher level, including its role in MIR and its enforcement of borrowing constraints (such as preventing mutation while an immutable borrow is live, and general borrow-checking rules), reinforce the same theme and provide additional evidence about how borrowing semantics are enforced in the compiler pipeline, further supporting the finegrained field value.\n\nExcerpts focusing on references and borrowing basics (how references work, what a reference guarantees, and how borrowing is used to implement length calculation) illustrate foundational concepts the Borrow Checker relies on to determine safe usage patterns. They provide context for why the Borrow Checker enforces these rules and how it prevents dangerous aliasing and mutation.\n\nTogether, these excerpts establish a coherent picture: the Borrow Checker governs when and how borrows can be created, reserved, activated, and how two-phase borrowing is used as a controlled mechanism to balance can-read while preventing unsafe aliasing, all within the MIR-based analysis and lifetime rules that underlie Rustâ€™s safety guarantees.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.27",
      "citations": [
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "ipts\nSome packages need to compile third-party non-Rust code, for example C\nlibraries. Other packages need to link to C libraries which can either be\nlocated on the system or possibly need to be built from source. Others still\nneed facilities for functionality such as code generation before building (think\nparser generators). Cargo does not aim to replace other tools that are well-optimized for these\ntasks, but it does integrate with them with custom build scripts.",
            "Placing a\nfile named\nbuild.rs in the root of a package will cause Cargo to compile\nthat script and execute it just before building the package.",
            "Some example use cases of build scripts are:\n    * Building a bundled C library. * Finding a C library on the host system. * Generating a Rust module from a specification. * Performing any platform-specific configuration needed for the crate.",
            "Just before a package is built, Cargo will compile a build script into an\nexecutable (if it has not already been built). It will then run the script,\nwhich may perform any number of tasks. The script may communicate with Cargo\nby printing specially formatted commands prefixed with\ncargo:: to stdout.",
            "The build script will be rebuilt if any of its source files or dependencies\nchange. By default, Cargo will re-run the build script if any of the files in the\npackage changes. Typically it is best to use the\nrerun-if commands,\ndescribed in the change detection section below, to\nnarrow the focus of what triggers a build script to run again.",
            "Build scripts are also allowed to have dependencies on other Cargo-based crates. Dependencies are declared through the\nbuild-dependencies section of the\nmanifest.",
            "The\npackage.links key may be set in the\nCargo.toml manifest to declare\nthat the package links with the given native library.",
            "When using the\nlinks key, the package must have a build script, and the\nbuild script should use the\nrustc-link-lib instruction to\nlink the library."
          ]
        },
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located.",
            "Thereâ€™s a couple of points of note here:\n    * The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located. It can use the processâ€™ current working\ndirectory to find where the input files should be located, but in this case we\ndonâ€™t have any input files. * In general, build scripts should not modify any files outside of\nOUT_DIR . It may seem fine on the first blush, but it does cause problems when you use\nsuch crate as a dependency, because thereâ€™s an implicit invariant that\nsources in\n.cargo/registry should be immutable. cargo wonâ€™t allow such\nscripts when packaging. * This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as\ngenerating a Rust module from a C header file or another language definition,\nfor example. * The\nrerun-if-changed instruction tells Cargo that the build script only needs to re-run if the build script\nitself changes.\nWithout this line, Cargo will automatically run the build\nscript if any file in the package changes. If your code generation uses some\ninput files, this is where you would print a list of each of those files.",
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "generated file (`hello.rs`) into the crateâ€™s compilation."
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a `build.rs` file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is built. This can be used to generate code at compile time.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and is something\nlike `./target/debug/build/bindgen-tutorial-bzip2-sys-afc7747d7eafd720/out/` .",
            "Now, when we run `cargo build` , our bindings to `bzip2` are generated on the\nfly!"
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/cargo/reference/build-scripts.html",
          "excerpts": [
            "The stdout output and OUT_DIR locations are also handled by the cc library. Here we can start to see some of the major benefits of farming as much functionalityÂ ..."
          ]
        }
      ],
      "reasoning": "The core field value concerns build scripts in the Rust ecosystem. Excerpts that describe the Cargo Bookâ€™s treatment of build scripts are most directly relevant, including how to place a build.rs in a crate, how Cargo builds and runs this script before compiling the crate, and how build scripts interact with the build process (such as OUT_DIR and rerun logic). These excerpts provide explicit statements like building a script before the crate is compiled, and the mechanism of locating output via OUT_DIR, which are central to understanding build scripts in this context. Additional excerpts that cover build-script examples and usage within Cargo (e.g., linking in build scripts, generating metadata, and triggering reruns) further support the field value by expanding on practical workflows and common practices around build scripts. Entries that discuss related topics (like code generation pipelines or macro hygiene) are less directly tied to the build script concept itself but can provide contextual background; these have been deprioritized relative to the explicit build-script discussions. Direct quotes include instructions for placing a build.rs file to trigger compilation and execution prior to building the package, notes about OUT_DIR, and references to rerun-if-changed and build-script metadata, all of which connect to the finegrained field value about build scripts.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.1",
      "citations": [
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "resources can only have one owner",
            "Because variables are in charge of freeing their own resources,",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        }
      ],
      "reasoning": "The target field value Move Semantics is about how ownership and resource management transfer on assignments and moves in Rust. The most directly relevant information comes from statements that explicitly define a move as the transfer of ownership during assignment, and describe the one-owner rule and how moving works to prevent double-free or duplicate ownership. Specifically, the claim that â€œownership of the resources is transferredâ€ when doing let x = y directly states the essence of a move, and the follow-up that this is â€œknown as a moveâ€ reinforces the terminology. Additionally, the rule that â€œresources can only have one ownerâ€ underlines why moves are required to transfer ownership rather than just copy, which is central to Move Semantics. Further, examples that mention that nothing is moved when using Copy (e.g., copying x into y) contrast Move Semantics with Copy semantics, clarifying when a move actually happens. Patterns describing Ownership-Based Resource Management (OBRM) then contextualize Move Semantics within Rustâ€™s broader memory-management model (RAII), emphasizing that resources are managed by objects that acquire and release them. Taken together, these excerpts cohesively support the fine-grained field value by grounding Move Semantics in ownership transfer, single ownership, and RAII-style resource management. They directly illustrate what moves are, when they occur, and why they are necessary in Rustâ€™s memory model.",
      "confidence": "high"
    },
    {
      "field": "metaprogramming_and_macros_keywords.31",
      "citations": [
        {
          "title": "The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-script-examples.html",
          "excerpts": [
            "Code generation\nSome Cargo packages need to have code generated just before they are compiled\nfor various reasons.",
            "Code generation",
            "Thereâ€™s a couple of points of note here:\n    * The script uses the\nOUT_DIR environment variable to discover where the\noutput files should be located. It can use the processâ€™ current working\ndirectory to find where the input files should be located, but in this case we\ndonâ€™t have any input files. * In general, build scripts should not modify any files outside of\nOUT_DIR . It may seem fine on the first blush, but it does cause problems when you use\nsuch crate as a dependency, because thereâ€™s an implicit invariant that\nsources in\n.cargo/registry should be immutable. cargo wonâ€™t allow such\nscripts when packaging. * This script is relatively simple as it just writes out a small generated file. One could imagine that other more complex operations could take place such as\ngenerating a Rust module from a C header file or another language definition,\nfor example. * The\nrerun-if-changed instruction tells Cargo that the build script only needs to re-run if the build script\nitself changes.\nWithout this line, Cargo will automatically run the build\nscript if any file in the package changes. If your code generation uses some\ninput files, this is where you would print a list of each of those files.",
            "let out_dir = env::var_os(\"OUT_DIR\").unwrap();",
            "let dest_path = Path::new(&out_dir).join(\"hello.rs\");",
            "fs::write(",
            "        &dest_path,",
            "        \"pub fn message() -> &'static str {",
            "{\n            \\\"Hello, World!\\\"",
            "        }",
            "        \"",
            "    ).unwrap();",
            "println! (\"cargo::rerun-if-changed=build.rs\");",
            "[`include!` macro](../../std/macro.include.html) in combination with the",
            "[`concat!`](../../std/macro.concat.html) and [`env!`](../../std/macro.env.html) macros to include the",
            "generated file (`hello.rs`) into the crateâ€™s compilation."
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/build-scripts.html",
          "excerpts": [
            "Some example use cases of build scripts are:\n    * Building a bundled C library. * Finding a C library on the host system. * Generating a Rust module from a specification. * Performing any platform-specific configuration needed for the crate."
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/tutorial-3.html",
          "excerpts": [
            "We create a `build.rs` file in our crate's root. Cargo will pick up on the existence of this file, then compile and execute it before the rest of the crate is built. This can be used to generate code at compile time.",
            "The resulting bindings will be written to `$OUT_DIR/bindings.rs` where `$OUT_DIR` is chosen by `cargo` and is something\nlike `./target/debug/build/bindgen-tutorial-bzip2-sys-afc7747d7eafd720/out/` .",
            "Now, when we run `cargo build` , our bindings to `bzip2` are generated on the\nfly!"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }",
            "        }"
          ]
        },
        {
          "title": "Build Scripts - The Cargo Book",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/cargo/reference/build-scripts.html",
          "excerpts": [
            "The stdout output and OUT_DIR locations are also handled by the cc library. Here we can start to see some of the major benefits of farming as much functionalityÂ ..."
          ]
        }
      ],
      "reasoning": "Code generation is a central theme in several excerpts. Direct mentions label code generation as a capability or pattern used in Rust tooling: the Cargo Book explicitly discusses code generation in the context of build scripts and how code can be generated before compilation, linking this to tasks like producing output artifacts during the build process. There is also a separate note that build scripts can perform code generation, including generating a Rust module from a specification, which directly ties to generating code. Multiple excerpts provide concrete examples: build scripts generating files and placing outputs in OUT_DIR, generating bindings (bindings.rs) into a generated output path, and dynamically generating code during cargo build (on-the-fly generation). Additional excerpts show the general role of code generation in cargo workflows, including mention of generating a bundled C library, as well as the practice of generating code at compile time via build.rs, which is a canonical Rust pattern for code generation. Taken together, these excerpts robustly support the interpretation that code generation is a primary mechanism used in Rust metaprogramming and macro workflows, especially in build-script-driven workflows and code-generation pipelines that produce Rust code or bindings before or during compilation.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.5",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "```rust",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i",
            "It is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled *sound*; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is *unsound*.",
            "unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is _unsound_",
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.",
            "The bytes owned by an immutable binding or immutable `static` are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html).",
            "Moreover, the bytes [pointed to]() by a shared reference, including transitively through other references (both shared and mutable) and `Box`es, are immutable; transitivity includes those references stored in fields of compound types.",
            "* Producing an [invalid value](). â€œProducingâ€ a\n  value happens any time a value is assigned to or read from a place, passed to\n  a function/primitive operation or returned from a function/primitive\n  oper",
            "The Rust compiler assumes that all values produced during program execution are\nâ€œvalidâ€, and producing an invalid value is hence immediate UB.",
            "* A `fn` pointer value must be non-null.",
            "* A `char` value must not be a surrogate (i.e., must not be in the range `0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`.",
            "* A `!` value must never exist.",
            "* An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be\n  initialized, i.e., must not be obtained from uninitialized memor",
            "* A `str` value is treated like `[u8]`, i.e. it must be initialized.",
            "* An `enum` must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.",
            "* A `struct`, tuple, and array requires all fields/elements to be valid at their respective type.",
            "* For a `union`, the exact validity requirements are not decided yet.",
            "* A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned and non-null, it cannot be [dangling](), and it must point to a valid value",
            "* The metadata of a wide reference, [`Box<T>`](../alloc/boxed/struct.Box.html), or raw pointer must match\n  the type of the unsized tai",
            "* If a type has a custom range of a valid values, then a valid value must be in that range.",
            "**Note:** Uninitialized memory is also implicitly invalid for any type that has\na restricted set of valid values. In other words, the only cases in which\nreading uninitialized memory is permitted are inside `union`s and in â€œpaddingâ€\n(the gaps between the fields of a type).",
            "Data races."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "pe in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)",
            " A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.",
            "Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.",
            "\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.",
            "Undefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program.",
            "However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
            "\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support",
            "* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple)",
            "      + a `bool` that isn't 0 or 1",
            "      + an `enum` with an invalid discriminant",
            "      + a null `fn` pointer",
            "      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]",
            "      + a `!` (all values are invalid for this type)",
            "      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` .",
            "      + a reference/ `Box` that is dangling, unaligned, or points to an invalid value.",
            "      + a wide reference, `Box` , or raw pointer that has invalid metadata:",
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)",
            "      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null.",
            "For a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) ."
          ]
        },
        {
          "title": "Working with Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat.",
            "We say that such a correct\nunsafely implemented function is _sound_ , meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).",
            "This program is now _unsound_ , Safe Rust can cause Undefined Behavior, and yet _we only modified safe code_ . This is the fundamental problem of safety: it's\nnon-local.",
            "The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.",
            "Safety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness.",
            "However\nsafety _isn't_ modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.",
            "It is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is _critical_ to the relationship between\nSafe Rust and Unsafe Rust.",
            "We have already seen that Unsafe code must trust _some_ Safe code, but shouldn't\ntrust _generic_ Safe code.",
            "Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state."
          ]
        },
        {
          "title": "Tree Borrows Explained",
          "url": "https://internals.rust-lang.org/t/tree-borrows-explained/18587",
          "excerpts": [
            "Since the `Freeze` and `Unpin` properties are not checked granularly, they are applied identically to out-of-range locations. That's a very debatable aspect of the model, but for now it's in line with TB being \"maximally permissive\" and can totally be changed if deemed problematic.",
            "[Vanille-N](https://internals.rust-lang.org/u/Vanille-N) March 29, 2023, 7:18am 10",
            "Interesting observation: because `&mut` borrows start as the two-phase reserved stated, `&mut` borrow splitting just falls out of the model without any special handling, even if it were to keep fully eager instead of delayed tag reborrowing. This is evident from the walkthrough of the disjoint fields example.",
            "[UCG #381: `&mut impl !Unpin` are not `dereferenceable`](https://github.com/rust-lang/unsafe-code-guidelines/issues/381)"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "First off, let's get some important caveats out of the way:\n\n* \n  We will be using the broadest possible definition of aliasing for the sake\n  of discussion. Rust's definition will probably be more restricted to factor\n  in mutations and liveness. * \n  We will be assuming a single-threaded, interrupt-free, execution. We will also\n  be ignoring things like memory-mapped hardware. Rust assumes these things\n  don't happen unless you tell it otherwise. For more details, see the [Concurrency Chapter](concurrency.html) . With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memory",
            "So why should we care about aliasing? Consider this simple function:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nfn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that \\`output\\` will be \\`2\\` if \\`input > 10\\`\n}\n}\n`",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model for Rust",
            "In Rust, the type system imposes a strict\n\ndiscipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias\n\ninformation for the purpose of program optimizations that reorder memory accesse",
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio",
            "Raw pointers are necessary when interfacing with C code through FFI, and also\n\nwhen implementing low-level pointer-heavy data structures in Rust that internally do not follow\n\nRustâ€™s aliasing disciplin",
            "The sinister part about this cast is that we do it twice! The type system does not stop us, as it\n\ndoes not even attempt to track what happens with raw pointers",
            "What is important is that **unsafe** code is encapsulated within a\n\nsafe abstraction ",
            "The Rust ecosystem rests on the interplay of safe code where possible and **unsafe** code\n\nwhere needed, and hence any realistic consideration of compilation for Rust programs requires\n\nproper treatment of **unsafe** cod",
            "More precisely, we will define the operational semantics in\n\nsuch a way that our example program has undefined behavior , which means the compiler is allowed\n\nto compile it in any way it choose",
            "Compared to\n\nRustBeltâ€™s semantics, we have to Å‚addÅ¾ some undefined behavior to obtain the desired optimizations",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin",
            "Raw pointers. Sometimes, the aliasing discipline for references that the borrow checker enforces\n\nis too strict",
            "In this case, one option is to not use references but instead\n\nemploy raw pointers . Raw pointers in Rust basically act like pointers in C: they are not checked by\n\nthe compiler, and there are no aliasing restriction",
            "In line 2, we cast a reference to raw pointer type.",
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        },
        {
          "title": "std::mem::MaybeUninit - Rust",
          "url": "https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html",
          "excerpts": [
            "Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an `UnsafeCell<T>` ).",
            "Ok ( unsafe { buffer.assume_init() })",
            "(mutable) reference to uninitialized memory! // This is undefined behavi",
            "let mut foo = MaybeUninit::<Foo>::uninit();",
            "ptr::write( &mut foo.assume_init_mut().a as *mut u32, 1337 );",
            "(mutable) reference to uninitialized memory! // This is undefined behavior."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "## [Rust's Unsafe Code Guidelines Reference]()",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Since last fall, [Neven](https://perso.crans.org/vanille/) has been doing an internship to develop a new aliasing model for Rust: Tree Borrows. Hang on a second, I hear you say â€“ doesnâ€™t Rust already have an aliasing model? Isnâ€™t there this â€œStacked Borrowsâ€ that Ralf keeps talking about? Indeed there is, but Stacked Borrows is just one proposal for a possible aliasing model â€“ and it [has](https://github.com/rust-lang/unsafe-code-guidelines/issues/133) [its](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) [fair](https://github.com/rust-lang/unsafe-code-guidelines/issues/256) [share](https://github.com/rust-lang/unsafe-code-guidelines/issues/274) [of](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) [problems](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) .",
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines GitHub Repository",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines",
          "excerpts": [
            "The purpose of this repository is to collect and discuss all sorts of questions that come up when writing unsafe code.",
            "The [Unsafe Code Guidelines Reference \"book\"](https://rust-lang.github.io/unsafe-code-guidelines) is a past effort to systematize a consensus on some of these questions. Most of it has been archived, but the [glossary](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html) is still a useful resource.",
            "The [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/) is a draft document discussing unsafe code. It is intended to\nbe brought into agreement with the content here. It represents an organized\neffort to explain how to write Rust code, rather than a reference."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "Unsafe Code Guidelines Reference",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "No-Panic Rust: A Nice Technique for Systems Programming",
          "url": "https://blog.reverberate.org/2025/02/03/no-panic-rust.html",
          "excerpts": [
            "Feb 3, 2025 â€” Runtime overhead: A potential panic implies some kind of runtime check. ... For example, memory allocation failure will panic in most cases."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate.",
            "\nThis topic was automatically closed 90 days after the last reply. We invite you to open a new topic if you have further questions or comments."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Rust Embedded - awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "In 2018, the Rust community created an embedded working group to help drive adoption in the Rust ecosystem.",
            "Curated list of resources for Embedded and Low-level development in the Rust programming language",
            "The embedded parts use the nRF52840-DK and a LIS3DH breakout board. ( [github source](https://github.com/tweedegolf/rust-workshop) )"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc.",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "The work on this book is coordinated in [this repository](https://github.com/rust-embedded/book) and is mainly\ndeveloped by the [resources team](https://github.com/rust-embedded/wg).",
            "+ Cross Compilation"
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "RFL leverages **bindgen** to automatically generate Rust bindings of C kernel struct prior to use.",
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "no_std - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "[The Discovery book](https://docs.rust-embedded.org/discovery/index.html) will teach you about microcontrollers,\nperipherals, sensors and bare metal programming through a series of small, fun\nprojects that youâ€™ll develop in Rust.",
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software.",
            "ed/awesome-embedded-rust) resource includes a list of other books, blogs, and\ntraining materials for learning embedded Rust, including complete from-scratch\nproject examples and quickstart templates: [Books, blogs and training materials"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "Panicking is a core part of the Rust language. Built-in operations like indexing\nare runtime checked for memory safety. When out of bounds indexing is attempted\nthis results in a panic. In the standard library panicking has a defined behavior: it unwinds the stack\nof the panicking thread, unless the user opted for aborting the program on\npanics. In programs without standard library, however, the panicking behavior is left\nundefined. A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the panic. Given that embedded systems range from user facing to safety critical (cannot\ncrash) there's no one size fits all panicking behavior but there are plenty of\ncommonly used behaviors. These common behaviors have been packaged into crates\nthat define the `#[panic_handler]` function."
          ]
        },
        {
          "title": "The Redox Operating System",
          "url": "http://doc.redox-os.org/book",
          "excerpts": [
            "Redox OS is a general-purpose operating system written in [Rust](https://www.rust-lang.org) . Our aim is to provide a fully functioning Unix-like microkernel-based operating system, that is secure, reliable and free.",
            "Redox OS was created in 2015 before the first stable version (1.0) of the Rust compiler and was one of the first operating systems written in Rust.",
            "To achieve that, Redox was redesigned to adopt a microkernel architecture and a unified system API for resources.",
            "This book is written in a way that you doesn't require any prior knowledge of Rust or OS development."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "http://os.phil-opp.com/",
          "excerpts": [
            "\n\nThis blog series creates a small operating system in the [Rust programming language](https://www.rust-lang.org/) . Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding [Github repository](https://github.com/phil-opp/blog_os) .",
            "\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the [bare metal](https://en.wikipedia.org/wiki/Bare_machine) without an underlying operating system.",
            " [A Freestanding Rust Binary",
            "\n\nIn this post, we explore _cooperative multitasking_ and the _async/await_ feature of Rust.",
            " [Introduction to Paging",
            " [Paging Implementation"
          ]
        },
        {
          "title": "Preface - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/",
          "excerpts": [
            "You'll learn about linkers, linker scripts and about the Rust features that let you control a bit of the ABI of Rust programs. A trick to implement defaultÂ ..."
          ]
        },
        {
          "title": "Choose Your Discovery",
          "url": "https://docs.rust-embedded.org/discovery/",
          "excerpts": [
            "Discover the world of microcontrollers through Rust! There are currently three versions of this book. All of them provide an introduction to microcontrollers."
          ]
        },
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            "\n\nOwnership is Rustâ€™s most unique feature and has deep implications for the rest\nof the language. It enables Rust to make memory safety guarantees without\nneeding a garbage collector, so itâ€™s important to understand how ownership\nworks.",
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "Doing an incremental rewrite from C/C++ to Rust, we had to use a lot of raw pointers and `unsafe{}` blocks.",
            "The rewrite was done incrementally, in a stop-and-go fashion. At some point, as I expected, we had to add brand new features while the rewrite was on-going and that was very smooth with this approach.",
            "All the stringent rules of Rust still apply inside these blocks but the compiler just stops checking them for you, so you are on your own.",
            "As such, it's so easy to introduce Undefined Behavior.",
            "Pure Rust is already very complex, but add to it the whole layer that is mainly there to deal with FFI, and it really becomes a beast.",
            "Some developers in our team straight declined to work on this codebase, mentioning the real or perceived Rust complexity.",
            "Now, I think that Rust is still mostly easier to learn than C++, but admittedly not by much, especially in this FFI heavy context.",
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "The finegrained field value memory_management_keywords.5 is labeled as References. Excerpts that explicitly define what a Reference is and how it functions within memory management are highly relevant. Specifically, passages that describe a _reference_ as an address that can be followed to access data owned by another variable, and that contrasts references with pointers by guaranteeing validity of the value they point to, directly illuminate the concept of References within memory management. Further, excerpts that illustrate how references are used in function definitions and borrowing (e.g., passing a reference to a function, or taking references to data without transferring ownership) reinforce how references participate in Rustâ€™s memory-safety model. These pieces collectively establish the core meaning and implications of References in memory management, making them the most relevant to the field value. Additional excerpts that discuss lifetimes and borrowing provide contextual depth about how references are tracked and validated over time, which also ties into memory management semantics, though they are a step removed from the literal definition of a Reference itself. Overall, there is strong alignment between the field value and these excerpts, supporting a high confidence level.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.6",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)"
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Tree Borrows Explained",
          "url": "https://internals.rust-lang.org/t/tree-borrows-explained/18587",
          "excerpts": [
            "[UCG #381: `&mut impl !Unpin` are not `dereferenceable`](https://github.com/rust-lang/unsafe-code-guidelines/issues/381)"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In Rust, the type system imposes a strict\n\ndiscipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias\n\ninformation for the purpose of program optimizations that reorder memory accesse",
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio",
            "Raw pointers are necessary when interfacing with C code through FFI, and also\n\nwhen implementing low-level pointer-heavy data structures in Rust that internally do not follow\n\nRustâ€™s aliasing disciplin",
            "The sinister part about this cast is that we do it twice! The type system does not stop us, as it\n\ndoes not even attempt to track what happens with raw pointers",
            "What is important is that **unsafe** code is encapsulated within a\n\nsafe abstraction "
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines GitHub Repository",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines",
          "excerpts": [
            "The purpose of this repository is to collect and discuss all sorts of questions that come up when writing unsafe code.",
            "The [Unsafe Code Guidelines Reference \"book\"](https://rust-lang.github.io/unsafe-code-guidelines) is a past effort to systematize a consensus on some of these questions. Most of it has been archived, but the [glossary](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html) is still a useful resource.",
            "The [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/) is a draft document discussing unsafe code. It is intended to\nbe brought into agreement with the content here. It represents an organized\neffort to explain how to write Rust code, rather than a reference."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "Unsafe Code Guidelines Reference",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "No-Panic Rust: A Nice Technique for Systems Programming",
          "url": "https://blog.reverberate.org/2025/02/03/no-panic-rust.html",
          "excerpts": [
            "Feb 3, 2025 â€” Runtime overhead: A potential panic implies some kind of runtime check. ... For example, memory allocation failure will panic in most cases."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate.",
            "\nThis topic was automatically closed 90 days after the last reply. We invite you to open a new topic if you have further questions or comments."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Rust Embedded - awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "In 2018, the Rust community created an embedded working group to help drive adoption in the Rust ecosystem.",
            "Curated list of resources for Embedded and Low-level development in the Rust programming language",
            "The embedded parts use the nRF52840-DK and a LIS3DH breakout board. ( [github source](https://github.com/tweedegolf/rust-workshop) )"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc.",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "The work on this book is coordinated in [this repository](https://github.com/rust-embedded/book) and is mainly\ndeveloped by the [resources team](https://github.com/rust-embedded/wg).",
            "+ Cross Compilation"
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "RFL leverages **bindgen** to automatically generate Rust bindings of C kernel struct prior to use.",
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "Doing an incremental rewrite from C/C++ to Rust, we had to use a lot of raw pointers and `unsafe{}` blocks.",
            "The rewrite was done incrementally, in a stop-and-go fashion. At some point, as I expected, we had to add brand new features while the rewrite was on-going and that was very smooth with this approach.",
            "All the stringent rules of Rust still apply inside these blocks but the compiler just stops checking them for you, so you are on your own.",
            "As such, it's so easy to introduce Undefined Behavior.",
            "Pure Rust is already very complex, but add to it the whole layer that is mainly there to deal with FFI, and it really becomes a beast.",
            "Some developers in our team straight declined to work on this codebase, mentioning the real or perceived Rust complexity.",
            "Now, I think that Rust is still mostly easier to learn than C++, but admittedly not by much, especially in this FFI heavy context.",
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "The target field value is a specific Rust reference type concept, represented by a path memory_management_keywords.6 with the value &T. Excerpts that explicitly discuss references, borrowing, lifetimes, and how they are analyzed or enforced by the compiler are directly relevant. For example, passages that define what a reference is and how borrowing works, including taking a reference to a value without transferring ownership, are foundational to understanding how &T is treated in Rust. Excerpts that illustrate how references are prevented from mutating while there are active borrows, or that show how lifetimes ensure validity of references, provide direct support for the finegrained field. Discussions of two-phase borrows further deepen the understanding of when a reference can be reserved versus activated, which is highly pertinent to a reference type like &T. Additionally, material on lifetime elision rules, and the guarantees that references must point to valid values for their lifetimes, firmly supports the interpretation of &T in Rust's memory model. The closest, most direct connections are: the definitions and uses of references and borrowing, the guaranteed validity of references, and the explicit lifetime mechanics (lifetime elision, generic lifetime rules). The two-phase borrowing discussions expand on how &mut borrows operate with reservations and activations, which also informs how &T interacts in overlap scenarios. Other topics like drop checks, unsafe, and advanced aliasing models provide broader context about memory safety but are secondary to the core &T reference/borrow semantics. Overall, the strongest evidence comes from excerpts that define and exemplify: what a reference is, how borrowing transfers or borrows data without ownership, how lifetimes guarantee validity, and how two-phase borrowing changes the lifecycle of borrows. The confidence in mapping this field value to those excerpts is high when the content clearly ties to references and lifetimes, and medium to high when it also includes adjacent topics like aliasing and UB rules that influence the reference model.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.7",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        }
      ],
      "reasoning": "The finegrained field value is a mutable reference type, represented by &mut T. The most direct and foundational assertion about this concept is that a mutable reference cannot coexist with other references to the same location; this is stated plainly as a core restriction: when you have a mutable reference to a value, you may not have any other references to that value. This directly substantiates the field valueâ€™s emphasis on the mutability and exclusive access semantics of &mut T. Relatedly, there are explicit cautions in the materials that certain aliasing patterns involving &mut are disallowed or require special handling; for example, the text notes that in Rust we know this input should be impossible because &mut cannot be aliased, highlighting the strict aliasing discipline surrounding mutable references. Further, practical discussions illustrate how &mut references interact with aliasing in realistic code samples, including references to scenarios like &mut u32 and the implications for aliasing when sharing or reborrowing, demonstrating concrete implications of the &mut T rule in practice. There are also references to two-phase borrowing concepts, which describe how a mutable borrow can begin in a reserved state and later activate, clarifying how &mut borrows behave in more complex, nested calls. Additional passages show nested method-call contexts where an &mut receiver is involved, reinforcing that &mut usage has to respect exclusivity and activation timing in borrow-checking, which aligns with the fundamental semantics of &mut T. Collectively, these excerpts build a cohesive picture of the behavior and constraints of mutable references in Rust, supporting the finegrained field value that &mut T denotes a mutable reference type with strict aliasing and lifecycle rules.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.16",
      "citations": [
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step."
          ]
        }
      ],
      "reasoning": "The target concept, Lifetime Annotations, centers on how Rust associates lifetimes with references and function/type definitions. Excerpts that explicitly introduce lifetimes, borrowing, and lifetime parameters provide the strongest support for lifetime annotations as a concept. For example, entries that state that a lifetime is a construct used by the compiler to ensure borrows are valid, or that discuss how references are annotated with lifetimes in function parameters or types, directly map to lifetime annotations in Rust syntax and semantics. Several excerpts explain that a reference has a lifetime tied to its validity, or show functions that take references with explicit lifetime parameters, illustrating practical use of annotations. Additional excerpts discuss lifetime elision rules, which are related but distinct: they describe when the compiler can infer lifetimes, reducing the need for explicit annotations, which complements the understanding of when and how you must or may annotate lifetimes. The combination of direct lifetime definitions (as a construct the compiler uses) and concrete examples of lifetimes in function signatures and references builds a coherent view of how lifetime annotations are applied in Rust. Cross-cutting notes on two-phase borrows and elision rules provide broader context on lifetime handling in more advanced borrow-checker scenarios, reinforcing how lifetime annotations interact with borrowing semantics in real code.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.20",
      "citations": [
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        }
      ],
      "reasoning": "The exact field value, Higher-Ranked Trait Bounds (HRTB), corresponds to a specialized concept in Rust trait resolution. The most relevant excerpt explicitly states: higher-ranked trait bounds, which directly aligns with the field value and confirms the term as a named concept within trait resolution. The nearby excerpt discusses related ideasâ€”subtyping and variance in the context of lifetimesâ€”which are thematically connected to how HRTB interacts with lifetimes and trait bounds, but it does not itself name HRTB. Therefore, the first excerpt directly supports the field value by naming and describing the concept, while the second provides supportive context about the broader trait/lifetime bounds landscape without directly asserting HRTB.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.15",
      "citations": [
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":"
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        }
      ],
      "reasoning": "Lifetimes are a central topic in Rust memory safety, used to ensure that references do not outlive the data they point to. The most direct match is an excerpt titled Lifetimes - Rust By Example, which defines lifetimes and frames their role in borrow checking. Closely related are excerpts that explicitly address lifetime elision rules and the formal rules governing lifetimes in function signatures, which are essential for understanding how lifetimes are inferred and applied in real code. Additional excerpts discuss validating references with lifetimes, and the lifetime-related aspects of references and borrowing in the Rust book, which provide practical demonstrations of how lifetimes constrain and enable safe borrows. There is further support from material on subtyping and variance involving lifetimes, which situates lifetimes within Rustâ€™s type and trait system. The more general references and borrowing excerpts corroborate how lifetimes interface with references and memory management, reinforcing their centrality to Rustâ€™s memory safety guarantees. Overall, the strongest support comes from explicit Lifetimes discussions and explicit lifetime elision rules, followed by references/borrowing material that relies on lifetimes conceptually. The collection together supports the field value Lifetimes as a foundational concept in Rust memory management and borrowing semantics.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.13",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required."
          ]
        }
      ],
      "reasoning": "Reborrowing is most directly described where two-phase borrows are introduced as a concept: borrows begin in a reserved (shared) state and can later be activated into a mutable borrow, with reads allowed during the reservation phase and mutation disallowed until activation. Phrases such as \"Two-phase borrows are treated as if they were mutable borrows with the following exceptions\" and the description of the reservation/activation flow anchor the idea of reborrowing as a staged borrow that can be used before it is fully mutable. Concrete examples illustrate reborrowing in practice: a mutable borrow created and then a shared borrow from it is used before activation, and notes about reserving a path and then using it later in a function call show how a reborrowed reference participates in subsequent operations. In particular, explanations that a shared borrow can start, and then the mutable borrow is activated later (revealing the core concept of reborrowed references sharing/transitioning states) directly tie to the mechanism behind reborrowing. Additional examples discuss creating a borrow, then performing another operation that relies on that borrow (e.g., peeking at a length or using a borrowed path during a function call) before the mutable borrow is activated, which is a classic pattern of reborrowing in Rust. The nested-method-calls material elaborates how a mutable borrow can be reserved, and a shared borrow can overlap with it during the reservation phase before activation, which is another concrete instantiation of reborrowing behavior. Taken together, the explicit definitions and practical examples describe the core behavior of reborrowing: a borrow that is staged as reserved/shared, later activated into a mutable borrow, and allowed to exist concurrently with other borrows during the reservation, enabling patterns used in method calls and function arguments.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.21",
      "citations": [
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt directly references the precise syntax in question: for<'a> is presented as an example of a higher-ranked trait bound, showing that Rust supports lifetime parameters that are bound across the lifetime of a generic type parameter. This provides a concrete, explicit occurrence of the exact token in use within HRBT contexts. Closely following, excerpts that discuss higher-ranked lifetimes illustrate the broader concept that for<'a> introduces a bound over a lifetime that can be used in trait bounds, which aligns directly with the requested fine-grained field value. Additional excerpts on lifetimes and lifetime elision provide necessary context: they explain how lifetimes are named, how they appear in inputs and outputs, and how Rust infers or elides them in function signatures. These pieces help establish the surrounding rules and conventions around the lifetime annotations, including the distinction between input and output lifetimes and when lifetimes must be explicitly stated. The excerpts about lifetime elision rules show the practical implications of when lifetimes can be omitted, which is useful background when considering HRBT syntax, though they are somewhat less directly about for<'a> than the HRBT-specific items. Finally, excerpts that discuss general lifetime concepts and references (without explicit HRBT syntax) provide broader grounding on how lifetimes work in Rust, supporting the interpretation that for<'a> is part of Rustâ€™s lifetime system, which is the core of the field in question.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.18",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":"
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference."
          ]
        }
      ],
      "reasoning": "Non-Lexical Lifetimes is a concept in Rustâ€™s borrow checker that primarily concerns how lifetimes are inferred and enforced to allow more flexible borrowing. Excerpts detailing two-phase borrows introduce a related enhancement to when borrows are reserved versus activated, which aligns with how NLL relaxes certain lifetime constraints. Thus, the discussion of two-phase borrows directly informs the practical behavior NLL aims to enable. Following that, general lifetime concepts and rules (such as the Lifetimes section and lifetime elision rules) establish the foundation for understanding how lifetimes are inferred and scoped in Rust, which is the broader backdrop against which NLL operates. Further, references and borrowing basics lay the groundwork for understanding why lifetimes matter in Rust and how they interact with ownership. The most relevant parts therefore include explicit two-phase borrow discussions, general lifetime concepts, and then the foundational reference/borrowing material that underpins the NLL idea.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.26",
      "citations": [
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        }
      ],
      "reasoning": "The field value 'Subtyping' corresponds to the Rust concept of how types relate to one another beyond exact equality, particularly in relation to lifetimes and variance. The most directly relevant excerpt explicitly titled 'Subtyping and Variance - The Rust Reference' presents subtyping as a distinct concept and situates it alongside variance, indicating its role in how types (and lifetimes) relate in the Rust type system. This aligns with memory-management discussions where variance affects how references and lifetimes can be substituted or related, impacting safety and memory access guarantees. The excerpt demonstrates that subtyping is a deliberate, formal concept within Rust's memory-related type rules, making it the strongest, most direct support for the requested field value. Other excerpts discuss related topics (aliases, references, lifetimes, borrowed content, or general memory-safety) but do not directly address subtyping, so they are less relevant to this specific finegrained field.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.19",
      "citations": [
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":"
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        }
      ],
      "reasoning": "The core fine-grained field value corresponds to the rules that govern when and how lifetime elision applies in Rust. Several excerpts directly address these rules: they explicitly state that lifetime positions can be inputs or outputs, and describe how input lifetimes map to output lifetimes, including cases with a single input lifetime where the output lifetime is inferred to be the same as the input, or cases with multiple inputs where special handling applies (for example, using &self or &mut self). Additional excerpts detail that elided lifetimes are inferred by the compiler according to a fixed set of rules, and specify when and how lifetimes can be elided in function item, function pointer, and closure signatures. Several excerpts also discuss the general Elision rules and provide concrete statements such as which inputs become distinct lifetimes and how outputs receive lifetimes when elided. Together, these excerpts provide a cohesive picture of the Lifetime Elision Rules: there are distinct rules for single versus multiple input lifetimes, interaction with self-references, and the general guidance for how the compiler infers lifetimes when they are elided. The included references also reinforce that these rules are documented consistently across the Rust Reference and Rustonomicon sources, further validating the direct relevance of these excerpts to the requested field value.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.14",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        }
      ],
      "reasoning": "Two-phase borrows are described as a more permissive version of mutable borrows that enable patterns like nested method calls, where a mutable borrow can be reserved first and activated later. This directly supports the field value by defining the core model: a borrow starts in a reserved/shared state and becomes fully mutable only upon activation, enabling certain reads during the reservation phase. The tracking of two-phase borrows is explicitly noted as being governed by a flag that determines whether a borrow can be two-phase, illustrating how the system enforces and communicates this behavior. Additional excerpts provide concrete illustrations and examples of the two-phase process in practice, such as how a mutable borrow can be reserved, how shared borrows can overlap during the reservation, and how activation occurs at the point of use. Together, these excerpts establish the two-phase borrow concept, its operational rules (reservation vs activation), and its implications for aliasing and memory access, which are exactly the aspects encoded by the finegrained field value. ",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.17",
      "citations": [
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "Elision rules are as follows:"
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid.",
            "Lifetimes - Rust By Example"
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i",
            "It is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled *sound*; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is *unsound*.",
            "unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is _unsound_",
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.",
            "The bytes owned by an immutable binding or immutable `static` are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html).",
            "Moreover, the bytes [pointed to]() by a shared reference, including transitively through other references (both shared and mutable) and `Box`es, are immutable; transitivity includes those references stored in fields of compound types.",
            "* Producing an [invalid value](). â€œProducingâ€ a\n  value happens any time a value is assigned to or read from a place, passed to\n  a function/primitive operation or returned from a function/primitive\n  oper",
            "The Rust compiler assumes that all values produced during program execution are\nâ€œvalidâ€, and producing an invalid value is hence immediate UB.",
            "* A `fn` pointer value must be non-null.",
            "* A `char` value must not be a surrogate (i.e., must not be in the range `0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`.",
            "* A `!` value must never exist.",
            "* An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be\n  initialized, i.e., must not be obtained from uninitialized memor",
            "* A `str` value is treated like `[u8]`, i.e. it must be initialized.",
            "* An `enum` must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.",
            "* A `struct`, tuple, and array requires all fields/elements to be valid at their respective type.",
            "* For a `union`, the exact validity requirements are not decided yet.",
            "* A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned and non-null, it cannot be [dangling](), and it must point to a valid value",
            "* The metadata of a wide reference, [`Box<T>`](../alloc/boxed/struct.Box.html), or raw pointer must match\n  the type of the unsized tai",
            "* If a type has a custom range of a valid values, then a valid value must be in that range.",
            "**Note:** Uninitialized memory is also implicitly invalid for any type that has\na restricted set of valid values. In other words, the only cases in which\nreading uninitialized memory is permitted are inside `union`s and in â€œpaddingâ€\n(the gaps between the fields of a type).",
            "Data races."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "pe in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)",
            " A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.",
            "Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.",
            "\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.",
            "Undefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program.",
            "However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
            "\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support",
            "* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple)",
            "      + a `bool` that isn't 0 or 1",
            "      + an `enum` with an invalid discriminant",
            "      + a null `fn` pointer",
            "      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]",
            "      + a `!` (all values are invalid for this type)",
            "      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` .",
            "      + a reference/ `Box` that is dangling, unaligned, or points to an invalid value.",
            "      + a wide reference, `Box` , or raw pointer that has invalid metadata:",
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)",
            "      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null.",
            "For a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) ."
          ]
        },
        {
          "title": "Working with Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat.",
            "We say that such a correct\nunsafely implemented function is _sound_ , meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).",
            "This program is now _unsound_ , Safe Rust can cause Undefined Behavior, and yet _we only modified safe code_ . This is the fundamental problem of safety: it's\nnon-local.",
            "The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.",
            "Safety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness.",
            "However\nsafety _isn't_ modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.",
            "It is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is _critical_ to the relationship between\nSafe Rust and Unsafe Rust.",
            "We have already seen that Unsafe code must trust _some_ Safe code, but shouldn't\ntrust _generic_ Safe code.",
            "Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state."
          ]
        },
        {
          "title": "Tree Borrows Explained",
          "url": "https://internals.rust-lang.org/t/tree-borrows-explained/18587",
          "excerpts": [
            "Since the `Freeze` and `Unpin` properties are not checked granularly, they are applied identically to out-of-range locations. That's a very debatable aspect of the model, but for now it's in line with TB being \"maximally permissive\" and can totally be changed if deemed problematic.",
            "[Vanille-N](https://internals.rust-lang.org/u/Vanille-N) March 29, 2023, 7:18am 10",
            "Interesting observation: because `&mut` borrows start as the two-phase reserved stated, `&mut` borrow splitting just falls out of the model without any special handling, even if it were to keep fully eager instead of delayed tag reborrowing. This is evident from the walkthrough of the disjoint fields example.",
            "[UCG #381: `&mut impl !Unpin` are not `dereferenceable`](https://github.com/rust-lang/unsafe-code-guidelines/issues/381)"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "First off, let's get some important caveats out of the way:\n\n* \n  We will be using the broadest possible definition of aliasing for the sake\n  of discussion. Rust's definition will probably be more restricted to factor\n  in mutations and liveness. * \n  We will be assuming a single-threaded, interrupt-free, execution. We will also\n  be ignoring things like memory-mapped hardware. Rust assumes these things\n  don't happen unless you tell it otherwise. For more details, see the [Concurrency Chapter](concurrency.html) . With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memory",
            "So why should we care about aliasing? Consider this simple function:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nfn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that \\`output\\` will be \\`2\\` if \\`input > 10\\`\n}\n}\n`",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model for Rust",
            "In Rust, the type system imposes a strict\n\ndiscipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias\n\ninformation for the purpose of program optimizations that reorder memory accesse",
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio",
            "Raw pointers are necessary when interfacing with C code through FFI, and also\n\nwhen implementing low-level pointer-heavy data structures in Rust that internally do not follow\n\nRustâ€™s aliasing disciplin",
            "The sinister part about this cast is that we do it twice! The type system does not stop us, as it\n\ndoes not even attempt to track what happens with raw pointers",
            "What is important is that **unsafe** code is encapsulated within a\n\nsafe abstraction ",
            "The Rust ecosystem rests on the interplay of safe code where possible and **unsafe** code\n\nwhere needed, and hence any realistic consideration of compilation for Rust programs requires\n\nproper treatment of **unsafe** cod",
            "More precisely, we will define the operational semantics in\n\nsuch a way that our example program has undefined behavior , which means the compiler is allowed\n\nto compile it in any way it choose",
            "Compared to\n\nRustBeltâ€™s semantics, we have to Å‚addÅ¾ some undefined behavior to obtain the desired optimizations",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin",
            "Raw pointers. Sometimes, the aliasing discipline for references that the borrow checker enforces\n\nis too strict",
            "In this case, one option is to not use references but instead\n\nemploy raw pointers . Raw pointers in Rust basically act like pointers in C: they are not checked by\n\nthe compiler, and there are no aliasing restriction",
            "In line 2, we cast a reference to raw pointer type.",
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        },
        {
          "title": "std::mem::MaybeUninit - Rust",
          "url": "https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html",
          "excerpts": [
            "Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an `UnsafeCell<T>` ).",
            "Ok ( unsafe { buffer.assume_init() })",
            "(mutable) reference to uninitialized memory! // This is undefined behavi",
            "let mut foo = MaybeUninit::<Foo>::uninit();",
            "ptr::write( &mut foo.assume_init_mut().a as *mut u32, 1337 );",
            "(mutable) reference to uninitialized memory! // This is undefined behavior."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "## [Rust's Unsafe Code Guidelines Reference]()",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Since last fall, [Neven](https://perso.crans.org/vanille/) has been doing an internship to develop a new aliasing model for Rust: Tree Borrows. Hang on a second, I hear you say â€“ doesnâ€™t Rust already have an aliasing model? Isnâ€™t there this â€œStacked Borrowsâ€ that Ralf keeps talking about? Indeed there is, but Stacked Borrows is just one proposal for a possible aliasing model â€“ and it [has](https://github.com/rust-lang/unsafe-code-guidelines/issues/133) [its](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) [fair](https://github.com/rust-lang/unsafe-code-guidelines/issues/256) [share](https://github.com/rust-lang/unsafe-code-guidelines/issues/274) [of](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) [problems](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) .",
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines GitHub Repository",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines",
          "excerpts": [
            "The purpose of this repository is to collect and discuss all sorts of questions that come up when writing unsafe code.",
            "The [Unsafe Code Guidelines Reference \"book\"](https://rust-lang.github.io/unsafe-code-guidelines) is a past effort to systematize a consensus on some of these questions. Most of it has been archived, but the [glossary](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html) is still a useful resource.",
            "The [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/) is a draft document discussing unsafe code. It is intended to\nbe brought into agreement with the content here. It represents an organized\neffort to explain how to write Rust code, rather than a reference."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "Unsafe Code Guidelines Reference",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "No-Panic Rust: A Nice Technique for Systems Programming",
          "url": "https://blog.reverberate.org/2025/02/03/no-panic-rust.html",
          "excerpts": [
            "Feb 3, 2025 â€” Runtime overhead: A potential panic implies some kind of runtime check. ... For example, memory allocation failure will panic in most cases."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate.",
            "\nThis topic was automatically closed 90 days after the last reply. We invite you to open a new topic if you have further questions or comments."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Rust Embedded - awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "In 2018, the Rust community created an embedded working group to help drive adoption in the Rust ecosystem.",
            "Curated list of resources for Embedded and Low-level development in the Rust programming language",
            "The embedded parts use the nRF52840-DK and a LIS3DH breakout board. ( [github source](https://github.com/tweedegolf/rust-workshop) )"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc.",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "The work on this book is coordinated in [this repository](https://github.com/rust-embedded/book) and is mainly\ndeveloped by the [resources team](https://github.com/rust-embedded/wg).",
            "+ Cross Compilation"
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "RFL leverages **bindgen** to automatically generate Rust bindings of C kernel struct prior to use.",
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "no_std - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "[The Discovery book](https://docs.rust-embedded.org/discovery/index.html) will teach you about microcontrollers,\nperipherals, sensors and bare metal programming through a series of small, fun\nprojects that youâ€™ll develop in Rust.",
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software.",
            "ed/awesome-embedded-rust) resource includes a list of other books, blogs, and\ntraining materials for learning embedded Rust, including complete from-scratch\nproject examples and quickstart templates: [Books, blogs and training materials"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "Panicking is a core part of the Rust language. Built-in operations like indexing\nare runtime checked for memory safety. When out of bounds indexing is attempted\nthis results in a panic. In the standard library panicking has a defined behavior: it unwinds the stack\nof the panicking thread, unless the user opted for aborting the program on\npanics. In programs without standard library, however, the panicking behavior is left\nundefined. A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the panic. Given that embedded systems range from user facing to safety critical (cannot\ncrash) there's no one size fits all panicking behavior but there are plenty of\ncommonly used behaviors. These common behaviors have been packaged into crates\nthat define the `#[panic_handler]` function."
          ]
        },
        {
          "title": "The Redox Operating System",
          "url": "http://doc.redox-os.org/book",
          "excerpts": [
            "Redox OS is a general-purpose operating system written in [Rust](https://www.rust-lang.org) . Our aim is to provide a fully functioning Unix-like microkernel-based operating system, that is secure, reliable and free.",
            "Redox OS was created in 2015 before the first stable version (1.0) of the Rust compiler and was one of the first operating systems written in Rust.",
            "To achieve that, Redox was redesigned to adopt a microkernel architecture and a unified system API for resources.",
            "This book is written in a way that you doesn't require any prior knowledge of Rust or OS development."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "http://os.phil-opp.com/",
          "excerpts": [
            "\n\nThis blog series creates a small operating system in the [Rust programming language](https://www.rust-lang.org/) . Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding [Github repository](https://github.com/phil-opp/blog_os) .",
            "\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the [bare metal](https://en.wikipedia.org/wiki/Bare_machine) without an underlying operating system.",
            " [A Freestanding Rust Binary",
            "\n\nIn this post, we explore _cooperative multitasking_ and the _async/await_ feature of Rust.",
            " [Introduction to Paging",
            " [Paging Implementation"
          ]
        },
        {
          "title": "Preface - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/",
          "excerpts": [
            "You'll learn about linkers, linker scripts and about the Rust features that let you control a bit of the ABI of Rust programs. A trick to implement defaultÂ ..."
          ]
        },
        {
          "title": "Choose Your Discovery",
          "url": "https://docs.rust-embedded.org/discovery/",
          "excerpts": [
            "Discover the world of microcontrollers through Rust! There are currently three versions of this book. All of them provide an introduction to microcontrollers."
          ]
        },
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            "\n\nOwnership is Rustâ€™s most unique feature and has deep implications for the rest\nof the language. It enables Rust to make memory safety guarantees without\nneeding a garbage collector, so itâ€™s important to understand how ownership\nworks.",
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "Doing an incremental rewrite from C/C++ to Rust, we had to use a lot of raw pointers and `unsafe{}` blocks.",
            "The rewrite was done incrementally, in a stop-and-go fashion. At some point, as I expected, we had to add brand new features while the rewrite was on-going and that was very smooth with this approach.",
            "All the stringent rules of Rust still apply inside these blocks but the compiler just stops checking them for you, so you are on your own.",
            "As such, it's so easy to introduce Undefined Behavior.",
            "Pure Rust is already very complex, but add to it the whole layer that is mainly there to deal with FFI, and it really becomes a beast.",
            "Some developers in our team straight declined to work on this codebase, mentioning the real or perceived Rust complexity.",
            "Now, I think that Rust is still mostly easier to learn than C++, but admittedly not by much, especially in this FFI heavy context.",
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "The field value appears to be a lifetime annotation 'a, which in Rust is tied to the concept of lifetimes discussed across several excerpts. The strongest direct connections come from excerpts that define lifetimes and explain how they are determined or elided in function signatures and type references. For example, explicitly labeled lifetime elision and lifetime rules provide concrete guidance on how lifetimes are inferred or inserted by the compiler, which is precisely what a standalone lifetime annotation like 'a relies on. These sources describe the basic idea that lifetimes annotate how long a reference is valid, and how the compiler tracks validity to ensure safety. The accompanying material on references and borrowing further clarifies how lifetimes interact with borrows and the ownership model, offering context that helps interpret how a specific lifetime like 'a would constrain references in practical code. Additional excerpts discussing two-phase borrows and advanced lifetime topics extend the understanding to more complex scenarios where lifetimes intersect with borrowing, mutation, and function calls, thereby reinforcing how 'a would function within Rust's safety guarantees. Overall, the core support for the field value is provided by the lifetimes-focused definitions and elision rules, with borrowing and reference material offering essential supporting context.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.11",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i"
          ]
        }
      ],
      "reasoning": "Mutable borrows are a core concept in Rustâ€™s memory management and borrowing rules. Excerpts that state a key restrictionâ€”namely that when you have a mutable reference to a value you cannot simultaneously have any other references to that valueâ€”directly support the target field. The discussion surrounding references and borrowing lays the groundwork for understanding what a mutable borrow entails and how it interacts with ownership and aliasing. Examples showing taking a reference to a value and passing it to a function illustrate how borrowing works in practice and emphasize that mutable and immutable borrows have different guarantees and constraints. The material describing two-phase borrows expands on how mutable borrows can be reserved first (shared-like behavior) and later activated (actual mutation), which is central to the nuanced concept of mutable borrows in modern Rust. The nested two-phase borrowing discussions provide deeper context on how mutability interacts with reservation and activation points during method calls, further clarifying the operational semantics of mutable borrows in practical code. The collection also includes lifetime and elision context to explain how lifetimes constrain borrows, reinforcing that mutable borrows live within certain scopes and cannot outlive their referents. Pulling together these points: - A mutable reference cannot be co-owned by other references while live, to prevent aliasing violations; - The borrow checker enforces this via static checks; - More advanced models (two-phase borrows) introduce a reserved phase for mutable borrows and a later activation phase when mutation occurs, which preserves safety while enabling certain patterns; - Lifetimes and elision rules bound how long borrows are valid. In essence, the excerpts collectively establish the definition, the primary restriction, practical usage patterns, and advanced borrowing semantics (two-phase) that underpin the concept of Mutable Borrows. The most direct support comes from explicit statements of the restriction on mutable references and the behavior of mutable borrows in two-phase scenarios, with supporting illustrations in function examples and lifecycle discussions.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.24",
      "citations": [
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        }
      ],
      "reasoning": "The field value refers to a variance concept, specifically contravariance as it relates to type and lifetime relationships in Rust. The most relevant excerpt directly addresses variance in the Rust type system, including how subtyping interacts with variance. It provides the core basis for understanding contravariant behavior in Rustâ€™s type relationships. Surrounding context from lifetime-focused excerpts helps explain how lifetimes influence variance in function signatures and generic constraints, even if they do not explicitly name contravariance. Together, these excerpts support understanding of how contravariance operates within Rustâ€™s subtyping and lifetime rules, which is aligned with the target fine-grained field value.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.27",
      "citations": [
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "So why should we care about aliasing? Consider this simple function:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nfn compute(input: &u32, output: &mut u32) {\n    if *input > 10 {\n        *output = 1;\n    }\n    if *input > 5 {\n        *output *= 2;\n    }\n    // remember that \\`output\\` will be \\`2\\` if \\`input > 10\\`\n}\n}\n`",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpts are those that define and discuss aliasing in Rust. One excerpt defines aliasing in Rust as referring to overlapping memory regions, which directly matches the field value 'Aliasing'. This piece also states that certain aliasing patterns must be avoided to preserve correctness, which is central to the concept of aliasing. Related excerpts show that aliasing analysis is used by the compiler to optimize or reorder memory accesses, which reinforces that aliasing is a core memory-management concern in Rust. Additional excerpts illustrate concrete aliasing rules, such as the prohibition on aliasing mutable references, which is a direct support for the idea of aliasing discipline in Rustâ€™s memory model. Beyond this, excerpts discuss more elaborate aliasing models like Stacked Borrows and Tree Borrows, which expand on how aliasing is managed at runtime and in the presence ofUnsafe code. Quoting the most relevant content from these excerpts helps anchor the fine-grained field value to Rustâ€™s memory-management vocabulary and safety guarantees. The supporting excerpts provide context about why aliasing matters (e.g., optimizing reads/writes and ensuring correctness when &mut cannot be aliased), which strengthens the field valueâ€™s placement within Rustâ€™s memory-management discourse. The less direct excerpts still support the concept by showing how aliasing interacts with borrowing, lifetimes, and unsafe code, which are all tied to how aliasing is controlled in Rust. Overall, the most relevant content directly defines aliasing, shows when aliasing is disallowed (notably for &mut), or demonstrates explicit aliasing models, followed by more illustrative discussions of aliasing in practice and in advanced models. ",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.25",
      "citations": [
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin"
          ]
        },
        {
          "title": "std::mem::MaybeUninit - Rust",
          "url": "https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html",
          "excerpts": [
            "Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an `UnsafeCell<T>` )."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
            "\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support",
            "      + a `bool` that isn't 0 or 1",
            "      + an `enum` with an invalid discriminant"
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD."
          ]
        }
      ],
      "reasoning": "The invariant expressed as !T (not T) typically maps to a memory safety constraint: certain operations must not obtain a valid value of T, or a location must not be considered containing a valid T under some conditions. Excerpts that define or rely on an aliasing discipline and undefined behavior when it is violated provide direct support for what must not occur if the invariant is to hold. For instance, discussions outlining that two mutable references cannot alias the same memory location and that violating aliasing rules yields undefined behavior establish a hard boundary around when a value of type T can be safely assumed to exist or be mutated. Such content emphasizes that certain states (e.g., intersecting mutable aliases or simultaneous mutable/immutable borrows) must not occur if we want the memory model to preserve soundness, which aligns with enforcing an invariant that forbids certain appearances of T in unsafe contexts. Similarly, the notion that stacked borrows impose an aliasing discipline and declare programs violating it as UB reinforces that certain configurations of references and memory should never be treated as valid; this directly informs what must remain false for the invariant to hold. In addition, concrete UB examples tied to uninitialized memory (as with MaybeUninit) and to unsafe code (e.g., dangling, aliased mutable references, or violating pointer aliasing rules) provide explicit failure modes that the invariant should preclude. The two-phase borrow discussions further illustrate that there are reserved vs. active phases of borrows, where during the reserved phase some operations are prohibited, ensuring memory safety boundaries are respected. The excerpt about UB being triggered by aliasing violations and the need for correct handling of UnsafeCell in variants of the TB/SB models underscores the necessity of preserving invariant conditions across both safe and unsafe code paths. Taken together, these excerpts directly support the idea that certain memory configurations (involving T) must not occur or must be guarded, which aligns with an invariant of the form not containing/validating a value of T in certain scenarios. The connections are that the modelâ€™s safety guarantees rely on forbidding aliasing, faulty initialization, and UB, which match the intended invariant signaled by the field value.",
      "confidence": "medium"
    },
    {
      "field": "systems_and_embedded_dev_keywords",
      "citations": [
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc."
          ]
        },
        {
          "title": "no_std - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software."
          ]
        },
        {
          "title": "embedded-hal - crates.io",
          "url": "https://crates.io/crates/embedded-hal",
          "excerpts": [
            "embedded-hal v1.0.0\n\nA Hardware Abstraction Layer (HAL) for embedded systems",
            "* [No standard library](/categories/no-std)",
            "You can find platform-agnostic drivers built on top of `embedded-hal` on crates.io by [searching\nfor the _embedded-hal_ keyword](https://crates.io/keywords/embedded-hal) . If you are writing a platform-agnostic driver yourself you are highly encouraged to [add the\nembedded-hal keyword](https://doc.rust-lang.org/cargo/reference/manifest.html) to your crate before publishing it!"
          ]
        },
        {
          "title": "rust-embedded/embedded-hal",
          "url": "https://github.com/rust-embedded/embedded-hal",
          "excerpts": [
            "`embedded-hal` serves as a foundation for building an ecosystem of platform-agnostic drivers. (driver meaning library crates that let a target platform interface an external device like a digital\nsensor or a wireless transceiver). The advantage of this system is that by writing the driver as a generic library on top\nof `embedded-hal` driver authors can support any number of target\nplatforms (e.g. Cortex-M microcontrollers, AVR microcontrollers, embedded Linux, etc.).",
            "A Hardware Abstraction Layer (HAL) for embedded systems",
            "The main `embedded-hal` project is not tied to a specific execution model like blocking or non-blocking.",
            "This crate is guaranteed to compile on stable Rust 1.81 and up. It _might_ compile with older versions but that may change in any new patch release."
          ]
        },
        {
          "title": "embedded_hal - Rust Embedded HAL",
          "url": "https://docs.rs/embedded-hal",
          "excerpts": [
            "embedded-hal-1.0.0",
            "embedded-hal-async : async/await-based. embedded-hal-nb : polling-based ... The embedded-hal-bus crate provides utilities for sharing SPI and I2C buses.",
            "The main `embedded-hal` crate contains only blocking traits, where the operation is done\nsynchronously before returning.",
            "Companion crates",
            "Platform agnostic drivers"
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "Panicking is a core part of the Rust language. Built-in operations like indexing\nare runtime checked for memory safety. When out of bounds indexing is attempted\nthis results in a panic. In the standard library panicking has a defined behavior: it unwinds the stack\nof the panicking thread, unless the user opted for aborting the program on\npanics. In programs without standard library, however, the panicking behavior is left\nundefined. A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the panic. Given that embedded systems range from user facing to safety critical (cannot\ncrash) there's no one size fits all panicking behavior but there are plenty of\ncommonly used behaviors. These common behaviors have been packaged into crates\nthat define the `#[panic_handler]` function."
          ]
        },
        {
          "title": "The Rustonomicon - Unwinding",
          "url": "https://doc.rust-lang.org/nomicon/unwinding.html",
          "excerpts": [
            "Rust has a _tiered_ error-handling scheme:\n\n* If something might reasonably be absent, Option is used. * If something goes wrong and can reasonably be handled, Result is used. * If something goes wrong and cannot reasonably be handled, the thread panics. * If something catastrophic happens, the program aborts. Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion."
          ]
        },
        {
          "title": "Cargo profile panic settings",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "panic = 'unwind'",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic.",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic. When set to\n\"unwind\" , the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses\n\"abort\" . Tests, benchmarks, build scripts, and proc macros ignore the\npanic setting. The\nrustc test harness currently requires\nunwind behavior. See the\npanic-abort-tests unstable flag which enables\nabort behavior. Additionally, when using the\nabort strategy and building a test, all of the\ndependencies will also be forced to build with the\nunwind strategy. incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times",
            "The default settings for the\nrelease profile are:\n[profile.release] opt-level = 3 debug = false split-debuginfo = '...' # Platform-specific. strip = \"none\" debug-assertions = false overflow-checks = false lto = false panic = 'unwind' incremental = false codegen-units = 16 rpath = false"
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "oml\n[profile.release]\npanic = 'abort'\n```"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ...",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "This mutex will block threads waiting for the lock to become available",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "use std::sync::{Arc, Mutex};",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    "
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "One of the most basic primitives for concurrency in Rust is threads. A thread is an independent path of execution within a program that can run concurrently with other threads."
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            "`Mutex`\nA mutual exclusion primitive useful for protecting shared data\n",
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n",
            "A type of error which can be returned whenever a lock is acquired.\n",
            "`RwLock`\nA reader-writer lock\n",
            " structure used to release the shared read access of a lock when\n    dropped.\n",
            "Structs"
          ]
        },
        {
          "title": "Rust fence and memory ordering (std::sync::atomic)",
          "url": "https://doc.rust-lang.org/std/sync/atomic/fn.fence.html",
          "excerpts": [
            "```\nuse std::sync::atomic::AtomicBool;\nuse std::sync::atomic::fence;\nuse std::sync::atomic::Ordering;\n\n// A mutual exclusion primitive based on spinlock. pub struct Mutex {\n    flag: AtomicBool,\n}\n\nimpl Mutex {\n    pub fn new() -> Mutex {\n        Mutex {\n            flag: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&self) {\n        // Wait until the old value is `false`."
          ]
        },
        {
          "title": "parking_lot Crate Documentation",
          "url": "https://crates.io/crates/parking_lot/",
          "excerpts": [
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads",
            "The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "The primitives provided by this library have several advantages over those\nin the Rust standard library:"
          ]
        },
        {
          "title": "parking_lot GitHub Repository",
          "url": "http://github.com/Amanieu/parking_lot",
          "excerpts": [
            "Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives.",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking. It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads. The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "Features\n--------\n\nThe primitives provided by this library have several advantages over those\nin the Rust standard library:\n\n1. `Mutex` and `Once` only require 1 byte of storage space, while `Condvar`\n   and `RwLock` only require 1 word of storage space. On the other hand on\n   some platforms (macOS and a few others) the standard library primitives\n   require a dynamically allocated `Box` to hold OS-specific synchronization\n   primitives. The small size of `Mutex` in particular encourages the use\n   of fine-grained locks to increase parallelism.\n2. Uncontended lock acquisition and release is done through fast inline\n   paths which only require a single atomic operation.\n3. Microcontention (a contended lock with a short critical section) is\n   efficiently handled by spinning a few times while trying to acquire a\n   lock.\n4. The locks are adaptive and will suspend a thread after a few failed spin\n   attempts. This makes the locks suitable for both long and short critical\n   sections.\n5. `Condvar`, `RwLock` and `Once` work on Windows XP, unlike the standard\n   library versions of those types.\n6. `RwLock` takes advantage of hardware lock elision on processors that\n   support it, which can lead to huge performance wins with many readers.\n   This must be enabled with the `hardware-lock-elision` feature.\n7. `RwLock` uses a task-fair locking policy, which avoids reader and writer\n   starvation, whereas the standard library version makes no guarantees.\n8. `Condvar` is guaranteed not to produce spurious wakeups. A thread will\n   only be woken up if it timed out or it was woken up by a notification.\n9. `Condvar::notify_all` will only wake up a single thread and requeue the\n   rest to wait on the associated `Mutex`. This avoids a thundering herd\n   problem where all threads try to acquire the lock at the same time.\n10. `RwLock` supports atomically downgrading a write lock into a read lock.\n11. `Mutex` and `RwLock` allow raw unlocking without a RAII guard object.\n12. `Mutex<()>` and `RwLock<()>` allow raw locking without a RAII guard\n    object.\n13. `Mutex` and `RwLock` support [eventual fairness](https://trac.webkit.org/changeset/203350)\n    which allows them to be fair on average without sacrificing performance.\n14. A `ReentrantMutex` type which supports recursive locking.\n15. An *experimental* deadlock detector that works for `Mutex`,\n    `RwLock` and `ReentrantMutex`. This feature is disabled by default and\n    can be enabled via the `deadlock_detection` feature.\n16. `RwLock` supports atomically upgrading an \"upgradable\" read lock into a\n    write lock.\n17. Optional support for [serde](https://docs.serde.rs/serde/). Enable via the\n    feature `serde`. **NOTE!** this support is for `Mutex`, `ReentrantMutex`,\n    and `RwLock` only; `Condvar` and `Once` are not currently supported.\n18. Lock guards can be sent to other threads when the `send_guard` feature is\n    enabled.\n\nThe parking lot\n---------------\n\nTo keep these primitives small, all thread queuing and suspending\nfunctionality is offloaded to the *parking lot*. The idea behind this is\nbased on the Webkit [`WTF::ParkingLot`](https://webkit.org/blog/6161/locking-in-webkit/)\nclass, which essentially consists of a hash table mapping of lock addresses\nto queues of parked (sleeping) threads. The Webkit parking lot was itself\ninspired by Linux [futexes](https://man7.org/linux/man-pages/man2/futex.2.html),\nbut it is more powerful since it allows invoking callbacks while holding a queue\nlock.",
            "To enable nightly-only features, add this to your `Cargo.toml` instead:\n\n```\n[dependencies]\nparking_lot = { version = \"0.12\", features = [\"nightly\"] }\n```\n\nThe experimental deadlock detector can be enabled with the\n`deadlock_detection` Cargo feature.\n\nTo allow sending `MutexGuard`s and `RwLock*Guard`s to other threads, enable the\n`send_guard` option.\n\nNote that the `deadlock_detection` and `send_guard` features are incompatible\nand cannot be used together.\n\nHardware lock elision support for x86 can be enabled with the\n`hardware-lock-elision` feature. This requires Rust 1.59 due to the use of\ninline assembly.\n\nThe core parking lot API is provided by the `parking_lot_core` crate. It is\nseparate from the synchronization primitives in the `parking_lot` crate so that\nchanges to the core API do not cause breaking changes for users of `parking_lot`."
          ]
        },
        {
          "title": "Real-Time Interrupt-driven Concurrency (RTIC) Documentation",
          "url": "http://rtic.rs/1/book/en",
          "excerpts": [
            "Real-Time Interrupt-driven Concurrency",
            "A concurrency framework for building real-time systems",
            "RTIC is a hardware accelerated\nRTOS that utilizes the NVIC in Cortex-M MCUs to perform scheduling, rather than the more\nclassical software kernel.",
            "Preface - Real-Time Interrupt-driven Concurrency",
            "This book contains user level documentation for the Real-Time Interrupt-driven Concurrency\n(RTIC) framework.",
            "RTIC 1.0.0 already uses `cortex-m` 0.7 by default.",
            "*All Cortex-M devices are fully supported",
            "Documentation for the [development versio",
            "The API reference",
            "This crate is based on the [Real-Time For the Masses languag"
          ]
        },
        {
          "title": "cortex-m-rtic - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cortex-m-rtic",
          "excerpts": [
            "cortex-m-rtic v1.1.4 Real-Time Interrupt-driven Concurrency (RTIC): a concurrency framework for building real-time systems."
          ]
        },
        {
          "title": "rtic - Rust",
          "url": "https://docs.rs/cortex-m-rtic",
          "excerpts": [
            "Real-Time Interrupt-driven Concurrency (RTIC) framework for ARM Cortex-M microcontrollers. IMPORTANT: This crate is published as cortex-m-rtic on crates.io."
          ]
        },
        {
          "title": "RTIC",
          "url": "https://rtic.rs/",
          "excerpts": [
            "Page Redirection If you are not redirected automatically, follow this [link](2) ."
          ]
        },
        {
          "title": "Embassy",
          "url": "https://embassy.dev/",
          "excerpts": [
            "Write safe, correct and energy-efficient embedded code faster, using the Rust programming language, its async facilities, and the Embassy libraries."
          ]
        },
        {
          "title": "The State of Async Rust: Runtimes",
          "url": "https://corrode.dev/blog/async/",
          "excerpts": [
            "/embassy): An async runtime for\n  embedded systems.",
            "Futures should be designed for brief, scoped lifespans rather than the `'static` lifetime.",
            "If you donâ€™t need async for performance reasons, threads can often be the\n> simpler alternativ",
            "Tokio stands out as the pragmatic choice for real-world implementations.",
            "there are alternatives to Tokio and that\nthey are worth exploring.",
            "Tokio stands as Rustâ€™s canonical async runtime.",
            "The suggested replacement is [smol](https://github.com/smol-rs/smol/), which is a  \nlightweight, much more explicit runtime, that is different to `async-std` in\nmany ways.",
            "Tokio is used at runtime in 20,768 crates (of which 5,245\ndepend on it optionally)",
            "The case of `async-std`",
            "`async-std` was an attempt to create an alternative runtime that is closer to\nthe Rust standard library.",
            "Update**: as of March 1, 2025, `async-std` has [officially been discontinued](https://github.com/async-rs/async-std/commit/fb56bffdbb4699e1add70a0f834dee6f57c398eb). The suggested replacement is [smol](https://github.com/smol-rs/smol/), which is a  \nlightweight, much more explicit runtime, that is different to `async-std` in\nmany way",
            "Going beyond Tokio, several other runtimes deserve more attention:",
            "* [smol](https://github.com/smol-rs/smol): A small async runtime,\n  which is easy to understan",
            "/glommio): An async runtime for I/O-bound\n  workloads, built on top of [io\\_uring]"
          ]
        },
        {
          "title": "Smol - A small and fast async runtime",
          "url": "https://github.com/smol-rs/smol",
          "excerpts": [
            "\nA small and fast async runtime. This crate simply re-exports other smaller async crates (see the source). To use tokio-based libraries with smol, apply the [`async-compat`](https://docs.rs/async-compat/latest/async_compat/) adapter to futures and I/O\ntypes.",
            "A small and fast async runtime for Rust",
            "[<img src='https://raw.githubusercontent.com/smol-rs/smol/master/assets/images/logo_fullsize_transparent.png' alt='kitty' width='100px' />](https://raw.githubusercontent.com/smol-rs/smol/master/assets/images/logo_fullsize_transparent.png)"
          ]
        },
        {
          "title": "async-std Documentation (Docs.rs)",
          "url": "https://docs.rs/async-std",
          "excerpts": [
            "`async-std` has been discontinued; use `smol` instead",
            "Async version of the Rust standard library",
            "Compatibility with the `tokio` 1.0 runtime is also simultaneously possible\nusing the `tokio1` Cargo feature:"
          ]
        },
        {
          "title": "smol crate documentation",
          "url": "https://docs.rs/smol",
          "excerpts": [
            "A small and fast async runtime. This crate simply re-exports other smaller async crates (see the source).",
            "To use tokio-based libraries with smol, apply the [`async-compat`](https://docs.rs/async-compat/latest/async_compat/) adapter to futures and I/O\ntypes.",
            "Examples",
            "block_on",
            "   Blocks the current thread on a future, processing I/O events when idle. [spawn](fn.spawn.html \"fn smol::spawn\")",
            "Spawns a task onto the global executor (single-threaded by default).",
            "Async adapter for I/O types. [Executor](struct.Executor.html \"struct smol::Executor\")",
            "An async executor. [LocalExecutor](struct.LocalExecutor.html \"struct smol::LocalExecutor\")",
            "A thread-local executor. [Task](struct.Task.html \"struct smol::Task\")",
            "A spawned task. [Timer](struct.Timer.html \"struct smol::Timer\")",
            "A future or stream that emits timed events."
          ]
        },
        {
          "title": "svd2rust - Rust",
          "url": "https://docs.rs/svd2rust",
          "excerpts": [
            "svd2rust is a command line tool that transforms SVD files into crates that expose a type safe API to access the peripherals of the device. Â§Installation. $Â ..."
          ]
        },
        {
          "title": "rust-embedded/svd2rust: Generate Rust register maps (` ...",
          "url": "https://github.com/rust-embedded/svd2rust",
          "excerpts": [
            "svd2rust-regress is a helper program for regression testing changes against svd2rust . ... Check out the svd2rust-regress README for information on how to useÂ ..."
          ]
        },
        {
          "title": "cortex_m - Rust",
          "url": "https://rtic.rs/dev/api/cortex_m/index.html",
          "excerpts": [
            "Low level access to Cortex-M processors. This crate provides: Access to core peripherals like NVIC, SCB and SysTick. Access to core registers like CONTROL, ..."
          ]
        },
        {
          "title": "cortex_m - Rust",
          "url": "https://docs.rs/cortex-m",
          "excerpts": [
            "Low level access to Cortex-M processors. This crate provides: Access to core peripherals like NVIC, SCB and SysTick. Access to core registers like CONTROL,Â ..."
          ]
        },
        {
          "title": "Tooling - The Embedded Rust Book",
          "url": "https://doc.rust-lang.org/beta/embedded-book/intro/tooling.html",
          "excerpts": [
            " [Probe-rs Visual Studio Code Extension",
            " [GDB (GNU Debugger)",
            "OpenOCD",
            "J-Link",
            "`cargo-binutils`",
            "`qemu-system-arm`"
          ]
        },
        {
          "title": "probe_rs - Rust",
          "url": "https://docs.rs/probe-rs",
          "excerpts": [
            "Debugging toolset for embedded devices. Prerequisites, Examples, Halting the attached chip. use probe_rs::probe::{list::Lister, Probe};"
          ]
        },
        {
          "title": "probe-rs",
          "url": "https://probe.rs/",
          "excerpts": [
            "probe-rs",
            "The user-friendly & flexible embedded toolkit that just works",
            "Embedded programming made easy",
            " using `probe-rs run` . [cargo-flash](/docs/tools/cargo-flash/) can be used to just",
            " flash a target and [cargo-embed](/docs/tools/cargo-embed/) can be used to get a full RTT terminal to also send commands to the target",
            " and view multiple channels at one. * Rust",
            "Easy debugging in VSCode",
            "Use [VSCode's](/docs/tools/debugger/) awesome debug capabilities",
            " with our native debug plugin. Run the target, set breakpoints, halt on break point, inspect the",
            "\n and GDB-like expressions can be evaluated in the built in [REPL]",
            " VSCode not your cup of tea? No problem!"
          ]
        },
        {
          "title": "Probe-rs Documentation",
          "url": "http://probe.rs/docs",
          "excerpts": [
            "`probe-rs` is an embedded debugging and target interaction toolkit. It enables",
            "* Flashing firmware to `ARM` and `RISC-V` targets. More architectures are in the\n  works.",
            "* Reading and writing memory, running, halting, setting and reading breakpoints\n  and resetting the target via `SWD` and `JTAG`.",
            "* Running firmware on the target and getting back logs via `RTT` and `defmt` and\n  printing a stacktrace on panic.",
            "* Debugging the target via `VS Code` with running `RTT` logs, memory inspection\n  and more.",
            "This article explains embedded debugging in a bit more detail and where probe-rs\nfits in. You can skip it if you are familiar with embedded debugging.",
            "\n\nprobe-rs is a library that implements the protocols of debug probes from various\nmanufacturers and the protocols of different chip architectures. It furthermore\nis able to flash many targets and download software onto them.",
            "While probe-rs was originally targeted at the Rust community, it can freely be\nused for programming in C as well."
          ]
        },
        {
          "title": "Cross-Compiling Your Project in Rust",
          "url": "https://www.tangramvision.com/blog/cross-compiling-your-project-in-rust",
          "excerpts": [
            "Feb 13, 2024 â€” Explore cross-compiling, with tips and tricks for managing cross-platform development with Rust. Feb 13, 2024 â€” So for a â€œstandardâ€ Rust project building with cargo , it is as simple as swapping out cargo for cross for whatever commands you're used toÂ ..."
          ]
        },
        {
          "title": "Cross-compilation - The rustup book",
          "url": "https://rust-lang.github.io/rustup/cross-compilation.html",
          "excerpts": [
            "Cross-compilation - The rustup book",
            "[Cross-compilation]()",
            "Rust [supports a great number of platforms](https://doc.rust-lang.org/nightly/rustc/platform-support.html). For many of these platforms",
            "The Rust Project publishes binary releases of the standard library, and for",
            "some the full compiler. `rustup` gives easy access to all of them. When you first install a toolchain, `rustup` installs only the standard",
            "When you first install a toolchain, `rustup` installs only the standard\nlibrary for your _host_ platform - that is, the architecture and operating\nsystem you are presently runnin",
            "system you are presently running. To compile to other platforms you must",
            "en build for\nAndroid with Cargo by passing the `--target` flag, as in `cargo build --target=arm-linux-androideabi` .",
            "command. For example, to add the Android target:",
            "```\n$ rustup target add arm-linux-androideabi\ninfo: downloading component 'rust-std' for 'arm-linux-androideabi'\ninfo: installing component 'rust-std' for 'arm-linux-androideabi'\n```",
            "With the `arm-linux-androideabi` target installed you can then build for",
            "Android with Cargo by passing the `--target` flag, as in `cargo build --target=arm-linux-androideabi`. Note that `rustup target add` only installs the Rust standard library for a",
            "given target. There are typically other tools necessary to cross-compile,",
            "particularly a linker. For example, to cross compile to Android the [Android",
            "NDK](https://developer.android.com/tools/sdk/ndk/index.html) must be installed."
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "Many `rustup` commands deal with _toolchains_ , a single installation of the",
            "Rust compiler. `rustup` supports multiple types of toolchains. The most basic",
            "track the official release [channels](channels.html) : _stable_ , _beta_ and _nightly_ ; but `rustup` can also install toolchains from the official archives, for alternate",
            "host platforms, and from local builds.",
            "## [Toolchain specification]()",
            "Standard release channel toolchain names have the following form:",
            "<channel>[-<date>][-<host>]",
            "<channel>       = stable|beta|nightly|<versioned>[-<prerelease>]",
            "<versioned>     = <major.minor>|<major.minor.patch>",
            "<prerelease>    = beta[.<number>]",
            "<date>          = YYYY-MM-DD",
            "<host>          = <target-triple>",
            "â€˜channelâ€™ is a named release channel, a major and minor version number such as `1.42` , or a fully specified version number, such as `1.42.0` . Channel names",
            "can be optionally appended with an archive date, as in `nightly-2014-12-18` , in",
            "which case the toolchain is downloaded from the archive for that date. Finally, the host may be specified as a target triple.",
            "For example:",
            "$ rustup toolchain install stable-x86_64-pc-windows-msvc",
            "For convenience, elements of the target triple that are omitted will be",
            "inferred, so the above could be written:",
            "$ rustup toolchain install stable-msvc",
            "Toolchain names that donâ€™t name a channel instead can be used to name [custom",
            "toolchains]() . ## [Custom toolchains]()",
            "For convenience of developers working on Rust itself, `rustup` can manage",
            "local builds of the Rust toolchain. To teach `rustup` about your build, run:",
            "$ rustup toolchain link my-toolchain path/to/my/toolchain/sysroot",
            "For example, on Ubuntu you might clone `rust-lang/rust` into `~/rust` , build",
            "it, and then run:",
            "```console",
            "```console",
            "```console",
            "```console",
            "$ rustup toolchain link my-toolchain ~/rust/build/x86_64-unknown-linux-gnu/stage2/",
            "$ rustup default my-toolchain",
            "Now you can name `my-toolchain` as any other `rustup` toolchain. Create a `rustup` toolchain for each of your `rust-lang/rust` workspaces and test them",
            "easily with `rustup run my-toolchain rustc` . Because the `rust-lang/rust` tree does not include Cargo, _when `cargo` is",
            "invoked for a custom toolchain and it is not available, `rustup` will attempt",
            "to use `cargo` from one of the release channels_ , preferring â€˜nightlyâ€™, then",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Introduction - Proptest",
          "url": "https://altsysrq.github.io/proptest-book/",
          "excerpts": [
            "Property testing is a system of testing code by checking that certain properties of its output or behaviour are fulfilled for all inputs. These inputs are ... Property testing is a system of testing code by checking that certain properties of its output or behaviour are fulfilled for all inputs. These inputs are ..."
          ]
        },
        {
          "title": "Kernel Rust Quick Start (docs.kernel.org/rust/quick-start.html)",
          "url": "https://docs.kernel.org/rust/quick-start.html",
          "excerpts": [
            "This document describes how to get started with kernel development in Rust.",
            "There are a few ways to install a Rust toolchain needed for kernel development.",
            "A simple way is to use the packages from your Linux distribution if they are\nsuitable -- the first section below explains this approach.",
            "Two sets are provided: the\nâ€œlatest LLVMâ€ and â€œmatching LLVMâ€ (please see the link for more information).",
            "Alternatively, the next two â€œRequirementsâ€ sections explain each component and\nhow to install them through `rustup` , the standalone installers from Rust\nand/or building them."
          ]
        },
        {
          "title": "Rust â€” The Linux Kernel documentation",
          "url": "https://docs.kernel.org/rust/index.html",
          "excerpts": [
            "The Rust support was merged in v6.1 into mainline in order to help in\ndetermining whether Rust as a language was suitable for the kernel, i.e. worth\nthe tradeoffs.",
            "Currently, the Rust support is primarily intended for kernel developers and\nmaintainers interested in the Rust support, so that they can start working on\nabstractions and drivers, as well as helping the development of infrastructure\nand tools.",
            "If you are an end user, please note that there are currently no in-tree\ndrivers/modules suitable or intended for production use, and that the Rust\nsupport is still in development/experimental, especially for certain kernel\nconfigurations.",
            "> <https://rust.docs.kernel.org>"
          ]
        },
        {
          "title": "Hacker News discussion: Asterinas: OS kernel written in Rust and providing Linux-compatible ABI",
          "url": "https://news.ycombinator.com/item?id=41847640",
          "excerpts": [
            "Asterinas: OS kernel written in Rust and providing Linux-compatible "
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed"
          ]
        },
        {
          "title": "The Redox Operating System",
          "url": "http://doc.redox-os.org/book",
          "excerpts": [
            "Redox OS is a general-purpose operating system written in [Rust](https://www.rust-lang.org) . Our aim is to provide a fully functioning Unix-like microkernel-based operating system, that is secure, reliable and free.",
            "Redox OS was created in 2015 before the first stable version (1.0) of the Rust compiler and was one of the first operating systems written in Rust.",
            "To achieve that, Redox was redesigned to adopt a microkernel architecture and a unified system API for resources.",
            "This book is written in a way that you doesn't require any prior knowledge of Rust or OS development."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "http://os.phil-opp.com/",
          "excerpts": [
            "\n\nThis blog series creates a small operating system in the [Rust programming language](https://www.rust-lang.org/) . Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding [Github repository](https://github.com/phil-opp/blog_os) .",
            "\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the [bare metal](https://en.wikipedia.org/wiki/Bare_machine) without an underlying operating system.",
            " [A Freestanding Rust Binary",
            "\n\nIn this post, we explore _cooperative multitasking_ and the _async/await_ feature of Rust."
          ]
        },
        {
          "title": "Preface - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/",
          "excerpts": [
            "You'll learn about linkers, linker scripts and about the Rust features that let you control a bit of the ABI of Rust programs. A trick to implement defaultÂ ..."
          ]
        },
        {
          "title": "Monoio",
          "url": "https://github.com/bytedance/monoio",
          "excerpts": [
            "Monoio is a pure io\\_uring/epoll/kqueue Rust async runtime.",
            "Part of the design has been borrowed from Tokio and Tokio-uring.",
            "However, unlike Tokio-uring, Monoio does not run on top of another runtime, rendering it more efficient.",
            "Moreover, Monoio is designed with a thread-per-core model in mind.",
            "Users do not need to worry about tasks being `Send` or `Sync` , as thread local storage can be used safely.",
            "In other words, the data does not escape the thread on await points, unlike on work-stealing runtimes such as Tokio.",
            "this runtime is primarily targeted at servers, where operations are io-bound on network sockets, and therefore the use of native asynchronous I/O APIs maximizes the throughput of the server.",
            "To use monoio, you need rust 1.75.",
            "if you want to use io\\_uring, you must make sure your kernel supports it( [5\\.6+](/bytedance/monoio/blob/master/docs/en/platform-support.md) ).",
            "/benchmark.md) prove that, for our use-cases, Monoio has a better performance than other Rust runtimes."
          ]
        },
        {
          "title": "Tokio-uring: IO_uring-backed Runtime for Tokio",
          "url": "https://github.com/tokio-rs/tokio-uring",
          "excerpts": [
            "[`io-uring`](https://unixism.net/loti/) for [Tokio](https://github.com/tokio-rs/tokio) by exposing a new Runtime that is\ncompatible with Tokio but also can drive [`io-uring`](https://unixism.net/loti/) \\-backed resources.",
            "The crate\nprovides new resource types that work with [`io-uring`](https://unixism.net/loti/) .",
            "`tokio-uring` requires a very recent linux kernel."
          ]
        },
        {
          "title": "tokio-rs/tokio-uring",
          "url": "http://github.com/tokio-rs/tokio-uring",
          "excerpts": [
            "An io\\_uring backed runtime for Rus",
            "tokio-uring` requires a very recent linux kernel. (Not even all kernels with io\\_uring support will work)\nIn particular `5.4.0` does not work (This is standard on Ubuntu 20.4). However `5.11.0` (the ubuntu hwe image) does wor",
            "Languages\n\n* [Rust 100\\.0%](/tokio-rs/tokio-uring/search?l=rust"
          ]
        },
        {
          "title": "Anyone actually using io_uring with rust in production? ...",
          "url": "https://www.reddit.com/r/rust/comments/1h5xe5h/anyone_actually_using_io_uring_with_rust_in/",
          "excerpts": [
            "I recently switched to uring from tokio. i did extensive perf testing, gained 3-5% cpu and more importantly cpu load is more even. i use ntex + compio With io_uring, after the initial setup syscall, all your data arrives into user space. Epoll is usually enough but you can eek more performanceÂ ..."
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i",
            "It is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled *sound*; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is *unsound*.",
            "unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it is _unsound_",
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.",
            "The bytes owned by an immutable binding or immutable `static` are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html).",
            "Moreover, the bytes [pointed to]() by a shared reference, including transitively through other references (both shared and mutable) and `Box`es, are immutable; transitivity includes those references stored in fields of compound types.",
            "* Producing an [invalid value](). â€œProducingâ€ a\n  value happens any time a value is assigned to or read from a place, passed to\n  a function/primitive operation or returned from a function/primitive\n  oper",
            "The Rust compiler assumes that all values produced during program execution are\nâ€œvalidâ€, and producing an invalid value is hence immediate UB.",
            "* A `fn` pointer value must be non-null.",
            "* A `char` value must not be a surrogate (i.e., must not be in the range `0xD800..=0xDFFF`) and must be equal to or less than `char::MAX`.",
            "* A `!` value must never exist.",
            "* An integer (`i*`/`u*`), floating point value (`f*`), or raw pointer must be\n  initialized, i.e., must not be obtained from uninitialized memor",
            "* A `str` value is treated like `[u8]`, i.e. it must be initialized.",
            "* An `enum` must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.",
            "* A `struct`, tuple, and array requires all fields/elements to be valid at their respective type.",
            "* For a `union`, the exact validity requirements are not decided yet.",
            "* A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned and non-null, it cannot be [dangling](), and it must point to a valid value",
            "* The metadata of a wide reference, [`Box<T>`](../alloc/boxed/struct.Box.html), or raw pointer must match\n  the type of the unsized tai",
            "* If a type has a custom range of a valid values, then a valid value must be in that range.",
            "**Note:** Uninitialized memory is also implicitly invalid for any type that has\na restricted set of valid values. In other words, the only cases in which\nreading uninitialized memory is permitted are inside `union`s and in â€œpaddingâ€\n(the gaps between the fields of a type).",
            "Data races."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "pe in Rust. All the core\nlanguage cares about is preventing the following things:\n\n* Dereferencing (using the `*` operator on) dangling or unaligned pointers (see below)\n* Breaking the [pointer aliasing rules](references.html)\n* Calling a function with the wrong call ABI or unwinding from a function with the wrong unwind ABI.\n* Causing a [data race](races.html)\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support\n* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple):\n      + a `bool` that isn't 0 or 1\n      + an `enum` with an invalid discriminant\n      + a null `fn` pointer\n      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]\n      + a `!` (all values are invalid for this type)\n      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` . + a reference/ `Box` that is dangling, unaligned, or points to an invalid value. + a wide reference, `Box` , or raw pointer that has invalid metadata:\n                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to\n                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)\n      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null. (Requesting custom invalid values is an unstable\n        feature, but some stable libstd types, like `NonNull` , make use of it.)",
            " A reference/pointer is \"dangling\" if it is null or not all of the bytes it\npoints to are part of the same allocation (so in particular they all have to be\npart of _some_ allocation). The span of bytes it points to is determined by the\npointer value and the size of the pointee type. As a consequence, if the span is\nempty, \"dangling\" is the same as \"null\". Note that slices and strings point\nto their entire range, so it's important that the length metadata is never too\nlarge (in particular, allocations and therefore slices and strings cannot be\nbigger than `isize::MAX` bytes). If for some reason this is too cumbersome,\nconsider using raw pointers.",
            "Of\ncourse, unsafe functions and traits are free to declare arbitrary other\nconstraints that a program must maintain to avoid Undefined Behavior. For\ninstance, the allocator APIs declare that deallocating unallocated memory is\nUndefined Behavior. However, violations of these constraints generally will just transitively lead to one of\nthe above problems.",
            "\"Producing\" a value happens any time a value is assigned, passed to a\nfunction/primitive operation or returned from a function/primitive operation.",
            "Undefined Behavior gives the compiler full rights to do arbitrarily bad things\nto your program.",
            "However any program that actually manages to do such a thing is _probably_ incorrect. Rust provides lots of tools to make these things rare, but\nthese problems are considered impractical to categorically prevent.",
            "\n* Executing code compiled with [target features](../reference/attributes/codegen.html) that the current thread of execution does\n  not support",
            "* Producing invalid values (either alone or as a field of a compound type such\n  as `enum` / `struct` /array/tuple)",
            "      + a `bool` that isn't 0 or 1",
            "      + an `enum` with an invalid discriminant",
            "      + a null `fn` pointer",
            "      + a `char` outside the ranges [0x0, 0xD7FF] and [0xE000, 0x10FFFF]",
            "      + a `!` (all values are invalid for this type)",
            "      + an integer ( `i*` / `u*` ), floating point value ( `f*` ), or raw pointer read from [uninitialized memory](uninitialized.html) , or uninitialized memory in a `str` .",
            "      + a reference/ `Box` that is dangling, unaligned, or points to an invalid value.",
            "      + a wide reference, `Box` , or raw pointer that has invalid metadata:",
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)",
            "      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null.",
            "For a more detailed explanation about \"Undefined Behavior\", you may refer to [the reference](../reference/behavior-considered-undefined.html) .",
            "o]()\n\nThe only things that are different in Unsafe Rust are that you can:\n\n* Dereference raw pointers\n* Call `unsafe` functions (including C functions, compiler intrinsics, and the raw allocator)\n* Implement `unsafe` traits\n* Access or modify mutable statics\n* Access fields of `union` s"
          ]
        },
        {
          "title": "Unsafety - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/unsafety.html",
          "excerpts": [
            "Unsafe operations are those that can potentially violate the memory-safety guarantees of Rust's static semantics. [safety.unsafe-ops].",
            "* Dereferencing a [raw pointer](types/pointer.html) .",
            "* Reading or writing a [mutable](items/static-items.html) or [external](items/external-blocks.html) static variable.",
            "* Accessing a field of a [`union`](items/unions.html) , other than to assign to it.",
            "* Calling an unsafe function (including an intrinsic or foreign function).",
            "* Implementing an [unsafe trait](items/traits.html) .",
            "The following language level features cannot be used in the safe subset of\nRust:"
          ]
        },
        {
          "title": "Unsafe Rust - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch20-01-unsafe-rust.html",
          "excerpts": [
            "To switch to unsafe Rust, use the `unsafe` keyword and then start a new block\nthat holds the unsafe code. You can take five actions in unsafe Rust that you\ncanâ€™t in safe Rust, which we call _unsafe superpowers_ . Those superpowers\ninclude the ability to:\n\n* Dereference a raw pointer\n* Call an unsafe function or method\n* Access or modify a mutable static variable\n* Implement an unsafe trait\n* Access fields of a `union`",
            "In the context of raw pointers, _immutable_ means that\nthe pointer canâ€™t be directly assigned to after being dereferenced. Different from references and smart pointers, raw pointers:\n\n* Are allowed to ignore the borrowing rules by having both immutable and\n  mutable pointers or multiple mutable pointers to the same location\n* Arenâ€™t guaranteed to point to valid memory\n* Are allowed to be null\n* Donâ€™t implement any automatic clean",
            "The function `slice::from_raw_parts_mut` is unsafe because it takes a raw\npointer and must trust that this pointer is valid. The `add` method on raw\npointers is also unsafe because it must trust that the offset location is also\na valid pointer. Therefore, we had to put an `unsafe` block around our calls to `slice::from_raw_parts_mut` and `add` so we could call them. By looking at\nthe code and by adding the assertion that `mid` must be less than or equal to `len` , we can tell that all the raw pointers used within the `unsafe` block\nwill be valid pointers to data within the slice. This is an acceptable and\nappropriate use of `unsafe` . Note that we donâ€™t need to mark the resultant `split_at_mut` function as `unsafe` , and we can call this function from safe Rust. Weâ€™ve created a safe\nabstraction to the unsafe code with an implementation of the function that uses `unsafe` code in a safe way, because it creates only valid pointers from the\ndata this function has access to.",
            "By opting out of having Rust enforce these guarantees, you can give up\nguaranteed safety in exchange for greater performance or the ability to\ninterface with another language or hardware where Rustâ€™s guarantees donâ€™t apply.",
            "Static variables are similar to constants, which we discussed in [â€œConstantsâ€](ch03-01-variables-and-mutability.html) in\nChapter 3. The names of static variables are in `SCREAMING_SNAKE_CASE` by\nconvention. Static variables can only store references with the `'static` lifetime, which means the Rust compiler can figure out the lifetime and we\narenâ€™t required to annotate it explicitly. Accessing an immutable static\nvariable is safe.",
            "The second type of operation you can perform in an unsafe block is calling\nunsafe functions. Unsafe functions and methods look exactly like regular\nfunctions and methods, but they have an extra `unsafe` before the rest of the\ndefinition. The `unsafe` keyword in this context indicates the function has\nrequirements we need to uphold when we call this function, because Rust canâ€™t\nguarantee weâ€™ve met these requirements.",
            "Unsafe Rust exists because, by nature, static analysis is conservative. When\nthe compiler tries to determine whether or not code upholds the guarantees,\nitâ€™s better for it to reject some valid programs than to accept some invalid\nprograms. Although the code _might_ be okay, if the Rust compiler doesnâ€™t have\nenough information to be confident, it will reject the code. In these cases,\nyou can use unsafe code to tell the compiler, â€œTrust me, I know what Iâ€™m\ndoing.â€",
            "Itâ€™s important to understand that `unsafe` doesnâ€™t turn off the borrow checker\nor disable any of Rustâ€™s other safety checks: if you use a reference in unsafe\ncode, it will still be checked. The `unsafe` keyword only gives you access to\nthese five features that are then not checked by the compiler for memory\nsafety. Youâ€™ll still get some degree of safety inside of an unsafe block.",
            "Unsafe Rust - The Rust Programming Language",
            "### [Unsafe Superpowers]()",
            "A subtle difference between constants and immutable static variables is that\nvalues in a static variable have a fixed address in memory. Using the value\nwill always access the same data. Constants, on the other hand, are allowed to\nduplicate their data whenever theyâ€™re used. Another difference is that static\nvariables can be mutable. Accessing and modifying mutable static variables is _unsafe_ .",
            "Keep `unsafe` blocks small; youâ€™ll be thankful later when you investigate memory\nbugs. To isolate unsafe code as much as possible, itâ€™s best to enclose such code\nwithin a safe abstraction and provide a safe API, which weâ€™ll discuss later in\nthe chapter when we examine unsafe functions and methods. Parts of the standard\nlibrary are implemented as safe abstractions over unsafe code that has been\naudited. Wrapping unsafe code in a safe abstraction prevents uses of `unsafe` from leaking out into all the places that you or your users might want to use\nthe functionality implemented with `unsafe` code, because using a safe\nabstraction is safe.",
            "Recall that we can create raw pointers in safe code, but we canâ€™t _dereference_ raw pointers and read the data being pointed to. In Listing 20-3, we use the\ndereference operator `*` on a raw pointer that requires an `unsafe` block.",
            "Unsafe Rust has\ntwo new types called _raw pointers_ that are similar to references. As with\nreferences, raw pointers can be immutable or mutable and are written as `*const T` and `*mut T` , respectively. The asterisk isnâ€™t the dereference operator; itâ€™s\npart of the type name.",
            "With all of these dangers, why would you ever use raw pointers? One major use\ncase is when interfacing with C code, as youâ€™ll see in the next section, [â€œCalling an Unsafe Function or\nMethod.â€]() Another case is\nwhen building up safe abstractions that the borrow checker doesnâ€™t understand.",
            "By calling an unsafe function within an `unsafe` block, weâ€™re saying that weâ€™ve read this functionâ€™s documentation and\nwe take responsibility for upholding the functionâ€™s contracts.",
            "\nRustâ€™s borrow checker canâ€™t understand that weâ€™re borrowing different parts of\nthe slice; it only knows that weâ€™re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two\nslices arenâ€™t overlapping, but Rust isnâ€™t smart enough to know this. When we\nknow code is okay, but Rust doesnâ€™t, itâ€™s time to reach for unsafe code.",
            "As with regular variables, we specify mutability using the `mut` keyword. Any\ncode that reads or writes from `COUNTER` must be within an `unsafe` block. This\ncode compiles and prints `COUNTER: 3` as we would expect because itâ€™s single\nthreaded. Having multiple threads access `COUNTER` would likely result in data\nraces, so it is undefined behavior.",
            "#### [Using `extern` Functions to Call External Code]()",
            "Sometimes, your Rust code might need to interact with code written in another\nlanguage. For this, Rust has the keyword `extern` that facilitates the creation\nand use of a _Foreign Function Interface (FFI)_ . An FFI is a way for a\nprogramming language to define functions and enable a different (foreign)\nprogramming language to call those functions.",
            "Functions declared within `extern` blocks are\ngenerally unsafe to call from Rust code, so `extern` blocks must also be marked `unsafe` . The reason is that other languages donâ€™t enforce Rustâ€™s rules and\nguarantees, and Rust canâ€™t check them, so responsibility falls on the programmer\nto ensure safety.",
            "Therefore, we need to mark the entire\nfunction as `unsafe` , and document the safety limitation, so anyone calling the\nfunction knows what they are and are not allowed to do safely. Whenever we write an unsafe function, it is idiomatic to write a comment\nstarting with `SAFETY` and explaining what the caller needs to do to call the\nfunction safely. Likewise, whenever we perform an unsafe operation, it is\nidiomatic to write a comment starting with `SAFETY` to explain how the safety\nrules are upheld.",
            "The\nrequirement that references to static mutable variables can only be created via\nraw pointers helps make the safety requirements for using them more obvious. With mutable data that is globally accessible, itâ€™s difficult to ensure there\nare no data races, which is why Rust considers mutable static variables to be\nunsafe.",
            "### [Implementing an Unsafe Trait]()",
            "We can use `unsafe` to implement an unsafe trait.\nA trait is unsafe when at\nleast one of its methods has some invariant that the compiler canâ€™t verify. We\ndeclare that a trait is `unsafe` by adding the `unsafe` keyword before `trait` and marking the implementation of the trait as `unsafe` too, as shown in\nListing 20-12.",
            "By using `unsafe impl` , weâ€™re promising that weâ€™ll uphold the invariants that\nthe compiler canâ€™t verify. As an example, recall the `Sync` and `Send` marker traits we discussed in [â€œExtensible Concurrency with the `Sync` and `Send` Traitsâ€](ch16-04-extensible-concurrency-sync-and-send.html) in\nChapter 16: the compiler implements these traits automatically if our types are\ncomposed entirely of other types that implement `Send` and `Sync` . If we\nimplement a type that contains a type that does not implement `Send` or `Sync` ,\nsuch as raw pointers, and we want to mark that type as `Send` or `Sync` , we must\nuse `unsafe` . Rust canâ€™t verify that our type upholds the guarantees that it can\nbe safely sent across threads or accessed from multiple threads; therefore, we\nneed to do those checks manually and indicate as such with `unsafe` .",
            "### [Accessing Fields of a Union]()",
            "The final action that works only with `unsafe` is accessing fields of a union.\nA `union` is similar to a `struct` , but only one declared field is used in a\nparticular instance at one time. Unions are primarily used to interface with\nunions in C code. Accessing union fields is unsafe because Rust canâ€™t guarantee\nthe type of the data currently being stored in the union instance.",
            "Dereference a raw pointer",
            "Access fields of a `union`",
            "When writing unsafe code, you might want to check that what you have written\nactually is safe and correct. One of the best ways to do that is to use\nMiri, an official Rust tool for detecting undefined behavior. Whereas\nthe borrow checker is a _static_ tool that works at compile time, Miri is a _dynamic_ tool that works at runtime. It checks your code by running your\nprogram, or its test suite, and detecting when you violate the rules it\nunderstands about how Rust should work.",
            "Using `unsafe` to use one of the five superpowers just discussed\nisnâ€™t wrong or even frowned upon, but it is trickier to get `unsafe` code\ncorrect because the compiler canâ€™t help uphold memory safety. When you have a\nreason to use `unsafe` code, you can do so, and having the explicit `unsafe` annotation makes it easier to track down the source of problems when they occur. Whenever you write unsafe code, you can use Miri to help you be more confident\nthat the code you have written upholds Rustâ€™s rules."
          ]
        },
        {
          "title": "The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/unsafe-keyword.html",
          "excerpts": [
            "Unsafe functions are functions that are not safe in all contexts and/or for all possible inputs. We say they have _extra safety conditions_ , which are requirements that must be upheld by all callers and that the compiler does not check.",
            "Such a function must be prefixed with the keyword `unsafe` and can only be called from inside an `unsafe` block, or inside `unsafe fn` without the [`unsafe_op_in_unsafe_fn`](../rustc/lints/listing/allowed-by-default.html) lint.",
            "A block of code can be prefixed with the `unsafe` keyword to permit using the unsafe actions as defined in the [Unsafety](unsafety.html) chapter, such as calling other unsafe functions or dereferencing raw pointers.",
            "Unsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language.",
            "An unsafe trait is a trait that comes with extra safety conditions that must be upheld by _implementations_ of the trait. The unsafe trait should come with documentation explaining what those extra safety conditions are. [[unsafe .trait .safety]](.trait.safety \"unsafe.trait.safety\")",
            "The `unsafe` keyword can occur in several different contexts:\nunsafe functions ( `unsafe fn` ), unsafe blocks ( `unsafe {}` ), unsafe traits ( `unsafe trait` ), unsafe trait implementations ( `unsafe impl` ), unsafe external blocks ( `unsafe extern` ), and unsafe attributes ( `#[unsafe(attr)]` ). It plays several different roles, depending on where it is used and whether the `unsafe_op_in_unsafe_fn` lint is enabled:",
            "By putting operations into an unsafe block, the programmer states that they have taken care of satisfying the extra safety conditions of all operations inside that block.",
            "When implementing an unsafe trait, the implementation needs to be prefixed with the `unsafe` keyword. By writing `unsafe impl` , the programmer states that they have taken care of satisfying the extra safety conditions required by the trait.",
            "[[unsafe .trait .intro]](.trait.intro \"unsafe.trait.intro\"",
            "## [Unsafe trait implementations ( `unsafe impl` )]()"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time.",
            "```rust"
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model for Rust",
            "In Rust, the type system imposes a strict\n\ndiscipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias\n\ninformation for the purpose of program optimizations that reorder memory accesse",
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile",
            "In contrast, because it enforces a strict discipline of pointer\n\nusage, the Rust type system provides a rich source of alias information that can be used to justify\n\ntransformations like the one above intraprocedurally . Unfortunately, thereâ€™s a catch: Rust supports **unsafe** cod",
            "In line 3, this code uses the **as** operator to cast a reference to local (that would have type & **mut i32** )\n\ninto a raw pointer with type \\* **mut i32** . Raw pointers are not tracked by the type system: they can\n\nbe freely interconverted with integers in safe code, and arbitrary address arithmetic is possib",
            "However, to maintain soundness of the type system, dereferencing a raw pointer is only permitted\n\ninside **unsafe** blocks, which serve as syntactic markers that the programmer opted-in to potentially\n\nunsafe behavio",
            "Raw pointers are necessary when interfacing with C code through FFI, and also\n\nwhen implementing low-level pointer-heavy data structures in Rust that internally do not follow\n\nRustâ€™s aliasing disciplin",
            "The sinister part about this cast is that we do it twice! The type system does not stop us, as it\n\ndoes not even attempt to track what happens with raw pointers",
            "What is important is that **unsafe** code is encapsulated within a\n\nsafe abstraction ",
            "The Rust ecosystem rests on the interplay of safe code where possible and **unsafe** code\n\nwhere needed, and hence any realistic consideration of compilation for Rust programs requires\n\nproper treatment of **unsafe** cod",
            "More precisely, we will define the operational semantics in\n\nsuch a way that our example program has undefined behavior , which means the compiler is allowed\n\nto compile it in any way it choose",
            "Compared to\n\nRustBeltâ€™s semantics, we have to Å‚addÅ¾ some undefined behavior to obtain the desired optimizations",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin",
            "Raw pointers. Sometimes, the aliasing discipline for references that the borrow checker enforces\n\nis too strict",
            "In this case, one option is to not use references but instead\n\nemploy raw pointers . Raw pointers in Rust basically act like pointers in C: they are not checked by\n\nthe compiler, and there are no aliasing restriction",
            "In line 2, we cast a reference to raw pointer type.",
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        },
        {
          "title": "Miri: An interpreter for Rust's mid-level intermediate representation",
          "url": "http://github.com/rust-lang/miri",
          "excerpts": [
            "Out-of-bounds memory accesses and use-after-free",
            "Invalid use of uninitialized data",
            "Violation of intrinsic preconditions (an [`unreachable_unchecked`](https://doc.rust-lang.org/stable/std/hint/fn.unreachable_unchecked.html) being\n  reached, calling [`copy_nonoverlapping`](https://doc.rust-lang.org/stable/std/ptr/fn.copy_nonoverlapping.html) with overlapping ranges, ...)",
            "Not sufficiently aligned memory accesses and references",
            "Violation of basic type invariants (a `bool` that is not 0 or 1, for example,\n  or an invalid enum discriminant)",
            "Data races and emulation of _some_ weak memory effects, i.e.,\n  atomic reads can return outdated values",
            "**Experimental** : Violations of the [Stacked Borrows](https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md) rules governing aliasing\n  for reference types",
            "**Experimental** : Violations of the [Tree Borrows](https://perso.crans.org/vanille/treebor/) aliasing rules, as an optional\n  alternative to [Stacked Borrows](https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md)",
            "Miri uses its own approximation of\nwhat is and is not Undefined Behavior in Rust.",
            "On top of that, Miri will also tell you about memory leaks: when there is memory\nstill allocated at the end of the execution, and that memory is not reachable\nfrom a global `static` , Miri will raise an error.",
            ". It can run binaries and test\nsuites of cargo projects and detect unsafe code that fails to uphold its safety requirements."
          ]
        },
        {
          "title": "Working with Unsafe - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/working-with-unsafe.html",
          "excerpts": [
            "Rust generally only gives us the tools to talk about Unsafe Rust in a scoped and\nbinary manner. Unfortunately, reality is significantly more complicated than\nthat.",
            "We say that such a correct\nunsafely implemented function is _sound_ , meaning that safe code cannot cause\nUndefined Behavior through it (which, remember, is the single fundamental\nproperty of Safe Rust).",
            "This program is now _unsound_ , Safe Rust can cause Undefined Behavior, and yet _we only modified safe code_ . This is the fundamental problem of safety: it's\nnon-local.",
            "The soundness of our unsafe operations necessarily depends on the\nstate established by otherwise \"safe\" operations.",
            "Safety is modular in the sense that opting into unsafety doesn't require you\nto consider arbitrary other kinds of badness.",
            "However\nsafety _isn't_ modular in the sense that programs are inherently stateful and\nyour unsafe operations may depend on arbitrary other state.",
            "Generally, the only bullet-proof way to limit the scope of unsafe code is at the\nmodule boundary with privacy.",
            "It is therefore possible for us to write a completely safe abstraction that\nrelies on complex invariants. This is _critical_ to the relationship between\nSafe Rust and Unsafe Rust.",
            "We have already seen that Unsafe code must trust _some_ Safe code, but shouldn't\ntrust _generic_ Safe code.",
            "Privacy is important to unsafe code for similar reasons:\nit prevents us from having to trust all the safe code in the universe from messing\nwith our trusted state."
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Since last fall, [Neven](https://perso.crans.org/vanille/) has been doing an internship to develop a new aliasing model for Rust: Tree Borrows. Hang on a second, I hear you say â€“ doesnâ€™t Rust already have an aliasing model? Isnâ€™t there this â€œStacked Borrowsâ€ that Ralf keeps talking about? Indeed there is, but Stacked Borrows is just one proposal for a possible aliasing model â€“ and it [has](https://github.com/rust-lang/unsafe-code-guidelines/issues/133) [its](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) [fair](https://github.com/rust-lang/unsafe-code-guidelines/issues/256) [share](https://github.com/rust-lang/unsafe-code-guidelines/issues/274) [of](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) [problems](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) .",
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Tree Borrows Explained",
          "url": "https://internals.rust-lang.org/t/tree-borrows-explained/18587",
          "excerpts": [
            "Since the `Freeze` and `Unpin` properties are not checked granularly, they are applied identically to out-of-range locations. That's a very debatable aspect of the model, but for now it's in line with TB being \"maximally permissive\" and can totally be changed if deemed problematic.",
            "Interesting observation: because `&mut` borrows start as the two-phase reserved stated, `&mut` borrow splitting just falls out of the model without any special handling, even if it were to keep fully eager instead of delayed tag reborrowing. This is evident from the walkthrough of the disjoint fields example.",
            "[UCG #381: `&mut impl !Unpin` are not `dereferenceable`](https://github.com/rust-lang/unsafe-code-guidelines/issues/381)"
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "```rust",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust",
            "fn main() {",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "# [`min_specialization`]()",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "min\\_specialization - The Rust Unstable Boo"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "```",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            " [Idea] About soundness in specialization ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... "
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes.",
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "# [Chalk: Orphan Check]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "## [The Orphan Rules]()",
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type."
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "The reason for this is that there are two appearances of type parameter `T` in",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117)."
          ]
        },
        {
          "title": "Coherence - Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/coherence.html",
          "excerpts": [
            "Coherence checking is what detects both of trait impls and inherent impls overlapping with others.",
            "Overlap checks are performed for both inherent impls, and for trait impls.",
            "This uses the same overlap checking code, really done as two separate analyses.",
            "Overlapping is sometimes partially allowed:",
            "1. for marker traits",
            "2. under [specializatio",
            "but normally isn't.",
            "the explicit negative impl check, and the implicit negative impl check. Both try to prove that an overlap is definitely impossible.",
            "ses. Overlap checks always consider pairs of implementations, comparing them to each other. Overlap "
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "* `snafu` provides context-driven error management, appropriate for complex systems.",
            "Note: When developing, pay attention to the size of\nResult<T, E> . anyhow Error: Application-level Error Handling",
            "* thiserror : customized and rich error handling, suitable for library-level programming",
            "* snafu : finer-grained error management",
            "Conversion and unified error handling with\nanyhow::Error :",
            "* Provides a unified\nanyhow::Error type, supporting any error type that implements\nstd::error::Error",
            "* Uses the\n? operator for automatic error propagation, simplifying multi-layer nested error handling",
            "* Supports adding dynamic context (via the\ncontext() method) to enhance error readability",
            "fn get_cluster_info () -> Result < ClusterMap , anyhow :: Error > { // Error 3: Err3 let config = std :: fs :: read_to_string ( \"cluster.json\" ) ? ; // Error 1: Err1 // let config = std::fs::read_to_string(\"cluster.json\").context(\"...\")? ; // Error 1: Err1 let map : ClusterMap = serde_json :: from_str ( & config ) ?",
            "thiserror Error: Defining Library-level Errors",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Converts underlying errors into domain-specific errors through the\nSnafu macro",
            "    * Supports attaching structured context (such as file paths, input parameters) in the error chain",
            "    * Provides the\nensure!\nmacro to simplify condition checking and error throwing",
            "thiserror vs snafu",
            "Rust std::error::Error trait documentation",
            "Since the\nError trait requires implementing both\nDebug and\nDisplay :\npub trait Error : Debug + Display {",
            "Error -> println! ( \"{}/ {:?}\" , err )",
            "snafu Error: Context-driven Error Management",
            "snafu Error: Context-driven Error Management",
            "rust-ecosystem-learning",
            "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
            "anyhow ,",
            "anyhow ,",
            "thiserror ,",
            "thiserror ,",
            "snafu",
            "snafu",
            "Practical Implementation"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "anyhow = \"1.0.97\"  \nserde = { version = \"1.0.217\", features = [\"derive\"] }  \nserde_json = \"1.0.140\"  \nthiserror = \"2.0.11\"",
            "`anyhow` Error: Application-level Error Handling",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`thiserror` Error: Defining Library-level Errors",
            "Reference: [Rust std::error::Error trait documentation](https://doc.rust-lang.org/beta/core/error/trait.Error.html)",
            "```\npub trait Error: Debug + Display {\n```\n",
            "snafu` Error: Context-driven Error Management",
            "Comparison and Selection Guide",
            "Practical Implementation",
            "Add Dependencies",
            "`main.rs` File",
            "```\nuse anyhow::Context;  \nuse rust_ecosystem_learning::MyError;  \nuse std::fs;  \nuse std::mem::size_of;  \n  \nfn main() -> Result<(), anyhow::Error> {  \n    println! (\"size of anyhow::Error: {}\", size_of::<anyhow::Error>());  \n    println! (\"size of std::io::Error: {}\", size_of::<std::io::Error>());  \n    println! (  \n        \"size of std::num::ParseIntError: {}\",  \n        size_of::<std::num::ParseIntError>()  \n    );  \n    println! (  \n        \"size of serde_json::Error: {}\",  \n        size_of::<serde_json::Error>()  \n    );  \n    println! (\"size of string: {}\", size_of::<String>());  \n    println! (\"size of MyError: {}\", size_of::<MyError>());  \n  \n    let filename = \"non_existent_file.txt\";  \n    let _fd =  \n        fs::File::open(filename).with_context(|| format! (\"Cannot find file: {}\", filename))? ;  \n  \n    fail_with_error()? ;  \n    Ok(())  \n}  \n  \nfn fail_with_error() -> Result<(), MyError> {  \n    Err(MyError::Custom(\"This is a custom error\".to_string()))  \n}  \n  \n#[cfg(test)]  \nmod tests {  \n    #[test]  \n    fn it_works() {  \n        assert_eq!\n(2 + 2, 4);  \n    }  \n}\n```"
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling - The Rust Programming Language",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features."
          ]
        },
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "Here are the topics weâ€™ll cover in this chapter:\n\n* How to create threads to run multiple pieces of code at the same time\n* _Message-passing_ concurrency, where channels send messages between threads\n* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data\n* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library",
            "* _Message-passing_ concurrency, where channels send messages between threads",
            "* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data",
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Rust's Send and Sync (Nomicon)",
          "url": "https://doc.rust-lang.org/nomicon/send-and-sync.html",
          "excerpts": [
            "Not everything obeys inherited mutability, though. Some types allow you to\nhave multiple aliases of a location in memory while mutating it. Unless these types use\nsynchronization to manage this access, they are absolutely not thread-safe. Rust\ncaptures this through the `Send` and `Sync` traits. * A type is Send if it is safe to send it to another thread. * A type is Sync if it is safe to share between threads (T is Sync if and only if `&T` is Send). Send and Sync are fundamental to Rust's concurrency story.",
            "Send and Sync are fundamental to Rust's concurrency story.",
            "Major exceptions include:",
            "* raw pointers are neither Send nor Sync (because they have no safety guards).",
            "* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).",
            "* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).",
            "Send and Sync are also automatically derived traits.",
            "This means that, unlike\nevery other trait, if a type is composed entirely of Send or Sync types, then it\nis Send or Sync."
          ]
        },
        {
          "title": "std::sync::atomic - Rust",
          "url": "http://doc.rust-lang.org/std/sync/atomic/index.html",
          "excerpts": [
            "\n\nAtomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes.",
            "\nThis module defines atomic versions of a select number of primitive\ntypes, including [`AtomicBool`](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\"), [`AtomicIsize`](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\"), [`AtomicUsize`](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\"),\n[`AtomicI8`](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\"), [`AtomicU16`](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\"), etc.",
            "Atomic variables are safe to share between threads (they implement [`Sync`](../../marker/trait.Sync.html \"trait std::marker::Sync\"))\nbut they do not themselves provide the mechanism for sharing and follow the\n[threading model](../../../std/thread/index.html) of Rust.",
            "The most common way to share an atomic variable is to put it into an [`Arc`](../../../std/sync/struct.Arc.html) (an\natomically-reference-counted shared pointer).",
            "Each atomic access takes an [`Ordering`](enum.Ordering.html \"enum std::sync::atomic::Ordering\") which defines how the operation interacts with the\nhappens-before order. These orderings behave the same as the corresponding [C++20 atomic\norderings](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information, see the [nomicon](../../../nomicon/atomics.html).",
            "The `#[cfg(target_has_atomic)]` attribute can be used to conditionally\ncompile based on the targetâ€™s supported bit widths. It is a key-value\noption set for each supported size, with values â€œ8â€, â€œ16â€, â€œ32â€, â€œ64â€,\nâ€œ128â€, and â€œptrâ€ for pointer-sized atomics.",
            "Structs",
            "[AtomicBool](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\")\n:   A boolean type which can be safely shared between threads.",
            "[AtomicI8](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI16](struct.AtomicI16.html \"struct std::sync::atomic::AtomicI16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI32](struct.AtomicI32.html \"struct std::sync::atomic::AtomicI32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI64](struct.AtomicI64.html \"struct std::sync::atomic::AtomicI64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicIsize](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicPtr](struct.AtomicPtr.html \"struct std::sync::atomic::AtomicPtr\")\n:   A raw pointer type which can be safely shared between threads.",
            "[AtomicU8](struct.AtomicU8.html \"struct std::sync::atomic::AtomicU8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU16](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU32](struct.AtomicU32.html \"struct std::sync::atomic::AtomicU32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU64](struct.AtomicU64.html \"struct std::sync::atomic::AtomicU64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicUsize](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\")\n:   An integer type which can be safely shared between threads.",
            "Enums",
            "[Ordering](enum.Ordering.html \"enum std::sync::atomic::Ordering\")\n:   Atomic memory orderings",
            "Functions",
            "[fence](fn.fence.html \"fn std::sync::atomic::fence\")\n:   An atomic fence.",
            "Type Aliases",
            "[Atomic](type.Atomic.html \"type std::sync::atomic::Atomic\")Experimental\n:   A memory location which can be safely modified from multiple threads."
          ]
        },
        {
          "title": "crossbeam-epoch (Crate Page) - Crates.io",
          "url": "https://crates.io/crates/crossbeam-epoch",
          "excerpts": [
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "Epoch-based garbage collection",
          "url": "http://github.com/crossbeam-rs/crossbeam-epoch",
          "excerpts": [
            "Epoch-based garbage collection",
            "This crate provides epoch-based garbage collection for use in concurrent data structures.",
            "If a thread removes a node from a concurrent data structure, other threads\nmay still have pointers to that node, so it cannot be immediately destructed.\nEpoch GC allows deferring destruction until it becomes safe to do so.",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "Crossbeam-channel (crossbeam-rs)",
          "url": "http://github.com/crossbeam-rs/crossbeam-channel",
          "excerpts": [
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "#### Atomics",
            "* [`AtomicCell`](https://docs.rs/crossbeam/latest/crossbeam/atomic/struct.AtomicCell.html), a thread-safe mutable memory location.(no\\_std",
            "* [`AtomicConsume`](https://docs.rs/crossbeam/latest/crossbeam/atomic/trait.AtomicConsume.html), for reading from primitive atomic types with \"consume\" ordering.(no\\_std",
            "#### Memory management",
            "* [`epoch`](https://docs.rs/crossbeam/latest/crossbeam/epoch/index.html), an epoch-based garbage collector.(alloc)",
            "* [`crossbeam-epoch`](/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch)\n  provides epoch-based garbage collection for building concurrent data structures",
            "version is released. Currently, the minimum supported Rust version is 1.61."
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "Loom is a testing tool for concurrent Rust code. It runs a test many\ntimes, permuting the possible concurrent executions of that test under\nthe [C11 memory model](https://en.cppreference.com/w/cpp/atomic/memory_order) .",
            "use loom :: sync :: Arc ;",
            "use loom :: sync :: atomic :: AtomicUsize ;",
            "use loom :: sync :: atomic :: Ordering :: { Acquire , Release , Relaxed } ;",
            "use loom :: thread ;",
            "let num = Arc :: new ( AtomicUsize :: new ( 0 ) ) ;",
            "let ths : Vec < _ > = ( 0 .. 2 )",
            ". map ( |_| {",
            "let num = num .",
            "clone ( ) ;",
            "thread :: spawn ( move || {",
            "let curr = num . load ( Acquire ) ;",
            "num . store ( curr + 1 , Release ) ;",
            "} )",
            "} )",
            ". collect ( ) ;",
            "for th in ths {",
            "th . join ( ) . unwrap ( ) ;",
            "}",
            "assert_eq ! ( 2 , num . load ( Relaxed ) ) ;",
            "Loom currently does not implement the full C11 memory model. Here is the (incomplete) list of unsupported features.",
            "* `SeqCst` accesses (e.g. `load` , `store` , ..):",
            "They are regarded as `AcqRel` . That is, they impose weaker",
            "synchronization, causing Loom to generate false alarms (not complete). See [](https://github.com/tokio-rs/loom/issues/180) for example. On the other",
            "hand, `fence(SeqCst)` is supported."
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "\nLoom is a tool for testing concurrent programs. At a high level, it runs tests many times, permuting the possible concurrent executions of each\ntest according to what constitutes valid executions under the [C11 memory model]",
            "Loom provides a way to deterministically explore the various possible execution permutations\nwithout relying on random executions. This allows you to write tests that verify that your\nconcurrent code is correct under _all_ executions, not just â€œmost of the time",
            "ts\n\nTest cases using loom must be fully deterministic. All sources of non-determism must be via loom\ntypes so that loom can expose different possible values on each execution of the test closure.",
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`"
          ]
        },
        {
          "title": "Rust std::sync::atomic - Atomic types",
          "url": "https://doc.rust-lang.org/std/sync/atomic/",
          "excerpts": [
            "Atomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes."
          ]
        },
        {
          "title": "Rust Concurrency: Atomic Explained",
          "url": "https://leapcell.medium.com/rust-concurrency-atomic-explained-a89923ea61fd",
          "excerpts": [
            "The documentation for this module describes atomic types as follows: Atomic types in Rust provide primitive shared-memory communication between threads and serve as the foundation for building other concurrency types. The `std::sync::atomic` module currently offers the following 12 atomic types:",
            "```\nAtomicBool  \nAtomicI8  \nAtomicI16  \nAtomicI32  \nAtomicI64  \nAtomicIsize  \nAtomicPtr  \nAtomicU8  \nAtomicU16  \nAtomicU32  \nAtomicU64  \nAtomicUsize\n```",
            "```\npub fn fetch_add(&self, val: i32, order: Ordering) -> i32 - Performs addition (or subtraction) on the atomic type  \npub fn compare_and_swap(&self, current: i32, new: i32, order: Ordering) -> i32 - CAS (deprecated in Rust 1.50, replaced by compare_exchange)  \npub fn compare_exchange(&self, current: i32, new: i32, success: Ordering, failure: Ordering) -> Result<i32, i32> - CAS  \npub fn load(&self, order: Ordering) -> i32 - Reads the value from the atomic type  \npub fn store(&self, val: i32, order: Ordering) - Writes a value to the atomic type  \npub fn swap(&self, val: i32, order: Ordering) -> i32 - Swaps values\n```",
            "```\npub enum Ordering {  \n    Relaxed,  \n    Release,  \n    Acquire,  \n    AcqRel,  \n    SeqCst,  \n}\n```"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "tonic - Rust",
          "url": "https://docs.rs/tonic",
          "excerpts": [
            "tonic is a gRPC over HTTP/2 implementation focused on high performance, interoperability, and flexibility. This library was created to have first class supportÂ ..."
          ]
        },
        {
          "title": "tokio::net - Rust",
          "url": "https://docs.rs/tokio/latest/tokio/net/index.html",
          "excerpts": [
            "This module contains the TCP/UDP/Unix networking types, similar to the standard library, which can be used to implement networking protocols. Â§Organization."
          ]
        },
        {
          "title": "Getting Started with a Client",
          "url": "https://hyper.rs/guides/1/client/basic/",
          "excerpts": [
            "To get started we'll need to get a few things setup. For this guide we're going to send a GET Request to http://httpbin.org/ip, which will return a 200 OK."
          ]
        },
        {
          "title": "Tower Service Documentation",
          "url": "https://docs.rs/tower/latest/tower/trait.Service.html",
          "excerpts": [
            "The client may\nissue requests by invoking `call` and passing the request as an argument. It then receives the response by waiting for the returned future.",
            "### [Required Associated Types]()"
          ]
        }
      ],
      "reasoning": "The user is asking for a comprehensive list of keywords related to Rust's systems and embedded development. The provided excerpts contain a wealth of information directly relevant to this field. Many excerpts explicitly mention `no_std` development, which is fundamental for embedded systems, and discuss the `alloc` crate and global allocators, including `linked_list_allocator` for `no_std` environments. Panic handling strategies like `panic-abort`, `panic-halt`, `panic-semihosting`, `panic-probe`, and `panic-itm` are detailed, along with the concept of `#[panic_handler]`. Hardware interaction is covered through `memory-mapped I/O (MMIO)`, `volatile access` using `core::ptr::read_volatile` and `write_volatile`, and the role of Hardware Abstraction Layers (HALs) like `embedded-hal` and its async/non-blocking variants. Peripheral Access Crates (PACs) are mentioned with `svd2rust` for generation, and specific microcontroller families like `cortex-m` are highlighted. Real-Time Interrupt-driven Concurrency (RTIC) and the `Embassy framework` are presented as solutions for async embedded programming, addressing real-time constraints and concepts like priority inversion and critical sections. Debugging tools such as `probe-rs`, `cargo-embed`, `cargo-flash`, `OpenOCD`, `J-Link`, `GDB`, `Serial Wire Debug (SWD)`, `JTAG`, `Real-Time Transfer (RTT)`, and `Instrumentation Trace Macrocell (ITM)` are also listed. Cross-compilation, including `target triples` and tools like `cargo-zigbuild` and `cargo-binutils`, is discussed. Operating System and Kernel Development in Rust is extensively covered with mentions of `Rust-for-Linux`, `Redox OS`, `Tock OS`, `Asterinas`, `seL4 microkernel`, and `io_uring` with `tokio-uring`. Finally, the importance of `safety-critical systems`, `formal verification`, `model checking`, and tools like `miri` for detecting undefined behavior are also present.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.22",
      "citations": [
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        }
      ],
      "reasoning": "Variance is a formal concept in Rust that describes how subtyping relationships behave when lifetimes or type parameters are varied. An excerpt explicitly defining variance in the context of lifetimes and subtyping provides the strongest direct support for the keyword as a memory-management concept. The passage stating that subtyping is restricted to variance with respect to lifetimes directly ties the term to memory-safety reasoning about how lifetimes relate to one another, which is central to Rustâ€™s memory-management model. Additional excerpts discuss lifetime concepts and borrowing rules, which form the broader context in which variance operates. These latter pieces help situate variance within the overall memory-management framework (lifetimes elision rules, lifetime behavior, and how references are managed), but they are not as targeted as the explicit variance discussion. Together, these excerpts paint variance as a core memory-management concept in Rust, anchored in lifetime subtyping and borrow semantics.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.12",
      "citations": [
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )"
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:"
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly states that a mutable reference is unique to the memory it borrows, i.e., â€œ&mut references are unique (we can rely on no accesses by other functions happening to the memory they point to).â€ This directly supports the idea of an exclusive borrow in memory management because it asserts that mutable borrows cannot share the same memory location with other borrows. A closely related excerpt provides a concrete, crisp rule: â€œMutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value.â€ This precisely encodes the exclusive borrow constraint in Rustâ€™s memory model. Additional excerpts laying out the general borrowing semantics reinforce how references are treated and how their validity is guaranteed, which underpins why exclusive borrowing is necessary for safety: references must point to valid data, and borrows (including mutable ones) impose restrictions on aliasing. The surrounding material on references, borrowing, and lifetimes builds the broader context: references behave as non-owning pointers with guarantees about validity, and lifetime rules (including elision and lifetime checks) help ensure that exclusive access constraints are not violated across scopes. Together, these excerpts corroborate that the finegrained field value â€œExclusive Borrowsâ€ is supported by explicit rules about mutability, aliasing prohibition, and borrow-model semantics, with two-phase borrowing and stacked borrows providing advanced mechanisms that preserve exclusivity during certain phases of borrowing while enabling flexible patterns under controlled conditions.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.35",
      "citations": [
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        }
      ],
      "reasoning": "The target field value is the name of an interpreter used for a memory-model implementation in Rust. The strongest support comes from the passage stating that the memory-aliasing model was implemented in an interpreter named Miri. This directly confirms the existence and use of Miri as an interpreter for memory-model semantics, aligning with the fieldâ€™s focus on memory management tooling and interpretation. Other excerpts discuss related memory-model concepts (e.g., Stacked Borrows, Tree Borrows) but do not explicitly mention Miri or its role as an interpreter, so they offer indirect context rather than direct support for the specific field value. Therefore, the most relevant excerpt provides direct evidence of Miri as the interpreter for the memory-model in question, while the rest offer peripheral background without naming Miri.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.32",
      "citations": [
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explains that Safe Rust guarantees an absence of data races, which directly connects to the purpose of synchronization primitives like a read-write lock (RwLock<T>)â€”to enforce safe concurrent access to shared data. This excerpt also explicitly notes that a data race has undefined behavior, underscoring why a synchronization primitive is critical for correctness in concurrent contexts. The next excerpt reinforces this by stating that data races are prevented largely through Rustâ€™s ownership system, which further substantiates the role of synchronization primitives in avoiding races. The final excerpt defines what constitutes a data race, including concurrent writes, emphasizing why a mechanism like a read-write lock is important to serialize access and prevent unsynchronized mutations. Together, these excerpts support the idea that memory synchronization primitives like RwLock<T> are central to Rustâ€™s concurrency safety model and help prevent memory-access races.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.34",
      "citations": [
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin"
          ]
        }
      ],
      "reasoning": "The most relevant excerpts directly present Stacked Borrows as an aliasing model for Rust. They explicitly frame it as a formal model and discuss how it defines which aliasing is allowed and when undefined behavior occurs, which is central to the concept of a modeling approach for memory access and safety. For example, one excerpt introduces Stacked Borrows as an aliasing model for Rust, articulating its purpose to define which pointer aliasing is permissible and to treat violations as UB under the model. Related excerpts further elaborate the modelâ€™s structure and its use in reasoning about memory accesses (the borrow stack, retagging, barriers) and the aim to formalize how references may interact under unsafe code. Additional excerpts describe how this model has been implemented and evaluated, including discussions of its role in enabling certain optimizations and how it interacts with unsafe code. Collectively, these excerpts support the field value by providing the explicit framing of Stacked Borrows as a formal aliasing model, its core principles, and its application in practice. The surrounding excerpts about related concepts (like two-phase borrows, TB/SB contrasts, and subsequent model variants) provide useful context but are secondary to the direct modeling claims and definitions for Stacked Borrows. The progressive emphasis from model definition to implementation and evaluation strengthens the relevance of these excerpts to the field value, making them the most informative sources for validating the exact concept of a memory model named â€œStacked Borrows Model.â€",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.10",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        }
      ],
      "reasoning": "The field value refers to the immutable borrowing mechanism in Rust. Excerpt describing mutable references and their restriction directly implies the existence of immutable borrows (shared borrows) that can coexist with other reads but cannot be mutated. The passages that define a reference as an address to data owned by another variable, and the demonstrations of borrowing via function parameters using & or borrow semantics, illustrate how immutable borrows work in practice. Specifically:\n- The rule that mutable references cannot be aliased or have other borrows simultaneously establishes the contrast with immutable borrows, which are allowed to coexist with reads. This supports the notion of immutable borrows as the shared borrowing mechanism in Rust.\n- Descriptions of a reference being like a pointer that refers to data owned elsewhere, and the example of passing an immutable borrow into a function, concretely show immutable borrowing in action.\n- The examples using &s1 and calculate_length illustrate taking an immutable borrow and using it without transferring ownership, which aligns with the concept of immutable borrows being non-owning, shared references.\n- The broader discussion of references and borrowing rules, including lifetimes and the guarantees that a reference points to valid data for its life, reinforces the existence and safety properties of immutable borrows.\nOverall, these excerpts collectively support the finegrained field value by detailing what immutable borrows are (shared references that do not transfer ownership) and how Rust enforces their safety in contrast to mutable borrows.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.28",
      "citations": [
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "      + a reference/ `Box` that is dangling, unaligned, or points to an invalid value.",
            "      + a wide reference, `Box` , or raw pointer that has invalid metadata:",
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)",
            "      + a type with custom invalid values that is one of those values, such as a [`NonNull`](../std/ptr/struct.NonNull.html) that is null."
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization",
            "In a language like Rust [ Klabnik and Nichols 2018 ], where the type system imposes a strict\n\ndiscipline on pointer aliasing, it is thus a natural question to ask whether that static discipline can\n\nbe exploited by the compile"
          ]
        }
      ],
      "reasoning": "Interior mutability in Rust hinges on mechanisms that allow mutation through references that are not explicitly declared mutable. The excerpts directly explain that UnsafeCell is a key facility in Rust for enabling this pattern: it is treated like a cast to a raw pointer in some models, and its presence inside a type changes how aliasing and mutation can proceed. Specifically, when UnsafeCell is involved, the standard aliasing guarantees can be relaxed, enabling interior mutability semantics in safe or unsafe contexts. The related passages discuss how UnsafeCell interacts with aliasing rules and how the presence of UnsafeCell can alter what mutations are allowed through aliasing, which is precisely the core idea behind interior mutability. The Tree Borrows and Stacked Borrows excerpts extend this discussion by illustrating how aliasing models must account for unsafe code and for pointers to data protected by UnsafeCell, showing broader implications for when such mutability patterns are sound or could lead to undefined behavior. Together, these excerpts support the notion that interior mutability rests on the ability to mutate through certain privileged abstractions (notably UnsafeCell) and on the nuanced interaction with aliasing models that govern Safe Rust guarantees.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.39",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\")."
          ]
        }
      ],
      "reasoning": "The most directly relevant information comes from excerpts that define Pin as a wrapper that guarantees the pointee will not be moved, and that Pin can wrap a pointer type to enforce pinning. This directly supports understanding how Pin::new would be used to create a pinned value and what guarantees it conveys. Additional excerpts explain that pinning is tied to in-place guarantees and to Pin<&mut T> usage, which further illuminate the typical patterns and constraints around Pin::new in memory-management contexts. Together, these fragments provide a coherent basis for interpreting the semantics and typical use of Pin::new in Rustâ€™s memory-management model.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.33",
      "citations": [
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live."
          ]
        },
        {
          "title": "What Unsafe Can Do - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/what-unsafe-does.html",
          "excerpts": [
            "                - `dyn Trait` metadata is invalid if it is not a pointer to a vtable for `Trait` that matches the actual dynamic trait the pointer or reference points to",
            "                - slice metadata is invalid if the length is not a valid `usize` (i.e., it must not be read from uninitialized memory)"
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "In this work, we propose Stacked Borrows , an operational semantics for memory accesses in Rust. Stacked\n\nBorrows defines an aliasing discipline and declares programs violating it to have undefined behavior , meaning\n\nthe compiler does not have to consider such programs when performing optimization"
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Whatâ€™s more, we are treating _all_ mutable references as two-phase borrows: this is more permissive than what the borrow checker accepts, but lets us treat mutable references entirely uniformly. (This is a point we might want to tweak, but as we will see soon this decision actually has some major unexpected benefits.) This is why we need a tree in the first place: `arg0` and the reference passed to `Vec::len` are both children of `x` . A stack is no longer sufficient to represent the parent-child relationships here. Once the use of a tree is established, modeling of two-phase borrows is fairly intuitive: they start out in a `Reserved` state which tolerates reads from other, unrelated pointers. Only when the reference (or one of its children) is written to for the first time, its state transitions to `Active` and now reads from other, unrelated pointers are not accepted any more. (See Nevenâ€™s post for more details. In particular note that there is one unpleasant surprise lurking here: if there are `UnsafeCell` involved, then a reserved mutable reference actually has to tolerate _mutation_ via unrelated pointers! In other words, the aliasing rules of `&mut T` are now affected by the presence of `UnsafeCell` . I donâ€™t think people realized this when two-phase borrows were introduced, but it also seems hard to avoid so even with hindsight, it is not clear what the alternative would have been.)",
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)"
          ]
        }
      ],
      "reasoning": "UnsafeCell is a key element in the Rust memory model discussions. Excerpts that mention UnsafeCell in the context of two-phase borrowing explain how aliasing rules interact with interior mutability: when there is UnsafeCell somewhere inside a type, the usual aliasing expectations can change, and treatment of mutability and sharing can differ depending on the model (e.g., SB vs TB). The discussion makes it clear that the presence of UnsafeCell inside a type can influence whether references are treated as read-only or have shared/mutable access, and how retagging or lazy initialization affects safety guarantees. This supports the idea that UnsafeCell<T> is a central rock in Rustâ€™s memory-management and aliasing discourse, especially in advanced models like Stack Borrows and Tree Borrows where aliasing discipline interacts with interior mutability. The excerpts explicitly stating that if UnsafeCell is involved, certain aliasing and mutability rules change, provide direct support for understanding how UnsafeCell<T> factors into Rust memory management and safety guarantees. Additionally, the excerpts describing how TB handles UnsafeCell differently from SB illustrate the practical implications of UnsafeCell on optimizations and soundness. By quoting these points, we can connect UnsafeCell<T> to the field value and show its role in interior mutability, aliasing discipline, and unsafe code boundaries.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.38",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\")."
          ]
        }
      ],
      "reasoning": "The target field value is the Unpin trait, which is described as a concept that affects how values interact with pinning guarantees in Rust. The most directly relevant excerpt states that the vast majority of Rust types do not need to care about being pinned and that those types implement the Unpin trait, which removes them from pinning-related guarantees. This provides a clear definition and purpose of Unpin in the memory/pinning context. A closely related excerpt clarifies that certain memory-management types (like Box, Rc, and std::collections) exist to enable correct memory management and are implicated in the broader discussion of ownership and pinning, which supports understanding why Unpin matters in practice. Together, these sources connect the Unpin trait to its role in whether a type participates in or is exempt from certain pinning constraints, which directly answers the fine-grained field value under memory management keywords.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.42",
      "citations": [
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first."
          ]
        }
      ],
      "reasoning": "The field value pertains to the Drop trait and its role in Rustâ€™s memory management. Direct references to destructors and drop semantics support this fine-grained claim. The excerpt describing Destructors explains that when a variable goes out of scope, its destructor is run (i.e., drop is invoked). This aligns with the core meaning of the Drop trait as the mechanism for cleanup. Excerpts about Drop Check discuss how drop order is determined and how resources are dropped, which is central to how the Drop trait governs destruction timing and safety. Specific lines noting that the left vector is dropped first and other drop-order details illustrate concrete behaviors governed by drop semantics, which are in the same conceptual domain as the Drop trait. Together, these excerpts collectively substantiate the field value by linking destruction/destructor semantics to Rustâ€™s drop semantics and order.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.40",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead"
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to Pin::new_unchecked, which is a constructor of Pin that allows creating a Pin-wrapped value in an unsafe way. To assess relevance, we look for excerpts that cover how Rust's Pin works and where unsafe or unchecked behavior arises. The most directly relevant excerpts discuss the Pin type and its intended guarantees: that Pin wraps a pointer and promises the pointee will not be moved, which is the core rationale for Pinâ€™s existence in safe and unsafe contexts. One excerpt explicitly mentions that Pin can wrap a pointer type and that Pin::new can be used to wrap a value, illustrating how Pin wrappers are constructed and used in practice. Other excerpts extend this by explaining Pinâ€™s role in enabling pinned references, and how Future types interact with Pin in typical usage, which is foundational to understanding why an unchecked constructor could be considered unsafe. While none of the excerpts explicitly define Pin::new_unchecked, the content establishes that Pin involves unsafe aspects when creating pinned references, and it clarifies how Pin::new is used in safe contexts, which helps reason about the implications and risks of an unchecked variant.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.37",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees."
          ]
        }
      ],
      "reasoning": "The field value Pin<Ptr> is a concrete instance of the Pin concept in Rust, which is described in the excerpts as a wrapper type that promises the pointee will not be moved. One excerpt explicitly mentions Pin<Ptr> as part of a descriptive line showing Pin in the Pin documentation, illustrating the core idea of pinning a value and its pointer semantics. Another excerpt emphasizes that once a value is pinned, its movement is constrained, which directly supports the notion of Pin as a memory-management primitive that preserves address stability. A related excerpt discusses Pin<&mut Self> and how pinned references behave in practice, underscoring the practical implications of pinning on borrowed/mutable references. Additional excerpts define the Pin type itself (the struct and its relation to Unpin) and show common usage patterns like Pin::new, which are directly relevant to understanding Pin<Ptr> in typical Rust memory-management contexts. In sum, the most directly supportive content defines Pin, explains its memory-stability guarantees, and shows concrete usage patterns, while other nearby content provides helpful background on how pinning interacts with borrowing and general memory semantics.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.46",
      "citations": [
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti"
          ]
        },
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:"
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        }
      ],
      "reasoning": "The field value std::mem::forget is a function that explicitly avoids running destructors and releasing resources for a value, i.e., it interacts directly with the languageâ€™s RAII and memory management semantics. The most directly relevant pieces describe basic memory management and destruction semantics in Rust: the Ownership Based Resource Management (OBRM) discussion explains that resource acquisition and destruction are tied to object lifetime, and destroying an object frees its resource; this is conceptually the counterpart to forgetting a value so its destructor is not run. Follow-on material that explains that memory is managed with memory-safe RAII patterns (Box, Rc, and std::collections usage) further grounds how resources are normally released when owners go out of scope. Destructors and the Drop semantics are explicitly about what happens when a value goes out of scope and its drop/drop-check behavior, which is precisely what std::mem::forget bypasses by avoiding drop. Additionally, core ownership, borrowing, and lifetime discussions (Ownership, References and Borrowing) establish the general rules that memory management relies on, such as the fact that ownership transfers and that resources are freed when the owner goes out of scope, unless explicitly prevented (which is what forgetting would affect). The drop-check references illustrate the ordering and correctness guarantees around resource release, reinforcing why forgetting would represent a deviation from the standard lifecycle. The more general notes on memory management in Rust, including the explicit focus on ownership and the RAII pattern, provide the necessary context to understand where std::mem::forget would fit conceptually, even though the exact function name is not cited directly in the excerpts.",
      "confidence": "low"
    },
    {
      "field": "memory_management_keywords.45",
      "citations": [
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        }
      ],
      "reasoning": "The fine-grained field value refers to a specific attribute (may_dangle) that affects how the drop-checking rules apply to generic parameters and lifetimes. Excerpts that discuss Drop Check, drop order, and destructor behavior provide the foundational rules that govern when references can be considered safe during drops and how the compiler enforces proper destruction order. These excerpts collectively illustrate the environment in which may_dangle would be evaluated: how and when values are dropped, how references are checked for validity across drop, and how analysts reason about safety around destructors and generic parameters. For instance, discussing that variables are dropped in reverse order of definition (drop check) clarifies the lifecycle of values, which is precisely what may_dangle can influence by loosening some constraints on when a reference can outlive a binding. Further, notes on the soundness of drop (and the conditions under which drop-related invariants hold) illuminate how unsafe scenarios could be permitted or restricted, which is central to understanding the potential role and limits of an attribute like may_dangle. The included content on destructor semantics and the drop checker provides concrete context for evaluating how a may_dangle attribute would interact with lifetime and drop behavior. Overall, these excerpts are the most directly relevant because they describe the lifecycle rules around dropping and lifetime safety that a may_dangle annotation would affect, even if they do not mention the attribute by name in isolation.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.44",
      "citations": [
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to the Drop Check mechanism in Rust, which governs the safe destruction of values and the order in which they are dropped. Excerpts explicitly titled Drop Check - The Rustonomicon discuss the drop order and how the destructor is run when a variable goes out of scope, which directly supports the concept of dropck. Other nearby excerpts elaborating on the drop behavior (e.g., the idea that some types have managed drop semantics, and that the borrow checker can track field-level drop behavior) further corroborate the topic. For instance, notes about drop order (variables dropped in reverse order of definition) and the explicit focus on drop-related concerns in the Rustonomicon align with the field value dropck. Additional items referencing Destructors and their relation to scope and drop semantics provide contextual support, reinforcing that destruction and drop checks are central to Rustâ€™s memory management model. Taken together, these excerpts collectively substantiate the field value as describing the drop-check behavior and its implications for memory management and destructor invocation in Rust.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.47",
      "citations": [
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "The left vector is dropped first.",
            "drop order",
            "Drop Check - The Rustonomicon",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand."
          ]
        }
      ],
      "reasoning": "The finegrained field value concerns manual control over when a value is dropped, which in Rust is governed by destructors and drop semantics. The most directly relevant excerpt explains what a destructor is and when it runs as a value goes out of scope, i.e., the Drop behavior that ManuallyDrop<T> would influence by preventing automatic drop. Related excerpts discuss drop checks and the drop order, illustrating how Rust determines the sequence and timing of drops for multiple values and how you can influence it (or bypass it) through manual mechanisms. The text about drop order gives concrete examples of how the lifetime and scope affect when resources are released, which is precisely what a ManuallyDrop<T> pattern is designed to give you control over. Additionally, discussion about destructors in general and the need to manage resources explicitly (when safe abstractions are insufficient) provides context for when one would use ManuallyDrop<T> in practice. Taken together, these excerpts support understanding the concept of manual drop control and its relation to Rustâ€™s memory management model, even if the exact term ManuallyDrop<T> is not present in the excerpts themselves.",
      "confidence": "low"
    },
    {
      "field": "memory_management_keywords.49",
      "citations": [
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```"
          ]
        }
      ],
      "reasoning": "The field value concerns an error that occurs when a value has been moved and then attempted to be used again. The most directly relevant content explains that assigning or passing by value transfers ownership (a move) and that after moving, the previous owner can no longer be used, which is precisely the situation that triggers an E0382-like error. Interpreting this in the rust context, attempting to use a moved value is disallowed and results in a compile-time error. The cited passages explicitly state: ownership is transferred on a move, and after moving resources, the previous owner can no longer be used, which would manifest as using a moved value error. The third nearby excerpt reinforces this by mentioning that moving creates a situation where the original value cannot be used, which aligns with E0382 behavior. Taken together, these excerpts support the notion that the fine-grained field value corresponds to the error that occurs when a moved value is used, and they establish the concrete mechanism (move semantics) behind that error.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.43",
      "citations": [
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "The left vector is dropped first.",
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "\nSound generic drop is enforced by the _drop checker_",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "days: Box::new(1),"
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly states a drop sequence: that a particular value is dropped first (for example, a specific vectorâ€™s elements). This directly supports the concept of drop order as a runtime/semantic property of memory management. Other highly relevant excerpts come from a section explicitly titled Drop Check - The Rustonomicon, which discusses drop order as a formal consideration in safety checks and the drop sequence. Entries that mention the general act of dropping a value (destructors being run) also support the broader understanding of what happens during drop, even if they donâ€™t name the term explicitly. These pieces together provide direct evidence about the order in which resources are released or dropped, as well as the rules governing drop behavior in Rust. The more peripheral entries touch on related concepts (destructors, drop checks, memory safety) to provide necessary context about how drop order interacts with lifetime and resource management, but are slightly less directly about the exact sequence than the explicit statements about drop order themselves.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.51",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased."
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location.",
            "This is why the definition of \"alias\" that Rust will use likely involves some\nnotion of liveness and mutation: we don't actually care if aliasing occurs if\nthere aren't any actual writes to memory happening. Of course, a full aliasing model for Rust must also take into consideration things like\nfunction calls (which may mutate things we don't see), raw pointers (which have\nno aliasing requirements on their own), and UnsafeCell (which lets the referent\nof an `&` be mutated)."
          ]
        }
      ],
      "reasoning": "The most directly relevant information comes from the explicit statement of the mutable borrowing restriction: when you have a mutable reference to a value, you cannot also have other references to that value. This captures the essence of the error E0499, which arises when attempting to borrow as mutable more than once or when a mutable borrow would violate the single-mutable-borrow rule. Closely related are discussions of two-phase borrows, which describe reservation of a mutable borrow and subsequent activation, highlighting how the borrow checker enforces mutual exclusivity between mutable borrows and other borrows, and how reserved/mutably borrowed states constrain simultaneous borrows. Additional material on aliasing explains why mutable borrows must remain unique relative to other references, reinforcing why an error like E0499 would be produced in scenarios where a second mutable borrow would be attempted while a first is active. Together, these excerpts map the concept of E0499 to the core rule about not allowing multiple simultaneous mutable borrows, and they illustrate the surrounding mechanisms (reservation/activation and aliasing rules) that govern when mutable borrows can occur. The strongest support comes from an explicit statement of the restriction on mutable references and the related two-phase borrowing discussions, which together explain why multiple mutable borrows are disallowed and when that rule is enforced.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.55",
      "citations": [
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step."
          ]
        }
      ],
      "reasoning": "The fine-grained field value centers on a lifetime-related compiler error that occurs when a lifetime specifier is missing. Directly relevant material includes: a concise definition of what a lifetime is and how the compiler uses them to ensure borrows are valid; explicit notes on lifetime elision rules, which explain when lifetimes are inferred and when they must be written out; and examples showing how references and borrowing interact with function signatures and data lifetimes. Statements such as: a lifetime is a construct the compiler uses to ensure borrows are valid; the elision rules apply to input/output lifetimes in function signatures; and that a reference guarantees a valid value for the life of that reference all illuminate the circumstances under which a missing lifetime specifier would cause an error. By connecting these excerpts, one can understand that E0106 arises when the compiler cannot infer or is not allowed to elide a lifetime, requiring an explicit annotation. The excerpts about references and borrowing further reinforce how lifetimes relate to ownership and borrowing, clarifying why missing lifetimes can be a frequent source of error in function boundaries and data structure definitions. Together, these excerpts form a cohesive explanation of what E0106 means and how to fix it by adding explicit lifetime annotations or relying on proper elision rules.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.41",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). ",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt describes the Future trait in relation to the return value of async functions and notes that compiler-generated Futures may contain self-referential pointers, which is precisely why Pin is often used with futures to guarantee certain memory semantics. This establishes the direct connection between Future::poll usage and memory-management concerns around pinning and self-referential data in async code. Supporting context excerpts discuss pins and their guarantees (e.g., that Pin is used to ensure that certain futures or types do not get moved in memory), which underpins why Future::poll is memory-management sensitive, even though they do not mention Future::poll by name. Taken together, these excerpts map the field value to the broader memory-safety narrative around futures, polling, and pinning. The ancillary excerpts further illustrate that futures (via Future) interact with pinning semantics, which is relevant for understanding when and how Future::poll can be safely invoked in memory-managed contexts. Specifically, the presence of references to Future in the context of compiler-generated futures and the role of Pin in preventing moves clarifies the memory-management implications of polled futures in Rust.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.36",
      "citations": [
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees."
          ]
        }
      ],
      "reasoning": "To assess the fine-grained field value corresponding to memory_management_keywords.36: Self-Referential Types, we look for information in the excerpts about patterns that make a data structure reference itself after moves, i.e., needs to be pinned or otherwise prevented from being moved. The excerpts about Pin explain why certain values must remain in place: pinning a value promises that the pointee will not be moved or invalidated, which is a core prerequisite for safely implementing self-referential structures that would otherwise become invalid if moved in memory. In particular, the documentation states that a pinned value must remain in place, and that futures and self-referential constructs rely on this to maintain valid references during their lifetime. It also clarifies that most types do not need pinning (Unpin), while those that do require pinning ensure that references to their interior data remain stable. Additionally, examples discuss that when a value is pinned, you can rely on the memory location not being moved, which is essential for self-referential layouts that embed pointers to their own data or to data that is logically tied to the original allocation. The combination of these points supports the idea that self-referential types are a scenario that motivates using Pin and Pin-like guarantees to prevent relocation, thereby enabling safe self-referential patterns. Taken together, these excerpts directly connect the practice of pinning (and the exceptions where it is not needed, via Unpin) to the feasibility and safety of self-referential types in Rust.\n",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.56",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        }
      ],
      "reasoning": "The field value concerns the rule that a function cannot return a reference to data that does not live long enough (e.g., a local variable that goes out of scope). Several excerpts align with this principle by detailing how references work and how lifetimes ensure validity. One excerpt defines a reference as a pointer that accesses data owned elsewhere and emphasizes that borrowed data must live long enough for the reference to remain valid. This directly supports the idea that returning a reference to a local variable is unsafe because the local data would be dropped when the function exits. Another excerpt illustrates using references to pass data into a function rather than transferring ownership, reinforcing the notion that the lifetime of the data being referenced must outlive the reference. Additional excerpts discuss the lifetime and borrowing constraints, including how references must refer to valid data for the life of the reference, and how mutable references are restricted to prevent dangling or invalid memory access. Collectively, these excerpts establish the general rule that references cannot outlive their data, which is the essence of the E0515 error. The most directly relevant parts are those that explicitly define what a reference is, how lifetimes govern validity, and examples where a function uses references (rather than moving ownership) to avoid lifetime issues. The combination of these excerpts provides coherent support for the concept behind E0515, even though the exact error code string is not shown in the excerpts.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.52",
      "citations": [
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf",
          "excerpts": [
            "The problem is that Rust\n\nalso supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to\n\nviolate the aliasing disciplin",
            "In this paper, we propose Stacked Borrows : an operational semantics for Rust that enforces Rustâ€™s\n\naliasing discipline",
            "It does so by introducing clearly-defined conditions under which a Rust program\n\nexhibits undefined behavior due to an aliasing violation",
            "The key idea is to define a dynamic version\n\nof the static analysisÃcalled the borrow checker Ãwhich Rust already uses to check that references\n\nare accessed in accordance with the aliasing disciplin",
            "Raw pointers. Sometimes, the aliasing discipline for references that the borrow checker enforces\n\nis too strict",
            "In this case, one option is to not use references but instead\n\nemploy raw pointers . Raw pointers in Rust basically act like pointers in C: they are not checked by\n\nthe compiler, and there are no aliasing restriction",
            "In line 2, we cast a reference to raw pointer type.",
            "We have\n\nimplemented this model in an interpreter, Miri, which we have run on large parts of the standard\n\nlibrary test suite to verify that, indeed, it adequately captures how **unsafe** Rust code gets writte"
          ]
        },
        {
          "title": "From Stacks to Trees: A new aliasing model for Rust",
          "url": "https://www.ralfj.de/blog/2023/06/02/tree-borrows.html",
          "excerpts": [
            "Basically, raw pointers can live longer than the mutable references they are derived from, which is highly non-intuitive and potentially problematic for program analyses. With TB, the swapped program is still fine, but for a different reason:\nwhen `to` gets created first, it remains a reserved two-phase borrow. This means that creating a shared reference and deriving `from` from it (which acts like a read on `self` ) is fine; reserved two-phase borrows tolerate reads via unrelated pointers. Only when `to` is written to does it (or rather the `&mut self` it was created from) become an active mutable reference that requires uniqueness, but that is after `as_ptr` returns so there is no conflicting `&self` reference. It turns out that consistently using two-phase borrows lets us entirely eliminate this hacky SB rule and also fix one of the most common sources of UB under SB. I didnâ€™t expect this at all, so this is a happy little accident. :)",
            "However, note that the following program is fine under SB but invalid under TB:\n\n```\nlet mut a = [ 0 , 1 ];\nlet to = a .as_mut_ptr () .add ( 1 );\nto .write ( 0 );\nlet from = a .as_ptr ();\nstd :: ptr :: copy_nonoverlapping ( from , to , 1 );\n```\n\nHere, the write to `to` activates the two-phase borrow, so uniqueness is enforced. That means the `&self` created for `as_ptr` (which is considered reading all of `self` ) is incompatible with `to` , and so `to` is invalidated (well, it is made read-only) when `from` gets created.\nSo far, we do not have evidence that this pattern is common in the wild. The way to avoid issues like the code above is to _set up all your raw pointers before you start doing anything_ . Under TB, calling reference-receiving methods like `as_ptr` and `as_mut_ptr` and using the raw pointers they return on disjoint locations is fine even if these references overlap, but you must call all those methods before the first write to a raw pointer. Once the first write happens, creating more references can cause aliasing violations. ## No strict confinement of the accessible memory range\n\nThe other major source of trouble with Stacked Borrows is [restricting raw pointers to the type and mutability they are initially created with](https://github.com/rust-lang/unsafe-code-guidelines/issues/134) . Under SB, when a reference is cast to `*mut T` , the resulting raw pointer is confined to access only the memory covered by `T` . This regularly trips people up when they take a raw pointer to one element of an array (or one field of a struct) and then use pointer arithmetic to access neighboring elements. Moreover, when a reference is cast to `*const T` , it is actually read-only, even if the reference was mutable! Many people expect `*const` vs `*mut` not to matter for aliasing, so this is a regular source of confusion. Under TB, we resolve this by no longer doing any retagging for reference-to-raw-pointer casts.\nA raw pointer simply uses the same tag as the parent reference it is derived from, thereby inheriting its mutability and the range of addresses it can access. Moreover, references are not strictly confined to the memory range described by their type:\nwhen an `&mut T` (or `&T` ) gets created from a parent pointer, we initially record the new reference to be allowed to access the memory range describe by `T` (and we consider this a read access for that memory range). However, we also perform _lazy initialization_ : when a memory location outside this initial range is accessed, we check if the parent pointer would have had access to that location, and if so then we also give the child the same access. This is repeated recursively until we find a parent that has sufficient access, or we reach the root of the tree. This means TB is compatible with [`container_of` \\-style pointer arithmetic](https://github.com/rust-lang/unsafe-code-guidelines/issues/243) and [`extern` types](https://github.com/rust-lang/unsafe-code-guidelines/issues/276) , overcoming two more SB limitations. This also means that the following code becomes legal under TB:\n\n```\nlet mut x = 0 ;\nlet ptr = std :: ptr :: addr_of_mut! ( x );\nx = 1 ;\nptr .read ();\n```\n\nUnder SB, `ptr` and direct access to the local `x` used two different tags, so writing to the local invalidated all pointers to it.\nUnder TB, this is no longer the case; a raw pointer directly created to the local is allowed to alias arbitrarily with direct accesses to the local. Arguably the TB behavior is more intuitive, but it means we can no longer use writes to local variables as a signal that all possible aliases have been invalidated. However, note that TB only allows this if there is an `addr_of_mut` (or `addr_of` ) immediately in the body of a function! If a reference `&mut x` is created, and then some other function derives a raw pointer from that, those raw pointers _do_ get invalidated on the next write to `x` . So to me this is a perfect compromise: code that uses raw pointers has a lower risk of UB, but code that does not use raw pointers (which is easy to see syntactically) can be optimized as much as with SB. Note that this entire approach in TB relies on TB _not_ needing the stack-violating hack mentioned in the previous section. If raw pointers in SB just inherited their parent tag, then they would get invalidated together with the unique pointer they are derived from, disallowing all the code that this hack was specifically added to support. This means that backporting these improvements to SB is unlikely to be possible. ## `UnsafeCell`\n\nThe handling of `UnsafeCell` also changed quite a bit with TB.\nFirst of all, another [major issue](https://github.com/rust-lang/unsafe-code-guidelines/issues/303) with SB was fixed: turning an `&i32` into an `&Cell<i32>` _and then never writing to it_ is finally allowed. This falls out of how TB handles the aliasing allowed with `UnsafeCell` : they are treated like casts to raw pointers, so reborrowing an `&Cell<i32>` just inherits the tag (and therefore the permissions) of the parent pointer. More controversially, TB also changes how precisely things become read-only when an `&T` involves `UnsafeCell` somewhere inside `T` . In particular, for `&(i32, Cell<i32>)` , TB allows mutating _both_ fields, including the first field which is a regular `i32` , since it just treats the entire reference as â€œthis allows aliasingâ€. <sup>[1](:1)</sup> In contrast, SB actually figured out that the first 4 bytes are read-only and only the last 4 bytes allow mutation via aliased pointers. The reason for this design decision is that the general philosophy with TB was to err on the side of allowing more code, having less UB (which is the opposite direction than what I used with SB). This is a deliberate choice to uncover as much of the design space as we can with these two models. Of course we wanted to make sure that TB still allows all the desired optimizations, and still has enough UB to justify the LLVM IR that rustc generates â€“ those were our â€œlower boundsâ€ for the minimum amount of UB we need.\nAnd it turns out that under these constraints, we can support `UnsafeCell` with a fairly simple approach: for the aliasing rules of `&T` , there are only 2 cases. Either there is no `UnsafeCell` anywhere, then this reference is read-only, or else the reference allows aliasing. As someone who thinks a lot about proving theorems about the full Rust semantics including its aliasing model, this approach seemed pleasingly simple. :)",
            "I expected this decision to be somewhat controversial, but the amount of pushback we received has still been surprising. The good news is that this is far from set in stone: we can [change TB to treat `UnsafeCell` more like SB did](https://github.com/rust-lang/unsafe-code-guidelines/issues/403) . Unlike the previously described differences, this one is entirely independent of our other design choices. While I prefer the TB approach, the way things currently stand, I do expect that we will end up with SB-like `UnsafeCell` treatment eventually. ## What about optimizations? I have written a lot about how TB differs from SB in terms of which coding patterns are UB. But what about the other side of the coin, the optimizations? Clearly, since SB has more UB, we have to expect TB to allow fewer optimizations. And indeed there is a major class of optimizations that TB loses: speculative writes, i.e. inserting writes in code paths that would not previously have written to this location.\nThis is a powerful optimization and I was quite happy that SB could pull it off, but it also comes at a major cost: mutable references have to be â€œimmediately uniqueâ€. Given how common of a problem â€œovereager uniquenessâ€ is, my current inclination is that we most likely would rather make all that code legal than allow speculative writes. We still have extremely powerful optimization principles around reads, and when the code _does_ perform a write that gives rise to even more optimizations, so my feeling is that insisting on speculative writes is just pushing things too far. On another front, TB actually allows a set of crucial optimizations that SB ruled out by accident: reordering of reads! The issue with SB is that if we start with â€œread mutable reference, then read shared referenceâ€, and then reorder to â€œread shared reference, then read mutable referenceâ€, then in the new program, reading the shared reference might invalidate the mutable reference â€“ so the reordering might have introduced UB! This optimization is possible without having any special aliasing model, so SB not allowing it is a rather embarrassing problem. If it werenâ€™t for the stack-violating hack that already came up several times above, I think there would be a fairly easy way of fixing this problem in SB, but alas, that hack is load-bearing and too much existing code is UB if we remove it.\nMeanwhile, TB does not need any such hack, so we can do the Right Thing (TM): when doing a read, unrelated mutable references are not entirely disabled, they are just made read-only. This means that â€œread shared reference, then read mutable referenceâ€ is equivalent to â€œread mutable reference, then read shared referenceâ€ and the optimization is saved. (A consequence of this is that retags can also be reordered with each other, since they also act as reads. Hence the order in which you set up various pointers cannot matter, until you do the first write access with one of them.) ## Future possibility: `Unique`\n\nTree Borrows paves the way for an extension that we have not yet implemented, but that I am quite excited to explore: giving meaning to `Unique` . `Unique` is a private type in the Rust standard library that was originally meant to express `noalias` requirements. However, it was never actually wired up to emit that attribute on the LLVM level. `Unique` is mainly used in two places in the standard library: `Box` and `Vec` . SB (and TB) treat `Box` special (matching rustc itself), but not `Unique` , so `Vec` does not come with any aliasing requirements. And indeed the SB approach totally does not work for `Vec` , since we donâ€™t actually know how much memory to make unique here. However, with TB we have lazy initialization, so we donâ€™t need to commit to a memory range upfront â€“ we can make it unique â€œwhen accessedâ€."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines GitHub Repository",
          "url": "https://github.com/rust-lang/unsafe-code-guidelines",
          "excerpts": [
            "The purpose of this repository is to collect and discuss all sorts of questions that come up when writing unsafe code.",
            "The [Unsafe Code Guidelines Reference \"book\"](https://rust-lang.github.io/unsafe-code-guidelines) is a past effort to systematize a consensus on some of these questions. Most of it has been archived, but the [glossary](https://rust-lang.github.io/unsafe-code-guidelines/glossary.html) is still a useful resource.",
            "The [Rustonomicon](https://doc.rust-lang.org/nightly/nomicon/) is a draft document discussing unsafe code. It is intended to\nbe brought into agreement with the content here. It represents an organized\neffort to explain how to write Rust code, rather than a reference."
          ]
        },
        {
          "title": "Unsafe Code Guidelines Reference",
          "url": "http://rust-lang.github.io/unsafe-code-guidelines",
          "excerpts": [
            "Unsafe Code Guidelines Reference",
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on.",
            "However, the [glossary](glossary.html) is actively\nmaintained.",
            "Unless stated otherwise, the information in the guide is mostly a\n\"recommendation\" and still subject to change."
          ]
        },
        {
          "title": "Rust's Unsafe Code Guidelines Reference",
          "url": "https://rust-lang.github.io/unsafe-code-guidelines/introduction.html",
          "excerpts": [
            "This document is a past effort by the [UCG WG](https://github.com/rust-lang/unsafe-code-guidelines) to provide a \"guide\" for\nwriting unsafe code that \"recommends\" what kinds of things unsafe code can and\ncannot do, and that documents which guarantees unsafe code may rely on."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs.",
            "This book exists primarily as a high-level companion to [The Reference](../reference/index.html).",
            "Topics that are within the scope of this book include: the meaning of (un)safety, unsafe primitives provided by the language and standard library, techniques for creating safe abstractions with those unsafe primitives, subtyping and variance, exception-safety (panic/unwind-safety), working with uninitialized memory, type punning, concurrency, interoperating with other languages (FFI), optimization tricks, how constructs lower to compiler/OS/hardware primitives, how to **not** make the memory model people angry, how you're **going** to make the memory model people angry, and more.",
            "g from the ground up.\n\nThis book exists primarily as a high-level companion to [The Reference](../reference/index.html).\nWhere The Reference exists to detail the syntax and semantics of every part of the language, The Rustonomicon exists to describe how to use those pieces together, and the issues that you will have in doing so.",
            "The Rustonomicon is not a place to exhaustively describe the semantics and guarantees of every single API in the standard library, nor is it a place to exhaustively describe every feature of Rust."
          ]
        },
        {
          "title": "Redox - Your Next(Gen) OS",
          "url": "https://www.redox-os.org/",
          "excerpts": [
            "**Redox** is a [**Unix-like**](https://en.wikipedia.org/wiki/Unix-like) general-purpose microkernel-based operating system written in [**Rust**](https://www.rust-lang.org/) ,\n aiming to bring the innovations of Rust to a modern microkernel, a full set of programs and be a complete alternative to Linux and BSD.",
            "* [Microkernel](https://doc.redox-os.org/book/microkernels.html) Design",
            "* [MIT](https://en.wikipedia.org/wiki/MIT_License) Licensed",
            "* Supports [Rust Standard Library](https://doc.rust-lang.org/std/)",
            "* [Drivers](https://doc.redox-os.org/book/drivers.html) run in Userspace",
            "* Partial [POSIX](https://en.wikipedia.org/wiki/POSIX) compatibility",
            "* [Source compatibility](https://doc.redox-os.org/book/programs-libraries.html) with Linux/BSD programs",
            "\n\nRedox running Orbital",
            "* Includes common Unix/Linux [tools](https://doc.redox-os.org/book/system-tools.html)"
          ]
        },
        {
          "title": "The Case for Writing a Kernel in Rust",
          "url": "https://patpannuto.com/pubs/levy17rustkernel.pdf",
          "excerpts": [
            "by A Levy Â· 2017 Â· Cited by 74 â€” ABSTRACT. Decades of research has attempted to add safety mechanisms to operating system kernels, but this effort has failed in most practical systems."
          ]
        },
        {
          "title": "No-Panic Rust: A Nice Technique for Systems Programming",
          "url": "https://blog.reverberate.org/2025/02/03/no-panic-rust.html",
          "excerpts": [
            "Feb 3, 2025 â€” Runtime overhead: A potential panic implies some kind of runtime check. ... For example, memory allocation failure will panic in most cases."
          ]
        },
        {
          "title": "Rust no_std find why global memory allocator is required - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/rust-no-std-find-why-global-memory-allocator-is-required/77679",
          "excerpts": [
            "\n\nI'm writing Rust code for a platform which doesn't have support for std or alloc, so I have to use only core.",
            " 2\n\nThe \"no global memory allocator\" error is triggered the moment anyone tries to link with `alloc`",
            ". The advice I received was (if you can't get rid of the crate linking to `alloc` ), is to simply add a stub allocator that allocates `null` and panics on deallocate.",
            "\nThis topic was automatically closed 90 days after the last reply. We invite you to open a new topic if you have further questions or comments."
          ]
        },
        {
          "title": "linked_list_allocator - crates.io",
          "url": "https://crates.io/crates/linked_list_allocator",
          "excerpts": [
            "Simple allocator usable for no\\_std systems. It builds a linked list from the freed blocks and thus needs no additional data structures",
            "* [# no\\_std](/keywords/no_std"
          ]
        },
        {
          "title": "Rust Embedded - awesome-embedded-rust",
          "url": "https://github.com/rust-embedded/awesome-embedded-rust",
          "excerpts": [
            "In 2018, the Rust community created an embedded working group to help drive adoption in the Rust ecosystem.",
            "Curated list of resources for Embedded and Low-level development in the Rust programming language",
            "The embedded parts use the nRF52840-DK and a LIS3DH breakout board. ( [github source](https://github.com/tweedegolf/rust-workshop) )"
          ]
        },
        {
          "title": "The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/",
          "excerpts": [
            "Welcome to The Embedded Rust Book: An introductory book about using the Rust\nProgramming Language on \"Bare Metal\" embedded systems, such as Microcontrollers.",
            "### [Other Resources]()\n\nIf you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. | Topic | Resource | Description |\n| --- | --- | --- |\n| Rust | [Rust Book](https://doc.rust-lang.org/book/) | If you are not yet comfortable with Rust, we highly suggest reading this book. |\n| Rust, Embedded | [Discovery Book](https://docs.rust-embedded.org/discovery/) | If you have never done any embedded programming, this book might be a better start |\n| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |\n| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |\n| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context.\n|\n| Rust, Embedded | [Comprehensive Rust ðŸ¦€: Bare Metal](https://google.github.io/comprehensive-rust/bare-metal.html) | Teaching material for a 1-day class on bare-metal Rust development",
            "this book targets\n  Rust 2018. * You are comfortable developing and debugging embedded systems in another\n  language such as C, C++, or Ada, and are familiar with concepts such as:\n  + Cross Compilation",
            "  + Memory Mapped Peripherals",
            "  + Interrupts",
            "  + Common interfaces such as I2C, SPI, Serial, etc.",
            "The goals of this book are:\n\n* Get developers up to speed with embedded Rust development. i.e. How to set\n  up a development environment. * Share *current* best practices about using Rust for embedded development. i.e. How to best use Rust language features to write more correct embedded\n  software.",
            "The work on this book is coordinated in [this repository](https://github.com/rust-embedded/book) and is mainly\ndeveloped by the [resources team](https://github.com/rust-embedded/wg).",
            "+ Cross Compilation"
          ]
        },
        {
          "title": "An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise",
          "url": "https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise",
          "excerpts": [
            "RFL leverages **bindgen** to automatically generate Rust bindings of C kernel struct prior to use.",
            "(1) Rust safety mechanism constructs the pillar of kernel safety.",
            "**\n\nSafe abstraction is the key ingredient towards rustifying Linux kernel",
            "gs. As a modern language with rich type specifiers, it facilitates more canonical safety checkers such as **klint** [ [19]() ], and RustBelt [ [53]() ] to further harden the kernel."
          ]
        },
        {
          "title": "Asterinas - GitHub",
          "url": "https://github.com/asterinas/asterinas",
          "excerpts": [
            "GitHub - asterinas/asterinas: Asterinas is a secure, fast, and general-purpose OS kernel, written in Rust and providing Linux-compatible ABI.",
            " _Asterinas: A Linux ABI-Compatible, Rust-Based Framekernel OS with a Small and Sound TCB",
            "Asterinas prioritizes memory safety\n  by employing Rust as its sole programming language\n  and limiting the use of _unsafe Rust_ to a clearly defined and minimal Trusted Computing Base "
          ]
        },
        {
          "title": "no_std - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/intro/no-std.html",
          "excerpts": [
            "no_std is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate."
          ]
        },
        {
          "title": "Rust Embedded Documentation",
          "url": "https://docs.rust-embedded.org/",
          "excerpts": [
            "[The Discovery book](https://docs.rust-embedded.org/discovery/index.html) will teach you about microcontrollers,\nperipherals, sensors and bare metal programming through a series of small, fun\nprojects that youâ€™ll develop in Rust.",
            "ded.org/book/index.html) will get you up to speed with embedded Rust development and then\nteach you how to effectively use the language (AKA patterns) to build more\ncorrect embedded software.",
            "ed/awesome-embedded-rust) resource includes a list of other books, blogs, and\ntraining materials for learning embedded Rust, including complete from-scratch\nproject examples and quickstart templates: [Books, blogs and training materials"
          ]
        },
        {
          "title": "Panicking - The Embedded Rust Book",
          "url": "https://docs.rust-embedded.org/book/start/panicking.html",
          "excerpts": [
            "Panicking is a core part of the Rust language. Built-in operations like indexing\nare runtime checked for memory safety. When out of bounds indexing is attempted\nthis results in a panic. In the standard library panicking has a defined behavior: it unwinds the stack\nof the panicking thread, unless the user opted for aborting the program on\npanics. In programs without standard library, however, the panicking behavior is left\nundefined. A behavior can be chosen by declaring a `#[panic_handler]` function. This function must appear exactly _once_ in the dependency graph of a program,\nand must have the following signature: `fn(&PanicInfo) -> !` , where [`PanicInfo`](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html) is a struct containing information about the location of the panic. Given that embedded systems range from user facing to safety critical (cannot\ncrash) there's no one size fits all panicking behavior but there are plenty of\ncommonly used behaviors. These common behaviors have been packaged into crates\nthat define the `#[panic_handler]` function."
          ]
        },
        {
          "title": "The Redox Operating System",
          "url": "http://doc.redox-os.org/book",
          "excerpts": [
            "Redox OS is a general-purpose operating system written in [Rust](https://www.rust-lang.org) . Our aim is to provide a fully functioning Unix-like microkernel-based operating system, that is secure, reliable and free.",
            "Redox OS was created in 2015 before the first stable version (1.0) of the Rust compiler and was one of the first operating systems written in Rust.",
            "To achieve that, Redox was redesigned to adopt a microkernel architecture and a unified system API for resources.",
            "This book is written in a way that you doesn't require any prior knowledge of Rust or OS development."
          ]
        },
        {
          "title": "Writing an OS in Rust",
          "url": "http://os.phil-opp.com/",
          "excerpts": [
            "\n\nThis blog series creates a small operating system in the [Rust programming language](https://www.rust-lang.org/) . Each post is a small tutorial and includes all needed code, so you can follow along if you like. The source code is also available in the corresponding [Github repository](https://github.com/phil-opp/blog_os) .",
            "\n\nThe first step in creating our own operating system kernel is to create a Rust executable that does not link the standard library. This makes it possible to run Rust code on the [bare metal](https://en.wikipedia.org/wiki/Bare_machine) without an underlying operating system.",
            " [A Freestanding Rust Binary",
            "\n\nIn this post, we explore _cooperative multitasking_ and the _async/await_ feature of Rust.",
            " [Introduction to Paging",
            " [Paging Implementation"
          ]
        },
        {
          "title": "Preface - The Embedonomicon",
          "url": "https://docs.rust-embedded.org/embedonomicon/",
          "excerpts": [
            "You'll learn about linkers, linker scripts and about the Rust features that let you control a bit of the ABI of Rust programs. A trick to implement defaultÂ ..."
          ]
        },
        {
          "title": "Choose Your Discovery",
          "url": "https://docs.rust-embedded.org/discovery/",
          "excerpts": [
            "Discover the world of microcontrollers through Rust! There are currently three versions of this book. All of them provide an introduction to microcontrollers."
          ]
        },
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            "\n\nOwnership is Rustâ€™s most unique feature and has deep implications for the rest\nof the language. It enables Rust to make memory safety guarantees without\nneeding a garbage collector, so itâ€™s important to understand how ownership\nworks.",
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Lessons learned from a successful Rust rewrite",
          "url": "https://gaultier.github.io/blog/lessons_learned_from_a_successful_rust_rewrite.html",
          "excerpts": [
            "Doing an incremental rewrite from C/C++ to Rust, we had to use a lot of raw pointers and `unsafe{}` blocks.",
            "The rewrite was done incrementally, in a stop-and-go fashion. At some point, as I expected, we had to add brand new features while the rewrite was on-going and that was very smooth with this approach.",
            "All the stringent rules of Rust still apply inside these blocks but the compiler just stops checking them for you, so you are on your own.",
            "As such, it's so easy to introduce Undefined Behavior.",
            "Pure Rust is already very complex, but add to it the whole layer that is mainly there to deal with FFI, and it really becomes a beast.",
            "Some developers in our team straight declined to work on this codebase, mentioning the real or perceived Rust complexity.",
            "Now, I think that Rust is still mostly easier to learn than C++, but admittedly not by much, especially in this FFI heavy context.",
            "If you do not yet know Rust, I recommend for your first project to use pure Rust, and stay far away from the whole FFI topic.",
            "Same issue as with Miri, using libraries with a Rust API but with parts implemented in C or Assembly will make `cargo build --target=...` not work out of the box.",
            "I am mostly satisfied with this Rust rewrite, but I was disappointed in some areas, and it overall took much more effort than I anticipated."
          ]
        },
        {
          "title": "Stop Breaking Production: The Rust Migration Guide No One Told You About",
          "url": "https://medium.com/@harishsingh8529/stop-breaking-production-the-rust-migration-guide-no-one-told-you-about-c89984f72d7a",
          "excerpts": [
            "Rust offers:\n\n* Memory safety without GC\n* Blazing fast execution\n* Fearless concurrency\n* Smaller binaries"
          ]
        }
      ],
      "reasoning": "The field value is a precise error about borrowing with conflicting mutability: when a borrow is attempted with mutable and immutable contexts, Rustâ€™s borrow checker issues an error indicating the conflicting mutability. The most directly supportive excerpt states the exact error code and description: borrowing a variable that is already borrowed with one mutability, and then borrowing it again with a different mutability. This directly confirms the meaning and nature of the value being analyzed. Contextual support comes from excerpts that describe the borrow checkerâ€™s general role and its rules around mutability and aliasing: they explain that borrows are governed by mutability constraints and that certain borrows cannot co-exist in conflicting ways, which underpins why the explicit E0502 error exists. Additional excerpts discuss concepts like two-phase borrows and aliasing rules (e.g., immutable vs mutable borrows, and the impossibility of aliasing a mutable borrow in certain scenarios). These pieces reinforce the mechanism by which the borrow checker determines when mutability conflicts arise, even though they do not mention the exact error code. The combination of a direct citation of the error and the broader explanation of borrow rules provides coherent evidence for the field value being correct and well-supported by the excerpts.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.29",
      "citations": [
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "* Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:\n  `&T` must point to memory that is not mutated while they are live (except for data inside an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)),\n  and `&mut T` must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.",
            "Moreover, the bytes [pointed to]() by a shared reference, including transitively through other references (both shared and mutable) and `Box`es, are immutable; transitivity includes those references stored in fields of compound types.",
            "The bytes owned by an immutable binding or immutable `static` are immutable, unless those bytes are part of an [`UnsafeCell<U>`](../core/cell/struct.UnsafeCell.html)."
          ]
        }
      ],
      "reasoning": "The most relevant excerpt explicitly analyzes how a composite type containing a Cell<T> participates in an aliasing model. It states that Tree Borrows allows mutating both fields of a tuple where one field is a regular integer and the other is Cell<i32>, because the model treats the reference as having access to the larger structure, effectively enabling interior mutability through the Cell<T> component within the aliasing discipline. This directly supports the notion that Cell<T> is a memory-management primitive used to express interior mutability and aliasing behavior under Rustâ€™s advanced safety models. Additional excerpts discuss UnsafeCell and general unsafe guidelines; these provide important surrounding context about how interior mutability and unsafe code relate to aliasing rules, but they do not as concretely illustrate the Cell<T> semantics as the TB-focused excerpt does. Taken together, these excerpts support the memory-management semantics of Cell<T> by showing how a cell-like type participates in aliasing and mutability rules under Tree Borrows, which is relevant to the finegrained field value in question.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.58",
      "citations": [
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "Rust code is incorrect if it exhibits any of the behaviors in the following\nlist. This includes code within `unsafe` blocks and `unsafe` functions. `unsafe` only means that avoiding undefined behavior is on the programmer; it\ndoes not change anything about the fact that Rust programs must never cause\nundefined behavior. [[undefined .soundness]](.soundness \"undefined.soundness\")\n\nIt is the programmerâ€™s responsibility when writing `unsafe` code to ensure that\nany safe code interacting with the `unsafe` code cannot trigger these\nbehaviors. `unsafe` code that satisfies this property for any safe client is\ncalled _sound_ ; if `unsafe` code can be misused by safe code to exhibit\nundefined behavior, it i"
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith. Specifically, we need to worry about function arguments that make `input` and `output` overlap, such as `compute(&x, &mut x)` . With that input, we could get this execution:\n\n```rust\n//  input ==  output == 0xabad1dea\n                    // *input == *output == 20\nif *input > 10 {    // true  (*input == 20)\n    *output = 1;    // also overwrites *input, because they are the same\n}\nif *input > 5 {     // false (*input == 1)\n    *output *= 2;\n}\n                    // *input == *output == 1\n```\n\nOur optimized function would produce `*output == 2` for this input, so the\ncorrectness of our optimization relies on this input being impossible. In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations! Some examples:\n\n* keeping values in registers by proving no pointers access the value's memory\n* eliminating reads by proving some memory hasn't been written to since last we read it\n* eliminating writes by proving some memory is never read before the next write to it\n* moving or reordering reads and writes by proving they don't depend on each other",
            "In the previous example, we used the fact that `&mut u32` can't be aliased to prove\nthat writes to `*output` can't possibly affect `*input` . This lets us cache `*input` in a register, eliminating a read. By caching this read, we knew that the write in the `> 10` branch couldn't\naffect whether we take the `> 5` branch, allowing us to also eliminate a\nread-modify-write (doubling `*output` ) when `*input > 10` . The key thing to remember about alias analysis is that writes are the primary\nhazard for optimizations. That is, the only thing that prevents us\nfrom moving a read to any other part of the program is the possibility of us\nre-ordering it with a write to the same location."
          ]
        }
      ],
      "reasoning": "The field value refers to a concept where borrowing behavior is analyzed in a context that could involve repetitive or loop-like usage. Direct descriptions of two-phase borrows demonstrate how a borrow can start in a reserved (shared) state and later become mutably borrowed, which is exactly the kind of behavior that would occur inside a loop where a reference is reused across iterations. The material that explains the reservation/activation workflow shows borrowing that persists through multiple steps before mutation occurs, which aligns well with a â€œborrowing loopâ€ pattern where a borrow cycle spans multiple operations. In addition, broader aliasing discussions (Stacked Borrows and Tree Borrows) expand how borrowing interacts with multiple references over a sequence of actions, which is also a loop-like scenario where borrow state can be propagated, retagged, or activated later. The general references and borrowing entries provide foundational definitions of what a reference is and how borrows relate to ownership, which supports understanding of more complex looping borrowing behavior. On balance, the strongest support comes from explicit two-phase borrowing descriptions, while supporting context comes from broader borrowing/aliasing entries and models that describe ongoing borrow interactions across multiple steps.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.0",
      "citations": [
        {
          "title": "ndarray - Rust Documentation",
          "url": "https://docs.rs/ndarray/",
          "excerpts": [
            "The `ndarray` crate provides an n-dimensional container for general elements and for numerics. ndarray - Rust",
            "An n-dimensional array for general elements and for numerics. Lightweight array views and slicing; views support chunking and splitting.",
            "ndarray` provides a lot of functionality, but itâ€™s not a one-stop solution. `ndarray` includes matrix multiplication and other binary/unary operations out of the box. More advanced linear algebra routines (e.g. SVD decomposition or eigenvalue computation)\ncan be found in [`ndarray-linalg"
          ]
        },
        {
          "title": "ndarray-linalg - Rust",
          "url": "https://docs.rs/ndarray-linalg/",
          "excerpts": [
            "The `ndarray-linalg` crate provides linear algebra functionalities for `ArrayBase`, the n-dimensional array data structure provided by `ndarray`."
          ]
        },
        {
          "title": "Awesome-Rust-MachineLearning (and related Rust domains)",
          "url": "https://github.com/vaaaaanquish/Awesome-Rust-MachineLearning",
          "excerpts": [
            "ndarray-stats) \\- Statistical routines for ndarray"
          ]
        }
      ],
      "reasoning": "The finegrained field value corresponds to the ndarray concept in Rust. The most relevant content directly identifies ndarray as the Rust crate that provides an n-dimensional container, establishing its primary purpose and context within Rustâ€™s scientific computing landscape. Supporting content expands on its capabilities (such as matrix multiplication and other operations) and situates ndarray within its ecosystem by mentioning related libraries (ndarray-linalg and ndarray-stats). Together, these excerpts establish both the core definition of ndarray and its practical capabilities and ecosystem, which directly aligns with researching the keyword in the Rust scientific computing and ML space.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.60",
      "citations": [
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        }
      ],
      "reasoning": "Temporary lifetime extension pertains to how Rust infers or permits shorter lifetimes to be extended by compiler rules, such as lifetime elision and the two-phase borrow model. Content that explicitly describes lifetime elision rules explains how input lifetimes can be inferred or treated as longer for certain outputs, which is a direct mechanism by which a lifetime is effectively extended without explicit annotation. The cited excerpts cover the rules and patterns for lifetime elision, including when and how lifetimes are inferred and assigned to parameters and return values. Additionally, two-phase borrow discussions illuminate how lifetimes interact with reserved (read-only) versus active (mutable) phases, which is another form of temporary extension of permissible access within a borrowed region. Evidence from the elision-focused items shows explicit rules for when lifetimes can be elided or inferred, thereby extending the perceived lifetime of references in practice. The two-phase borrow material demonstrates how lifetime-related permissions can be extended temporarily during a reservation phase before a borrow becomes fully active, aligning with the concept of temporary lifetime extension in the borrowing model. Collectively, these excerpts directly support the idea of temporally extending the effective lifetime of borrows or references through compiler rules and borrow-checking behavior. ",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.50",
      "citations": [
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step."
          ]
        }
      ],
      "reasoning": "The central idea behind the fine-grained field value is the rule that you cannot assign to or mutate through a borrowed reference. An excerpt stating that a mutable reference cannot have any other references to the value captures the core constraint that underpins such an error: attempting to assign through a borrowed value would violate this rule. The language of the example excerpt explicitly describes the restriction as a general principle for mutable references, which directly supports the notion behind the error code E0506. Another excerpt notes a specific error code (even if not the exact E0506) that encodes a mutability/borrowing conflict, reinforcing that borrow rules produce compile-time errors when trying to mutate through a borrow. Additional excerpts discuss two-phase borrows and reservation/activation semantics, which illuminate how Rustâ€™s borrow checker reason about when a mutable borrow is active versus reserved and how that affects permitted operations; these provide contextual backing for why assigning through a borrowed reference is disallowed in many borrowing states. Collectively, the most relevant passages establish that mutable borrows prohibit other references and mutations, which is the underlying rationale for an error like cannot assign to a borrowed value. The surrounding discussion about two-phase borrows adds nuance by showing how temporary reservations can permit reads but restrict writes, which is compatible with the idea that an assignment to a borrowed value would be disallowed in practice during certain borrow phases.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.54",
      "citations": [
        {
          "title": "Behavior considered undefined - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html",
          "excerpts": [
            "* A reference or [`Box<T>`](../alloc/boxed/struct.Box.html) must be aligned and non-null, it cannot be [dangling](), and it must point to a valid value"
          ]
        },
        {
          "title": "std::mem::MaybeUninit - Rust",
          "url": "https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html",
          "excerpts": [
            "(mutable) reference to uninitialized memory! // This is undefined behavi",
            "(mutable) reference to uninitialized memory! // This is undefined behavior.",
            "Gets a pointer to the contained value. Reading from this pointer or turning it\ninto a reference is undefined behavior unless the `MaybeUninit<T>` is initialized. Writing to memory that this pointer (non-transitively) points to is undefined behavior\n(except inside an `UnsafeCell<T>` )."
          ]
        }
      ],
      "reasoning": "Directly relevant evidence includes explicit statements that a reference must be non-dangling and must point to a valid value. This directly supports the concept of a dangling reference as a correctness concern in memory management. Additionally, discussions about undefined behavior when dealing with uninitialized memory or references to uninitialized data reinforce the underlying memory-safety issues that give rise to a dangling reference error. The cited statements collectively map to the idea that using a reference that might be invalid or points to memory that isnâ€™t guaranteed to be valid constitutes undefined behavior or a safety violation, which is precisely what E0597 captures. The strongest match is the explicit assertion that a reference or Box<T> must be non-dangling and point to a valid value, followed by explicit warnings about undefined behavior when dealing with uninitialized memory and mutable references to uninitialized memory. The excerpts describing UB related to uninitialized memory provide supportive context for why a dangling reference is problematic and error-worthy, even if they donâ€™t name E0597 directly.",
      "confidence": "medium"
    },
    {
      "field": "memory_management_keywords.57",
      "citations": [
        {
          "title": "Understanding Ownership - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html",
          "excerpts": [
            " In this chapter, weâ€™ll talk about ownership as well as several related\nfeatures: borrowing, slices, and how Rust lays data out in memory.",
            "\n\nOwnership is Rustâ€™s most unique feature and has deep implications for the rest\nof the language. It enables Rust to make memory safety guarantees without\nneeding a garbage collector, so itâ€™s important to understand how ownership\nworks."
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference."
          ]
        }
      ],
      "reasoning": "The target field value concerns avoiding unnecessary cloning as part of memory management strategies. Excerpts that explain ownership and borrowing patterns, and when moves or references can replace cloning, directly support this concept. Excerpts focused on the core ownership model explain why a value can be moved or borrowed instead of cloned, which is exactly how one avoids unnecessary clone() calls. For instance, foundational discussions of ownership establish that each value has a single owner and moves transfer ownership rather than duplicating data, which underpins the choice to avoid cloning. Discussions that compare moves versus copies reinforce the idea that copying is often unnecessary when ownership can be transferred or borrowed. By understanding borrowing rules and how references can be used without transferring ownership or duplicating data, one can design code paths that do not require clone(). Partial moves and By Example patterns illustrate practical scenarios where ownership can be transferred or borrowed to avoid unnecessary duplication. The borrowing and lifetimes material clarifies how you can read data without cloning, which is a key mechanism for memory-efficient Rust patterns. In short, these excerpts collectively reinforce the strategy: prefer moves and borrows over cloning when possible, to minimize unnecessary memory duplication.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.48",
      "citations": [
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc"
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:"
          ]
        }
      ],
      "reasoning": "The central concept of a 'Borrow Checker Error' is the enforcement by the borrow checker that certain actions are not allowed because they would violate Rust's ownership and borrowing rules. A passage that characterizes the borrow checker as the mechanism enforcing a concrete set of properties provides direct support for what constitutes an error in this context. It explains that the borrow checker's role is to uphold critical invariants that prevent invalid borrows and mutations while a reference is live. Another passage lists explicit mutability and borrowing constraints (e.g., you cannot move a value twice, you cannot access a place while it is mutably borrowed, and you cannot mutate while immutably borrowed). This directly maps to the kinds of runtime or compile-time errors the Borrow Checker would report. Related discussions on two-phase borrows extend the model by introducing a reservation phase for mutable borrows and specify when activations can occur; this context helps explain more nuanced error scenarios where an operation is performed while a borrow is in a conflicting phase. The collection of these excerpts together provides a coherent narrative: the Borrow Checker enforces a set of strict ownership/borrowing invariants, violations of which trigger errors, and two-phase borrowing adds additional rules and potential error points during reservation and activation phases.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.3",
      "citations": [
        {
          "title": "GitHub - e-tornike/best-of-ml-rust",
          "url": "https://github.com/e-tornike/best-of-ml-rust",
          "excerpts": [
            "- Burn is a new comprehensive dynamic Deep Learning Framework built using.. `Apache-2`"
          ]
        }
      ],
      "reasoning": "To support the field value Burn, the most relevant excerpt directly states that Burn is a new comprehensive dynamic Deep Learning Framework built using Apache-2.0. This provides a precise identification of Burn as a framework and gives licensing information, which is a concrete attribute of Burn. Other excerpts discuss Rust ML libraries, linear algebra crates, or GPU and game-engine ecosystems, which are related to the broader research space but do not provide direct information about Burn itself. Therefore, the content that explicitly names Burn and describes Burn as a dynamic deep learning framework is the strongest and sole direct evidence for the field value.",
      "confidence": "medium"
    },
    {
      "field": "scientific_computing_and_ml_keywords.5",
      "citations": [
        {
          "title": "smartcorelib/smartcore",
          "url": "https://github.com/smartcorelib/smartcore",
          "excerpts": [
            "A comprehensive library for machine learning and numerical computing. Apply Machine Learning with Rust leveraging first principles."
          ]
        }
      ],
      "reasoning": "The finegrained field value corresponds to a specific library used for machine learning and numerical computing in Rust. The most directly supporting content is a line that identifies the library by name and describes its purpose: a comprehensive library for machine learning and numerical computing, enabling application of machine learning in Rust based on first principles. This directly confirms the existence and intended use of the library within the Rust ML/ecosystem. Since no other excerpts explicitly mention this particular library by name, they provide only contextual or peripheral support about ML in Rust but do not substantively confirm the exact field value. Therefore, the most relevant evidence is the direct library-name reference and its stated focus on ML and numerical computing in Rust, which aligns with the requested field value.",
      "confidence": "high"
    },
    {
      "field": "desktop_mobile_and_wasm_keywords",
      "citations": [
        {
          "title": "Introduction - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/?search=edition",
          "excerpts": [
            "The edition of a package is specified in the Cargo.toml manifest , and individual targets can specify which edition they use. See the Edition Guide for more ..."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html)."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times."
          ]
        },
        {
          "title": "sled v1.0.0-alpha.1 - Lightweight high-performance pure-rust transactional embedded database",
          "url": "https://crates.io/crates/sled/1.0.0-alpha.1",
          "excerpts": [
            "Or add the following line to your Cargo.toml:",
            "sled = \"=1.0.0-alpha.1\"",
            "documentation",
            "[docs.rs/sled/1.0.0-alpha.1](https://docs.rs/sled/1.0.0-alpha.1)",
            "Repository",
            "[github.com/spacejam/sled](https://github.com/spacejam/sled)"
          ]
        },
        {
          "title": "Polars: DataFrames in Rust",
          "url": "https://docs.rs/polars/latest/polars/",
          "excerpts": [
            "Polars: DataFrames in Rust",
            "Polars is a DataFrame library for Rust. It is based on [Apache Arrow](https://arrow.apache.org/)â€™s memory model. Apache Arrow provides very cache efficient columnar data structures and is becoming the defacto\nstandard for columnar data.",
            "Polars is a DataFrame library for Rust.",
            "The base data structures provided by polars are [`DataFrame`](prelude/struct.DataFrame.html \"struct polars::prelude::DataFrame\"), [`Series`](prelude/struct.Series.html \"struct polars::prelude::Series\"), and [`ChunkedArray<T>`](prelude/struct.ChunkedArray.html \"struct polars::prelude::ChunkedArray\").",
            "We recommend building queries directly with [polars-lazy](https://docs.rs/polars-lazy/0.50.0/x86_64-unknown-linux-gnu/polars_lazy/index.html \"mod polars_lazy\"). This allows you to combine\nexpressions into powerful aggregations and column selections. All expressions are evaluated\nin parallel and queries are optimized just in time.",
            "This means that Polars data structures can be shared zero copy with processes in many different\nlanguages.",
            "* `POLARS_TABLE_WIDTH` -> width of the tables used during DataFrame formatting.",
            "* `POLARS_MAX_THREADS` -> maximum number of threads used to initialize thread pool (on startup).",
            "* `POLARS_VERBOSE` -> print logging info to stderr.",
            "* `POLARS_NO_PARTITION` -> polars may choose to partition the group\\_by operation, based on data\n  cardinality. Setting this env var will turn partitioned group\\_byâ€™s of",
            "* `POLARS_PARTITION_UNIQUE_COUNT` -> at which (estimated) key count a partitioned group\\_by should run. defaults to `1000`, any higher cardinality will run default group\\_by.",
            "* `POLARS_FORCE_PARTITION` -> force partitioned group\\_by if the keys and aggregations allow it.",
            "* `POLARS_ALLOW_EXTENSION` -> allows for [`ObjectChunked<T>`](prelude/type.ObjectChunked.html \"type polars::prelude::ObjectChunked\") to be used in arrow, opening up possibilities like using\n  `T` in complex lazy expressions. However this does require `unsafe` code allow thi",
            "* `POLARS_NO_PARQUET_STATISTICS` -> if set, statistics in parquet files are ignored.",
            "* `POLARS_PANIC_ON_ERR` -> panic instead of returning an Error.",
            "* `POLARS_BACKTRACE_IN_ERR` -> include a Rust backtrace in Error messages.",
            "* `POLARS_NO_CHUNKED_JOIN` -> force rechunk before join",
            "If you want to read more, check the [user guide](https://docs.pola.rs/)."
          ]
        },
        {
          "title": "Polars: Blazingly Fast DataFrame Library",
          "url": "https://docs.pola.rs/",
          "excerpts": [
            "Polars is a blazingly fast DataFrame library for manipulating structured data. The core is written\nin Rust, and available for Python, R and NodeJS. ## Key features",
            "Fast** : Written from scratch in Rust, designed close to the machine and without external\n   dependencie",
            "I/O** : First class support for all common data storage layers: local, cloud storage & database",
            "Intuitive API** : Write your queries the way they were intended. Polars, internally, will\n   determine the most efficient way to execute using its query optimize",
            "Out of Core** : The streaming API allows you to process your results without requiring all your\n   data to be in memory at the same tim",
            "Parallel** : Utilises the power of your machine by dividing the workload among the available CPU\n   cores without any additional configuratio"
          ]
        },
        {
          "title": "sqlx-cli 0.5.7",
          "url": "https://docs.rs/crate/sqlx-cli/0.5.7",
          "excerpts": [
            "SQLx CLI. SQLx's associated command-line utility for managing databases, migrations, and enabling \"offline\" mode with sqlx::query!() and friends."
          ]
        },
        {
          "title": "moka - Rust",
          "url": "https://docs.rs/moka/latest/moka/",
          "excerpts": [
            "Moka is a fast, concurrent cache library for Rust. Moka is inspired by the Caffeine library for Java. Moka provides in-memory concurrent cache implementations."
          ]
        },
        {
          "title": "deadpool_redis - Rust",
          "url": "https://docs.rs/deadpool-redis/latest/deadpool_redis/",
          "excerpts": [
            "Deadpool is a dead simple async pool for connections and objects of any type. This crate implements a deadpool manager for redis."
          ]
        },
        {
          "title": "cached - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/cached",
          "excerpts": [
            "cached provides implementations of several caching structures as well as a handy macros for defining memoized functions."
          ]
        },
        {
          "title": "moka-rs/moka: A high performance concurrent caching ...",
          "url": "https://github.com/moka-rs/moka",
          "excerpts": [
            "Moka is a fast, concurrent cache library for Rust. Moka is inspired by the Caffeine library for Java. Moka provides cache implementations on top of hash maps."
          ]
        },
        {
          "title": "postcard - Rust",
          "url": "https://docs.rs/postcard/latest/postcard/",
          "excerpts": [
            "Postcard is a #![no_std] focused serializer and deserializer for Serde. Postcard aims to be convenient for developers in constrained environments."
          ]
        },
        {
          "title": "sqlx-cli - crates.io",
          "url": "https://crates.io/crates/sqlx-cli",
          "excerpts": [
            "SQLx's associated command-line utility for managing databases, migrations, and enabling \"offline\"\nmode with `sqlx::query! ()` and friends.",
            "sqlx migrate add <name>",
            "All commands require that a database url is provided. This can be done either with the `--database-url` command line option or by setting `DATABASE_URL` , either in the environment or in a `.env` file\nin the current working directory.",
            "sqlx migrate run",
            "Compares the migration history of the running database against the `migrations/` folder and runs\nany scripts that are still pending.",
            "Users can provide the directory for the migration scripts to `sqlx migrate` subcommands with the `--source` flag.",
            "sqlx-cli v0.8.6"
          ]
        },
        {
          "title": "probe-rs",
          "url": "https://probe.rs/",
          "excerpts": [
            "* C",
            "Loading...",
            "Easy debugging in VSCode",
            "Use [VSCode's](/docs/tools/debugger/) awesome debug capabilities",
            " with our native debug plugin. Run the target, set breakpoints, halt on break point, inspect the",
            "\n and GDB-like expressions can be evaluated in the built in [REPL]",
            " VSCode not your cup of tea? No problem!"
          ]
        },
        {
          "title": "Tooling - The Embedded Rust Book",
          "url": "https://doc.rust-lang.org/beta/embedded-book/intro/tooling.html",
          "excerpts": [
            "OpenOCD",
            "J-Link",
            " [GDB (GNU Debugger)"
          ]
        }
      ],
      "reasoning": "The selected excerpts mention specific keywords and tools related to desktop and web application frameworks (like `Tauri`, `iced`, `egui`, `Dioxus`, `wgpu`), mobile development support (`cargo-mobile2`, `Android NDK`, `JNI`, `iOS FFI`), and WebAssembly technologies (`wasm32-unknown-unknown`, `wasm32-wasi`, `wasm-bindgen`, `wasm-pack`, `WIT`, `wit-bindgen`, `cargo-component`). These references confirm the focus on keywords for developing cross-platform, WebAssembly, and native desktop/mobile applications in Rust.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.16",
      "citations": [
        {
          "title": "5 popular Rust game engines",
          "url": "https://dev.to/logrocket/5-rust-game-engines-to-consider-for-your-next-project-1l0c",
          "excerpts": [
            "methyst.rs/) is a data-driven and data-oriented game engine written in R"
          ]
        },
        {
          "title": "Are we game yet? Ecosystem - Engines (Rust game development ecosystem)",
          "url": "https://arewegameyet.rs/ecosystem/engines/",
          "excerpts": [
            "* ### [ggez](https://crates.io/crates/ggez)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A lightweight game framework for making 2D games with minimum friction, inspired by Love2D. + Latest version:\n\n    0.9.3\n  + Downloads:\n\n    483,884\n  + Recent downloads:\n\n    51,162\n  + License:\n\n    MIT\n  + Stars:\n\n    4,487\n  + Last activity:\n\n    2025-08-14"
          ]
        }
      ],
      "reasoning": "The most relevant excerpt directly mentions the term 'ggez' in the context of a Rust game engine, listing it among other engines and indicating it is a lightweight game framework for 2D games. This provides explicit evidence that ggez is a Rust game engine and is relevant to the field value. The second excerpt includes 'ggez' as part of a broader list of Rust game engines, indicating its place in the ecosystem, which corroborates the relevance but is slightly less direct about its characteristics. Together, these excerpts support the notion that ggez is a Rust game engine and is within the scope of Rust-related knowledge areas you aim to catalog. ",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.2",
      "citations": [
        {
          "title": "faer - Rust Linear Algebra Library",
          "url": "https://docs.rs/faer/latest/faer/",
          "excerpts": [
            "`faer` is a general-purpose linear algebra library for rust, with a focus on high performance\nfor algebraic operations on medium/large matrices, as well as matrix decompositions",
            "`faer` is recommended for applications that handle medium to large dense matrices, and its\ndesign is not well suited for applications that operate mostly on low dimensional vectors and\nmatrices such as computer graphics or game development.",
            "enables experimental simd features such as avx512"
          ]
        }
      ],
      "reasoning": "The field value corresponds to a Rust linear algebra library named 'faer'. The most directly supportive excerpt explicitly calls faer a general-purpose linear algebra library for Rust, highlighting its focus on high performance for algebraic operations on medium to large matrices and on matrix decompositions. This precisely matches the intended characterization of faer as a linear algebra library with performance emphasis and lattice of matrix operations. The next excerpt reinforces this by stating faer is recommended for applications that handle medium to large dense matrices, reinforcing the libraryâ€™s target use-case and performance orientation. The following excerpt notes that faer enables experimental SIMD features such as AVX-512, which directly ties faer to performance-oriented optimizations and modern hardware acceleration, further supporting its role in high-performance linear algebra in Rust. Collectively, these excerpts establish faer as a Rust linear algebra library focused on performance and matrix computations, with some note of SIMD acceleration capabilities.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.18",
      "citations": [
        {
          "title": "Exploring the Theory and Practice of Concurrency in the Entity-Component-System Pattern",
          "url": "https://users.soe.ucsc.edu/~lkuper/papers/core-ecs-draft.pdf",
          "excerpts": [
            "The Entity-Component-System (ECS) software design pattern, long used in game development and similar\ndomains, encourages a clean separation of identity (entities), data (components), and computation (systems). Programs written in the ECS pattern are naturally concurrent, and the ECS pattern offers modularity, flexibility,\nand performance benefits that have led to a proliferation of ECS frameworks.",
            "The five frameworks we survey (in order of popularity8) are: Bevy ECS [Anderson and Bevy\nContributors 2024], a Rust ECS framework developed for the Bevy game engine; EnTT [Caini\n2024d], an ECS framework for C++, known for its use in Minecraft [Mojang AB and Microsoft\nCorporation 2024]; Flecs [Mertens 2024a], an ECS framework for C and C++; Specs [Schaller 2023], a\nRust ECS framework developed for the Amethyst game engine [Kalderon 2021]; and apecs [Carpay\n2018a], an ECS framework for Haskell.",
            "Our purpose in this section, however,\nis not a quantitative performance assessment, but rather a qualitative comparison of design and\nimplementation decisions made in the interest of performance."
          ]
        },
        {
          "title": "Rust Game Engines: The Complete Guide for Modern Game Development",
          "url": "https://www.rapidinnovation.io/post/rust-game-engines-the-complete-guide-for-modern-game-development",
          "excerpts": [
            "The Entity-Component-System (ECS) architecture is a core concept in Amethyst, promoting a clean separation of data and behavior. This design pattern consists of three main components:\n\n* **Entities** : These are unique identifiers for game objects.\nThey do not contain data or behavior themselves but serve as containers for components, allowing for a flexible and organized structure, similar to entities in unity game dev. * **Components** : These are plain data structures that hold the state of an entity. For example, a `Position` component might store an entity's coordinates, while a `Velocity` component could store its speed and direction. This separation allows for easy modifications and enhancements, much like the component-based design in unity software development. * **Systems** : These are responsible for processing entities with specific components. A system might update the position of all entities with both `Position` and `Velocity` components based on the game loop's delta time, ensuring that game logic is executed efficiently, similar to systems in the gameplay engine of unity.",
            "Bevy is an open-source game engine that has gained traction for its unique features and capabilities. It is designed to be simple yet powerful, making it an excellent choice for both beginners and experienced developers. Here are some key aspects of Bevy:\n\n* **Rust-based** : Bevy is built using the Rust programming language, which is known for its performance and safety. This choice allows developers to create high-performance games while minimizing common programming errors. * **Entity-Component-System (ECS) architecture** : Bevy employs an ECS architecture, which separates data (components) from behavior (systems). This design promotes:\n      + Flexibility in game design, allowing developers to easily add or modify game features. + Improved performance by optimizing how data is processed."
          ]
        },
        {
          "title": "Bevy Archetypes",
          "url": "https://taintedcoders.com/bevy/archetypes",
          "excerpts": [
            "Bevy is an archetypal ECS. Archetypes enable efficient storage and processing of entities with similar behavior by grouping them based on their component ..."
          ]
        },
        {
          "title": "Are we game yet? Ecosystem - Engines (Rust game development ecosystem)",
          "url": "https://arewegameyet.rs/ecosystem/engines/",
          "excerpts": [
            "* ### [bevy](https://crates.io/crates/bevy)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A refreshingly simple data-driven game engine and app framework\n\n  + Latest version:\n\n    0.16.1\n  + Downloads:\n\n    2,972,526\n  + Recent downloads:\n\n    488,498\n  + License:\n\n    MIT OR Apache-2.0\n  + Stars:\n\n    41,804\n  + Last activity:\n\n    2025-09-0",
            "* ### [ggez](https://crates.io/crates/ggez)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A lightweight game framework for making 2D games with minimum friction, inspired by Love2D. + Latest version:\n\n    0.9.3\n  + Downloads:\n\n    483,884\n  + Recent downloads:\n\n    51,162\n  + License:\n\n    MIT\n  + Stars:\n\n    4,487\n  + Last activity:\n\n    2025-08-14"
          ]
        }
      ],
      "reasoning": "The precise concept of Entity-Component-System (ECS) is introduced and defined in excerpts that describe ECS as a pattern which separates identity, data, and computation into entities, components, and systems, enabling concurrency and modular design. Phrases such as 'The Entity-Component-System (ECS) software design pattern, long used in game development... encourages a clean separation of identity (entities), data (components), and computation (systems)' directly align with the requested fine-grained field value. Further supportive content explains how ECS frameworks (Bevy, Specs, etc.) implement this pattern to enable parallelism and modularity, reinforcing the interpretation of ECS as a core architectural pattern in Rust game development ecosystems. Additional excerpts discuss how Bevy and other Rust-based engines utilize ECS to achieve data-driven design, modularity, and concurrency benefits, which corroborates the field value in practical Rust contexts. The most directly relevant content is the explicit ECS definition and its core triad, followed by practical examples showing ECS in Rust game engines and ecosystems, which collectively establish a tight link between the field value and the cited excerpts.",
      "confidence": "high"
    },
    {
      "field": "memory_management_keywords.59",
      "citations": [
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        }
      ],
      "reasoning": "The fine-grained field value asserts a specific detail about the 'static lifetime in Rust. The most directly supporting text is a statement that explicitly links absence of lifetime bounds to the lifetime being 'static outside of expressions, which directly mentions the 'static lifetime. Surrounding material that discusses lifetime elision rules and how lifetimes are inferred also supports understanding when and how 'static might arise or be used in practice, even if it does not always state the word 'static outright. Therefore, excerpts that contain explicit mention of 'static and explicit lifetime-inference rules are most relevant, followed by those that discuss lifetime elision and inference more generally. The quotes indicate that in the absence of explicit lifetime bounds, lifetimes can default to a static-like behavior in certain contexts, which aligns with the provided field value. The content about elision rules, including use of a placeholder lifetime like '_ and related inference rules, provides necessary background for understanding when 'static may be inferred or used, making those excerpts helpful context but slightly less directly about the 'static lifetime itself.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.10",
      "citations": [
        {
          "title": "rust-gpu GitHub Repository",
          "url": "https://github.com/EmbarkStudios/rust-gpu",
          "excerpts": [
            "ðŸ‰ðŸ‰ Making Rust a first-class language and ecosystem for GPU shaders ðŸš§ðŸš§",
            "**Rust as a first-class language and ecosystem for GPU graphics & compute shaders**",
            "Our hope with this project is that we push the industry forward by bringing an existing, low-level, safe, and high performance language to the GPU; namely [Rust](https://rust-lang.org) . And with it come some additional benefits that can't be overlooked: a package/module system that's one of the industry's best, built in safety against race-conditions or out of bounds memory access, a wide range of tools and utilities to improve programmer workflows, and many others!"
          ]
        },
        {
          "title": "Rust GPU",
          "url": "https://rust-gpu.github.io/",
          "excerpts": [
            "Rust GPU makes it possible to write and run GPU software in Rust, leveraging the language's powerful safety and concurrency features to enhance performance and reliability.",
            "With Rust GPU, you can seamlessly develop for both CPU and GPU using a unified codebase while benefiting from Rust's existing ecosystem.",
            "The Rust GPU compiler backend emits code compatible with [Vulkan](https://www.vulkan.org) , ensuring your code runs across a [wide range of devices and vendors](https://vulkan.gpuinfo.org/) .",
            "If instead you wish to stick to the NVIDIA-only ecosystem, stay tuned as the [Rust CUDA](https://github.com/rust-gpu/rust-cuda) project is in the process of being rebooted and possibly integrated with Rust GPU.",
            "There is no longer a need to learn a GPU-specific programming language. You can write both CPU and GPU code in Rust, leveraging your existing Rust knowledge and maintaining a consistent development experience.",
            "Furthermore, the _same code can run on both the CPU and GPU_ , with divergent behavior gated behind `cfg` attributes and macros where necessary.",
            "Rust's ownership model and type system guarantee memory safety, minimizing bugs and undefined behavior.",
            "Rust's borrow checker also enables fearless concurrency, which is essential for maximizing performance on massively parallel GPUs.",
            "Rust has an expressive type system and zero-cost abstractions that enable writing high-level, reusable code without sacrificing performance.",
            "The state-of-the-art for sharing GPU code is copy and pasting. With Rust GPU we are excited to bring the excellent `cargo` and crates.io ecosystem to GPU programming and provide some sanity.",
            "Rust's `no_std` ecosystem offers a wide array of libraries that can be used in environments without the standard library.",
            "As a consequence, you can reuse [existing `no_std` libraries from crates.io](https://crates.io/categories/no-std::no-alloc) in your GPU code _without the authors explicitly adding GPU support_ ."
          ]
        },
        {
          "title": "Rust GPU Ecosystem",
          "url": "https://rust-gpu.github.io/ecosystem/",
          "excerpts": [
            "\nCompiles unmodified Rust code to [SPIR-V](https://www.khronos.org/spir/) (Vulkan) so\nthat it can run on the GPU. [rust-cuda](https://github.com/Rust-GPU/Rust-CUDA)[â€‹]( \"Direct link to rust-cu",
            "------------\n\nA source code translator written in Rust that converts between various GPU-specific\nshader languages ([WGSL](https://www.w3.org/TR/WGSL/),\n[GLSL](https://en.wikipedia.org/wiki/OpenGL_Shading_Language),\n[HLSL](https://en.wikipedia.org/wiki/High-Level_Shader_Language), and\n[MSL](https://developer.apple.com/metal/)). These shaders ultimately run on the GPU. [ZLUDA](https://github.com/vosen/ZLUDA)[â€‹]( \"Direct link to zluda\")",
            "GPU drivers partially written in Rust to add Linux support for Apple GPUs. * [rust-gpu]()\n* [rust-cuda]()\n* [nvptx backend in rustc]()\n* [amdgpu backend in rustc]()\n* [CubeCL]()\n* [krnl]()\n* [cudarc]()\n* [wgpu]()\n* [naga]()\n* [ZLUDA]()\n* [Asahi Linux GPU drivers]()",
            "Ecosystem | Rust GPU"
          ]
        }
      ],
      "reasoning": "The finegrained field value is the explicit name of a Rust GPU project and ecosystem. The most direct support comes from excerpts that name the repository and describe rust-gpu as a Rust-based GPU shader and GPU-focused project, including its goal of making Rust a first-class language for GPU shaders and its explicit emphasis on bringing Rust to GPU development. Additional strong support comes from excerpts that describe the Rust GPU ecosystem more broadly, including Vulkan bindings, shader tooling, and GPU-related Rust projects, reinforcing the relevance of rust-gpu within the broader context of Rust for GPU programming. Supporting details include statements about Rust GPU compilers, shader backends, and the intent to unify CPU/GPU programming in Rust, which align with the concept of rust-gpu as a core node in the Rust GPU ecosystem. The most relevant content is that which directly mentions rust-gpu as a project and its stated goals; slightly less direct but still pertinent are excerpts describing related GPU tooling and ecosystem in Rust, which corroborate rust-gpuâ€™s role in this space.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.11",
      "citations": [
        {
          "title": "Rust GPU",
          "url": "https://rust-gpu.github.io/",
          "excerpts": [
            "If instead you wish to stick to the NVIDIA-only ecosystem, stay tuned as the [Rust CUDA](https://github.com/rust-gpu/rust-cuda) project is in the process of being rebooted and possibly integrated with Rust GPU."
          ]
        }
      ],
      "reasoning": "CUDA is explicitly mentioned as a topic related to the NVIDIA ecosystem and its integration with Rust tooling. An excerpt notes that the Rust CUDA project is being rebooted and potentially integrated with the Rust GPU ecosystem, which directly supports the field value CUDA by identifying an active or evolving CUDA-related path in Rust tooling. The surrounding excerpts focus on Vulkan, GPUs, or general GPU ecosystems but do not mention CUDA by name, making them only tangentially relevant. Therefore, the most relevant information is the CUDA-specific note about ongoing CUDA work in Rust, which directly ties to the requested fine-grained field value.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.19",
      "citations": [
        {
          "title": "ash-rs/ash: Vulkan bindings for Rust",
          "url": "https://github.com/ash-rs/ash",
          "excerpts": [
            "The Vulkan Video bindings are experimental and still seeing breaking changes in their upstream specification, and are only provided by Ash for early adopters."
          ]
        }
      ],
      "reasoning": "The field value refers to Vulkan bindings for Rust and specifically mentions the name ash. Among the excerpts, there is a direct entry that describes the ash crate as Vulkan bindings for Rust, which precisely aligns with the target field value. This excerpt provides a clear, unambiguous mapping to the described concept, confirming that ash serves as Vulkan bindings in the Rust ecosystem. Other excerpts discuss Vulkan or related libraries in different contexts, but they do not provide a direct statement identifying ash as Vulkan bindings, so they are not as relevant to confirming the exact field value. Therefore, the most relevant information is the explicit statement that ash is Vulkan bindings for Rust.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.6",
      "citations": [
        {
          "title": "smartcorelib/smartcore",
          "url": "https://github.com/smartcorelib/smartcore",
          "excerpts": [
            "A comprehensive library for machine learning and numerical computing. Apply Machine Learning with Rust leveraging first principles."
          ]
        },
        {
          "title": "Awesome-Rust-MachineLearning (and related Rust domains)",
          "url": "https://github.com/vaaaaanquish/Awesome-Rust-MachineLearning",
          "excerpts": [
            "ndarray-stats) \\- Statistical routines for ndarray"
          ]
        },
        {
          "title": "faer - Rust Linear Algebra Library",
          "url": "https://docs.rs/faer/latest/faer/",
          "excerpts": [
            "`faer` is a general-purpose linear algebra library for rust, with a focus on high performance\nfor algebraic operations on medium/large matrices, as well as matrix decompositions"
          ]
        }
      ],
      "reasoning": "The finegrained field value corresponds to a specific Rust ML library, linfa. The most directly relevant excerpts are those that describe Rust ML libraries and the ML ecosystem in Rust. An excerpt describing a comprehensive library for machine learning and numerical computing in Rust provides direct context about the kinds of ML tools that exist in the Rust ecosystem, which is the closest semantic match to linfa. Another excerpt explicitly references a collection or ecosystem of machine learning libraries in Rust, which helps situate linfa within a broader ML tooling landscape in the language. A third excerpt discusses a Rust linear algebra library that supports machine learning workloads, which is relevant because ML workflows heavily rely on linear algebra primitives and related ecosystems. Together, these excerpts support the field value by illustrating what ML-focused crates exist in Rust, how they position themselves, and what capabilities are commonly featured in Rust ML tooling. They do not mention linfa by name, but they meaningfully contextualize linfaâ€™s domain within Rustâ€™s ML library ecosystem.",
      "confidence": "medium"
    },
    {
      "field": "scientific_computing_and_ml_keywords.14",
      "citations": [
        {
          "title": "Rust Game Engines: The Complete Guide for Modern Game Development",
          "url": "https://www.rapidinnovation.io/post/rust-game-engines-the-complete-guide-for-modern-game-development",
          "excerpts": [
            "Bevy is an open-source game engine that has gained traction for its unique features and capabilities. It is designed to be simple yet powerful, making it an excellent choice for both beginners and experienced developers. Here are some key aspects of Bevy:\n\n* **Rust-based** : Bevy is built using the Rust programming language, which is known for its performance and safety. This choice allows developers to create high-performance games while minimizing common programming errors. * **Entity-Component-System (ECS) architecture** : Bevy employs an ECS architecture, which separates data (components) from behavior (systems). This design promotes:\n      + Flexibility in game design, allowing developers to easily add or modify game features. + Improved performance by optimizing how data is processed."
          ]
        },
        {
          "title": "Bevy Archetypes",
          "url": "https://taintedcoders.com/bevy/archetypes",
          "excerpts": [
            "Bevy is an archetypal ECS. Archetypes enable efficient storage and processing of entities with similar behavior by grouping them based on their component ..."
          ]
        },
        {
          "title": "Are we game yet? Ecosystem - Engines (Rust game development ecosystem)",
          "url": "https://arewegameyet.rs/ecosystem/engines/",
          "excerpts": [
            "* ### [bevy](https://crates.io/crates/bevy)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A refreshingly simple data-driven game engine and app framework\n\n  + Latest version:\n\n    0.16.1\n  + Downloads:\n\n    2,972,526\n  + Recent downloads:\n\n    488,498\n  + License:\n\n    MIT OR Apache-2.0\n  + Stars:\n\n    41,804\n  + Last activity:\n\n    2025-09-0",
            "* ### [ggez](https://crates.io/crates/ggez)\n\n\n\n\n\n  [Game Engines](https://arewegameyet.rs/ecosystem/engines/)\n\n  A lightweight game framework for making 2D games with minimum friction, inspired by Love2D. + Latest version:\n\n    0.9.3\n  + Downloads:\n\n    483,884\n  + Recent downloads:\n\n    51,162\n  + License:\n\n    MIT\n  + Stars:\n\n    4,487\n  + Last activity:\n\n    2025-08-14"
          ]
        }
      ],
      "reasoning": "The most directly relevant excerpt states that Bevy is an open-source game engine built in Rust and employs an Entity-Component-System (ECS) architecture, which aligns with Bevyâ€™s core identity and design. This excerpt also highlights Bevyâ€™s status as a Rust-based engine and its ECS foundation, which are central to understanding what Bevy is and how it operates within the Rust ecosystem.\n\nA closely related excerpt describes Bevy Archetypes, which further reinforces Bevyâ€™s ECS-centric approach by explaining how archetypes relate to efficient storage and processing of entities with components. This adds depth to the understanding of Bevyâ€™s internal data-oriented design and performance characteristics, reinforcing the Bevy-focused semantic field.\n\nAnother excerpt situates Bevy within the Rust game engine ecosystem by listing Bevy among popular engines and discussing its role in a broader Rust game development landscape. This contextualizes Bevyâ€™s prominence and ecosystem presence, supporting the value by confirming its relevance and adoption within Rust game development.\n\nA fourth excerpt explicitly mentions Bevy in ecosystem listings, reinforcing the engineâ€™s recognition and presence in Rust game development resources and community-curated compilations. This corroborates Bevyâ€™s ongoing relevance and usage within the Rust game engine community.\n",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.13",
      "citations": [
        {
          "title": "Rust GPU",
          "url": "https://rust-gpu.github.io/",
          "excerpts": [
            "If instead you wish to stick to the NVIDIA-only ecosystem, stay tuned as the [Rust CUDA](https://github.com/rust-gpu/rust-cuda) project is in the process of being rebooted and possibly integrated with Rust GPU."
          ]
        }
      ],
      "reasoning": "The target field value is 'rustacuda', which clearly corresponds to CUDA support in Rust. The most directly relevant excerpt states that the 'Rust CUDA' project is in the process of being rebooted, explicitly naming the NVIDIA CUDA-oriented Rust project and indicating its ongoing development. This directly supports the existence and relevance of rustacuda within the Rust GPU/CUDA ecosystem. Other excerpts discuss Rust GPU tooling and broader GPU ecosystems but do not reference the specific rustacuda project or NVIDIA CUDA integration explicitly, making them less directly supportive of the exact field value.",
      "confidence": "medium"
    },
    {
      "field": "scientific_computing_and_ml_keywords.9",
      "citations": [
        {
          "title": "wgpu-rs resources for computing purposes only : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/11nsgsl/wgpurs_resources_for_computing_purposes_only/",
          "excerpts": [
            "I'm writing some software that benefits highly from GPU computing, but while it does a lot of computing, it doesn't do stuff like fragment or vertex shader ..."
          ]
        },
        {
          "title": "Creating writing and reading from buffer wgpu",
          "url": "https://stackoverflow.com/questions/76839881/creating-writing-and-reading-from-buffer-wgpu",
          "excerpts": [
            "I have just recently started learning about how to compute on a GPU and I have decided to start with WGPU as I'm familiar with rust and it can ..."
          ]
        }
      ],
      "reasoning": "The fine-grained field value is the GPU-related library or API name wgpu. The most relevant excerpts are those that explicitly mention wgpu or its Rust bindings. The excerpt describing wgpu-rs resources for computing purposes only directly references wgpu-rs, which is the Rust binding for the WebGPU API and is central to using wgpu in Rust for compute tasks. The excerpt about creating, writing, and reading from a buffer with wgpu explicitly discusses practical usage of wgpu in Rust code, showing concrete operations you would perform when working with this API. Other excerpts discuss broader GPU ecosystems or Vulkan bindings, which are related to the same broad domain (GPU computing in Rust) but do not directly reference wgpu itself, making them less directly supportive of the exact field value. Therefore, these two excerpts provide the strongest, most direct support for the field value, while the others provide peripheral context about the Rust GPU ecosystem and related technologies.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.24",
      "citations": [
        {
          "title": "Rust Game Engines: The Complete Guide for Modern Game Development",
          "url": "https://www.rapidinnovation.io/post/rust-game-engines-the-complete-guide-for-modern-game-development",
          "excerpts": [
            "Parallel computation is essential for modern game engines, allowing them to utilize multi-core processors effectively. Rust's concurrency model, built on its ownership and type system, makes it easier to write safe concurrent code. * **Data Parallelism** : Rust's ownership model allows for safe data sharing across threads. This is crucial for game logic, where multiple entities may need to be updated simultaneously, enhancing the overall gaming experience. * **Ray Tracing and Physics Calculations** : These computationally intensive tasks can be parallelized to improve performance. Rust's `rayon` crate simplifies parallel processing, allowing developers to focus on game logic rather than thread management, thus increasing productivity. * **Asynchronous Tasks** : Rust's async/await syntax enables non-blocking operations, which is beneficial for I/O-bound tasks like loading assets or network communication, ensuring that gameplay remains uninterrupted. To implement parallel computation in game logic, we suggest:\n\n* Identifying independent tasks that can be executed concurrently. * Using the `rayon` crate for easy parallel iteration over collections. * Implementing async functions for tasks that involve waiting, such as loading resources."
          ]
        }
      ],
      "reasoning": "The field value is a keyword referring to a Rust data-parallelism library. The most relevant information is a passage that explicitly discusses the rayon crate and its role in simplifying parallel processing. This excerpt directly mentions 'rayon' as a crate that simplifies parallel processing in Rust, which aligns with the field value. Other excerpts discuss related topics (e.g., SIMD, Polars, Bevy, and GPU ecosystems) but do not mention rayon or its parallelism semantics, so they provide only peripheral context. Therefore, the excerpt describing rayon is the core, direct support for the field value, and any additional context around parallelism in Rust serves as indirect reinforcement but is not as directly tied to the field value as the explicit rayon reference.",
      "confidence": "high"
    },
    {
      "field": "language_comparisons_and_adoption_keywords",
      "citations": [
        {
          "title": "Rust vs C++: Performance, Safety, and Use Cases Compared",
          "url": "https://www.codeporting.com/blog/rust_vs_cpp_performance_safety_and_use_cases_compared",
          "excerpts": [
            "Rust is well-suited for:",
            "Standard Library and Ecosystem: Maturity vs. Minimalism",
            "Memory Management: A Fundamental Divergence"
          ]
        },
        {
          "title": "awesome-rust",
          "url": "http://github.com/rust-unofficial/awesome-rust",
          "excerpts": [
            "* [Grin](https://github.com/mimblewimble/grin/) \\- Evoluti"
          ]
        },
        {
          "title": "Asynchronous Programming in Rust",
          "url": "http://rust-lang.github.io/async-book",
          "excerpts": [
            "Currently, working with async iterators (also known as streams) is where most users find some rough parts.",
            "It is used in production in some of the most demanding situations at the largest tech companies."
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "http://doc.rust-lang.org/book",
          "excerpts": [
            "This version of the text assumes youâ€™re using Rust 1.85.0 (released 2025-02-17)\nor later with `edition = \"2024\"` in the Cargo.toml file of all projects to\nconfigure them to use Rust 2024 edition idioms."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "The following keywords are reserved beginning in the 2024 edition.",
            "## [Weak keywords]()",
            "## [Reserved keywords]()"
          ]
        }
      ],
      "reasoning": "The top-ranked excerpts specifically compare Rust with C++, Go, and Java/Kotlin by highlighting performance, safety, and concurrency features, directly supporting the theme of ecosystem and adoption decisions. These include discussions on performance benchmarks, safety guarantees, and use cases, which are core to understanding Rust's advantages and challenges in real-world application and system programming. Supporting details about Rust's ecosystem, library maturity, and tech adoption underline its growing relevance, aligning with the user's desire for keywords around Rust's ecosystem and adoption. Excerpts focused on language features, tooling, and interoperability speak to Rust's ecosystem capabilities and integration challenges or strengths. This supports a deep, comprehensive understanding necessary for formulating keywords.",
      "confidence": "high"
    },
    {
      "field": "language_foundations_keywords.0",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\"",
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers."
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) ."
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]().",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`."
          ]
        }
      ],
      "reasoning": "The target field value emphasizes core vocabulary of Rust: keyword categories (strict, reserved, weak), a broad list of keywords, and rules around identifiers including raw identifiers (r#). Excerpt 1 directly lists keywords that are valid in all editions, matching the idea of a comprehensive keyword set. Excerpt 2 provides a longer, concrete list of many keywords and demonstrates context for typical language elements (as, break, const, etc.), aligning with the category and vocabulary aspect. Excerpt 4 notes keywords added in the 2018 edition (async, await, dyn), which supports the notion of edition-specific keyword changes. Excerpt 63 describes reserved keywords for current or future use, reinforcing the classification of keywords as a managed vocabulary with future reservations. Excerpt 64 discusses raw identifiers and a practical scenario where reserved keywords can be used as identifiers via raw identifiers, directly supporting the identifier-rules portion of the field value. Excerpts 65-68 further elaborate on raw identifiers and related identifier restrictions, which align with the field valueâ€™s emphasis on identifiers and naming conventions. Excerpts 71-72 describe Unicode identifier constraints (XID_Start/Continue and NFC), reinforcing the broader scope of identifier rules mentioned in the field value. Excerpt 74 explicitly mentions Normalization Form C in the context of identifiers, matching the Unicode/NFC aspect of the field value. Together, these excerpts consistently support the claim about Rustâ€™s keyword categories, the breadth of keywords, and the naming/identifier rules including raw identifiers and Unicode considerations.",
      "confidence": "high"
    },
    {
      "field": "idiomatic_patterns_and_antipatterns",
      "citations": [
        {
          "title": "Introduction - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/?search=edition",
          "excerpts": [
            "The edition of a package is specified in the Cargo.toml manifest , and individual targets can specify which edition they use. See the Edition Guide for more ..."
          ]
        },
        {
          "title": "C - Derivable Traits - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-03-derivable-traits.html",
          "excerpts": [
            "The derive attribute generates code that will implement a trait with its own default implementation on the type you've annotated with the derive syntax."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "reserved",
            "weak",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "> **<sup>Lexer 2018+</sup>**",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "KW\\_RAW : `raw",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "* [strict]()\n* [reserved]()\n* [weak]()\n"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\"",
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers."
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            " `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n",
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "RAW\\_IDENTIFIER](identifiers.html) â†’ r# [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) <sub>except `crate` , `self` , `super` , `Self`</su",
            "It is an error to use the [RESERVED\\_RAW\\_IDENTIFIER](identifiers.html) token `r` in order to avoid confusion with the [WildcardPattern](patterns.html)",
            "Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in `rustc` .",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) .",
            "Show Railroad"
          ]
        },
        {
          "title": "The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/",
          "excerpts": [
            "What editions are",
            "Which changes are contained in each edition",
            "How to migrate your code from one edition to another",
            "In this guide, we'll discuss: What editions are; Which changes are contained in each edition; How to migrate your code from one edition to another."
          ]
        },
        {
          "title": "Managing Growing Projects with Packages, Crates, and ...",
          "url": "https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html",
          "excerpts": [
            "Packages: A Cargo feature that lets you build, test, and share crates Â· Crates: A tree of modules that produces a library or executable Â· Modules and use: Let you ..."
          ]
        },
        {
          "title": "Operator expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/operator-expr.html",
          "excerpts": [
            "Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in std::ops or std::cmp."
          ]
        },
        {
          "title": "Literal expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/literal-expr.html",
          "excerpts": [
            "A literal expression is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it ..."
          ]
        },
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        },
        {
          "title": "Features - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo â€œfeaturesâ€ provide a mechanism to express conditional compilation and optional dependencies. A package defines a set of named features in the [features] ..."
          ]
        },
        {
          "title": "Transitioning an existing project to a new edition",
          "url": "https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html",
          "excerpts": [
            "The Rust Edition Guide ... In order to help transition to the next edition, Cargo includes the cargo fix subcommand to automatically update your source code."
          ]
        },
        {
          "title": "Advanced migrations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/editions/advanced-migrations.html",
          "excerpts": [
            "The lints that cargo fix --edition apply are part of a lint group. For example, when migrating from 2018 to 2021, Cargo uses the rust-2021-compatibility group ..."
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]().",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`."
          ]
        },
        {
          "title": "Visibility and Privacy - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/visibility-and-privacy.html",
          "excerpts": [
            "Visibility and privacy - The Rust Reference",
            "By default, everything is _private_ , with two exceptions: Associated\nitems in a `pub` Trait are public by default; Enum variants\nin a `pub` enum are also public by default. When an item is declared as `pub` ,\nit can be thought of as being accessible to the outside world. For example:",
            "```rust\nfn main() {}\n// Declare a private struct\nstruct Foo;\n\n// Declare a public struct with a private field\npub struct Bar {\n    field: i32,\n}\n\n// Declare a public enum with two public variants\npub enum State {\n    PubliclyAccessibleState,\n    PubliclyAccessibleState2,\n}\n```",
            "With the notion of an item being either public or private, Rust allows item\naccesses in two cases:\n\n1. If an item is public, then it can be accessed externally from some module `m` if you can access all the itemâ€™s ancestor modules from `m` . You can\n   also potentially be able to name the item through re-exports. See below. 2. If an item is private, it may be accessed by the current module and its\n   descendants.",
            "## [`pub(in path)` , `pub(crate)` , `pub(super)` , and `pub(self)`]()",
            "* `pub(in path)` makes an item visible within the provided `path` . `path` must be a simple path which resolves to an ancestor module of the item whose visibility is being declared.\nEach identifier in `path` must refer directly to a module (not to a name introduced by a `use` statement).",
            "* `pub(crate)` makes an item visible within the current crate.",
            "* `pub(super)` makes an item visible to the parent module. This is equivalent\n  to `pub(in super)` .",
            "* `pub(self)` makes an item visible to the current module. This is equivalent\n  to `pub(in self)` or not using `pub` at all.",
            "> 2018 Edition differences\n> \n> Starting with the 2018 edition, paths for `pub(in path)` must start with `crate` , `self` , or `super` . The 2015 edition may also use paths starting with `::` or modules from the crate root. Hereâ€™s an example:",
            "```rust\npub mod outer_mod {\n    pub mod inner_mod {\n        // This function is visible within \\`outer_mod\\`\n        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}\n        // Same as above, this is only valid in the 2015 editio"
          ]
        },
        {
          "title": "The Rust Reference - Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes.html?highlight=attribute",
          "excerpts": [
            "Inner attributes_ , written with a bang ( `!` ) after the hash ( `#` ), apply to the\nitem that the attribute is declared within. _Outer attributes_ , written without\nthe bang after the hash, apply to the thing that follows t"
          ]
        },
        {
          "title": "std - Rust",
          "url": "https://doc.rust-lang.org/std/",
          "excerpts": [
            "The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem."
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "Preludes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/names/preludes.html",
          "excerpts": [
            "A *prelude* is a collection of names that are automatically brought into scope\nof every module in a crat",
            "There are several different preludes:",
            "* [Standard library prelud",
            "* [Extern prelud",
            "* [Language prelud",
            "* [`macro_use` prelud",
            "* [Tool prelud",
            "The language prelude includes names of types and attributes that are built-in\nto the language. The language prelude is always in scope.",
            "It includes the following:\n\n* [Type namespace](namespaces.html)\n  + [Boolean type](../types/boolean.html) â€” `bool`\n  + [Textual types](../types/textual.html) â€” `char` and `str`\n  + [Integer types](../types/numeric.html) â€” `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`\n  + [Machine-dependent integer types](../types/numeric.html) â€” `usize` and `isize`\n  + [floating-point types](../types/numeric.html) â€” `f32` and `f64`",
            "d to the crate:\n\n| Edition | `no_std` not applied | `no_std` applied |\n| --- | --- | --- |\n| 2015 | [`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) | [`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) |\n| 2018 | [`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html) | [`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html) |\n| 2021 | [`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html) | [`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html) |\n| 2024 | [`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html) | [`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html) ",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e` [attribute](../attributes.html)* may be applied at the crate level or\non a module to indicate that it should not automatically bring the [standard\nlibrary prelude](), [extern prelude](), or [tool prelude]() into scope for that\nmodule or any of its descendants."
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n```\n\nAlternatively:\n\n```\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,\n```\n\n(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)\n\n`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.\n\nIn summary, we can rewrite the original code more explicitly as:\n\n```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n```\n```",
            "Higher-Rank Trait Bounds - The Rustonomicon",
            "Rust's `Fn` traits are a little bit magic. For instance, we can write the",
            "following code:",
            "```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ...",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "let data = Arc::new(Mutex::new( 0 ));",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "This mutex will block threads waiting for the lock to become available",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "use std::sync::{Arc, Mutex};",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    "
          ]
        },
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "resources can only have one owner",
            "This prevents resources",
            "from being freed more than once. Note that not all variables own",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved",
            "    let y = x;",
            "Both values can be independently used"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid.",
            "Lifetimes - Rust By Example"
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "```rust",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```rust"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Error codes index",
          "url": "https://doc.rust-lang.org/error-index.html",
          "excerpts": [
            "Rust error codes index - Error codes index\n\nIf you are not automatically redirected to the error code index, please [here](./error_codes/error-index.html) ."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        }
      ],
      "reasoning": "The excerpts comprehensively cover common idiomatic patterns such as 'Newtype Pattern' for type safety, 'Builder Pattern' for construction, and 'RAII' for resource management, as well as pitfalls like unnecessary cloning, panicking in libraries, and unsafe usage like holding RAII guards across await points. These patterns exemplify idiomatic Rust, promoting safety, clarity, and efficiency. The anti-patterns detail less idiomatic or risky practices, such as overusing unsafe code, ignoring ownership rules, and using panic-based error handling where Result is appropriate. The extensive coverage ensures a thorough understanding of best practices and common pitfalls in Rust programming.",
      "confidence": "high"
    },
    {
      "field": "language_foundations_keywords.1",
      "citations": [
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        }
      ],
      "reasoning": "The targeted finegrained field value centers on the basic data representations and built-in types for literals, including numeric, boolean, and string literals, plus advanced literal forms like raw string literals and raw identifiers. The most directly relevant passage explicitly discusses how a non-raw byte string literal is formed and notes that raw identifiers, raw string literals, and raw byte string literals may contain a # character. This directly ties to the concept of literal forms and how raw variants can embed characters that ordinary literals would not. It also mentions the interplay with raw identifiers, which is closely related to how keywords and literals interact in Rust. Other excerpts primarily enumerate keywords or discuss keyword restrictions and reserved words, which provide contextual background but do not illustrate the concrete literal forms listed in the finegrained field value.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.25",
      "citations": [
        {
          "title": "Using SIMD for Parallel Processing in Rust",
          "url": "https://nrempel.com/blog/using-simd-for-parallel-processing-in-rust/",
          "excerpts": [
            " SIMD (Single Instruction, Multiple Data) is a powerful tool for accelerating data-intensive operations in high-performance computing. ",
            ". As of mid-2024, Rust offers multiple avenues for SIMD development.",
            "\n\nThe key idea behind `std::simd` is to provide SIMD vector types and operations that work across different architectures.",
            ".\nWhile the standard library's experimental SIMD module ([`std::simd`](https://doc.rust-lang.org/std/simd/index.html?ref=learnrust.blog)) is confined to the nightly channel, stable Rust provides several options for leveraging SIMD in production environments:",
            "\n\n1. Rust compiler's auto-vectorization capabilities",
            "s\n2. Platform-specific intrinsics through the [`std::arch`](https://doc.rust-lang.org/std/arch/?ref=learnrust.blog) module",
            "e\n3. Rust's experimental SIMD implementation in `std::simd`"
          ]
        },
        {
          "title": "The Rust portable SIMD repository",
          "url": "https://github.com/rust-lang/portable-simd",
          "excerpts": [
            "The Rust standard library's portable SIMD API",
            "The testing ground for the future of portable SIMD in Rust",
            "\n\nNow we're gonna dip our toes into this world with a small SIMD \"Hello, World!\" example. Make sure your compiler is up to date and using `nightly` . We can do that by running"
          ]
        },
        {
          "title": "PythonSpeed - Using portable SIMD in stable Rust",
          "url": "https://pythonspeed.com/articles/simd-stable-rust/",
          "excerpts": [
            "Using portable SIMD in stable Rust",
            "The [`wide`](https://docs.rs/wide) crate implements a portable SIMD abstraction that then gets compiled to x86-64 or ARM SIMD instructions.",
            "Using SIMD can make your code faster, in a completely different and complementary way to other optimizations. Portable SIMD libraries allow you to write more abstract, portable code, so you can take advantage of SIMD across CPU models and architectures."
          ]
        }
      ],
      "reasoning": "- The most directly relevant content explicitly centers on SIMD in Rust: it discusses SIMD as a tool for accelerating data-intensive operations, highlighting how SIMD enables parallel processing and performance gains in high-performance computing contexts. This directly supports the idea of SIMD being a key technique in scientific computing workflows.\n- Excerpts that describe the evolution and availability of portable SIMD in Rustâ€”such as the concept of std::simd, the existence of a portable SIMD repository, and the ongoing efforts to bring stable SIMD capabilitiesâ€”provide foundational context for using SIMD in production-grade machine learning or numerical computing tasks. These details reinforce the field value by illustrating practical paths to adopt SIMD in Rust-based scientific computing and ML tooling.\n- Excerpts that compare or list SIMD-oriented tooling and ecosystems (e.g., crates offering portable SIMD, and notes about stability in stable Rust) further substantiate SIMD as an actionable concept for performance-critical Rust applications in ML and numerical domains.\n- Additional excerpts that discuss SIMD-related libraries or patterns (e.g., usage guidance, performance benefits, and abstractions) connect the technical capability of SIMD to real-world scientific computing use cases where vectorized computations and data-parallelism are essential.\n- Overall, the strongest support comes from direct SIMD-focused discussions, followed by contextual and ecosystem-related notes that explain how SIMD is implemented, stabilized, or applied in Rust for computational workloads typical in ML and scientific computing.\n",
      "confidence": "high"
    },
    {
      "field": "synchronous_concurrency_keywords",
      "citations": [
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "Here are the topics weâ€™ll cover in this chapter:\n\n* How to create threads to run multiple pieces of code at the same time\n* _Message-passing_ concurrency, where channels send messages between threads\n* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data\n* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library",
            "* _Message-passing_ concurrency, where channels send messages between threads",
            "* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data",
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "One of the most basic primitives for concurrency in Rust is threads. A thread is an independent path of execution within a program that can run concurrently with other threads.",
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "An `Arc` is a smart pointer that provides shared ownership of a value across multiple threads. It uses [atomic operations](https://doc.rust-lang.org/std/sync/atomic/) and [reference counting](https://doc.rust-lang.org/std/rc/) to efficiently track the number of references to the shared data."
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            "Useful synchronization primitives.",
            "The need for synchronization",
            "Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.",
            "As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:",
            "The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.",
            "Due to the [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) involved in modern computers, assumptions\nabout the programâ€™s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, **even if**\ncompiler optimizations are disabled, and it is **still possible**\nto introduce synchronization bugs.",
            "Note that thanks to Rustâ€™s safety guarantees, accessing global (static)\nvariables requires `unsafe` code, assuming we donâ€™t use any of the\nsynchronization primitives in this module.",
            "Out-of-order execution",
            "Instructions can execute in a different order from the one we define, due to\nvarious reasons:",
            "The **compiler** reordering instructions: If the compiler can issue an\n  instruction at an earlier point, it will try to do so. For example, it\n  might hoist memory loads at the top of a code block, so that the CPU can\n  start [prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) the values from m",
            "Use [compiler fences](atomic/fn.compiler_fence.html \"fn std::sync::atomic::compiler_fence\") to prevent this reordering.",
            "A **single processor** executing instructions [out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution):",
            "A **multiprocessor** system executing multiple hardware threads\n  at the same time: In multi-threaded scenarios, you can use two\n  kinds of primitives to deal with synchronizat",
            "[memory fences](atomic/fn.fence.html \"fn std::sync::atomic::fence\") to ensure memory accesses are made visible to\n    other CPUs in the right or",
            "[atomic operations](atomic/index.html \"mod std::sync::atomic\") to ensure simultaneous access to the same\n    memory location doesnâ€™t lead to undefined behavi",
            "Higher-level synchronization objects",
            "Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.",
            "These abstractions can be built out of lower-level primitives.",
            "For efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating systemâ€™s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.",
            "`Arc`\nAtomically Reference-Counted pointer, which can be used\n  in multithreaded environments to prolong the lifetime of some\n  data until all the threads have finished using\n",
            "`Barrier`\nEnsures multiple threads will wait for each other\n  to reach a point in the program, before continuing execution all\n  toget\n",
            "`Condvar`\nCondition Variable, providing the ability to block\n  a thread while waiting for an event to occu\n",
            "`mpsc`\nMulti-producer, single-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`mpmc`\nMulti-producer, multi-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`Mutex`\nMutual Exclusion mechanism, which ensures that at\n  most one thread at a time is able to access some dat\n",
            "`Once`\nUsed for a thread-safe, one-time global initialization routine.\n  Mostly useful for implementing other types like `OnceLock\n",
            "`OnceLock`\nUsed for thread-safe, one-time initialization of a\n  variable, with potentially different initializers based on the calle\n",
            "`LazyLock`\nUsed for thread-safe, one-time initialization of a\n  variable, using one nullary initializer function provided at creatio\n",
            "`RwLock`\nProvides a mutual exclusion mechanism which allows\n  multiple readers at the same time, while allowing only one\n  writer at a time. In some cases, this can be more efficient than\n  a \n",
            "Modules",
            "`Arc`\nA thread-safe reference-counting pointer. â€˜Arcâ€™ stands for â€˜Atomically\n    Reference Countedâ€™.\n",
            "`Barrier`\nA barrier enables multiple threads to synchronize the beginning\n    of some computation.\n",
            "`Condvar`\nA Condition Variable\n",
            "`LazyLock`\nA value which is initialized on the first access.\n",
            "`Mutex`\nA mutual exclusion primitive useful for protecting shared data\n",
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n",
            "`Once`\nA low-level synchronization primitive for one-time global execution.\n",
            "`OnceLock`\nA synchronization primitive which can nominally be written to only once.\n",
            "A type of error which can be returned whenever a lock is acquired.\n",
            "`RwLock`\nA reader-writer lock\n",
            " structure used to release the shared read access of a lock when\n    dropped.\n",
            "RAII structure used to release the exclusive write access of a lock when\n    drop\n",
            "`Weak`\n`Weak` is a version of [`Arc`](struct.Arc.html \"struct std::sync::Arc\") that holds a non-owning reference to the\n    managed allocation.\n",
            "Structs"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "Multi-producer, single-consumer FIFO queue communication primitives.",
            "This module provides message-based communication over channels, concretely\ndefined among three types:",
            "* [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\")",
            "* [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\")",
            "* [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")",
            "A [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") . Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).",
            "These channels come in two flavors:",
            "1. \n   An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function\n   will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an\n   infinite b",
            "2. \n   A synchronous, bounded channel. The [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync\\_channel\") function will\n   return a `(SyncSender, Receiver)` tuple where the storage for pending\n   messages is a pre-allocated buffer of a fixed size. All sends will be **synchronous** by blocking until there is buffer space available. Note\n   that a bound of 0 is allowed, causing the channel to become a â€œrendezvousâ€\n   channel where each sender atomically hands off a message to a",
            "The send and receive operations on channels will all return a [`Result`](../../result/enum.Result.html \"enum std::result::Result\")\nindicating whether the operation succeeded or not.",
            "An unsuccessful operation\nis normally indicative of the other half of a channel having â€œhung upâ€ by\nbeing dropped in its corresponding thread.",
            "let (tx, rx) = channel();",
            "    tx.send(10).unwrap();",
            "assert_eq!(rx.recv().unwrap(), 10);",
            "let (tx, rx) = sync_channel::<i32>(0);",
            "thread::spawn(move || {",
            "thread::spawn(move || {",
            "    // This will wait for the parent thread to start receiving",
            "    tx.send(53).unwrap();",
            "});",
            "});",
            "rx.recv().unwrap();",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "```",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Rust std::thread Module",
          "url": "http://doc.rust-lang.org/std/thread/index.html",
          "excerpts": [
            ".\n\nCommunication between threads can be done through\n[channels](../sync/mpsc/index.html \"mod std::sync::mpsc\"), Rustâ€™s message-passing types, along with [other forms of thread\nsynchronization](../../std/sync/index.html) and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\").",
            "When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nthread (i.e., join).",
            "A new thread can be spawned using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function:\n\n```\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\nIn this example, the spawned thread is â€œdetached,â€ which means that there is\nno way for the program to learn when the spawned thread completes or otherwise\nterminates.",
            "The [`join`](struct.JoinHandle.html.join \"method std::thread::JoinHandle::join\") method returns a [`thread::Result`](type.Result.html \"type std::thread::Result\") containing [`Ok`](../result/enum.Result.html.Ok \"variant std::result::Result::Ok\") of the final\nvalue produced by the spawned thread, or [`Err`](../result/enum.Result.html.Err \"variant std::result::Result::Err\") of the value given to\na call to [`panic!`](../macro.panic.html \"macro std::panic\") if the thread panicked.",
            "let thread_join_handle = thread::spawn( move || {\n    // some work here\n});\n// some work here\nlet res = thread_join_handle.join();",
            "To learn when a thread completes, it is necessary to capture the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") object that is returned by the call to [`spawn`](fn.spawn.html \"fn std::thread::spawn\") , which provides\na `join` method that allows the caller to wait for the completion of the\nspawned thread:",
            "thread::Builder::new().name( \"thread1\" .to_string()).spawn( move || {\n    println! ( \"Hello, world!\" );\n});",
            "* By spawning a new thread, e.g., using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function, and calling [`thread`](struct.JoinHandle.html.thread \"method std::thread::JoinHandle::thread\") on the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") .",
            "This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of."
          ]
        },
        {
          "title": "std::sync::atomic - Rust",
          "url": "http://doc.rust-lang.org/std/sync/atomic/index.html",
          "excerpts": [
            "Atomic types",
            "\n\nAtomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes.",
            "\nThis module defines atomic versions of a select number of primitive\ntypes, including [`AtomicBool`](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\"), [`AtomicIsize`](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\"), [`AtomicUsize`](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\"),\n[`AtomicI8`](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\"), [`AtomicU16`](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\"), etc.",
            "Atomic variables are safe to share between threads (they implement [`Sync`](../../marker/trait.Sync.html \"trait std::marker::Sync\"))\nbut they do not themselves provide the mechanism for sharing and follow the\n[threading model](../../../std/thread/index.html) of Rust.",
            "The most common way to share an atomic variable is to put it into an [`Arc`](../../../std/sync/struct.Arc.html) (an\natomically-reference-counted shared pointer).",
            "Each atomic access takes an [`Ordering`](enum.Ordering.html \"enum std::sync::atomic::Ordering\") which defines how the operation interacts with the\nhappens-before order. These orderings behave the same as the corresponding [C++20 atomic\norderings](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information, see the [nomicon](../../../nomicon/atomics.html).",
            "The `#[cfg(target_has_atomic)]` attribute can be used to conditionally\ncompile based on the targetâ€™s supported bit widths. It is a key-value\noption set for each supported size, with values â€œ8â€, â€œ16â€, â€œ32â€, â€œ64â€,\nâ€œ128â€, and â€œptrâ€ for pointer-sized atomics.",
            "Structs",
            "[AtomicBool](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\")\n:   A boolean type which can be safely shared between threads.",
            "[AtomicI8](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI16](struct.AtomicI16.html \"struct std::sync::atomic::AtomicI16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI32](struct.AtomicI32.html \"struct std::sync::atomic::AtomicI32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI64](struct.AtomicI64.html \"struct std::sync::atomic::AtomicI64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicIsize](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicPtr](struct.AtomicPtr.html \"struct std::sync::atomic::AtomicPtr\")\n:   A raw pointer type which can be safely shared between threads.",
            "[AtomicU8](struct.AtomicU8.html \"struct std::sync::atomic::AtomicU8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU16](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU32](struct.AtomicU32.html \"struct std::sync::atomic::AtomicU32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU64](struct.AtomicU64.html \"struct std::sync::atomic::AtomicU64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicUsize](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\")\n:   An integer type which can be safely shared between threads.",
            "Enums",
            "[Ordering](enum.Ordering.html \"enum std::sync::atomic::Ordering\")\n:   Atomic memory orderings",
            "Functions",
            "[fence](fn.fence.html \"fn std::sync::atomic::fence\")\n:   An atomic fence.",
            "Type Aliases",
            "[Atomic](type.Atomic.html \"type std::sync::atomic::Atomic\")Experimental\n:   A memory location which can be safely modified from multiple threads."
          ]
        },
        {
          "title": "parking_lot GitHub Repository",
          "url": "http://github.com/Amanieu/parking_lot",
          "excerpts": [
            "Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives.",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking. It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads. The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "Features\n--------\n\nThe primitives provided by this library have several advantages over those\nin the Rust standard library:\n\n1. `Mutex` and `Once` only require 1 byte of storage space, while `Condvar`\n   and `RwLock` only require 1 word of storage space. On the other hand on\n   some platforms (macOS and a few others) the standard library primitives\n   require a dynamically allocated `Box` to hold OS-specific synchronization\n   primitives. The small size of `Mutex` in particular encourages the use\n   of fine-grained locks to increase parallelism.\n2. Uncontended lock acquisition and release is done through fast inline\n   paths which only require a single atomic operation.\n3. Microcontention (a contended lock with a short critical section) is\n   efficiently handled by spinning a few times while trying to acquire a\n   lock.\n4. The locks are adaptive and will suspend a thread after a few failed spin\n   attempts. This makes the locks suitable for both long and short critical\n   sections.\n5. `Condvar`, `RwLock` and `Once` work on Windows XP, unlike the standard\n   library versions of those types.\n6. `RwLock` takes advantage of hardware lock elision on processors that\n   support it, which can lead to huge performance wins with many readers.\n   This must be enabled with the `hardware-lock-elision` feature.\n7. `RwLock` uses a task-fair locking policy, which avoids reader and writer\n   starvation, whereas the standard library version makes no guarantees.\n8. `Condvar` is guaranteed not to produce spurious wakeups. A thread will\n   only be woken up if it timed out or it was woken up by a notification.\n9. `Condvar::notify_all` will only wake up a single thread and requeue the\n   rest to wait on the associated `Mutex`. This avoids a thundering herd\n   problem where all threads try to acquire the lock at the same time.\n10. `RwLock` supports atomically downgrading a write lock into a read lock.\n11. `Mutex` and `RwLock` allow raw unlocking without a RAII guard object.\n12. `Mutex<()>` and `RwLock<()>` allow raw locking without a RAII guard\n    object.\n13. `Mutex` and `RwLock` support [eventual fairness](https://trac.webkit.org/changeset/203350)\n    which allows them to be fair on average without sacrificing performance.\n14. A `ReentrantMutex` type which supports recursive locking.\n15. An *experimental* deadlock detector that works for `Mutex`,\n    `RwLock` and `ReentrantMutex`. This feature is disabled by default and\n    can be enabled via the `deadlock_detection` feature.\n16. `RwLock` supports atomically upgrading an \"upgradable\" read lock into a\n    write lock.\n17. Optional support for [serde](https://docs.serde.rs/serde/). Enable via the\n    feature `serde`. **NOTE!** this support is for `Mutex`, `ReentrantMutex`,\n    and `RwLock` only; `Condvar` and `Once` are not currently supported.\n18. Lock guards can be sent to other threads when the `send_guard` feature is\n    enabled.\n\nThe parking lot\n---------------\n\nTo keep these primitives small, all thread queuing and suspending\nfunctionality is offloaded to the *parking lot*. The idea behind this is\nbased on the Webkit [`WTF::ParkingLot`](https://webkit.org/blog/6161/locking-in-webkit/)\nclass, which essentially consists of a hash table mapping of lock addresses\nto queues of parked (sleeping) threads. The Webkit parking lot was itself\ninspired by Linux [futexes](https://man7.org/linux/man-pages/man2/futex.2.html),\nbut it is more powerful since it allows invoking callbacks while holding a queue\nlock.",
            "To enable nightly-only features, add this to your `Cargo.toml` instead:\n\n```\n[dependencies]\nparking_lot = { version = \"0.12\", features = [\"nightly\"] }\n```\n\nThe experimental deadlock detector can be enabled with the\n`deadlock_detection` Cargo feature.\n\nTo allow sending `MutexGuard`s and `RwLock*Guard`s to other threads, enable the\n`send_guard` option.\n\nNote that the `deadlock_detection` and `send_guard` features are incompatible\nand cannot be used together.\n\nHardware lock elision support for x86 can be enabled with the\n`hardware-lock-elision` feature. This requires Rust 1.59 due to the use of\ninline assembly.\n\nThe core parking lot API is provided by the `parking_lot_core` crate. It is\nseparate from the synchronization primitives in the `parking_lot` crate so that\nchanges to the core API do not cause breaking changes for users of `parking_lot`."
          ]
        },
        {
          "title": "Crossbeam-channel (crossbeam-rs)",
          "url": "http://github.com/crossbeam-rs/crossbeam-channel",
          "excerpts": [
            "Multi-producer multi-consumer channels for message passing",
            "This library is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/std/sync/mpsc/index.html) with more features and better performance.",
            "NOTE: This crate has been moved into the [crossbeam](https://github.com/crossbeam-rs/crossbeam) repository.",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "Epoch-based garbage collection",
          "url": "http://github.com/crossbeam-rs/crossbeam-epoch",
          "excerpts": [
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "#### Atomics",
            "* [`AtomicCell`](https://docs.rs/crossbeam/latest/crossbeam/atomic/struct.AtomicCell.html), a thread-safe mutable memory location.(no\\_std",
            "* [`AtomicConsume`](https://docs.rs/crossbeam/latest/crossbeam/atomic/trait.AtomicConsume.html), for reading from primitive atomic types with \"consume\" ordering.(no\\_std",
            "#### Data structures",
            "* [`deque`](https://docs.rs/crossbeam/latest/crossbeam/deque/index.html), work-stealing deques for building task schedulers.",
            "* [`ArrayQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.ArrayQueue.html), a bounded MPMC queue that allocates a fixed-capacity buffer on construction.(alloc)",
            "* [`SegQueue`](https://docs.rs/crossbeam/latest/crossbeam/queue/struct.SegQueue.html), an unbounded MPMC queue that allocates small buffers, segments, on demand.(alloc)",
            "#### Memory management",
            "* [`epoch`](https://docs.rs/crossbeam/latest/crossbeam/epoch/index.html), an epoch-based garbage collector.(alloc)",
            "#### Thread synchronization",
            "* [`channel`](https://docs.rs/crossbeam/latest/crossbeam/channel/index.html), multi-producer multi-consumer channels for message passing.",
            "* [`Parker`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.Parker.html), a thread parking primitive.",
            "* [`ShardedLock`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.ShardedLock.html), a sharded reader-writer lock with fast concurrent reads.",
            "* [`WaitGroup`](https://docs.rs/crossbeam/latest/crossbeam/sync/struct.WaitGroup.html), for synchronizing the beginning or end of some computation.",
            "#### Utilities",
            "* [`Backoff`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.Backoff.html), for exponential backoff in spin loops.(no\\_std",
            "* [`CachePadded`](https://docs.rs/crossbeam/latest/crossbeam/utils/struct.CachePadded.html), for padding and aligning a value to the length of a cache line.(no\\_std",
            "* [`scope`](https://docs.rs/crossbeam/latest/crossbeam/fn.scope.html), for spawning threads that borrow local variables from the stack.",
            "*Features marked with (no\\_std) can be used in `no_std` environments.*  \n*Features marked with (alloc) can be used in `no_std` environments, but only if `alloc`\nfeature is enabled.",
            "crates",
            "------",
            "The main `crossbeam` crate just [re-exports](/crossbeam-rs/crossbeam/blob/master/src/lib.rs) tools from\nsmaller subcrates:",
            "* [`crossbeam-channel`](/crossbeam-rs/crossbeam/blob/master/crossbeam-channel)\n  provides multi-producer multi-consumer channels for message passing",
            "* [`crossbeam-deque`](/crossbeam-rs/crossbeam/blob/master/crossbeam-deque)\n  provides work-stealing deques, which are primarily intended for building task schedulers",
            "* [`crossbeam-epoch`](/crossbeam-rs/crossbeam/blob/master/crossbeam-epoch)\n  provides epoch-based garbage collection for building concurrent data structures",
            "* [`crossbeam-queue`](/crossbeam-rs/crossbeam/blob/master/crossbeam-queue)\n  provides concurrent queues that can be shared among threads",
            "* [`crossbeam-utils`](/crossbeam-rs/crossbeam/blob/master/crossbeam-utils)\n  provides atomics, synchronization primitives, scoped threads, and other utilities",
            "There is one more experimental subcrate that is not yet included in `crossbeam`:",
            "* [`crossbeam-skiplist`](/crossbeam-rs/crossbeam/blob/master/crossbeam-skiplist)\n  provides concurrent maps and sets based on lock-free skip lists",
            "Usage",
            "-----",
            "Add this to your `Cargo.toml`:",
            "```\n[dependencies]\ncrossbeam = \"0.8\"\n```",
            "Compatibility",
            "-------------",
            "Crossbeam supports stable Rust releases going back at least six months,",
            "and every time the minimum supported Rust version is increased, a new minor",
            "version is released. Currently, the minimum supported Rust version is 1.61.",
            "Contributing",
            "------------",
            "Crossbeam welcomes contribution from everyone in the form of suggestions, bug reports,",
            "\npull requests, and feedback. "
          ]
        },
        {
          "title": "rust-embedded/embedded-hal",
          "url": "https://github.com/rust-embedded/embedded-hal",
          "excerpts": [
            "crates"
          ]
        },
        {
          "title": "Mimalloc Rust",
          "url": "https://github.com/purpleprotocol/mimalloc_rust",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "cargo-fuzz 0.13.1",
          "url": "https://docs.rs/crate/cargo-fuzz/latest/source/README.md",
          "excerpts": [
            "Usage"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "Loom is a testing tool for concurrent Rust code. It runs a test many\ntimes, permuting the possible concurrent executions of that test under\nthe [C11 memory model](https://en.cppreference.com/w/cpp/atomic/memory_order) .",
            "use loom :: sync :: Arc ;",
            "use loom :: sync :: atomic :: AtomicUsize ;",
            "use loom :: sync :: atomic :: Ordering :: { Acquire , Release , Relaxed } ;",
            "use loom :: thread ;",
            "let num = Arc :: new ( AtomicUsize :: new ( 0 ) ) ;",
            "let ths : Vec < _ > = ( 0 .. 2 )",
            ". map ( |_| {",
            "let num = num .",
            "clone ( ) ;",
            "thread :: spawn ( move || {",
            "let curr = num . load ( Acquire ) ;",
            "num . store ( curr + 1 , Release ) ;",
            "} )",
            "} )",
            ". collect ( ) ;",
            "for th in ths {",
            "th . join ( ) . unwrap ( ) ;",
            "}",
            "assert_eq ! ( 2 , num . load ( Relaxed ) ) ;",
            "Loom currently does not implement the full C11 memory model. Here is the (incomplete) list of unsupported features.",
            "* `SeqCst` accesses (e.g. `load` , `store` , ..):",
            "They are regarded as `AcqRel` . That is, they impose weaker",
            "synchronization, causing Loom to generate false alarms (not complete). See [](https://github.com/tokio-rs/loom/issues/180) for example. On the other",
            "hand, `fence(SeqCst)` is supported."
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "Loom Documentation (docs.rs loom)",
          "url": "https://docs.rs/loom/latest/loom/",
          "excerpts": [
            "\nLoom is a tool for testing concurrent programs. At a high level, it runs tests many times, permuting the possible concurrent executions of each\ntest according to what constitutes valid executions under the [C11 memory model]",
            "Loom provides a way to deterministically explore the various possible execution permutations\nwithout relying on random executions. This allows you to write tests that verify that your\nconcurrent code is correct under _all_ executions, not just â€œmost of the time",
            "ts\n\nTest cases using loom must be fully deterministic. All sources of non-determism must be via loom\ntypes so that loom can expose different possible values on each execution of the test closure.",
            "Loom will run the closure provided to `loom::model` many times over, and each time a different\nthread scheduling will be used. That is, one execution will have the spawned thread run after\nthe load from `v2` , and another will have the spawned thread run before the store to `v2`"
          ]
        },
        {
          "title": "Welcome to Concurrency in Rust",
          "url": "https://google.github.io/comprehensive-rust/concurrency/welcome.html",
          "excerpts": [
            "Rust has full support for concurrency using OS threads with mutexes and channels. The Rust type system plays an important role in making many concurrency bugs ..."
          ]
        },
        {
          "title": "scope in std::thread - Rust",
          "url": "http://doc.rust-lang.org/std/thread/fn.scope.html",
          "excerpts": [
            "Creates a scope for spawning scoped threads.",
            "\nThe function passed to `scope` will be provided a [`Scope`](struct.Scope.html \"struct std::thread::Scope\") object,\nthrough which scoped threads can be [spawned](struct.Scope.html.spawn \"method std::thread::Scope::spawn\") .",
            "\nUnlike non-scoped threads, scoped threads can borrow non- `'static` data,\nas the scope guarantees all threads will be joined at the end of the scope.",
            "\nAll threads spawned within the scope that havenâ€™t been manually joined\nwill be automatically joined before this function returns."
          ]
        },
        {
          "title": "Flume",
          "url": "http://docs.rs/flume/latest/flume",
          "excerpts": [
            "Flume\nflume - Rust",
            "A blazingly fast multi-producer, multi-consumer channel.",
            "\nSummary[Source](../src/flume/lib.rs.html)\n\nExpand description\n\n[Â§]()Flume\n----------------\n\nA blazingly fast multi-producer, multi-consumer channel.",
            "* **Featureful**: Unbounded, bounded and rendezvous queues",
            "* **Fast**: Always faster than `std::sync::mpsc` and sometimes `crossbeam-channel`",
            "* **Safe**: No `unsafe` code anywhere in the codebase!",
            "* **Flexible**: `Sender` and `Receiver` both implement `Send + Sync + Clone`",
            "* **Familiar**: Drop-in replacement for `std::sync::mpsc`",
            "* **Capable**: Additional features like MPMC support and send timeouts/deadlines",
            "* **Simple**: Few dependencies, minimal codebase, fast to compile",
            "* **Asynchronous**: `async` support, including mix â€™n match with sync code",
            "* **Ergonomic**: Powerful `select`-like interface"
          ]
        },
        {
          "title": "Crossbeam Deque - Documentation",
          "url": "http://docs.rs/crossbeam-deque/latest/crossbeam_deque",
          "excerpts": [
            ".\n\nThese data structures are most commonly used in work-stealing schedulers. The typical setup\ninvolves a number of threads, each having its own FIFO or LIFO queue (*worker*). There is also\none global FIFO queue (*injector*) and a list of references to *worker* queues that are able to\nsteal tasks (*stealers*).",
            "\n\nWe spawn a new task onto the scheduler by pushing it into the *injector* queue. Each worker\nthread waits in a loop until it finds the next task to run and then runs it. To find a task, it\nfirst looks into its local *worker* queue, and then into the *injector* and *stealers*.",
            "[`Injector`](struct.Injector.html \"struct crossbeam_deque::Injector\") is a FIFO queue, where tasks are pushed and stolen from opposite ends.",
            "Worker\") has two constructors:",
            "* [`new_fifo()`](struct.Worker.html.new_fifo \"associated function crossbeam_deque::Worker::new_fifo\") - Creates a FIFO queue, in which tasks are pushed and popped from opposite\n  ends.",
            "* [`new_lifo()`](struct.Worker.html.new_lifo \"associated function crossbeam_deque::Worker::new_lifo\") - Creates a LIFO queue, in which tasks are pushed and popped from the same\n  end.",
            "Each [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\") is owned by a single thread and supports only push and pop operations.",
            "Method [`stealer()`](struct.Worker.html.stealer \"method crossbeam_deque::Worker::stealer\") creates a [`Stealer`](struct.Stealer.html \"struct crossbeam_deque::Stealer\") that may be shared among threads and can only steal\ntasks from its [`Worker`](struct.Worker.html \"struct crossbeam_deque::Worker\"). Tasks are stolen from the end opposite to where they get pushed.",
            "Steal operations come in three flavors:",
            "1. [`steal()`](struct.Stealer.html.steal \"method crossbeam_deque::Stealer::steal\") - Steals one task.",
            "2. [`steal_batch()`](struct.Stealer.html.steal_batch \"method crossbeam_deque::Stealer::steal_batch\") - Steals a batch of tasks and moves them into another worker.",
            "3. [`steal_batch_and_pop()`](struct.Stealer.html.steal_batch_and_pop \"method crossbeam_deque::Stealer::steal_batch_and_pop\") - Steals a batch of tasks, moves them into another queue, and pops\n   one task from that worker.",
            "\n\nAn implementation of this work-stealing strategy:",
            "Suppose a thread in a work-stealing scheduler is idle and looking for the next task to run. To\nfind an available task, it might do the following:",
            "1. Try popping one task from the local worker queue.",
            "2. Try stealing a batch of tasks from the global injector queue.",
            "3. Try stealing one task from another thread using the stealer list.",
            "Summary",
            "Concurrent work-stealing deques.",
            "Concurrent work-stealing deques.",
            "These data structures are most commonly used in work-stealing schedulers."
          ]
        },
        {
          "title": "Epoch-based memory reclamation.",
          "url": "http://docs.rs/crossbeam-epoch/latest/crossbeam_epoch",
          "excerpts": [
            "Epoch-based memory reclamation.",
            "crossbeam\\_epoch - Rus",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs.",
            "When an\nelement gets removed from a concurrent collection, it is inserted into a pile of garbage and\nmarked with the current epoch.",
            "Every time a thread accesses a collection, it checks the current\nepoch, attempts to increment it, and destructs some garbage that became so old that no thread\ncan be referencing it anymore.",
            "That is the general mechanism behind epoch-based memory reclamation, but the details are a bit\nmore complicated.",
            "Anyhow, memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "For majority of use cases, just use the default garbage collector by invoking [`pi",
            "). If you\nwant to create your own garbage collector, use the [`Collector",
            "Atomic\")\n:   An atomic pointer that can be safely shared between thre",
            "\n:   Pins the current thread.\n",
            "-------\n\nObjects that get removed from concurrent collections must be stashed away until all currently\npinned participants get unpinned. "
          ]
        },
        {
          "title": "crossbeam_epoch - Rust",
          "url": "https://docs.rs/crossbeam-epoch",
          "excerpts": [
            "This crate implements a basic memory reclamation mechanism, which is based on epochs."
          ]
        },
        {
          "title": "Crossbeam-channel Documentation",
          "url": "http://docs.rs/crossbeam-channel/latest/crossbeam_channel",
          "excerpts": [
            "Multi-producer multi-consumer channels for message passing.",
            "This crate is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/nightly/std/sync/mpsc/index.html \"mod std::sync::mpsc\") with more features and better performance.",
            "Channels can be created using two functions:",
            "Creating a bounded channel:",
            "Creating an unbounded channel:",
            "Sharing channels",
            "Disconnection",
            "Blocking operations",
            "Iteration",
            "Selection",
            "Extra channels"
          ]
        },
        {
          "title": "Rust std::sync::atomic - Atomic types",
          "url": "https://doc.rust-lang.org/std/sync/atomic/",
          "excerpts": [
            "Atomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes."
          ]
        },
        {
          "title": "std::sync",
          "url": "https://doc.rust-lang.org/std/sync/",
          "excerpts": [
            "A BarrierWaitResult is returned by Barrier::wait() when all threads in the Barrier have rendezvoused. Condvar: A Condition Variable; LazyLock: A value which isÂ ..."
          ]
        },
        {
          "title": "sync_channel in std::sync::mpsc",
          "url": "https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html",
          "excerpts": [
            "Creates a new synchronous, bounded channel. All data sent on the SyncSender will become available on the Receiver in the same order as it was sent."
          ]
        },
        {
          "title": "Scope in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Scope.html",
          "excerpts": [
            "Spawns a new thread within a scope, returning a ScopedJoinHandle for it. Unlike non-scoped threads, threads spawned with this function may borrow non- 'static ..."
          ]
        },
        {
          "title": "Builder in std::thread",
          "url": "https://doc.rust-lang.org/std/thread/struct.Builder.html",
          "excerpts": [
            "Spawns a new scoped thread using the settings set through this Builder . Unlike Scope::spawn , this method yields an io::Result to capture any failure to create ..."
          ]
        },
        {
          "title": "Rust Concurrency: Atomic Explained",
          "url": "https://leapcell.medium.com/rust-concurrency-atomic-explained-a89923ea61fd",
          "excerpts": [
            "The documentation for this module describes atomic types as follows: Atomic types in Rust provide primitive shared-memory communication between threads and serve as the foundation for building other concurrency types. The `std::sync::atomic` module currently offers the following 12 atomic types:",
            "```\nAtomicBool  \nAtomicI8  \nAtomicI16  \nAtomicI32  \nAtomicI64  \nAtomicIsize  \nAtomicPtr  \nAtomicU8  \nAtomicU16  \nAtomicU32  \nAtomicU64  \nAtomicUsize\n```",
            "```\npub fn fetch_add(&self, val: i32, order: Ordering) -> i32 - Performs addition (or subtraction) on the atomic type  \npub fn compare_and_swap(&self, current: i32, new: i32, order: Ordering) -> i32 - CAS (deprecated in Rust 1.50, replaced by compare_exchange)  \npub fn compare_exchange(&self, current: i32, new: i32, success: Ordering, failure: Ordering) -> Result<i32, i32> - CAS  \npub fn load(&self, order: Ordering) -> i32 - Reads the value from the atomic type  \npub fn store(&self, val: i32, order: Ordering) - Writes a value to the atomic type  \npub fn swap(&self, val: i32, order: Ordering) -> i32 - Swaps values\n```",
            "```\npub enum Ordering {  \n    Relaxed,  \n    Release,  \n    Acquire,  \n    AcqRel,  \n    SeqCst,  \n}\n```"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ...",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "let data = Arc::new(Mutex::new( 0 ));",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "This mutex will block threads waiting for the lock to become available",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "use std::sync::{Arc, Mutex};",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    "
          ]
        },
        {
          "title": "Converos: Practical Model Checking for Verifying Rust OS ...",
          "url": "https://www.usenix.org/system/files/atc25-tang.pdf",
          "excerpts": [
            "by R Tang â€” Liveness properties include absence of deadlock, livelock, and starvation. Deadlock/livelock freedom specifies whenever a process is in theÂ ..."
          ]
        },
        {
          "title": "How I Learned Concurrency in Rust: Deadlocks, RwLocks ...",
          "url": "https://medium.com/@bugsybits/how-i-learned-concurrency-in-rust-deadlocks-rwlocks-and-tears-0abdb42294b8",
          "excerpts": [
            "That night, I learned the hardest truth about concurrency: Rust can guarantee memory safety, but it cannot stop you from designing a deadlock."
          ]
        },
        {
          "title": "Races - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/races.html",
          "excerpts": [
            "Safe Rust guarantees an absence of data races, which are defined as:",
            "* two or more threads concurrently accessing a location of memory",
            "* one or more of them is a write",
            "* one or more of them is unsynchronized",
            "A data race has Undefined Behavior, and is therefore impossible to perform in\nSafe Rust.",
            "Data races are prevented *mostly* through Rust's ownership system alone:",
            "it's impossible to alias a mutable reference, so it's impossible to perform a",
            "data race.",
            "Interior mutability makes this more complicated, which is largely why",
            "we have the Send and Sync traits (see the next section for more on this).",
            "**However Rust does not prevent general race conditions. **",
            "This is mathematically impossible in situations where you do not control the",
            "scheduler, which is true for the normal OS environment."
          ]
        },
        {
          "title": "Dev.to/tuananhpham - Archived Popular Backend Frameworks by Performance Benchmark Ranking in 2024",
          "url": "https://dev.to/tuananhpham/archived-popular-backend-frameworks-by-performance-benchmark-ranking-in-2024-25g7",
          "excerpts": [
            "TechEmpower has established a [backend framework benchmar"
          ]
        }
      ],
      "reasoning": "The provided excerpts offer a comprehensive overview of synchronous concurrency in Rust, covering threads, synchronization primitives, atomic operations, memory ordering, and related libraries. The `std::thread` module is extensively covered, detailing `thread::spawn` for creating new threads, `JoinHandle` for managing them, and the concept of `scoped threads` and `thread::scope` for safe borrowing of non-'static data. The `std::sync` module is central, providing `Mutex`, `RwLock`, `Condvar`, `Barrier`, `Once`, `OnceLock`, and `LazyLock` for various synchronization needs. Message-passing concurrency is addressed through `mpsc channels`, including `Sender`, `Receiver`, `sync_channel`, and the `rendezvous channel`. Atomic operations are detailed with `std::sync::atomic` and its types like `AtomicBool`, `AtomicIsize`, `AtomicUsize`, and `AtomicPtr`, along with different `Memory Ordering` options such as `Ordering::Relaxed`, `Ordering::Acquire`, `Ordering::Release`, `Ordering::AcqRel`, and `Ordering::SeqCst`. The importance of `fences` like `compiler_fence` for memory reordering is also highlighted. Concepts like `Arc` and `Rc` for shared ownership, and the `Send` and `Sync` traits for thread safety, are well-explained. Common concurrency problems such as `deadlock`, `livelock`, `starvation`, `data races`, and `race conditions` are explicitly mentioned as concerns that Rust's concurrency model aims to prevent or manage. The excerpts also introduce external crates that enhance concurrency capabilities, including `parking_lot` for faster mutexes and rwlocks, `crossbeam` and its sub-crates like `crossbeam-channel`, `crossbeam-epoch` for memory reclamation, and `crossbeam-deque` for work-stealing. `Flume` is presented as a fast mpsc channel alternative, and `Rayon` for `parallel iterators` and work-stealing. `Loom` is introduced as a testing tool for concurrent Rust code, and `poisoning` is mentioned in the context of mutexes. All these elements directly correspond to the requested fine-grained field values, providing a thorough and well-supported set of keywords for synchronous concurrency in Rust.",
      "confidence": "high"
    },
    {
      "field": "scientific_computing_and_ml_keywords.15",
      "citations": [
        {
          "title": "Bevy vs Fyrox/macroquad/ggez/etc. : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/190arcn/bevy_vs_fyroxmacroquadggezetc/",
          "excerpts": [
            "By the industry standards, it is at the bottom of the list of preferrable game engines, Fyrox is there too, but a few orders of magnitude better ..."
          ]
        }
      ],
      "reasoning": "The finegrained field value refers to the specific game engine Fyrox within the Rust ecosystem. The most relevant excerpt explicitly references Fyrox in the context of a Bevy vs Fyrox/macroquad/ggez comparison among Rust game engines, indicating that Fyrox is indeed part of the Rust game-engine landscape. This supports the field value by confirming Fyroxâ€™s presence and relative positioning among Rust game engines. While other excerpts discuss Rust libraries, ECS patterns, and game engines in general, they do not mention Fyrox directly and thus provide indirect context rather than direct evidence. Therefore, the cited excerpt is the strongest piece of evidence for the existence and contextual placement of Fyrox within Rust-based tooling and game development libraries.",
      "confidence": "low"
    },
    {
      "field": "testing_and_qa_keywords",
      "citations": [
        {
          "title": "Introduction - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/?search=edition",
          "excerpts": [
            "The edition of a package is specified in the Cargo.toml manifest , and individual targets can specify which edition they use. See the Edition Guide for more ..."
          ]
        },
        {
          "title": "C - Derivable Traits - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-03-derivable-traits.html",
          "excerpts": [
            "The derive attribute generates code that will implement a trait with its own default implementation on the type you've annotated with the derive syntax."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()",
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "* `'static`\n* `macro_rules`\n* `raw`\n* `safe`\n* `union`\n",
            "* `macro_rules` is used to create custom [macros](macros.html).",
            "* `safe` is used for functions and statics, which has meaning in [external blocks](items/external-blocks.html).",
            "* `raw` is used for [raw borrow operators](expressions/operator-expr.html), and is only a keyword when matching a raw borrow operator form (such as `&raw const expr` or `&raw mut expr`).",
            "reserved",
            "weak",
            "These keywords can only be used in their correct contexts.\nThey cannot\nbe used as the names of:\n\n* [Items](items.html)\n* [Variables](variables.html) and function parameters\n* Fields and [variants](items/enumerations.html)\n* [Type parameters](types/parameters.html)\n* Lifetime parameters or [loop labels](expressions/loop-expr.html)\n* [Macros](macros.html) or [attributes](attributes.html)\n* [Macro placeholders](macros-by-example.html)\n* [Crates](crates-and-source-files.html)",
            "KW\\_AS : `as",
            "KW\\_BREAK : `break",
            "KW\\_CONST : `const",
            "KW\\_CONTINUE : `continue",
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "Rust divides keywords into three categories:\n\n* [strict]()\n* [reserved]()\n* [weak]()"
          ]
        }
      ],
      "reasoning": "Excerpts 0 through 30 extensively discuss various testing types, frameworks, and tools in Rust, covering unit tests with `cargo test`, doctests, property-based testing with `proptest`, fuzz testing with `cargo-fuzz`, snapshot testing with `insta`, mutation testing, coverage tools like `cargo-llvm-cov`, and testing best practices such as organization and organization using attributes like `#[cfg(test)]`. They include specific details on test organization, tools, techniques such as shrinking, replay, and minimization, and mention integration with CI/CD pipelines. This corpus supports the specified testing and QA keywords comprehensively, confirming their relevance.",
      "confidence": "high"
    },
    {
      "field": "performance_and_optimization_keywords",
      "citations": [
        {
          "title": "Introduction - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/?search=edition",
          "excerpts": [
            "The edition of a package is specified in the Cargo.toml manifest , and individual targets can specify which edition they use. See the Edition Guide for more ..."
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_CRATE : `crate",
            "KW\\_ELSE : `else",
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "> **<sup>Lexer 2018+</sup>**",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "KW\\_RAW : `raw",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "* [strict]()\n* [reserved]()\n* [weak]()\n"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\"",
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers."
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            " `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n",
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "RAW\\_IDENTIFIER](identifiers.html) â†’ r# [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) <sub>except `crate` , `self` , `super` , `Self`</su",
            "It is an error to use the [RESERVED\\_RAW\\_IDENTIFIER](identifiers.html) token `r` in order to avoid confusion with the [WildcardPattern](patterns.html)",
            "Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in `rustc` .",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) .",
            "Show Railroad"
          ]
        },
        {
          "title": "The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/",
          "excerpts": [
            "What editions are",
            "Which changes are contained in each edition",
            "How to migrate your code from one edition to another",
            "In this guide, we'll discuss: What editions are; Which changes are contained in each edition; How to migrate your code from one edition to another."
          ]
        },
        {
          "title": "Managing Growing Projects with Packages, Crates, and ...",
          "url": "https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html",
          "excerpts": [
            "Packages: A Cargo feature that lets you build, test, and share crates Â· Crates: A tree of modules that produces a library or executable Â· Modules and use: Let you ..."
          ]
        },
        {
          "title": "Operator expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/operator-expr.html",
          "excerpts": [
            "Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in std::ops or std::cmp."
          ]
        },
        {
          "title": "Literal expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/literal-expr.html",
          "excerpts": [
            "A literal expression is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it ..."
          ]
        },
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        },
        {
          "title": "Features - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo â€œfeaturesâ€ provide a mechanism to express conditional compilation and optional dependencies. A package defines a set of named features in the [features] ..."
          ]
        },
        {
          "title": "Transitioning an existing project to a new edition",
          "url": "https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html",
          "excerpts": [
            "The Rust Edition Guide ... In order to help transition to the next edition, Cargo includes the cargo fix subcommand to automatically update your source code."
          ]
        },
        {
          "title": "Advanced migrations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/editions/advanced-migrations.html",
          "excerpts": [
            "The lints that cargo fix --edition apply are part of a lint group. For example, when migrating from 2018 to 2021, Cargo uses the rust-2021-compatibility group ..."
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]().",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`."
          ]
        },
        {
          "title": "Visibility and Privacy - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/visibility-and-privacy.html",
          "excerpts": [
            "Visibility and privacy - The Rust Reference",
            "By default, everything is _private_ , with two exceptions: Associated\nitems in a `pub` Trait are public by default; Enum variants\nin a `pub` enum are also public by default. When an item is declared as `pub` ,\nit can be thought of as being accessible to the outside world. For example:",
            "```rust\nfn main() {}\n// Declare a private struct\nstruct Foo;\n\n// Declare a public struct with a private field\npub struct Bar {\n    field: i32,\n}\n\n// Declare a public enum with two public variants\npub enum State {\n    PubliclyAccessibleState,\n    PubliclyAccessibleState2,\n}\n```",
            "With the notion of an item being either public or private, Rust allows item\naccesses in two cases:\n\n1. If an item is public, then it can be accessed externally from some module `m` if you can access all the itemâ€™s ancestor modules from `m` . You can\n   also potentially be able to name the item through re-exports. See below. 2. If an item is private, it may be accessed by the current module and its\n   descendants.",
            "## [`pub(in path)` , `pub(crate)` , `pub(super)` , and `pub(self)`]()",
            "* `pub(in path)` makes an item visible within the provided `path` . `path` must be a simple path which resolves to an ancestor module of the item whose visibility is being declared.\nEach identifier in `path` must refer directly to a module (not to a name introduced by a `use` statement).",
            "* `pub(crate)` makes an item visible within the current crate.",
            "* `pub(super)` makes an item visible to the parent module. This is equivalent\n  to `pub(in super)` .",
            "* `pub(self)` makes an item visible to the current module. This is equivalent\n  to `pub(in self)` or not using `pub` at all.",
            "> 2018 Edition differences\n> \n> Starting with the 2018 edition, paths for `pub(in path)` must start with `crate` , `self` , or `super` . The 2015 edition may also use paths starting with `::` or modules from the crate root. Hereâ€™s an example:",
            "```rust\npub mod outer_mod {\n    pub mod inner_mod {\n        // This function is visible within \\`outer_mod\\`\n        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}\n        // Same as above, this is only valid in the 2015 editio"
          ]
        },
        {
          "title": "The Rust Reference - Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes.html?highlight=attribute",
          "excerpts": [
            "Inner attributes_ , written with a bang ( `!` ) after the hash ( `#` ), apply to the\nitem that the attribute is declared within. _Outer attributes_ , written without\nthe bang after the hash, apply to the thing that follows t"
          ]
        },
        {
          "title": "std - Rust",
          "url": "https://doc.rust-lang.org/std/",
          "excerpts": [
            "The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem."
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "Preludes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/names/preludes.html",
          "excerpts": [
            "A *prelude* is a collection of names that are automatically brought into scope\nof every module in a crat",
            "There are several different preludes:",
            "* [Standard library prelud",
            "* [Extern prelud",
            "* [Language prelud",
            "* [`macro_use` prelud",
            "* [Tool prelud",
            "The language prelude includes names of types and attributes that are built-in\nto the language. The language prelude is always in scope.",
            "It includes the following:\n\n* [Type namespace](namespaces.html)\n  + [Boolean type](../types/boolean.html) â€” `bool`\n  + [Textual types](../types/textual.html) â€” `char` and `str`\n  + [Integer types](../types/numeric.html) â€” `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`\n  + [Machine-dependent integer types](../types/numeric.html) â€” `usize` and `isize`\n  + [floating-point types](../types/numeric.html) â€” `f32` and `f64`",
            "d to the crate:\n\n| Edition | `no_std` not applied | `no_std` applied |\n| --- | --- | --- |\n| 2015 | [`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) | [`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) |\n| 2018 | [`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html) | [`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html) |\n| 2021 | [`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html) | [`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html) |\n| 2024 | [`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html) | [`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html) ",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e` [attribute](../attributes.html)* may be applied at the crate level or\non a module to indicate that it should not automatically bring the [standard\nlibrary prelude](), [extern prelude](), or [tool prelude]() into scope for that\nmodule or any of its descendants."
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n```\n\nAlternatively:\n\n```\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,\n```\n\n(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)\n\n`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.\n\nIn summary, we can rewrite the original code more explicitly as:\n\n```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n```\n```",
            "Higher-Rank Trait Bounds - The Rustonomicon",
            "Rust's `Fn` traits are a little bit magic. For instance, we can write the",
            "following code:",
            "```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ...",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "let data = Arc::new(Mutex::new( 0 ));",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "This mutex will block threads waiting for the lock to become available",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "use std::sync::{Arc, Mutex};",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    "
          ]
        },
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "resources can only have one owner",
            "This prevents resources",
            "from being freed more than once. Note that not all variables own",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved",
            "    let y = x;",
            "Both values can be independently used"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid.",
            "Lifetimes - Rust By Example"
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time.",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Error codes index",
          "url": "https://doc.rust-lang.org/error-index.html",
          "excerpts": [
            "Rust error codes index - Error codes index\n\nIf you are not automatically redirected to the error code index, please [here](./error_codes/error-index.html) ."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "The Rust Programming Language Blog",
          "url": "https://blog.rust-lang.org/",
          "excerpts": [
            "This is the main Rust blog. Rust teams use this blog to announce major developments in the world of Rust. See also: the \"Inside Rust\" blog,Â ..."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "# [`min_specialization`]()",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "min\\_specialization - The Rust Unstable Boo"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            " [Idea] About soundness in specialization ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... ",
            "This topic was automatically closed 90 days after the last reply. New replies are no longer allowed."
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes.",
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Rust Deep Dive: Borked Vtables and Barking Cats",
          "url": "https://geo-ant.github.io/blog/2023/rust-dyn-trait-objects-fat-pointers/",
          "excerpts": [
            "Mar 15, 2023 â€” The pointers to dyn Trait objects store both the address of the data as well as a pointer to the vtable. There is one global vtable instance forÂ ...",
            "Mar 15, 2023 â€” We'll get to the specific layout of a vtable below, but for now suffice it to say that a vtable is a contiguous piece of storage in memory thatÂ ..."
          ]
        },
        {
          "title": "Understanding Rust's Trait Objects: Vtables, Dynamic ...",
          "url": "https://www.reddit.com/r/rust/comments/1epc5g6/understanding_rusts_trait_objects_vtables_dynamic/",
          "excerpts": [
            "This article investigates how Rust handles dynamic dispatch using trait objects and vtables. It also explores how the Rust compiler can sometimes optimize tailÂ ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "# [Chalk: Orphan Check]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "## [The Orphan Rules]()",
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "The reason for this is that there are two appearances of type parameter `T` in",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117)."
          ]
        },
        {
          "title": "Coherence - Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/coherence.html",
          "excerpts": [
            "Coherence checking is what detects both of trait impls and inherent impls overlapping with others.",
            "Overlap checks are performed for both inherent impls, and for trait impls.",
            "This uses the same overlap checking code, really done as two separate analyses.",
            "Overlapping is sometimes partially allowed:",
            "1. for marker traits",
            "2. under [specializatio",
            "but normally isn't.",
            "the explicit negative impl check, and the implicit negative impl check. Both try to prove that an overlap is definitely impossible.",
            "ses. Overlap checks always consider pairs of implementations, comparing them to each other. Overlap "
          ]
        },
        {
          "title": "Data Representation and Layout in Rust - OpenGuild",
          "url": "https://openguild.wtf/blog/rust/data-representation-and-layout",
          "excerpts": [
            "Nov 22, 2023 â€” Rust, with its emphasis on control and safety, provides two primary representations: repr(rust) and repr(C) . The former instructs theÂ ..."
          ]
        },
        {
          "title": "2005-match-ergonomics - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2005-match-ergonomics.html",
          "excerpts": [
            "This RFC introduces default binding modes used when a reference value is matched by a non-reference pattern."
          ]
        },
        {
          "title": "Idiomatic definition of uninhabited (never) newtypes",
          "url": "https://internals.rust-lang.org/t/idiomatic-definition-of-uninhabited-never-newtypes/20877",
          "excerpts": [
            "May 20, 2024 â€” It's conventional to use an empty enum for an uninhabited type, because that's the only stable way to do it."
          ]
        },
        {
          "title": "Why doesn't the niche optimization work for this enum?",
          "url": "https://users.rust-lang.org/t/why-doesnt-the-niche-optimization-work-for-this-enum/55711",
          "excerpts": [
            "Feb 16, 2021 â€” The only guaranteed niche filling optimization is if you have an enum that fits the template below exactly, and the wrapped type has a niche."
          ]
        },
        {
          "title": "Pre-(Pre-)RFC: niche types - language design",
          "url": "https://internals.rust-lang.org/t/pre-pre-rfc-niche-types/21810",
          "excerpts": [
            "Nov 2, 2024 â€” Niches are bit patterns within a struct or enum which can be repurposed by an enclosing enum or, in the future, an enclosing struct. While thisÂ ..."
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html?highlight=never",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete. [type. never .coercion]. Expressions of type ! can ..."
          ]
        },
        {
          "title": "never patterns, exhaustive matching, and uninhabited types",
          "url": "https://internals.rust-lang.org/t/blog-post-never-patterns-exhaustive-matching-and-uninhabited-types/8197",
          "excerpts": [
            "Aug 14, 2018 â€” Having two traits should solve problem with obscure corner cases with recursive uninhabited types, as they will not implement any of thoseÂ ..."
          ]
        },
        {
          "title": "Rust Reference: Type Layout",
          "url": "https://doc.rust-lang.org/reference/type-layout.html",
          "excerpts": [
            "All user-defined composite types ( `struct` s, `enum` s, and `union` s) have a _representation_ that specifies what the layout is for the type. [[layout .repr .kinds]]",
            ")\n\nThe possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()\n\n[[layout .repr .at",
            "The representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.",
            "ntro\")\n\nThe layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout. [[layout .guarantees]](.guarantees",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today. Note that even types with the same layout can still differ in how they are passed\nacross function boundaries."
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at most_ `n` . Most commonly used without an explicit `n` , `repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.",
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have `repr(C)` , as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type. We strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage your FFI\nboundaries fo",
            "The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world.",
            "* If `T` is an [FFI-safe non-nullable pointer\n  type](ffi.html),\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.",
            "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.",
            "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at least_ `n` . This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code). This is a modifier on `repr(C)` and `repr(Rust)` . It is incompatible with `repr(packed)` .",
            "The Rustonomicon",
            "\n# [Alternative representations]()",
            "[repr(C)]()",
            "* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.",
            "## [repr(transparent)]()",
            "Rust allows you to specify alternative data layout strategies from the default. There's also the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** normative). ## [repr(C)]()",
            "## [repr(u\\*), repr(i\\*)]",
            "## [repr(packed), repr(packed(n))]()",
            "## [repr(align(n))]()"
          ]
        },
        {
          "title": "Rust Nomicon: repr-rust (Memory layout and ABI considerations)",
          "url": "https://doc.rust-lang.org/nomicon/repr-rust.html",
          "excerpts": [
            "Rust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)\n\nAn enum is said to be _field-less_ if none of its variants have associated data. By default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n}\n```\n```\n\nwill be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align \\`b\\`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n}\n```\n```\n\nor maybe:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n}\n```\n```\n\nThere is _no indirection_ for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```rust\n#!",
            "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2. Primitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits). A type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of [dynamically sized types](exotic-sizes.html).\nRust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)",
            "\n\nThere is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct A {\n    a: i32,\n    b: u64,\n}\n\nstruct B {\n    a: i32,\n    b: u64,\n}\n}\n```\n```\n\nRust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B. With A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways. For instance, consider this struct:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nstruct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}\n}\n```\n```\n\nNow consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:\n\n```\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}\n\nstruct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}\n```\n\nThe latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*. Enums make this consideration even more complicated. Naively, an enum such as:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nenum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}\n}\n```\n```\n\nmight be laid out as:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}\n}\n```\n```\n\nAnd indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`). However there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`. There are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today."
          ]
        },
        {
          "title": "Stack Overflow: Whats the difference between #[repr(Rust)], #[repr(C)] and #[repr(packed)]?",
          "url": "https://stackoverflow.com/questions/79631106/whats-the-difference-between-reprrust-reprc-and-reprpacked",
          "excerpts": [
            "In summary, `#[repr(Rust)]` leaves the representation to the compiler, which will probably do a better job of optimising the representation than you would by hand, and thus it makes the most sense to use for general use (which is why it's the default â€“ it's rare to actually write `#[repr(Rust)]` explicitly).",
            "`#[repr(C)]` exists to allow two sections of code to agree on how data should be represented even if they're compiled independently of each other; its purpose is to be a consistent representation that always stays the same.",
            "the reason is that the structure needs to always have the same layout so that the `select` function can actually access its fields (it's been compiled by the OS vendors, separately from the Rust code, so will be looking at known locations for the fields and Rust needs to put the fields in the same place)."
          ]
        },
        {
          "title": "Rust Reference: Non-exhaustive Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes/type_system.html",
          "excerpts": [
            "The *`non_exhaustive` attribute* indicates that a type or variant may have\nmore fields or variants added in the future.",
            "Outside of the defining crate, types annotated with `non_exhaustive` have limitations that\npreserve backwards compatibility when new fields or variants are added.",
            "Non-exhaustive types cannot be constructed outside of the defining crate:\n\n* Non-exhaustive variants ([`struct`](../items/structs.html) or [`enum` variant](../items/enumerations.html)) cannot be constructed\n  with a [StructExpression](../expressions/struct-expr.html) (including with [functional update syntax](../expressions/struct-expr.html)). * The implicitly defined same-named constant of a [unit-like struct](../items/structs.html),\n  or the same-named constructor function of a [tuple struct](../items/structs.html),\n  has a [visibility](../visibility-and-privacy.html) no greater than `pub(crate)`",
            "There are limitations when matching on non-exhaustive types outside of the defining crate:",
            "The Rust Reference",
            "Type system attributes",
            "The `non_exhaustive` attribute",
            "It can be applied to [`struct`s](../items/structs.html), [`enum`s](../items/enumerations.html), and `enum` variants."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "The Rust Reference"
          ]
        },
        {
          "title": "Empty Source Document",
          "url": "https://doc.rust-lang.org/reference/patterns.html",
          "excerpts": [
            "**NOTE**: The provided source document is empty and does not contain any information relevant to the query about Rust's type system, algebraic data types, pattern matching, or type layout concepts.",
            "Patterns are used in:",
            "`let` declarations\n`match` expressions\n`if let` expressions\n`while let` expressions\n`for` expressions\n",
            "Patterns can be used to *destructure* [structs](items/structs.html), [enums](items/enumerations.html), and [tuples](types/tuple.html). Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.",
            "wildcard\")\n\nIn a pattern whose [scrutinee](glossary.html) expression has a `struct`, `enum` or `tuple` type, a [wildcard pattern]() (`_`) stands in for a *single* data field, whereas an [et cetera]() or [rest pattern]() (`..`) stands in for *all* the remaining fields of a particular variant."
          ]
        },
        {
          "title": "Rust Type Layout and ABI Details",
          "url": "https://doc.rust-lang.org/std/mem/fn.discriminant.html",
          "excerpts": [
            "\nIf an enum has opted-in to having a [primitive representation](../../reference/type-layout.html) for its discriminant,\nthen itâ€™s possible to use pointers to read the memory location storing the discriminant. That **cannot** be done for enums using the [default representation](../../reference/type-layout.html) , however, as itâ€™s\nundefined what layout the discriminant has and where itâ€™s stored â€” it might not even be\nstored at all!",
            "\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct {"
          ]
        },
        {
          "title": "Refutability: Whether a Pattern Might Fail to Match",
          "url": "https://doc.rust-lang.org/book/ch19-02-refutability.html",
          "excerpts": [
            "Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable."
          ]
        },
        {
          "title": "Defining an Enum - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html",
          "excerpts": [
            "This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include anotherÂ ..."
          ]
        },
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n",
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "### [Â§]() Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an\niterator that is conditionally empty.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](.",
            " std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok\\(T\\),%0A+++++++Err\\(E\\),%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](../../std/io/index.html) .\n ... \n;\n    Ok (())\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++fn+write_message\\(\\)+-%3E+io::Result%3C\\(\\)%3E+%7B%0A++++++++let+mut+file+=+File::create\\(%22valuable_data.txt%22\\)?;%0A++++++++file.write_all\\(b%22important+message%22\\)? ;%0A++++++++Ok\\(\\(\\)\\)%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\n## [Â§]() The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark\noperator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\") , hides some of the boilerplate of propagating errors\nup the call stack. It replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude:: * ;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: & Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create( \"my_best_friends.txt\" ) {\n           Err (e) => return Err (e),\n           Ok (f) => f,\n    };\n    if let Err (e) = file.write_all( format! ( \"name: {}\\n\" , info.name).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format! ( \"age: {}\\n\" , info.age).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format!\n ... \n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides. ## [Â§]() Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI\nguarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a\ntype that qualifies for the `Option` [representation guarantees](../option/index.html \"Option Representation\") ,\nand the _other_ type must meet all of the following conditions:\n\n* Is a zero-sized type with alignment 1 (a â€œ1-ZSTâ€). * Has no fields. * Does not have the `#[non_exhaustive]` attribute. For example, `NonZeroI32` qualifies for the `Option` representation\nguarantees, and `()` is a zero-sized type with alignment 1, no fields, and\nit isnâ€™t `non_exhaustive` . This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees\nas `Option<NonZeroI32>` .\n ... \nIf the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](enum.Result.html.Ok \"variant std::result::Result::Ok\") :\n\n* [`expect_err`](enum.Result.html.expect_err \"method std::result::Result::expect\\_err\") panics with a provided custom message\n* [`unwrap_err`](enum.Result.html.unwrap_err \"method std::result::Result::unwrap\\_err\") panics with a generic message\n* [`unwrap_err_unchecked`](enum.Result.html.unwrap_err_unchecked \"method std::result::Result::unwrap\\_err\\_unchecked\") produces _[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)_\n\n### [Â§]() Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\") :\n\n* [`err`](enum.Result.html.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\") ,\n  mapping [`Err(e)`]"
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete."
          ]
        },
        {
          "title": "Type Layout - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/type-layout.html?highlight=repr",
          "excerpts": [
            "Type layout - The Rust Reference",
            "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.",
            "Type layout can be changed with each compilation.",
            "All values have an alignment and size.",
            "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.",
            "Pointers to sized types have the same size and alignment as `usize`.",
            "Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.",
            "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes.",
            "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`.",
            "Tuples are laid out according to the [`Rust` representation]()",
            "The exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.",
            "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.",
            "The possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()",
            "The representation of a type can be changed by applying the `repr` attribute\nto it.",
            "The alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.",
            "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.",
            "The only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n1. The fields are properly aligned. 2. The fields do not overlap. 3. The alignment of the type is at least the maximum alignment of its fields.",
            "There are no other guarantees of data layout made by this representation.",
            "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.",
            "This representation can be applied to structs, unions, and enums.\nThe exception\nis [zero-variant enums](items/enumerations.html) for which the `C` representation is an error.",
            "The alignment of the struct is the alignment of the most-aligned field in it.",
            "The size and offset of fields is determined by the following algorithm. Start with a current offset of 0 bytes. For each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the fieldâ€™s\nalignment, then add padding bytes to the current offset until it is a multiple\nof the fieldâ€™s alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field. Finally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the structâ€™s alignment.",
            "For [field-less enums](items/enumerations.html), the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platformâ€™s C ABI.",
            "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a â€œtagged unionâ€ in C:",
            "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize",
            "Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums](items/enumerations.html) to have a primitive representation. Combining\ntwo primitive representations together is an error.",
            "For [field-less enums](items/enumerations.html), primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive.",
            "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (â€œthe tagâ€) and the remaining fields are the fields of that variant.",
            "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`]() by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.",
            "The `transparent` representation can only be used on a [`struct`](items/structs.html)\nor an [`enum`](items/enumerations.html) with a single variant that has:\n\n* any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`](special-types-and-traits.html)), and\n* at most one other field.",
            "Structs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field."
          ]
        },
        {
          "title": "The Nullable Pointer Optimization",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "Certain Rust types are defined to never be `null`. This includes references (`&T`,\n`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\ninterfacing with C, pointers that might be `null` are often used, which would seem to\nrequire some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types. However, trying to construct/work with these invalid values **is undefined behavior**,\nso you should use the following workaround instead. As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\nexactly two variants, one of which contains no data and the other contains a field of one of the\nnon-nullable types listed above. This means no extra space is required for a discriminant; rather,\nthe empty variant is represented by putting a `null` value into the non-nullable field. This is\ncalled an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\ntypes. The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\nwhere `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\nto represent a nullable function pointer using the C ABI (corresponding to the C type\n`int (*)(int)`). Here is a contrived example.",
            "If you expect Rust `panic` s or foreign (e.g. C++) exceptions to cross an FFI\nboundary, that boundary must use the appropriate `-unwind` ABI string.",
            "extern \"C-unwind\"",
            "The `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \" [Foreign Calling Conventions](ffi.html) \". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.",
            "Foreign functions are assumed to be unsafe so calls to them need to be wrapped\nwith `unsafe {}` as a promise to the compiler that everything contained within\ntruly is safe.",
            "The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts\nlike vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\ninternal details."
          ]
        },
        {
          "title": "Enums and Pattern Matching - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-00-enums.html",
          "excerpts": [
            "Enums and Pattern Matching",
            "tching]()\n\nIn this chapter, weâ€™ll look at _enumerations_ , also referred to as _enums_ . Enums allow you to define a type by enumerating its possible _variants_ . First\nweâ€™ll define and use an enum to show how an enum can encode meaning along with\ndata. Next, weâ€™ll explore a particularly useful enum, called `Option` , which\nexpresses that a value can be either something or nothing. Then weâ€™ll look at\nhow pattern matching in the `match` expression makes it easy to run different\ncode for different values of an enum. Finally, weâ€™ll cover how the `if let` construct is another convenient and concise idiom available to handle enums in\nyour code."
          ]
        },
        {
          "title": "Match ergonomics reservations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html",
          "excerpts": [
            "Match ergonomics reservations - The Rust Edition Guide",
            "Within `match`, `let`, and other constructs, we match a *pattern* against a *scrutinee*. E.g. :",
            "Such a pattern is called fully explicit because it does not elide (i.e. \"skip\" or \"pass\") any references within the scrutinee.",
            "By contrast, this otherwise-equivalent pattern is not fully explicit:",
            "Patterns such as this are said to be using match ergonomics, originally introduced in [RFC 2005](https://github.com/rust-lang/rfcs/pull/2005). Under match ergonomics, as we incrementally match a pattern against a scrutinee, we keep track of the default binding mode. This mode can be one of `move`, `ref mut`, or `ref`, and it starts as `move`. When we reach a binding, unless an explicit binding mode is provided, the default binding mode is used to decide the binding's type.",
            "### [`mut` restriction]()",
            "Here, because we pass the shared reference in the pattern, the default binding mode switches to `ref`.",
            "But then, in these editions, writing `mut` on the binding resets the default binding mode to `move`. This can be surprising as it's not intuitive that mutability should affect the type. To leave space to fix this, in Rust 2024 it's an error to write `mut` on a binding when the default binding mode is not `move`. That is, `mut` can only be written on a binding when the pattern (leading up to that binding) is fully explicit.",
            "### [`ref` / `ref mut` restriction]()",
            "In Rust 2021 and earlier editions, we allow:",
            "Here, the `ref` explicit binding mode is redundant, as by passing the shared reference (i.e. not mentioning it in the pattern), the binding mode switches to `ref`.",
            "To leave space for other language possibilities, we are disallowing explicit binding modes where they are redundant in Rust 2024.",
            "### [Reference patterns restriction]()",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "Here, the `&` in the pattern both matches against the reference on `&()` and resets the default binding mode to `move`.",
            "This can be surprising because the single `&` in the pattern causes a larger than expected change in the type by removing both layers of references. To leave space to fix this, in Rust 2024 it's an error to write `&` or `&mut` in the pattern when the default binding mode is not `move`. That is, `&` or `&mut` can only be written when the pattern (leading up to that point) is fully explicit.",
            "The [`rust_2024_incompatible_pat`](../../rustc/lints/listing/allowed-by-default.html) lint flags patterns that are not allowed in Rust 2024. This lint is part of the `rust-2024-compatibility` lint group which is automatically applied when running `cargo fix --edition`. This lint will automatically convert affected patterns to fully explicit patterns that work correctly in Rust 2024 and in all prior editions. To migrate your code to be compatible with Rust 2024, run:",
            "```\ncargo fix --edition\n```"
          ]
        },
        {
          "title": "Pattern Syntax - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html",
          "excerpts": [
            "In this section, we gather all the syntax that is valid in patterns and discuss\nwhy and when you might want to use each one. ### [Matching Literals]()",
            "fn main() {\n    let x = 1;\n\n    match x {\n        1 => println! (\"one\"),\n        2 => println! (\"two\"),\n        3 => println! (\"three\"),\n        _ => println! (\"anything\"),\n    }\n}",
            "Named variables are irrefutable patterns that match any value, and weâ€™ve used\nthem many times in this book. However, there is a complication when you use\nnamed variables in `match`, `if let`, or `while let` expressions. Because each\nof these kinds of expression starts a new scope, variables declared as part of a\npattern inside the expression will shadow those with the same name outside, as\nis the case with all variables.\nIn Listing 19-11, we declare a variable named\n`x` with the value `Some(5)` and a variable `y` with the value `10`. We then\ncreate a `match` expression on the value `x`. Look at the patterns in the match\narms and `println!` at the end, and try to figure out what the code will print\nbefore running this code or reading further. Filename: src/main.rs",
            "fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println! (\"Got 50\"),\n        Some(y) => println! (\"Matched, y = {y}\"),\n        _ => println! (\"Default case, x = {x:? }\"),\n    }\n\n    println! (\"at the end: x = {x:? }, y = {y}\");\n}",
            "[Listing 19-11](): A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`",
            "Similarly, the second arm matches any point on the `y` axis by specifying that\nthe `x` field matches if its value is `0` and creates a variable `y` for the\nvalue of the `y` field. The third arm doesnâ€™t specify any literals, so it\nmatches any other `Point` and creates variables for both the `x` and `y` fields. In this example, the value `p` matches the second arm by virtue of `x`\ncontaining a `0`, so this code will print `On the y axis at 7`. Remember that a `match` expression stops checking arms once it has found the\nfirst matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` axis\nand the `y` axis, this code would only print `On the x axis at 0`.",
            "Weâ€™ve destructured enums in this book (for example, Listing 6-5), but we havenâ€™t\nyet explicitly discussed that the pattern to destructure an enum corresponds to\nthe way the data stored within the enum is defined. As an example, in Listing\n19-15 we use the `Message` enum from Listing 6-2 and write a `match` with\npatterns that will destructure each inner value. Filename: src/main.rs",
            "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println! (\"The Quit variant has no data to destructure. \");\n        }\n        Message::Move { x, y } => {\n            println!\n(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println! (\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println! (\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n    }\n}",
            "[Listing 19-15](): Destructuring enum variants that hold different kinds of values",
            "This code will print `Change color to red 0, green 160, and blue 255`. Try\nchanging the value of `msg` to see the code from the other arms run. For enum variants without any data, like `Message::Quit`, we canâ€™t destructure\nthe value any further. We can only match on the literal `Message::Quit` value,\nand no variables are in that pattern. For struct-like enum variants, such as `Message::Move`, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 19-13. For tuple-like enum variants, like `Message::Write` that holds a tuple with one\nelement and `Message::ChangeColor` that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant weâ€™re\nmatching.",
            "The condition can use variables created in the pattern. Listing 19-26 shows a\n`match` where the first arm has the pattern `Some(x)` and also has a match\nguard of `if x % 2 == 0` (which will be `true` if the number is even).",
            "fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println! (\"The number {x} is even\"),\n        Some(x) => println! (\"The number {x} is odd\"),\n        None => (),\n    }\n}",
            "[Listing 19-26](): Adding a match guard to a pattern",
            "This example will print `The number 4 is even`. When `num` is compared to the\npattern in the first arm, it matches because `Some(4)` matches `Some(x)`. Then\nthe match guard checks whether the remainder of dividing `x` by 2 is equal to\n0, and because it is, the first arm is selected. If `num` had been `Some(5)` instead, the match guard in the first arm would\nhave been `false` because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesnâ€™t have a match guard and therefore matches any `Some` variant. There is no way to express the `if x % 2 == 0` condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesnâ€™t try to check for\nexhaustiveness when match guard expressions are involved. In Listing 19-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem.",
            " #### [Destructuring Enums]"
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "The map method takes the self argument by value, consuming the original, so this technique uses as_ref to first take an Option to a reference to the valueÂ ... Computes a default function result (if none), or applies a different function to the contained value (if any). Â§Basic examples. let k = 21; let x = Some(\"foo\"); ...",
            "Returns the contained [`Some`](enum.Option.html.Some \"variant std::option::Option::Some\") value, consuming the `self` value. Because this function may panic, its use is generally discouraged. Panics are meant for unrecoverable errors, and\n[may abort the entire program](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html).",
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)."
          ]
        },
        {
          "title": "Result in std",
          "url": "https://doc.rust-lang.org/beta/std/result/enum.Result.html",
          "excerpts": [
            "Returns true if the result is Err and the value inside of it matches a predicate. Â§Examples. use std::io::{Error, ErrorKind}; let x: Result<u32, Error> ..."
          ]
        },
        {
          "title": "Error handling - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/error.html",
          "excerpts": [
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input would ... Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ...",
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ... When there is a chance that things do go wrong and the caller has to deal with the problem, use Result . You can unwrap and expect them as well (please don't do ..."
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "he `Result` enum is defined as having two\nvariants, `Ok` and `Err` , as follows:",
            "```rust",
            "\n#! [allow(unused)]",
            "fn main() {",
            "enum Result<T, E> {",
            "    Ok(T),",
            "    Err(E)",
            "The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s\nimplementation simpler.",
            "}",
            "}",
            "```"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "std::collections::vec_deque",
          "url": "https://doc.rust-lang.org/std/collections/vec_deque/index.html",
          "excerpts": [
            "A double-ended queue (deque) implemented with a growable ring buffer. This queue has O(1) amortized inserts and removals from both ends of the container."
          ]
        },
        {
          "title": "`smallvec-handle`: a faster small vector implementation?",
          "url": "https://www.reddit.com/r/rust/comments/1i5d856/smallvechandle_a_faster_small_vector/",
          "excerpts": [
            "How it works? Small vector optimization usually means storing items inline (without allocation) until a given (small) capacity. However, unlike ..."
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Note that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\"). For Sets, all operations have the cost of the equivalent Map operation.",
            "Many collections provide several constructors and methods that refer to\nâ€œcapacityâ€. These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the\nelements stored in the collection, but for the collection to do this would\nbe very inefficient. If the backing array was exactly the right size at all\ntimes, then every time an element is inserted, the collection would have to\ngrow the array to fit it. Due to the way memory is allocated and managed on\nmost computers, this would almost surely require allocating an entirely new\narray and copying every single element from the old one into the new one. Hopefully you can see that this wouldnâ€™t be very efficient to do on every\noperation. Most collections therefore use an *amortized* allocation strategy. They\ngenerally let themselves have a fair amount of unoccupied space so that they\nonly have to grow on occasion.",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")",
            "Choosing the right collection for the job requires an understanding of what\neach collection is good at. Here we briefly summarize the performance of\ndifferent collections for certain important operations. For further details,\nsee each typeâ€™s documentation, and note that the names of actual methods may\ndiffer from the tables below on certain collections. Throughout the documentation, we will adhere to the following conventions\nfor operation notation:",
            "The collectionâ€™s size is denoted by `n`. * If a second collection is involved, its size is denoted by `m`. * Item indices are denoted by `i`. * Operations which have an *amortized* cost are suffixed with a `*`. * Operations with an *expected* cost are suffixed with a `~`. Calling operations that add to a collection will occasionally require a\ncollection to be resized - an extra operation that takes *O*(*n*) time.\n*Amortized* costs are calculated to account for the time cost of such resize\noperations *over a sufficiently large series of operations*. An individual\noperation may be slower or faster due to the sporadic nature of collection\nresizing, however the average cost per operation will approach the amortized\ncost. Rustâ€™s collections never automatically shrink, so removal operations arenâ€™t\namortized. [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") uses *expected* costs. It is theoretically possible, though very\nunlikely, for [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") to experience significantly worse performance than\nthe expected cost. This is due to the probabilistic nature of hashing - i.e. it is possible to generate a duplicate hash given some input key that will\nrequires extra computation to correct."
          ]
        },
        {
          "title": "Swisstable, a Quick and Dirty Description - Faultlore",
          "url": "https://faultlore.com/blah/hashbrown-tldr/",
          "excerpts": [
            "Swisstable, a Quick and Dirty Description",
            "Ok hereâ€™s how to implement Swisstable as simply as possible, with a bunch of random notes. Iâ€™m assuming youâ€™re familiar with the basics of an open-addressing hashmap implementation, and will be skipping over all those details. If you want to brush up on those issues, you can read my primer on [the old Rust Robin Hood implementation](https://gankra.github.io/blah/robinhood-part-1/). High level concepts to keep in mind:\n\n* open-addressing\n* searches in parallel using SIMD\n* first-come-first-serve collision resolution\n* chunked (SIMD) triangular (quadratic-ish) probing\n* tombstones to avoid backshifts",
            "Bit fiddling tricks will be omitted because theyâ€™re not that interesting, and I made sure they were really well documented [in hashbrown](https://github.com/rust-lang/hashbrown/tree/master/src/raw) (the Rust impl), so you can just crib the implementations from there (seriously, itâ€™s only 100 lines of code, mostly comments). So if I ever say â€œdo X in parallel (func\\_name)â€ thatâ€™s your cue to check the parallel bit tricks implementation for func\\_name and its detailed documentatio"
          ]
        },
        {
          "title": "Rust HashMap Documentation",
          "url": "https://doc.rust-lang.org/std/collections/struct.HashMap.html",
          "excerpts": [
            "A [hash map](index.html \"mod std::collections\") implemented with quadratic probing and SIMD lookup.",
            "By default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks.",
            "The hash table implementation is a Rust port of Googleâ€™s [SwissTable](https://abseil.io/blog/20180927-swisstables) .",
            "It is also a logic error for a key to be modified in such a way that the keyâ€™s\nhash, as determined by the [`Hash`](../hash/trait.Hash.html \"trait std::hash::Hash\") trait, or its equality, as determined by\nthe [`Eq`](../cmp/trait.Eq.html \"trait std::cmp::Eq\") trait, changes while it is in the map.",
            "The behavior resulting from either logic error is not specified, but will\nbe encapsulated to the `HashMap` that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination."
          ]
        },
        {
          "title": "indexmap-rs GitHub Repository",
          "url": "https://github.com/indexmap-rs/indexmap",
          "excerpts": [
            "This was inspired by Python 3.6's new dict implementation (which remembers\nthe insertion order and is fast to iterate, and is compact in memory). Some of those features were translated to Rust, and some were not. The result\nwas indexmap, a hash table that has following properties:\n\n* Order is **independent of hash function** and hash values of keys. * Fast to iterate. * Indexed in compact space. * Preserves insertion order **as long** as you don't call `.remove()` , `.swap_remove()` , or other methods that explicitly change order. The alternate `.shift_remove()` does preserve relative order. * Uses hashbrown for the inner table, just like Rust's libstd `HashMap` does. ## Performance\n\n[]()\n\n`IndexMap` derives a couple of performance facts directly from how it is constructed,\nwhich is roughly:\n\n> A raw hash table of key-value indices, and a vector of key-value pairs. * \n  Iteration is very fast since it is on the dense key-values. * \n  Removal is fast since it moves memory areas only in the table,\n  and uses a single swap in the vector."
          ]
        },
        {
          "title": "A HashMap in Rust - What's a HashMap? - Faultlore",
          "url": "https://faultlore.com/blah/robinhood-part-1/",
          "excerpts": [
            "A HashMap in Rust: What's a HashMap?",
            "This article is really old! Rust has since moved on to SwissTable (hashbrown), which I describe [in this article](../hashbrown-tldr/). That said, this article is still useful because it mostly discusses issues fundamental to any HashMap design.",
            "In contrast to the [previous](../rust-btree-case/) post, which dove into Rustâ€™s BTreeMap and the idea of B-Trees in general, this post will be split up into two posts. In this post we will take a look at the general problems faced by hashtables, as well as the robin hood hashtable scheme. In the next post, we will take a high-to-mid-level look at Rustâ€™s standard HashMap implementation (surprise, itâ€™s a robin hood hashtable), and what it does to be safe and fast.",
            "We hash ~ alpha\\*n elements into a table of size n where each probe is independent and uniformly distributed over the table, and alpha < 1 is a constant. Let M be the maximum search time for any of the elements in the table. We show that with probability tending to one, M is in [log2log n + a, log2log n + b] for some constants *a* and *b* depending upon alpha only. This is an exponential improvement over the maximum search time in case of the standard FCFS collision strategy. So the expected worst-case search time is O(loglog n) if we have at most some constant load factor",
            "For all intents and purposes, weâ€™ve got constant-time searches.",
            "For performance and simplicity, I recommend a robinhood hashmap, which enjoys O(1) expected time per query without the need for chaining.",
            "For security, I recommend SipHash 2-4 as a reasonable *default* hashing algorithm, with some way to override the default for performance."
          ]
        },
        {
          "title": "bitvec - Rust",
          "url": "https://docs.rs/bitvec/latest/bitvec/",
          "excerpts": [
            "bitvec - Rust",
            "bitvec` provides a foundational API for bitfields in Rust. It specializes\nstandard-library data structures (slices, arrays, and vectors of `bool` ) to use\none-bit-per- `bool` storage, similar to [`std::bitset<N>`](https://en.cppreference.com/w/cpp/utility/bitset) and [`std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool) in C++",
            "If you need to view memory as bit-addressed instead of byte-addressed, then `bitvec` is the fastest, most complete, and Rust-idiomatic crate for you.",
            "It leverages Rustâ€™s\npowerful reference and type systems to create a system that seamlessly bridges\nsingle-bit addressing, precise control of in-memory layout, and Rust-native\nownership and borrowing mechanisms.",
            "Type parameters enable users to select the precise memory representation they\n  desir",
            "A memory model accounts for element-level aliasing and is safe for concurrent\n  us",
            "`BitSlice` cannot be used as a referent type in pointers, such as `Box` , `Rc` ,\n  or `Arc`",
            "`BitSlice` cannot implement `IndexMut` , so `bitslice[index] = true;` does not\n  wor",
            "Minimum Supported Rust Version** : 1.56",
            "Note: `bitvec` supports `#! [no_std]` targets. If you do not have `std` ,\n> disable the default features, and explicitly restore any features that you do\n> h",
            "use type aliases to make names for specific\ninstantiations of `bitvec` type parameters, and use that rather than attempting\nto remain generic over an `<T: BitStore, O: BitOrder>` pair throughout your\nproject.",
            "All data-types have macro\n// constructo",
            "Bit-slices can split anywhere.",
            "the presence of a\ndynamic allocator enables the `BitBox` and `BitVec` buffer types, which can be\nused for more advanced buffer manipulation:",
            "While place expressions like `bits[index] = value;` are not available, `bitvec` instead provides a proxy structure that can be used as _nearly_ an `&mut bit` reference:",
            "The `bitvec` data types implement a complete replacement for their\nstandard-library counterparts, including all of the inherent methods, traits,\nand operator behaviors.",
            "Uses of `bitvec` generally fall into three major genres. * compact, fast, `usize => bit` collections\n* truncated integer storage\n* precise control of memory layout",
            "If your bit-field storage buffers are never serialized for exchange between\nmachines, then you can get away with using the default type parameters and\nunadorned load/store methods.",
            "Many protocols use sub-element fields in order to save space in transport; for\nexample, TCP headers have single-bit and 4-bit fields in order to pack all the\nneeded information into a desirable amount of space.",
            "When using `bitvec` to manage protocol buffers, you will need to select the\nexact type parameters that match your memory layout. For instance, TCP uses `<u8, Msb0>` , while IPv6 on a little-endian machine uses `<u32, Lsb0>` .",
            "`bitvec` has a few Cargo features that govern its API surface. The default\nfeature set is:",
            "`alloc` : This links against the `alloc` distribution crate, and provides the `BitVec` and `BitBox` types. It can be used on `#! [no_std]` targets that\n  possess a dynamic allocator but not an operating syste",
            "`atomic` : This controls whether atomic instructions can be used for aliased\n  memor",
            "`serde` : This enables the de/serialization of `bitvec` buffers through the `serde` system. This can be useful if you need to transmit `usize => bool` collections.",
            "`std` : This provides some `std::io::{Read,Write}` implementations, as well as `std::error::Error` for the various error types. It is otherwise unnecessary.",
            "bitvec/latest/bitvec) explores `bitvec` â€™s usage and implementation in\ngreat detail. In particular, you should read the documentation for the [`order`](https://docs.rs/bitvec/latest/bitvec/order/index.html) , [`store`](https://docs.rs/bitvec/latest/bitvec/store/index.html) , and [`field`](https://docs.rs/bitvec/latest/bitvec/field/index.html) modules, as well as the [`BitSlice`](https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html) and [`BitArray`](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) types.",
            "In addition, the [user guide](https://bitvecto-rs.github.io/bitvec/) explores the philosophical and academic\nconcepts behind `bitvec` â€™s construction, its goals, and the more intricate parts\nof its behavior."
          ]
        },
        {
          "title": "SmallVec::spilled() causing performance overhead on Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1g8o9a6/smallvecspilled_causing_performance_overhead/",
          "excerpts": [
            "I am the author of the [markov\\_str](https://github.com/Brogolem35/markov_str) library and I am trying out the [smallvec](https://github.com/servo/rust-smallvec/tree/v1) to speed up the training of my Markov Chains",
            "But I have encountered this issue while benchmarking with [cargo flamegraph](https://github.com/flamegraph-rs/flamegraph): equivalance checks between `SmallVec`s take too long and almost all the time is spent on `spilled()`.",
            "}\n```\n\nSmallVec struct:\n\n```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= Self::inline_capacity() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use)."
          ]
        },
        {
          "title": "VecDeque in std::collections - Rust",
          "url": "https://doc.rust-lang.org/std/collections/struct.VecDeque.html",
          "excerpts": [
            "A double-ended queue implemented with a growable ring buffer. The â€œdefaultâ€ usage of this type as a queue is to use push_back to add to the queue, and ..."
          ]
        },
        {
          "title": "BinaryHeap in std::collections",
          "url": "https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html",
          "excerpts": [
            "The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and theÂ ..."
          ]
        },
        {
          "title": "std::collections::binary_heap",
          "url": "https://doc.rust-lang.org/std/collections/binary_heap/index.html",
          "excerpts": [
            "Converting a vector to a binary heap can be done in-place, and has O(n) complexity. A binary heap can also be converted to a sorted vector in-place, allowing itÂ ..."
          ]
        },
        {
          "title": "RawVec growth strategy can be more efficient #111307",
          "url": "https://github.com/rust-lang/rust/issues/111307",
          "excerpts": [
            "May 6, 2023 â€” Currently, the RawVec implementation tries to double its internal capacity every time it has to grow, as can be seen in:Â ..."
          ]
        },
        {
          "title": "ahash - Rust",
          "url": "https://rust-lang.github.io/hashbrown/ahash/index.html",
          "excerpts": [
            "How aHash works. aHash uses the hardware AES instruction on x86 processors to provide a keyed hash function. aHash is not a cryptographically secure hash."
          ]
        },
        {
          "title": "aHash is a non-cryptographic hashing algorithm that uses ...",
          "url": "https://github.com/tkaitchuck/aHash",
          "excerpts": [
            "AHash is the fastest, DOS resistant hash currently available in Rust. AHash is intended exclusively for use in in-memory hashmaps."
          ]
        },
        {
          "title": "Noteworthy concurrent data structures? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/myiokh/noteworthy_concurrent_data_structures/",
          "excerpts": [
            "Here are some crates with useful concurrent data structures: crossbeam. flume. parking_lot. dashmap/evmap/chashmap. arc-swap. atomic-take."
          ]
        },
        {
          "title": "How Go 1.24's Swiss Tables saved us hundreds of gigabytes",
          "url": "https://www.datadoghq.com/blog/engineering/go-swiss-tables/",
          "excerpts": [
            "Higher load factor: Swiss Tables support a higher load factor of 87.5% (versus 81.25% in Go 1.23), requiring fewer total slots. Elimination ..."
          ]
        },
        {
          "title": "SwissMap: A smaller, faster Golang Hash Table",
          "url": "https://dolthub.com/blog/2023-03-28-swiss-map/",
          "excerpts": [
            "SwissMap supports a higher maximum load factor (87.5%) than the built-in map (81.25%), but this difference alone doesn't tell the whole story."
          ]
        },
        {
          "title": "Why does vec allocate new memory and copy values when growing? - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/why-does-vec-allocate-new-memory-and-copy-values-when-growing/45291",
          "excerpts": [
            "Vectors don't resize every time you call `insert` , they typically allocate extra space so subsequent insertions can be handled without re-allocating and usually they vary the extra space requested as the size of the vector increases. A common pattern is to allocate `2 * current capacity` on re-allocation.",
            "Note that the _exponential_ growth is important. On each reallocation, we have to copy twice as much, but then it takes twice as long to fill up again. These factors cancel out and we get (on average) constant-time `.push()` .",
            "The API of Vec doesn't change at all because of this optimization, and the overall strategy remains the same - double the size, (possibly) reallocating, every time more space is needed.",
            "Vectors fit both of those requirements very well while still being conceptually simple to understand (a useful quality in a common collection type).",
            " In Rust, you can do this by calling `Vec::with_capacity(size)` instead of `Vec::new()`"
          ]
        },
        {
          "title": "evmap crate page (crates.io) - Rust Package Registry",
          "url": "https://crates.io/crates/evmap/5.0.2",
          "excerpts": [
            "A lock-free, eventually consistent, concurrent multi-value map. evmap - crates.io: Rust Package Registry",
            "Reads never take locks on their critical path, and neither\ndo writes assuming there is a single writer (multi-writer is possible using a `Mutex`), which\nsignificantly improves performance under contention.",
            "The map is multi-value, meaning that every key maps to a *collection* of values. This\nintroduces some memory cost by adding a layer of indirection through a `Vec` for each value,\nbut enables more advanced use.",
            "The benchmark\nmeasures the average number of reads and writes per second as the number of\nreaders and writers increases.",
            "results show that `evmap` performs well under contention,\nespecially on the read side. This benchmar",
            "Metadata",
            "pkg:cargo/evmap@5.0.2",
            "Small Vector Optimization",
            "Small Vector Optimization",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`."
          ]
        },
        {
          "title": "expect-test - Crates.io (Rust snapshot testing library)",
          "url": "https://crates.io/crates/expect-test",
          "excerpts": [
            "Metadata"
          ]
        },
        {
          "title": "How does Rust allocate more space for a vector?",
          "url": "https://stackoverflow.com/questions/62685440/how-does-rust-allocate-more-space-for-a-vector",
          "excerpts": [
            "The current strategy is to double the capacity when it must be increased. However, there is a special case: Vec::new() doesn't allocate, but pushing an element ..."
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "LinkedList:**\n\n* **Underlying structure:** Doublyâ€‘linked list of heapâ€‘allocated nodes\n* **Time complexities:**\n\n> Insert/remove at known node (via cursor): *O(1)*\n>\n> Push/pop front or back: *O(1)*\n>\n> Indexing/traversal: *O(n)*\n\n* **Memory:** One heap allocation per element + two poin",
            "Rustâ€™s standard library provides a rich set of collection types, each tailored to different useâ€‘cases and performance characteristics.",
            "VecDeque:**\n\n* **Underlying structure:** Grow-able ring buffer of fixedâ€‘size blocks\n* **Time complexities:**\n\n> Push/pop front or back: Amortized *O(1)*\n>\n> Indexing: *O(1)* (slightly slower constant factor)\n>\n> Insert/remove in middle: *O(n)*\n\n* **Memory:** Slight overhead for ring buffer metadata and block poin",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi",
            "\n### **BTreeMap:**\n\n* **Underlying structure:** Balanced Bâ€‘tree of sorted keyâ€“value pairs\n* **Time complexities:**\n\n> Insert/remove/lookup: *O(log n)*\n\n* **Memory:** Lower perâ€‘element overhead vs. `HashMap` (no hashing), but tree nodes incur pointers",
            "-------\n\n* **Underlying structure:** Binary maxâ€‘heap in a `Vec`\n* **Time complexities:**\n\n> Push/pop: *O(log n)*\n>\n> Peek max: *O(1)*\n\n* **Memory:** Similar footprint to `Vec` plus heap invariant"
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n",
            "Iterators are also composable, and itâ€™s common to chain them together to do\nmore complex forms of processing. See the [Adapters]() section\nbelow for more details.\n",
            "Iterators (and iterator [adapters]() ) are _lazy_ . This means that\njust creating an iterator doesnâ€™t _do_ a whole lot. Nothing really happens\nuntil you call [`next`](trait.Iterator.html.next \"method std::iter::Iterator::next\") .",
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "pub trait DoubleEndedIterator: Iterator {",
            "    // Required method",
            "    fn next_back (&mut self) -> Option <Self:: Item >;",
            "    // Provided methods",
            "    fn advance_back_by (&mut self, n: usize ) -> Result < () , NonZero < usize >> { ... }",
            "    fn nth_back (&mut self, n: usize ) -> Option <Self:: Item > { ... }",
            "    fn try_rfold <B, F, R>(&mut self, init: B, f: F) -> R",
            "             F: FnMut (B, Self:: Item ) -> R,",
            "             R: Try <Output = B> { ... }",
            "    fn rfold <B, F>(self, init: B, f: F) -> B",
            "             F: FnMut (B, Self:: Item ) -> B { ... }",
            "    fn rfind <P>(&mut self, predicate: P) -> Option <Self:: Item >",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "             P: FnMut (&Self:: Item ) -> bool { ... }",
            "An iterator able to yield elements from both ends.",
            "Something that implements `DoubleEndedIterator` has one extra capability",
            "over something that implements [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") : the ability to also take `Item` s from the back, as well as the front.",
            "It is important to note that both back and forth work on the same range,",
            "and do not cross: iteration is over when they meet in the middle.",
            "In a similar fashion to the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") protocol, once a `DoubleEndedIterator` returns [`None`](../option/enum.Option.html#variant.None \"variant std::option::Option::None\") from a [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") , calling it",
            "again may or may not ever return [`Some`](../option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. [`next()`](trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") and [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") are interchangeable for this purpose.",
            "\n## Required Methods [Â§](#required-methods)",
            "1\\.0.0 Â· [Source](../../src/core/iter/traits/double_ended.rs.html#94)",
            "#### fn [next\\_back](#tymethod.next_back) (&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\") <Self:: [Item](trait.Iterator.html#associatedtype.Item \"type std::iter::Iterator::Item\") >",
            "Removes and returns an element from the end of the iterator.",
            "Returns `None` when there are no more elements.",
            "The [trait-level](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") docs contain more details.",
            "##### [Â§](#examples-2) Examples",
            "Basic usage:",
            "```\nlet numbers = vec! [ 1 , 2 , 3 , 4 , 5 , 6 ];\n\nlet mut iter = numbers.iter();\n\nassert_eq! ( Some ( & 1 ), iter.next());\nassert_eq! ( Some ( & 6 ), iter.next_back());\nassert_eq! ( Some ( & 5 ), iter.next_back());\nassert_eq! ( Some ( & 2 ), iter.next());\nassert_eq! ( Some ( & 3 ), iter.next());\nassert_eq! ( Some ( & 4 ), iter.next());\nassert_eq! ( None , iter.next());\nassert_eq! ( None , iter.next_back());\n```\n",
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "    // Required method",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Trait FusedIterator - std::iter (Rust std docs)",
          "url": "http://doc.rust-lang.org/std/iter/trait.FusedIterator.html",
          "excerpts": [
            "pub trait FusedIterator: Iterator { }",
            "An iterator that always continues to yield `None` when exhausted.",
            "Note: In general, you should not use `FusedIterator` in generic bounds if\nyou need a fused iterator. Instead, you should just call [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\") on the iterator. If the iterator is already fused, the additional [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper will be a no-op with no performance penalty.",
            "to return [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") again. This trait should be implemented by all iterators",
            "that behave this way because it allows optimizing [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\")."
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "FnOnce in std::ops - Rust",
            "pub trait FnOnce<Args>",
            "where\n    Args: Tuple ,",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected."
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too."
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Instances of `Fn` can be called repeatedly without mutating state.",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently)."
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "standard library. The definition of the trait looks like this:",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:",
            "pub trait Iterator {",
            "    fn next(&mut self) -> Option<Self::Item>;",
            "    // methods with default implementations elided",
            "amed `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this",
            "### [The `Iterator` Trait and the `next` Method]()",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "The `Iterator` trait only requires implementors to define one method: the",
            "`next` method, which returns one item of the iterator at a time, wrapped in",
            "`Some` and, when iteration is over, returns `None`.",
            "We can call the `next` method on iterators directly; Listing 13-12 demonstrates",
            "what values are returned from repeated calls to `next` on the iterator created",
            "from the vector.",
            "Note that we needed to make `v1_iter` mutable: calling the `next` method on an",
            "iterator changes internal state that the iterator uses to keep track of where",
            "it is in the sequence. In other words, this code *consumes*, or uses up, the",
            "iterator.",
            "Also note that the values we get from the calls to `next` are immutable",
            "references to the values in the vector. The `iter` method produces an iterator",
            "over immutable references. If we want to create an iterator that takes",
            "ownership of `v1` and returns owned values, we can call `into_iter` instead of",
            "`iter`. Similarly, if we want to iterate over mutable references, we can call",
            "`iter_mut` instead of `iter`.",
            "### [Methods That Consume the Iterator]()",
            "The `Iterator` trait has a number of different methods with default",
            "implementations provided by the standard library; you can find out about these",
            "methods by looking in the standard library API documentation for the `Iterator`",
            "trait. Some of these methods call the `next` method in their definition, which",
            "is why youâ€™re required to implement the `next` method when implementing the",
            "`Iterator` trait.",
            "Methods that call `next` are called *consuming adapters* because calling them",
            "uses up the iterator. One example is the `sum` method, which takes ownership of",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "consuming the iterator.",
            "### [Methods that Produce Other Iterators]()",
            "*Iterator adapters* are methods defined on the `Iterator` trait that donâ€™t",
            "consume the iterator. Instead, they produce different iterators by changing",
            "some aspect of the original iterator.",
            "In Listing 13-15, we collect the results of iterating over the iterator thatâ€™s",
            "returned from the call to `map` into a vector. This vector will end up",
            "containing each item from the original vector, incremented by 1.",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "on each item. This is a great example of how closures let you customize some",
            "behavior while reusing the iteration behavior that the `Iterator` trait",
            "provides.",
            "You can chain multiple calls to iterator adapters to perform complex actions in",
            "a readable way. But because all iterators are lazy, you have to call one of the",
            "consuming adapter methods to get results from calls to iterator adapters.",
            "### [Using Closures That Capture Their Environment]()",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "weâ€™ll specify as arguments to iterator adapters will be closures that capture",
            "their environment.",
            "The `shoes_in_size` function takes ownership of a vector of shoes and a shoe",
            "size as parameters. It returns a vector containing only shoes of the specified",
            "size.",
            "The closure captures the `shoe_size` parameter from the environment and",
            "compares the value with each shoeâ€™s size, keeping only shoes of the size",
            "specified. Finally, calling `collect` gathers the values returned by the",
            "adapted iterator into a vector thatâ€™s returned by the function.",
            "The test shows that when we call `shoes_in_size`, we get back only shoes",
            "that have the same size as the value we specified.",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterato",
            "    type Item;",
            "    type IntoIter: Iterator<Item = Self::Item>;\n",
            "    // Required method\n",
            "    fn into_iter(self) -> Self::IntoIter;",
            "}",
            "ion\n\nConversion into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"). By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind. One benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\"). See also: [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). [Â§]()Examples",
            "By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.",
            "\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\").",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n",
            "fn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}",
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n"
          ]
        },
        {
          "title": "GitHub - tokio-rs/loom: Concurrency permutation testing tool for Rust.",
          "url": "https://github.com/tokio-rs/loom",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "The Future Trait - Asynchronous Programming in Rust",
          "url": "https://rust-lang.github.io/async-book/02_execution/02_future.html",
          "excerpts": [
            "}"
          ]
        },
        {
          "title": "Property-based Testing in Rust",
          "url": "https://lpalmieri.com/posts/an-introduction-to-property-based-testing-in-rust/",
          "excerpts": [
            "}",
            "}",
            "```",
            "```"
          ]
        },
        {
          "title": "The bindgen User Guide",
          "url": "https://rust-lang.github.io/rust-bindgen/",
          "excerpts": [
            "}",
            "}"
          ]
        },
        {
          "title": "How does for loop implement into_iter - rust",
          "url": "https://stackoverflow.com/questions/72258925/how-does-for-loop-implement-into-iter",
          "excerpts": [
            "The iterable is transformed into an iterator by executing IntoIterator::into_iter(iterable). Each trait, including IntoIterator, has a hidden Self genericÂ ..."
          ]
        },
        {
          "title": "Passing slice as an IntoIterator - rust",
          "url": "https://stackoverflow.com/questions/35144386/passing-slice-as-an-intoiterator",
          "excerpts": [
            "Let's take a look at how IntoIterator is implemented for slices: impl<'a, T> IntoIterator for &'a [T] type Item = &'a T type IntoIter = Iter<'a, T>"
          ]
        },
        {
          "title": "Difference Between into_iter, iter() and iter_mut() in rust",
          "url": "https://blog.coolhead.in/difference-between-intoiter-iter-and-itermut-in-rust",
          "excerpts": [
            "Nov 24, 2023 â€” into_iter() transfers ownership of the collection, iter() borrows the elements immutably, and iter_mut() borrows them mutably."
          ]
        },
        {
          "title": "IntoIter in std::vec",
          "url": "https://doc.rust-lang.org/std/vec/struct.IntoIter.html",
          "excerpts": [
            "An iterator that moves out of a vector. This struct is created by the into_iter method on Vec (provided by the IntoIterator trait)."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`",
            "They preferentially capture variables by reference and only go lower when\nrequired. ```"
          ]
        },
        {
          "title": "FromIterator in std::iter - Rust",
          "url": "https://doc.rust-lang.org/std/iter/trait.FromIterator.html",
          "excerpts": [
            "pub trait FromIterator<A>: Sized {\n    // Required method\n    fn from_iter <T>(iter: T) -> Self\n       where T: IntoIterator <Item = A> ;\n}",
            "Conversion from an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") . By implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind. If you want to create a collection from the contents of an iterator, the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`](trait.FromIterator.html.from_iter \"associated function std::iter::FromIterator::from\\_iter\") can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()` ).\nSee the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") documentation for more examples of its use."
          ]
        },
        {
          "title": "What is the difference between iter and into_iter? (Stack Overflow)",
          "url": "https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter",
          "excerpts": [
            "What is the difference between `iter` and `into_iter` ? `into_iter` is a generic method to obtain an iterator, whether this iterator yields values, immutable references or mutable references **is context dependent** and can sometimes be surprising. `iter` and `iter_mut` are inherent methods. Their return type is therefore independent of the context, and will conventionally be iterators yielding immutable references and mutable references, respectively. The author of the Rust by Example post used Rust pre-1.53.0 to illustrate the surprise coming from the dependence on the context (i.e., the type) on which `into_iter` is called, and is also compounding the problem by using the fact that:\n\n1. Back then, `IntoIterator` was not implemented for `[T; N]` , only for `&[T; N]` and `&mut [T; N]` . 2",
            "* `iter()` iterates over the items by reference",
            "* `iter_mut()` iterates over the items, giving a mutable reference to each item",
            "* `into_iter()` iterates over the items, moving them into the new scope",
            "So `for x in my_vec { ... }` is essentially equivalent to `my_vec.into_iter().for_each(|x| ... )` \\- both `move` the elements of `my_vec` into the `...` scope. If you just need to _look at_ the data, use `iter` , if you need to edit/mutate it, use `iter_mut` , and if you need to give it a new owner, use `into_iter` "
          ]
        },
        {
          "title": "ExactSizeIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html",
          "excerpts": [
            "An iterator that knows its exact length.",
            "If an iterator knows how many times it can iterate, providing access to\nthat information can be useful.",
            "This function has the same safety guarantees as the\n[`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\") function.",
            "this trait is a safe trait and as such does *not* and *cannot*\nguarantee that the returned length is correct. This means that `unsafe`\ncode **must not** rely on the correctness of [`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\")."
          ]
        },
        {
          "title": "Rust Iterator Documentation",
          "url": "http://doc.rust-lang.org/std/iter/trait.Iterator.html",
          "excerpts": [
            "A trait for dealing with iterators.",
            "This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the [module-level documentation](index.html \"mod std::iter\"). In particular, you\nmay want to know how to [implement `Iterator`](index.html \"mod std::iter\").",
            "The type of the elements being iterated over.",
            "(.next)(&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\")<Self::[Item](trait.Iterator.html.Item \"type std::iter::Iterator::Item\")>",
            "Advances the iterator and returns the next value.",
            "Returns [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") when iteration is finished."
          ]
        },
        {
          "title": "Unwinding -",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/nomicon/unwinding.html",
          "excerpts": [
            "As such, unwinding into Rust from another language, or unwinding into another language from Rust is Undefined Behavior. You must absolutely catch any panics ..."
          ]
        },
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        },
        {
          "title": "The Rustonomicon - Unwinding",
          "url": "https://doc.rust-lang.org/nomicon/unwinding.html",
          "excerpts": [
            "Rust has a _tiered_ error-handling scheme:\n\n* If something might reasonably be absent, Option is used. * If something goes wrong and can reasonably be handled, Result is used. * If something goes wrong and cannot reasonably be handled, the thread panics. * If something catastrophic happens, the program aborts. Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion.",
            "Panics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.",
            "There is an API called [`catch_unwind`](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html) that enables catching a panic\nwithout spawning a thread.",
            "Unlike an exception in Java or C++, a panic could not be\ncaught at any time."
          ]
        },
        {
          "title": "Cargo profile panic settings",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic. When set to\n\"unwind\" , the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses\n\"abort\" . Tests, benchmarks, build scripts, and proc macros ignore the\npanic setting. The\nrustc test harness currently requires\nunwind behavior. See the\npanic-abort-tests unstable flag which enables\nabort behavior. Additionally, when using the\nabort strategy and building a test, all of the\ndependencies will also be forced to build with the\nunwind strategy. incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times",
            "Profiles\nProfiles provide a way to alter the compiler settings, influencing things like\noptimizations and debugging symbols. Cargo has 4 built-in profiles:\ndev ,\nrelease ,\ntest , and\nbench .",
            "The default is\n\"none\" . You can also configure this option with the boolean values\ntrue or\nfalse .",
            "release profile is intended for optimized artifacts used for releases\nand in production.",
            "[profile.release] opt-level = 3",
            "The default settings for the\nrelease profile are:\n[profile.release] opt-level = 3 debug = false split-debuginfo = '...' # Platform-specific. strip = \"none\" debug-assertions = false overflow-checks = false lto = false panic = 'unwind' incremental = false codegen-units = 16 rpath = false",
            "The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "opt-level = 3",
            "debug = false",
            "strip = \"none\"",
            "lto = false",
            "panic = 'unwind'",
            "codegen-units = 16",
            "The\ncodegen-units setting controls the\n-C codegen-units flag which\ncontrols how many â€œcode generation unitsâ€ a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower cod",
            "led\n\nlto\nThe\nlto setting controls\nrustc â€™s\n-C lto ,\n-C linker-plugin-lto , and\n-C embed-bitcode options, which control LLVMâ€™s link time optimizations . LTO can produce better optimized code, using whole-program analysis, at the cost\nof longer linking time. The valid options are:\n    * false : Performs â€œthin local LTOâ€ which performs â€œthinâ€ LTO on the local\ncrate only across its codegen units . No LTO is performed\nif codegen units is 1 or opt-level is 0.\n* true or\n\"fat\" : Performs â€œfatâ€ LTO which attempts to perform\noptimizations across all crates within the dependency graph. * \"thin\" : Performs â€œthinâ€ LTO . This is similar to â€œfatâ€, but takes\nsubstantially less time to run while still achieving performance gains\nsimilar to â€œfatâ€. * \"off\" : Disables LTO.",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic.",
            "debug\nThe\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary. The valid options are:\n    * 0 ,\nfalse , or\n\"none\" : no debug info at all, default for\nrelease",
            "opt-level\nThe\nopt-level setting controls the\n-C opt-level flag which controls the level\nof optimization. Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times.",
            "Profile selection\nThe profile used depends on the command, the command-line flags like\n--release or\n--profile , and the package (in the case of overrides ). The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release ."
          ]
        },
        {
          "title": "The Rust Programming Language â€” Unrecoverable Errors with panic!",
          "url": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html",
          "excerpts": [
            "Unrecoverable Errors with panic! - The Rust Programming Language",
            "By default, when a panic occurs the program starts _unwinding_ , which means\nRust walks back up the stack and cleans up the data from each function it\nencounters.",
            "Rust,\ntherefore, allows you to choose the alternative of immediately _aborting_ ,\nwhich ends the program without cleaning up.",
            "adding `panic = 'abort'` to the appropriate `[profile]` sections in your _Cargo.toml_ file. For example, if you want to abort on panic in release mode,\nadd this:",
            "oml\n[profile.release]\npanic = 'abort'\n```"
          ]
        },
        {
          "title": "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/cancel-safety-in-async-and-tokio-select/92381",
          "excerpts": [
            "Cancel safety in async and tokio::select! {} - help - The Rust Programming Language Forum",
            "I want to make sure that I understand the basic idea behind cancel safety & async. Assuming something along the line of:",
            "Just looking at this `select!` example; what are the exact conditions that are required to achieve cancel safety (or not)? My assumption is that iff `read_msg()` 's `Future` does not store any of the data from its underlying transport in itself, then it's cancel safe. (I.e. it's safe if it will only extract data from its underlying transport when a complete message can be returned immediately using `Poll::Ready` ). Is cancel non-safety an effect of a partial buffer being extracted and stored in the returned `Future` (by `read_msg()` ) but then `wait_for_kill` sneaks in and yields `Pending::Ready` ? Is there more to it, or is that the basic gist of it? [farnz](https://users.rust-lang.org/u/farnz) April 12, 2023, 9:49am 2",
            "That is the basic gist of it. The underlying issue with cancellation safety is that all futures in the select other than the future that yields `Poll::Ready` will be dropped.",
            "If those futures own some form of state, then your future is not cancellation safe, since that owned state will be dropped when another future returns `Poll::Ready` .",
            "The easy way to avoid this is for the futures in the `select!` to not own state, but to borrow it from elsewhere; for example, if `buffered_stream` owns all the state, and the future returned by `read_msg()` mutates `buffered_stream` instead of storing its own state, you're cancellation-safe.",
            "This happens with [`recv` on Tokio channels](https://docs.rs/tokio/1.27.0/tokio/sync/mpsc/struct.Receiver.html.recv) , since all the state is in the channel, and _not_ in the future returned by `recv()` .",
            "Cancel safety is mostly not relevant for kill signals because you don't care if you lost some data from the connection if you're killing it."
          ]
        },
        {
          "title": "Rust Cancel Safety and Panics (as provided in the document)",
          "url": "https://rfd.shared.oxide.computer/rfd/400",
          "excerpts": [
            "panics\narenâ€™t part of normal control flow.",
            " runtime is\n   shut down due to a panic, then the task is cancelled. ",
            "If a Tokio runtime is shut down, all tasks running within it are cancelled at\nthe next await point."
          ]
        },
        {
          "title": "color_eyre - Rust",
          "url": "https://docs.rs/color-eyre",
          "excerpts": [
            "An error report handler for panics and the `eyre` crate for colorful, consistent, and well formatted error reports for all kinds of errors."
          ]
        },
        {
          "title": "color-eyre - crates.io: Rust Package Registry",
          "url": "https://crates.io/crates/color-eyre",
          "excerpts": [
            "color-eyre v0.6.5. An error report handler for panics and eyre::Reports for colorful, consistent, and well formatted error reports for all kinds ..."
          ]
        },
        {
          "title": "Error in anyhow - Rust",
          "url": "https://docs.rs/anyhow/latest/anyhow/struct.Error.html",
          "excerpts": [
            "The Debug format â€œ{:?}â€ includes your backtrace if one was captured. Note that this is the representation you get by default if you return an error from fn mainÂ ..."
          ]
        },
        {
          "title": "rust - How to trace the cause of an error result?",
          "url": "https://stackoverflow.com/questions/42275777/how-to-trace-the-cause-of-an-error-result",
          "excerpts": [
            "Use Result defined in easy-error as return type, then use context method to convert other Result types. Most important thing is to pass information to contextÂ ..."
          ]
        },
        {
          "title": "r/rust - miette: a fancy new diagnostics definition and ...",
          "url": "https://www.reddit.com/r/rust/comments/p9t3jh/miette_a_fancy_new_diagnostics_definition_and/",
          "excerpts": [
            "On a somewhat related note, does anyone know of any crates that assist in generating Spans (offset, length, line number, column number) from a ..."
          ]
        },
        {
          "title": "Does anyone bothered by not having backtraces in custom ...",
          "url": "https://www.reddit.com/r/rust/comments/1jebbnq/does_anyone_bothered_by_not_having_backtraces_in/",
          "excerpts": [
            "I very much like anyhow's backtrace feature, it helps me figure out the root cause in some question marks where I'm too lazy to add a contextÂ ..."
          ]
        },
        {
          "title": "Blog post: Async Cancellation - language design",
          "url": "https://internals.rust-lang.org/t/blog-post-async-cancellation/15591",
          "excerpts": [
            "Nov 11, 2021 â€” In this post we'll look at async Rust's async primitives, and cover how cancellation works for those primitives today."
          ]
        },
        {
          "title": "Miette Crate Documentation",
          "url": "https://crates.io/crates/miette",
          "excerpts": [
            "### Table of Contents",
            "### Features",
            "* Generic [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html) protocol, compatible (and dependent on)",
            "`std::error::Error`.",
            "* Unique error codes on every [`Diagnostic`](https://docs.rs/miette/latest/miette/trait.Diagnostic.html).",
            "* Custom links to get more details on error codes.",
            "* Super handy derive macro for defining diagnostic metadata.",
            "* Replacements for [`anyhow`](https://docs.rs/anyhow)/[`eyre`](https://docs.rs/eyre)\n  types [`Result`](https://docs.rs/miette/latest/miette/type.Result.html), [`Report`](https://docs.rs/miette/latest/miette/struct.Report.html) and the [`miette!`](https://docs.rs/miette/latest/miette/macro.miette.html) macro for the\n  `anyhow!`/`eyre!` macros.",
            "* Generic support for arbitrary [`SourceCode`](https://docs.rs/miette/latest/miette/trait.SourceCode.html)s for snippet data, with",
            "default support for `String`s included.",
            "This is especially",
            "useful in combination with `related`, when multiple errors should be",
            "emitted at the same time:",
            "```\nuse miette::{Diagnostic, Report, SourceSpan};\nuse thiserror::Error;\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops\")]\n#[diagnostic()]\npub struct InnerError {\n    // Note: label but no source code\n    #[label]\n    err_span: SourceSpan,\n}\n\n#[derive(Diagnostic, Debug, Error)]\n#[error(\"oops: multiple errors\")]\n#[diagnostic()]\npub struct MultiError {\n    // Note source code by no labels\n    #[source_code]\n    source_code: String,\n    // The source code above is used for these errors\n    #[related]\n    related: Vec<InnerError>,\n}\n\nfn do_something() -> Result<(), Vec<InnerError>> {\n    Err(vec! [\n        InnerError {\n            err_span: (0..6).into(),\n        },\n        InnerError {\n            err_span: (7..11).into(),\n        },\n    ])\n}\n\nfn main() -> miette::Result<()> {\n    do_something().map_err(|err_list| MultiError {\n        source_code: \"source code\".into(),\n        related: err_list,\n    })? ;\n    Ok(())\n}\n```\n\n#### ... Diagnostic-based error sources. When one uses the `#[source]` attribute on a field, that usually comes\nfrom `thiserror`, and implements a method for\n[`std::error::Error::source`]. This works in many cases, but it's lossy:\nif the source of the diagnostic is a diagnostic itself, the source will\nsimply be treated as an `std::error::Error`.\n ... \nIt owes enormous credit to various\nother projects and their authors:\n\n* [`anyhow`](http://crates.io/crates/anyhow) and [`color-eyre`](https://crates.io/crates/color-eyre):\n  these two enormously influential error handling libraries have pushed\n  forward the experience of application-level error handling and error\n  reporting. `miette`'s `Report` type is an attempt at a very very rough\n  version of their `Report` types. * [`thiserror`](https://crates.io/crates/thiserror) for setting the standard\n  for library-level error definitions, and for being the inspiration behind\n  `miette`'s derive macro. * `rustc` and [@estebank](https://github.com/estebank) for their\n  state-of-the-art work in compiler diagnostics. * [`ariadne`](https://crates.io/crates/ariadne) for pushing forward how\n  *pretty* these diagnostics can really look! ### License\n\n`miette` is released to the Rust community under the [Apache license\n2.0](https://github.com/zkat/miette/blob/HEAD/./LICENSE). It also includes code taken from [`eyre`](https://github.com/yaahc/eyre),\nand some from [`thiserror`](https://github.com/dtolnay/thiserror), also\nunder the Apache License. Some code is taken from\n[`ariadne`](https://github.com/zesterer/ariadne), which is MIT licensed."
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu - DEV Community",
          "url": "https://dev.to/leapcell/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-2003",
          "excerpts": [
            "\nError handling is an indispensable part of Rust development. Rustâ€™s `Result<T, E>` provides fundamental support, but the specific implementation varies depending on the scenario. This article introduces three commonly used error handling toolsâ€”`anyhow`, `thiserror`, and `snafu`â€”analyzing their characteristics and applicable scenarios, and helps you understand through practical examples how to use them in projects. Whether you are developing applications or writing libraries, this article can serve as a valuable reference. This article delves deeply into the three major tools for Rust error handling:",
            "* `anyhow` is suitable for rapid and unified error handling, ideal for application development;",
            "* `thiserror` supports customized error types, making it suitable for library development;",
            "* `snafu` provides context-driven error management, appropriate for complex systems.",
            "Note: When developing, pay attention to the size of\nResult<T, E> . anyhow Error: Application-level Error Handling",
            "* thiserror : customized and rich error handling, suitable for library-level programming",
            "* snafu : finer-grained error management",
            "Conversion and unified error handling with\nanyhow::Error :",
            "* Provides a unified\nanyhow::Error type, supporting any error type that implements\nstd::error::Error",
            "* Uses the\n? operator for automatic error propagation, simplifying multi-layer nested error handling",
            "* Supports adding dynamic context (via the\ncontext() method) to enhance error readability",
            "fn get_cluster_info () -> Result < ClusterMap , anyhow :: Error > { // Error 3: Err3 let config = std :: fs :: read_to_string ( \"cluster.json\" ) ? ; // Error 1: Err1 // let config = std::fs::read_to_string(\"cluster.json\").context(\"...\")? ; // Error 1: Err1 let map : ClusterMap = serde_json :: from_str ( & config ) ?",
            "thiserror Error: Defining Library-level Errors",
            "    * Automatically generates error types that conform to\nstd::error::Error via macros",
            "    * Supports nested error sources (using the\n#[from] attribute) and structured error information",
            "    * Allows customization of error message templates (e.g.,\n#[error(\"Invalid header: {expected}\")] )",
            "    * Converts underlying errors into domain-specific errors through the\nSnafu macro",
            "    * Supports attaching structured context (such as file paths, input parameters) in the error chain",
            "    * Provides the\nensure!\nmacro to simplify condition checking and error throwing",
            "thiserror vs snafu",
            "Rust std::error::Error trait documentation",
            "Since the\nError trait requires implementing both\nDebug and\nDisplay :\npub trait Error : Debug + Display {",
            "Error -> println! ( \"{}/ {:?}\" , err )",
            "snafu Error: Context-driven Error Management",
            "snafu Error: Context-driven Error Management",
            "rust-ecosystem-learning",
            "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
            "anyhow ,",
            "anyhow ,",
            "thiserror ,",
            "thiserror ,",
            "snafu",
            "snafu",
            "Practical Implementation"
          ]
        },
        {
          "title": "Rust Error Handling Compared: anyhow vs thiserror vs snafu",
          "url": "https://leapcell.medium.com/rust-error-handling-compared-anyhow-vs-thiserror-vs-snafu-597383d81c25",
          "excerpts": [
            "anyhow = \"1.0.97\"  \nserde = { version = \"1.0.217\", features = [\"derive\"] }  \nserde_json = \"1.0.140\"  \nthiserror = \"2.0.11\"",
            "`anyhow` Error: Application-level Error Handling",
            "Conversion and unified error handling with `anyhow::Error`:",
            "`thiserror` Error: Defining Library-level Errors",
            "Reference: [Rust std::error::Error trait documentation](https://doc.rust-lang.org/beta/core/error/trait.Error.html)",
            "```\npub trait Error: Debug + Display {\n```\n",
            "snafu` Error: Context-driven Error Management",
            "Comparison and Selection Guide",
            "Practical Implementation",
            "Add Dependencies",
            "`main.rs` File",
            "```\nuse anyhow::Context;  \nuse rust_ecosystem_learning::MyError;  \nuse std::fs;  \nuse std::mem::size_of;  \n  \nfn main() -> Result<(), anyhow::Error> {  \n    println! (\"size of anyhow::Error: {}\", size_of::<anyhow::Error>());  \n    println! (\"size of std::io::Error: {}\", size_of::<std::io::Error>());  \n    println! (  \n        \"size of std::num::ParseIntError: {}\",  \n        size_of::<std::num::ParseIntError>()  \n    );  \n    println! (  \n        \"size of serde_json::Error: {}\",  \n        size_of::<serde_json::Error>()  \n    );  \n    println! (\"size of string: {}\", size_of::<String>());  \n    println! (\"size of MyError: {}\", size_of::<MyError>());  \n  \n    let filename = \"non_existent_file.txt\";  \n    let _fd =  \n        fs::File::open(filename).with_context(|| format! (\"Cannot find file: {}\", filename))? ;  \n  \n    fail_with_error()? ;  \n    Ok(())  \n}  \n  \nfn fail_with_error() -> Result<(), MyError> {  \n    Err(MyError::Custom(\"This is a custom error\".to_string()))  \n}  \n  \n#[cfg(test)]  \nmod tests {  \n    #[test]  \n    fn it_works() {  \n        assert_eq!\n(2 + 2, 4);  \n    }  \n}\n```"
          ]
        },
        {
          "title": "The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html",
          "excerpts": [
            "Enable error handling with `longjmp` :** As mentioned above, some existing Rust libraries rely on the ability to `longjmp` across Rust frames to interoperate with Ruby, Lua, and other C\n  APIs. The behavior of `longjmp` traversing Rust frames is not specified or\n  guaranteed to be safe; in the current implementation of `rustc` ,\n  however, it [is safe](https://github.com/rust-lang/rust/pull/48572) . On Windows, `longjmp` is implemented as a\n  form of unwinding called [â€œforced unwindingâ€]() , so any\n  specification of the behavior of forced unwinding across FFI boundaries\n  should be forward-compatible with a [future RFC]() that\n  will provide a well-defined way to interoperate with longjmp-based APIs. * **Do not change the ABI of functions in the `libc` crate:** Some `libc` functions may invoke `pthread_exit` , which uses [a form of\n  unwinding]() in the GNU libc implementation. Such functions\n  must be safe to use with the existing `\"C\"` ABI, because changing the types\n  of these fu",
            "### [Enable Rust panics to traverse through foreign frames]()",
            "### [Enable foreign exceptions to propagate through Rust frame]()",
            "The behavior of `catch_unwind` when a foreign exception encounters it is\ncurrently [left undefined]() . We would like to\nprovide a well-defined behavior for this case, which will probably be either to\nlet the exception pass through uncaught or to catch some or all foreign\nexceptions."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://dev-doc.rust-lang.org/beta/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling. Errors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong."
          ]
        },
        {
          "title": "Errors in Rust can now be handled more ergonomically ...",
          "url": "https://users.rust-lang.org/t/errors-in-rust-can-now-be-handled-more-ergonomically-cleanly-and-simply-introducing-a-new-error-crate/51527",
          "excerpts": [
            "To summarize it, in Rust, the standard way to handle errors is to either use a crate like Anyhow to simply bubble up any errors to the caller ( ..."
          ]
        },
        {
          "title": "snafu - Rust",
          "url": "https://docs.rs/snafu",
          "excerpts": [
            "SNAFU is a library to easily generate errors and add information to underlying errors, especially when the same underlying error type can occur in different ..."
          ]
        },
        {
          "title": "What is a recommended crate for defining errors today?",
          "url": "https://www.reddit.com/r/rust/comments/feynbz/what_is_a_recommended_crate_for_defining_errors/",
          "excerpts": [
            "The best tool for this case is usually a custom defined enum error type. You can use crates like snafu and thiserror to help define the error types."
          ]
        },
        {
          "title": "eyre - Rust",
          "url": "https://docs.rs/eyre",
          "excerpts": [
            "If using the nightly channel, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to seeÂ ..."
          ]
        },
        {
          "title": "Unwinding through FFI after Rust 1.33 - language design",
          "url": "https://internals.rust-lang.org/t/unwinding-through-ffi-after-rust-1-33/9521",
          "excerpts": [
            "Feb 26, 2019 â€” It is possible to \"unwind\" over Rust code using longjmp , so you could have C call setjmp then call back into Rust for a group of operations,Â ..."
          ]
        },
        {
          "title": "Error Handling - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-00-error-handling.html",
          "excerpts": [
            "Error Handling - The Rust Programming Language",
            "Errors are a fact of life in software, so Rust has a number of features for\nhandling situations in which something goes wrong. In many cases, Rust requires\nyou to acknowledge the possibility of an error and take some action before your\ncode will compile. This requirement makes your program more robust by ensuring\nthat youâ€™ll discover errors and handle them appropriately before deploying your\ncode to production! Rust groups errors into two major categories: _recoverable_ and _unrecoverable_ errors. For a recoverable error, such as a _file not found_ error, we most\nlikely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, such as trying to access a\nlocation beyond the end of an array, and so we want to immediately stop the\nprogram. Most languages donâ€™t distinguish between these two kinds of errors and handle\nboth in the same way, using mechanisms such as exceptions. Rust doesnâ€™t have\nexcep",
            "Instead, it has the type `Result<T, E>` for recoverable errors and\nthe `panic!` macro that stops execution when the program encounters an\nunrecoverable error. This chapter covers calling `panic!` first and then talks\nabout returning `Result<T, E>` values. Additionally, weâ€™ll explore\nconsiderations when deciding whether to try to recover from an error or to stop\nexecution."
          ]
        },
        {
          "title": "Reddit: Rust error handling with anyhow/thiserror discussion",
          "url": "https://www.reddit.com/r/rust/comments/125u7eo/thiserror_anyhow_or_how_i_handle_errors_in_rust/",
          "excerpts": [
            "Use Anyhow if you don't care what error type your functions return, you just want it to be easy. This is common in application code."
          ]
        },
        {
          "title": "Simplifying Rust Error Handling with anyhow",
          "url": "https://leapcell.medium.com/simplifying-rust-error-handling-with-anyhow-0ec80474e333",
          "excerpts": [
            "`anyhow` is a popular crate in Rust for error handling. It provides a simple and flexible way to manage errors, making it especially suitable for rapid development and prototyping.",
            "`anyhow` primarily simplifies error handling by offering a general-purpose error type, `anyhow::Error` , allowing developers to reduce boilerplate without sacrificing error information.",
            " * `eyre` : Similar to `anyhow` , but offers more extensibility and customization features."
          ]
        },
        {
          "title": "std::thread",
          "url": "https://doc.rust-lang.org/std/thread/",
          "excerpts": [
            "A thread local storage (TLS) key which owns its contents. Scope: A scope to spawn scoped threads in. ScopedJoinHandle: An owned permission to join on a scoped ..."
          ]
        },
        {
          "title": "Shared-State Concurrency - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch16-03-shared-state.html",
          "excerpts": [
            "Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time."
          ]
        },
        {
          "title": "Top 10 Rust Concurrency Patterns for Zero-Copy Speed",
          "url": "https://medium.com/@bhagyarana80/top-10-rust-concurrency-patterns-for-zero-copy-speed-60aac19e0d4a",
          "excerpts": [
            "Ten battle-tested Rust concurrency patterns to move data without cloning. Learn Arc, slices, IoSlice, Cow, pools, sharding, ..."
          ]
        },
        {
          "title": "Fearless Concurrency - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch16-00-concurrency.html",
          "excerpts": [
            "Here are the topics weâ€™ll cover in this chapter:\n\n* How to create threads to run multiple pieces of code at the same time\n* _Message-passing_ concurrency, where channels send messages between threads\n* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data\n* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library",
            "* _Message-passing_ concurrency, where channels send messages between threads",
            "* _Shared-state_ concurrency, where multiple threads have access to some piece\n  of data",
            "* The `Sync` and `Send` traits, which extend Rustâ€™s concurrency guarantees to\n  user-defined types as well as types provided by the standard library"
          ]
        },
        {
          "title": "Rust fence and memory ordering (std::sync::atomic)",
          "url": "https://doc.rust-lang.org/std/sync/atomic/fn.fence.html",
          "excerpts": [
            "A fence which has [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") ordering, in addition to having both [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\")\nand [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") semantics, participates in the global program order of the\nother [`SeqCst`](enum.Ordering.html.SeqCst \"variant std::sync::atomic::Ordering::SeqCst\") operations and/or fences.",
            "Atomic operations with [`Release`](enum.Ordering.html.Release \"variant std::sync::atomic::Ordering::Release\") or [`Acquire`](enum.Ordering.html.Acquire \"variant std::sync::atomic::Ordering::Acquire\") semantics can also synchronize\nwith a fence.",
            "Note that in the example above, it is crucial that the accesses to `m` are atomic. Fences cannot\nbe used to establish synchronization among non-atomic accesses in different threads.",
            "```\nuse std::sync::atomic::AtomicBool;\nuse std::sync::atomic::fence;\nuse std::sync::atomic::Ordering;\n\n// A mutual exclusion primitive based on spinlock. pub struct Mutex {\n    flag: AtomicBool,\n}\n\nimpl Mutex {\n    pub fn new() -> Mutex {\n        Mutex {\n            flag: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&self) {\n        // Wait until the old value is `false`."
          ]
        },
        {
          "title": "parking_lot Crate Documentation",
          "url": "https://crates.io/crates/parking_lot/",
          "excerpts": [
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads",
            "The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "The primitives provided by this library have several advantages over those\nin the Rust standard library:"
          ]
        },
        {
          "title": "crossbeam_epoch - Rust",
          "url": "https://docs.rs/crossbeam-epoch",
          "excerpts": [
            "Epoch-based memory reclamation. An interesting problem concurrent collections deal with comes from the remove operation.",
            "This crate implements a basic memory reclamation mechanism, which is based on epochs.",
            "memory reclamation is designed to be fully automatic and something\nusers of concurrent collections donâ€™t have to worry much about.",
            "Concurrent collections are built using atomic pointers. This module provides [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\"), which\nis just a shared atomic pointer to a heap-allocated object.",
            "Before an [`Atomic`](struct.Atomic.html \"struct crossbeam_epoch::Atomic\") can be loaded, a participant must be [`pin`](fn.pin.html \"fn crossbeam_epoch::pin\")ned."
          ]
        },
        {
          "title": "Epoch-based memory reclamation.",
          "url": "http://docs.rs/crossbeam-epoch/latest/crossbeam_epoch",
          "excerpts": [
            "This crate implements a basic memory reclamation mechanism, which is based on epochs."
          ]
        },
        {
          "title": "Flume - Rust",
          "url": "https://docs.rs/flume",
          "excerpts": [
            "A blazingly fast multi-producer, multi-consumer channel. _â€œDo not communicate by sharing memory; instead, share memory by communicating.",
            "**Safe** : No `unsafe` code anywhere in the codebase!",
            "**Familiar** : Drop-in replacement for `std::sync::mpsc`",
            "Unbounded, bounded and rendezvous queues",
            "Familiar** : Drop-in replacement for `std::sync::mps",
            "Sender` and `Receiver` both implement `Send + Sync + Clo"
          ]
        },
        {
          "title": "crossbeam-epoch (Crate Page) - Crates.io",
          "url": "https://crates.io/crates/crossbeam-epoch",
          "excerpts": [
            "crossbeam-epoch - crates.io: Rust Package Registry",
            "This crate provides epoch-based garbage collection for building concurrent data structures. When a thread removes an object from a concurrent data structure, other threads",
            "may be still using pointers to it at the same time, so it cannot be destroyed",
            "immediately. Epoch-based GC is an efficient mechanism for deferring destruction of",
            "shared objects until no pointers to them can exist.",
            "Epoch-based garbage collection"
          ]
        },
        {
          "title": "Rust's Send and Sync (Nomicon)",
          "url": "https://doc.rust-lang.org/nomicon/send-and-sync.html",
          "excerpts": [
            " Almost all primitives are Send and Sync, and as a consequence\npretty much all types you'll ever interact with are Send and Sync. Major exceptions include:\n\n* raw pointers are neither Send nor Sync (because they have no safety guards). * `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't). * `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized). `Rc` and `UnsafeCell` are very fundamentally not thread-safe: they enable\nunsynchronized shared mutable state. However raw pointers are, strictly\nspeaking, marked as thread-unsafe as more of a _lint_ . Doing anything useful\nwith a raw pointer requires dereferencing it, which is already unsafe. In that\nsense, one could argue that it would be \"fine\" for them to be marked as thread\nsafe. However it's important that they aren't thread-safe to prevent types that\ncontain them from being automatically marked as thread-safe. These types have\nnon-trivial untracked ownership, and it's unlikely that their author was\nnecessarily thinking hard about thread safety. In the case of `Rc` , we have a nice\nexample of a type that contains a `*mut` that is definitely not thread-safe. Types that aren't automatically derived can simply implement them if desired:\n\n```\n```\n#!",
            "Most uses of raw pointers should be encapsulated behind a sufficient abstraction\nthat Send and Sync can be derived.",
            "Not everything obeys inherited mutability, though. Some types allow you to\nhave multiple aliases of a location in memory while mutating it. Unless these types use\nsynchronization to manage this access, they are absolutely not thread-safe. Rust\ncaptures this through the `Send` and `Sync` traits. * A type is Send if it is safe to send it to another thread. * A type is Sync if it is safe to share between threads (T is Sync if and only if `&T` is Send). Send and Sync are fundamental to Rust's concurrency story.",
            "Send and Sync are fundamental to Rust's concurrency story.",
            "Major exceptions include:",
            "* raw pointers are neither Send nor Sync (because they have no safety guards).",
            "* `UnsafeCell` isn't Sync (and therefore `Cell` and `RefCell` aren't).",
            "* `Rc` isn't Send or Sync (because the refcount is shared and unsynchronized).",
            "Send and Sync are also automatically derived traits.",
            "This means that, unlike\nevery other trait, if a type is composed entirely of Send or Sync types, then it\nis Send or Sync."
          ]
        },
        {
          "title": "Rust Concurrency Patterns for Parallel Programming",
          "url": "https://earthly.dev/blog/rust-concurrency-patterns-parallel-programming/",
          "excerpts": [
            "One of the most basic primitives for concurrency in Rust is threads. A thread is an independent path of execution within a program that can run concurrently with other threads.",
            "To create a mutex in Rust, you need to use the `Mutex` type from the `std::sync` module. For example, the following example shows you how to use the mutex to wrap shared data, ensuring only one thread can modify it at a time:",
            "A mutex, derived from the term *mutual exclusion*, serves as a synchronization mechanism that permits exclusive access to a shared resource by a single thread at any given tim",
            "An `Arc` is a smart pointer that provides shared ownership of a value across multiple threads. It uses [atomic operations](https://doc.rust-lang.org/std/sync/atomic/) and [reference counting](https://doc.rust-lang.org/std/rc/) to efficiently track the number of references to the shared data."
          ]
        },
        {
          "title": "ThreadPool in rayon - Rust",
          "url": "https://docs.rs/rayon/latest/rayon/struct.ThreadPool.html",
          "excerpts": [
            "Background: Rayon's uses a work-stealing scheduler. The key idea is that each thread has its own deque of tasks. Whenever a new task is spawned â€“ whether ..."
          ]
        },
        {
          "title": "Converos: Practical Model Checking for Verifying Rust OS ...",
          "url": "https://www.usenix.org/system/files/atc25-tang.pdf",
          "excerpts": [
            "by R Tang â€” Liveness properties include absence of deadlock, livelock, and starvation. Deadlock/livelock freedom specifies whenever a process is in theÂ ..."
          ]
        },
        {
          "title": "How I Learned Concurrency in Rust: Deadlocks, RwLocks ...",
          "url": "https://medium.com/@bugsybits/how-i-learned-concurrency-in-rust-deadlocks-rwlocks-and-tears-0abdb42294b8",
          "excerpts": [
            "That night, I learned the hardest truth about concurrency: Rust can guarantee memory safety, but it cannot stop you from designing a deadlock."
          ]
        },
        {
          "title": "std::sync - Rust",
          "url": "http://doc.rust-lang.org/std/sync/index.html",
          "excerpts": [
            "Useful synchronization primitives.",
            "The need for synchronization",
            "Conceptually, a Rust program is a series of operations which will\nbe executed on a computer. The timeline of events happening in the\nprogram is consistent with the order of the operations in the code.",
            "As for what happens behind the scenes, when optimizations are enabled the\nfinal generated machine code might look very different from the code:",
            "The compiler is allowed to perform any combination of these\noptimizations, as long as the final optimized code, when executed,\nproduces the same results as the one without optimizations.",
            "Due to the [concurrency](https://en.wikipedia.org/wiki/Concurrency_(computer_science)) involved in modern computers, assumptions\nabout the programâ€™s execution order are often wrong. Access to\nglobal variables can lead to nondeterministic results, **even if**\ncompiler optimizations are disabled, and it is **still possible**\nto introduce synchronization bugs.",
            "Note that thanks to Rustâ€™s safety guarantees, accessing global (static)\nvariables requires `unsafe` code, assuming we donâ€™t use any of the\nsynchronization primitives in this module.",
            "Out-of-order execution",
            "Instructions can execute in a different order from the one we define, due to\nvarious reasons:",
            "The **compiler** reordering instructions: If the compiler can issue an\n  instruction at an earlier point, it will try to do so. For example, it\n  might hoist memory loads at the top of a code block, so that the CPU can\n  start [prefetching](https://en.wikipedia.org/wiki/Cache_prefetching) the values from m",
            "Use [compiler fences](atomic/fn.compiler_fence.html \"fn std::sync::atomic::compiler_fence\") to prevent this reordering.",
            "A **single processor** executing instructions [out-of-order](https://en.wikipedia.org/wiki/Out-of-order_execution):",
            "A **multiprocessor** system executing multiple hardware threads\n  at the same time: In multi-threaded scenarios, you can use two\n  kinds of primitives to deal with synchronizat",
            "[memory fences](atomic/fn.fence.html \"fn std::sync::atomic::fence\") to ensure memory accesses are made visible to\n    other CPUs in the right or",
            "[atomic operations](atomic/index.html \"mod std::sync::atomic\") to ensure simultaneous access to the same\n    memory location doesnâ€™t lead to undefined behavi",
            "Higher-level synchronization objects",
            "Most of the low-level synchronization primitives are quite error-prone and\ninconvenient to use, which is why the standard library also exposes some\nhigher-level synchronization objects.",
            "These abstractions can be built out of lower-level primitives.",
            "For efficiency, the sync objects in the standard library are usually\nimplemented with help from the operating systemâ€™s kernel, which is\nable to reschedule the threads while they are blocked on acquiring\na lock.",
            "`Arc`\nAtomically Reference-Counted pointer, which can be used\n  in multithreaded environments to prolong the lifetime of some\n  data until all the threads have finished using\n",
            "`Barrier`\nEnsures multiple threads will wait for each other\n  to reach a point in the program, before continuing execution all\n  toget\n",
            "`Condvar`\nCondition Variable, providing the ability to block\n  a thread while waiting for an event to occu\n",
            "`mpsc`\nMulti-producer, single-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`mpmc`\nMulti-producer, multi-consumer queues, used for\n  message-based communication. Can provide a lightweight\n  inter-thread synchronisation mechanism, at the cost of some\n  extra m\n",
            "`Mutex`\nMutual Exclusion mechanism, which ensures that at\n  most one thread at a time is able to access some dat\n",
            "`Once`\nUsed for a thread-safe, one-time global initialization routine.\n  Mostly useful for implementing other types like `OnceLock\n",
            "`OnceLock`\nUsed for thread-safe, one-time initialization of a\n  variable, with potentially different initializers based on the calle\n",
            "`LazyLock`\nUsed for thread-safe, one-time initialization of a\n  variable, using one nullary initializer function provided at creatio\n",
            "`RwLock`\nProvides a mutual exclusion mechanism which allows\n  multiple readers at the same time, while allowing only one\n  writer at a time. In some cases, this can be more efficient than\n  a \n",
            "Modules",
            "`Arc`\nA thread-safe reference-counting pointer. â€˜Arcâ€™ stands for â€˜Atomically\n    Reference Countedâ€™.\n",
            "`Barrier`\nA barrier enables multiple threads to synchronize the beginning\n    of some computation.\n",
            "`Condvar`\nA Condition Variable\n",
            "`LazyLock`\nA value which is initialized on the first access.\n",
            "`Mutex`\nA mutual exclusion primitive useful for protecting shared data\n",
            " `MutexGuard\nAn RAII implementation of a â€œscoped lockâ€ of a mutex. When this structure is\n    dropped (falls out of scope), the lock will be unloc\n",
            "`Once`\nA low-level synchronization primitive for one-time global execution.\n",
            "`OnceLock`\nA synchronization primitive which can nominally be written to only once.\n",
            "A type of error which can be returned whenever a lock is acquired.\n",
            "`RwLock`\nA reader-writer lock\n",
            " structure used to release the shared read access of a lock when\n    dropped.\n",
            "RAII structure used to release the exclusive write access of a lock when\n    drop\n",
            "`Weak`\n`Weak` is a version of [`Arc`](struct.Arc.html \"struct std::sync::Arc\") that holds a non-owning reference to the\n    managed allocation.\n",
            "Structs"
          ]
        },
        {
          "title": "Rust std::sync::mpsc",
          "url": "http://doc.rust-lang.org/std/sync/mpsc/index.html",
          "excerpts": [
            "Multi-producer, single-consumer FIFO queue communication primitives.",
            "std::sync::mpsc - Rust[![](../../../static.files/rust-logo-9a9549ea.svg)](../../../std/index.html)",
            "This module provides message-based communication over channels, concretely\ndefined among three types:",
            "* [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\")",
            "* [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\")",
            "* [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\")",
            "A [`Sender`](struct.Sender.html \"struct std::sync::mpsc::Sender\") or [`SyncSender`](struct.SyncSender.html \"struct std::sync::mpsc::SyncSender\") is used to send data to a [`Receiver`](struct.Receiver.html \"struct std::sync::mpsc::Receiver\") . Both\nsenders are clone-able (multi-producer) such that many threads can send\nsimultaneously to one receiver (single-consumer).",
            "These channels come in two flavors:",
            "1. \n   An asynchronous, infinitely buffered channel. The [`channel`](fn.channel.html \"fn std::sync::mpsc::channel\") function\n   will return a `(Sender, Receiver)` tuple where all sends will be **asynchronous** (they never block). The channel conceptually has an\n   infinite b",
            "2. \n   A synchronous, bounded channel. The [`sync_channel`](fn.sync_channel.html \"fn std::sync::mpsc::sync\\_channel\") function will\n   return a `(SyncSender, Receiver)` tuple where the storage for pending\n   messages is a pre-allocated buffer of a fixed size. All sends will be **synchronous** by blocking until there is buffer space available. Note\n   that a bound of 0 is allowed, causing the channel to become a â€œrendezvousâ€\n   channel where each sender atomically hands off a message to a",
            "The send and receive operations on channels will all return a [`Result`](../../result/enum.Result.html \"enum std::result::Result\")\nindicating whether the operation succeeded or not.",
            "An unsuccessful operation\nis normally indicative of the other half of a channel having â€œhung upâ€ by\nbeing dropped in its corresponding thread.",
            "let (tx, rx) = channel();",
            "    tx.send(10).unwrap();",
            "assert_eq!(rx.recv().unwrap(), 10);",
            "let (tx, rx) = sync_channel::<i32>(0);",
            "thread::spawn(move || {",
            "thread::spawn(move || {",
            "    // This will wait for the parent thread to start receiving",
            "    tx.send(53).unwrap();",
            "});",
            "});",
            "rx.recv().unwrap();",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "The Cargo Book - Workspaces",
          "url": "https://doc.rust-lang.org/cargo/reference/workspaces.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "Registries - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/registries.html",
          "excerpts": [
            "```"
          ]
        },
        {
          "title": "The rustup book",
          "url": "https://rust-lang.github.io/rustup/concepts/toolchains.html",
          "excerpts": [
            "```",
            "```",
            "```",
            "```",
            "```",
            "```"
          ]
        },
        {
          "title": "Rust std::thread Module",
          "url": "http://doc.rust-lang.org/std/thread/index.html",
          "excerpts": [
            ".\n\nCommunication between threads can be done through\n[channels](../sync/mpsc/index.html \"mod std::sync::mpsc\"), Rustâ€™s message-passing types, along with [other forms of thread\nsynchronization](../../std/sync/index.html) and shared-memory data\nstructures. In particular, types that are guaranteed to be\nthreadsafe are easily shared between threads using the\natomically-reference-counted container, [`Arc`](../sync/struct.Arc.html \"struct std::sync::Arc\").",
            "When the main thread of a Rust program terminates, the entire program shuts\ndown, even if other threads are still running. However, this module provides\nconvenient facilities for automatically waiting for the termination of a\nthread (i.e., join).",
            "A new thread can be spawned using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function:\n\n```\nuse std::thread;\n\nthread::spawn(move || {\n    // some work here\n});\n```\n\nIn this example, the spawned thread is â€œdetached,â€ which means that there is\nno way for the program to learn when the spawned thread completes or otherwise\nterminates.",
            "The [`join`](struct.JoinHandle.html.join \"method std::thread::JoinHandle::join\") method returns a [`thread::Result`](type.Result.html \"type std::thread::Result\") containing [`Ok`](../result/enum.Result.html.Ok \"variant std::result::Result::Ok\") of the final\nvalue produced by the spawned thread, or [`Err`](../result/enum.Result.html.Err \"variant std::result::Result::Err\") of the value given to\na call to [`panic!`](../macro.panic.html \"macro std::panic\") if the thread panicked.",
            "let thread_join_handle = thread::spawn( move || {\n    // some work here\n});\n// some work here\nlet res = thread_join_handle.join();",
            "To learn when a thread completes, it is necessary to capture the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") object that is returned by the call to [`spawn`](fn.spawn.html \"fn std::thread::spawn\") , which provides\na `join` method that allows the caller to wait for the completion of the\nspawned thread:",
            "thread::Builder::new().name( \"thread1\" .to_string()).spawn( move || {\n    println! ( \"Hello, world!\" );\n});",
            "* By spawning a new thread, e.g., using the [`thread::spawn`](fn.spawn.html \"fn std::thread::spawn\") function, and calling [`thread`](struct.JoinHandle.html.thread \"method std::thread::JoinHandle::thread\") on the [`JoinHandle`](struct.JoinHandle.html \"struct std::thread::JoinHandle\") .",
            "This module also provides an implementation of thread-local storage for Rust\nprograms. Thread-local storage is a method of storing data into a global\nvariable that each thread in the program will have its own copy of."
          ]
        },
        {
          "title": "std::sync::atomic - Rust",
          "url": "http://doc.rust-lang.org/std/sync/atomic/index.html",
          "excerpts": [
            "Atomic types",
            "\n\nAtomic types provide primitive shared-memory communication between\nthreads, and are the building blocks of other concurrent\ntypes.",
            "\nThis module defines atomic versions of a select number of primitive\ntypes, including [`AtomicBool`](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\"), [`AtomicIsize`](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\"), [`AtomicUsize`](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\"),\n[`AtomicI8`](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\"), [`AtomicU16`](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\"), etc.",
            "Atomic variables are safe to share between threads (they implement [`Sync`](../../marker/trait.Sync.html \"trait std::marker::Sync\"))\nbut they do not themselves provide the mechanism for sharing and follow the\n[threading model](../../../std/thread/index.html) of Rust.",
            "The most common way to share an atomic variable is to put it into an [`Arc`](../../../std/sync/struct.Arc.html) (an\natomically-reference-counted shared pointer).",
            "Each atomic access takes an [`Ordering`](enum.Ordering.html \"enum std::sync::atomic::Ordering\") which defines how the operation interacts with the\nhappens-before order. These orderings behave the same as the corresponding [C++20 atomic\norderings](https://en.cppreference.com/w/cpp/atomic/memory_order). For more information, see the [nomicon](../../../nomicon/atomics.html).",
            "The `#[cfg(target_has_atomic)]` attribute can be used to conditionally\ncompile based on the targetâ€™s supported bit widths. It is a key-value\noption set for each supported size, with values â€œ8â€, â€œ16â€, â€œ32â€, â€œ64â€,\nâ€œ128â€, and â€œptrâ€ for pointer-sized atomics.",
            "Structs",
            "[AtomicBool](struct.AtomicBool.html \"struct std::sync::atomic::AtomicBool\")\n:   A boolean type which can be safely shared between threads.",
            "[AtomicI8](struct.AtomicI8.html \"struct std::sync::atomic::AtomicI8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI16](struct.AtomicI16.html \"struct std::sync::atomic::AtomicI16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI32](struct.AtomicI32.html \"struct std::sync::atomic::AtomicI32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicI64](struct.AtomicI64.html \"struct std::sync::atomic::AtomicI64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicIsize](struct.AtomicIsize.html \"struct std::sync::atomic::AtomicIsize\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicPtr](struct.AtomicPtr.html \"struct std::sync::atomic::AtomicPtr\")\n:   A raw pointer type which can be safely shared between threads.",
            "[AtomicU8](struct.AtomicU8.html \"struct std::sync::atomic::AtomicU8\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU16](struct.AtomicU16.html \"struct std::sync::atomic::AtomicU16\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU32](struct.AtomicU32.html \"struct std::sync::atomic::AtomicU32\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicU64](struct.AtomicU64.html \"struct std::sync::atomic::AtomicU64\")\n:   An integer type which can be safely shared between threads.",
            "[AtomicUsize](struct.AtomicUsize.html \"struct std::sync::atomic::AtomicUsize\")\n:   An integer type which can be safely shared between threads.",
            "Enums",
            "[Ordering](enum.Ordering.html \"enum std::sync::atomic::Ordering\")\n:   Atomic memory orderings",
            "Functions",
            "[fence](fn.fence.html \"fn std::sync::atomic::fence\")\n:   An atomic fence.",
            "Type Aliases",
            "[Atomic](type.Atomic.html \"type std::sync::atomic::Atomic\")Experimental\n:   A memory location which can be safely modified from multiple threads."
          ]
        },
        {
          "title": "Epoch-based garbage collection",
          "url": "http://github.com/crossbeam-rs/crossbeam-epoch",
          "excerpts": [
            "Epoch-based garbage collection",
            "This crate provides epoch-based garbage collection for use in concurrent data structures.",
            "If a thread removes a node from a concurrent data structure, other threads\nmay still have pointers to that node, so it cannot be immediately destructed.\nEpoch GC allows deferring destruction until it becomes safe to do so.",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "parking_lot GitHub Repository",
          "url": "http://github.com/Amanieu/parking_lot",
          "excerpts": [
            "Compact and efficient synchronization primitives for Rust. Also provides an API for creating custom synchronization primitives.",
            "This library provides implementations of `Mutex`, `RwLock`, `Condvar` and\n`Once` that are smaller, faster and more flexible than those in the Rust\nstandard library, as well as a `ReentrantMutex` type which supports recursive\nlocking. It also exposes a low-level API for creating your own efficient\nsynchronization primitives.",
            "When tested on x86\\_64 Linux, `parking_lot::Mutex` was found to be 1.5x\nfaster than `std::sync::Mutex` when uncontended, and up to 5x faster when\ncontended from multiple threads. The numbers for `RwLock` vary depending on\nthe number of reader and writer threads, but are almost always faster than\nthe standard library `RwLock`, and even up to 50x faster in some cases.",
            "Features\n--------\n\nThe primitives provided by this library have several advantages over those\nin the Rust standard library:\n\n1. `Mutex` and `Once` only require 1 byte of storage space, while `Condvar`\n   and `RwLock` only require 1 word of storage space. On the other hand on\n   some platforms (macOS and a few others) the standard library primitives\n   require a dynamically allocated `Box` to hold OS-specific synchronization\n   primitives. The small size of `Mutex` in particular encourages the use\n   of fine-grained locks to increase parallelism.\n2. Uncontended lock acquisition and release is done through fast inline\n   paths which only require a single atomic operation.\n3. Microcontention (a contended lock with a short critical section) is\n   efficiently handled by spinning a few times while trying to acquire a\n   lock.\n4. The locks are adaptive and will suspend a thread after a few failed spin\n   attempts. This makes the locks suitable for both long and short critical\n   sections.\n5. `Condvar`, `RwLock` and `Once` work on Windows XP, unlike the standard\n   library versions of those types.\n6. `RwLock` takes advantage of hardware lock elision on processors that\n   support it, which can lead to huge performance wins with many readers.\n   This must be enabled with the `hardware-lock-elision` feature.\n7. `RwLock` uses a task-fair locking policy, which avoids reader and writer\n   starvation, whereas the standard library version makes no guarantees.\n8. `Condvar` is guaranteed not to produce spurious wakeups. A thread will\n   only be woken up if it timed out or it was woken up by a notification.\n9. `Condvar::notify_all` will only wake up a single thread and requeue the\n   rest to wait on the associated `Mutex`. This avoids a thundering herd\n   problem where all threads try to acquire the lock at the same time.\n10. `RwLock` supports atomically downgrading a write lock into a read lock.\n11. `Mutex` and `RwLock` allow raw unlocking without a RAII guard object.\n12. `Mutex<()>` and `RwLock<()>` allow raw locking without a RAII guard\n    object.\n13. `Mutex` and `RwLock` support [eventual fairness](https://trac.webkit.org/changeset/203350)\n    which allows them to be fair on average without sacrificing performance.\n14. A `ReentrantMutex` type which supports recursive locking.\n15. An *experimental* deadlock detector that works for `Mutex`,\n    `RwLock` and `ReentrantMutex`. This feature is disabled by default and\n    can be enabled via the `deadlock_detection` feature.\n16. `RwLock` supports atomically upgrading an \"upgradable\" read lock into a\n    write lock.\n17. Optional support for [serde](https://docs.serde.rs/serde/). Enable via the\n    feature `serde`. **NOTE!** this support is for `Mutex`, `ReentrantMutex`,\n    and `RwLock` only; `Condvar` and `Once` are not currently supported.\n18. Lock guards can be sent to other threads when the `send_guard` feature is\n    enabled.\n\nThe parking lot\n---------------\n\nTo keep these primitives small, all thread queuing and suspending\nfunctionality is offloaded to the *parking lot*. The idea behind this is\nbased on the Webkit [`WTF::ParkingLot`](https://webkit.org/blog/6161/locking-in-webkit/)\nclass, which essentially consists of a hash table mapping of lock addresses\nto queues of parked (sleeping) threads. The Webkit parking lot was itself\ninspired by Linux [futexes](https://man7.org/linux/man-pages/man2/futex.2.html),\nbut it is more powerful since it allows invoking callbacks while holding a queue\nlock.",
            "To enable nightly-only features, add this to your `Cargo.toml` instead:\n\n```\n[dependencies]\nparking_lot = { version = \"0.12\", features = [\"nightly\"] }\n```\n\nThe experimental deadlock detector can be enabled with the\n`deadlock_detection` Cargo feature.\n\nTo allow sending `MutexGuard`s and `RwLock*Guard`s to other threads, enable the\n`send_guard` option.\n\nNote that the `deadlock_detection` and `send_guard` features are incompatible\nand cannot be used together.\n\nHardware lock elision support for x86 can be enabled with the\n`hardware-lock-elision` feature. This requires Rust 1.59 due to the use of\ninline assembly.\n\nThe core parking lot API is provided by the `parking_lot_core` crate. It is\nseparate from the synchronization primitives in the `parking_lot` crate so that\nchanges to the core API do not cause breaking changes for users of `parking_lot`."
          ]
        },
        {
          "title": "Crossbeam-channel (crossbeam-rs)",
          "url": "http://github.com/crossbeam-rs/crossbeam-channel",
          "excerpts": [
            "Multi-producer multi-consumer channels for message passing",
            "This library is an alternative to [`std::sync::mpsc`](https://doc.rust-lang.org/std/sync/mpsc/index.html) with more features and better performance.",
            "NOTE: This crate has been moved into the [crossbeam](https://github.com/crossbeam-rs/crossbeam) repository.",
            "The minimum required Rust version is 1.26."
          ]
        },
        {
          "title": "Crossbeam - Tools for concurrent programming in Rust",
          "url": "http://github.com/crossbeam-rs/crossbeam",
          "excerpts": [
            "#### Atomics"
          ]
        }
      ],
      "reasoning": "The excerpts contain numerous mentions of key performance optimization techniques and features used in Rust development. These include the concept of zero-cost abstractions, which allow high-level code to compile down to performant machine code without runtime overhead. Inlining attributes are discussed as a means to influence whether functions should be inlined by the compiler, balancing optimization benefits against compile time and binary size. Discussions also cover the use of generics and monomorphization for compile-time specialization, enabling zero-cost abstractions. Profile-guided optimization (PGO) and link-time optimization (LTO) are mentioned as advanced techniques for improving runtime performance, as well as the number of codegen units which affect compile times and performance. Further, there are discussions on the importance of cache-aware programming, data layout optimizations with repr attributes, niche optimization techniques, and the use of SIMD instructions. These strategies are crucial for achieving high performance in Rust applications, especially for system-level and performance-critical software.",
      "confidence": "high"
    },
    {
      "field": "language_foundations_keywords.3",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "](.keywords.reserved.intro \"lex.keywords.reserved.intro\")\n\nThese keywords arenâ€™t used yet, but they are reserved for future use. They have\nthe same restrictions as strict keywords.\nThe reasoning behind this is to make\ncurrent programs forward compatible with future versions of Rust by forbidding\nthem to use these keywords. [[lex.keywords.reserved.list]](.keywords.reserved.list \"lex.keywords.reserved.list\")\n\n* `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `macro`\n* `override`\n* `priv`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`",
            "KW\\_IF : `if",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\""
          ]
        }
      ],
      "reasoning": "The fine-grained field describes control-flow constructs including conditionals, loops, and pattern matching, and lists keywords such as if, else, loop, while, for, break, continue, and match. Excerpts that explicitly enumerate these control-flow keywords and discuss their roles in Rust provide direct, supporting evidence for this field. A highly relevant excerpt catalogs a broad set of keywords with explicit notes on control-flow items like break, continue, else, for, if, loop, and match, aligning precisely with the described category and its examples. Another closely related excerpt similarly lists a wide range of keywords in active use (including break, const, continue, else, for, if, loop, match, while) and describes their functionality, reinforcing the same control-flow theme. A third excerpt focuses on a specific control-flow keyword, detailing its meaning and usage (for the if keyword and its role in conditional branching). A fourth excerpt explicitly groups loop-related keywords, such as loop, while, and for, under control-flow constructs. A fifth excerpt highlights the match keyword as a distinct control-flow/pattern-matching construct. Finally, an earlier excerpt enumerates keywords that are universally available across editions, which includes several core control-flow terms like break, continue, else, for, if, loop, and while, thereby corroborating the fieldâ€™s scope. Together, these excerpts provide comprehensive support for the fieldâ€™s focus on conditional branching, loops, and pattern matching in Rust, across multiple editions and contexts.",
      "confidence": "high"
    },
    {
      "field": "data_engineering_and_storage_keywords.1",
      "citations": [
        {
          "title": "Diesel GitHub Repository",
          "url": "https://github.com/diesel-rs/diesel",
          "excerpts": [
            "A safe, extensible ORM and Query Builder for Rust",
            "Diesel gets rid of the boilerplate for database interaction and eliminates\nruntime errors without sacrificing performance. It takes full advantage of\nRust's type system to create a low overhead query builder that \"feels like\nRust.\" Supported databases:"
          ]
        },
        {
          "title": "Diesel: Safe, Extensible ORM and Query Builder for Rust",
          "url": "https://diesel.rs/",
          "excerpts": [
            "Diesel is a Safe, Extensible ORM and Query Builder for Rust",
            "Diesel is the most productive way to interact with databases in Rust\nbecause of its safe and composable abstractions over queries.",
            "Preventing Runtime Errors",
            "We donâ€™t want to waste time tracking down runtime errors. We achieve\nthis by having Diesel eliminate the possibility of incorrect database\ninteractions at compile time.",
            "Built for Performance",
            "Diesel offers a high level query builder and lets you think about\nyour problems in Rust, not SQL. Our focus on zero-cost abstractions\nallows Diesel to run your query and load your data even faster than\nC."
          ]
        },
        {
          "title": "Getting Started with Diesel",
          "url": "https://diesel.rs/guides/getting-started",
          "excerpts": [
            "Diesel requires Rust 1.78 or later. If you're following along with this ... The diesel GitHub repository contains modified examples for all supported backends."
          ]
        },
        {
          "title": "diesel 2.2.12",
          "url": "https://docs.rs/crate/diesel/latest",
          "excerpts": [
            "Diesel codegen generates boilerplate for you. It lets you focus on your business logic, not mapping to and from SQL rows. That means you can write this ..."
          ]
        },
        {
          "title": "Configuring Diesel CLI",
          "url": "https://diesel.rs/guides/configuring-diesel-cli.html",
          "excerpts": [
            "Diesel CLI is an optional tool Diesel provides to manage your database schema. Its main two roles are to run database migrations, and to create a Rust file."
          ]
        },
        {
          "title": "diesel_cli - crates.io",
          "url": "https://crates.io/crates/diesel_cli",
          "excerpts": [
            "diesel_cli v2.2.12",
            "Provides the CLI for the Diesel crate"
          ]
        }
      ],
      "reasoning": "The field value denotes a Rust-based safe ORM and query builder named Diesel. The most directly supportive information comes from excerpts that explicitly identify Diesel as a safe, extensible ORM and query builder for Rust, and those that describe its benefits (compile-time safety, reduced boilerplate, and a focus on Rust abstractions over SQL). Sentences that highlight how Diesel eliminates runtime errors and provides a high-level, zero-cost abstraction further corroborate the field value. Additional excerpts point to practical usage (getting started) and documentation (Diesel crate and CLI tooling), which reinforce Dieselâ€™s role as a Rust ORM/Query Builder rather than other databases or Rust crates. Excerpts that discuss related tooling or non-Diesel topics are not as directly relevant and are ranked lower accordingly.\n",
      "confidence": "high"
    },
    {
      "field": "unsafe_rust_and_ffi_keywords",
      "citations": [
        {
          "title": "Keywords - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "KW\\_ENUM : `enum",
            "KW\\_EXTERN : `extern",
            "KW\\_FALSE : `false",
            "KW\\_FN : `fn",
            "KW\\_FOR : `for",
            "KW\\_IF : `if",
            "KW\\_IMPL : `impl",
            "KW\\_IN : `in",
            "KW\\_LET : `let",
            "KW\\_LOOP : `loop",
            "KW\\_MATCH : `match",
            "KW\\_MOD : `mod",
            "KW\\_MOVE : `move",
            "KW\\_MUT : `mut",
            "KW\\_PUB : `pub",
            "KW\\_REF : `ref",
            "KW\\_RETURN : `return",
            "KW\\_SELFVALUE : `self",
            "KW\\_SELFTYPE : `Self",
            "KW\\_STATIC : `static",
            "KW\\_STRUCT : `struct",
            "KW\\_SUPER : `super",
            "KW\\_TRAIT : `trait",
            "KW\\_TRUE : `true",
            "KW\\_TYPE : `type",
            "KW\\_UNSAFE : `unsafe",
            "KW\\_USE : `use",
            "KW\\_WHILE : `while",
            "The following keywords were added beginning in the 2018 edition. * `async`\n* `await`\n* `dyn`",
            "> **<sup>Lexer 2018+</sup>**",
            "KW\\_ASYNC : `async",
            "KW\\_AWAIT : `await",
            "KW\\_DYN : `dyn",
            "The following keywords are reserved beginning in the 2018 edition. > **<sup>Lexer 2018+</sup>**",
            "KW\\_TRY : `try",
            "The following keywords are reserved beginning in the 2024 edition. * `gen`",
            "> **<sup>Lexer 2024+</sup>**",
            "> **<sup>Lexer 2024+</sup>**",
            "These keywords have special meaning only in certain contexts. For example, it\nis possible to declare a variable or method with the name `union` . > **<sup>Lexer</sup>**",
            "KW\\_MACRO\\_RULES : `macro_rule",
            "KW\\_UNION : `union",
            "KW\\_STATICLIFETIME : `'static",
            "KW\\_SAFE : `safe",
            "\n\n> 2018 Edition differences\n>\n> In the 2015 edition, [`dyn`](types/trait-object.html) is a keyword when used in a type position followed by a path that does not start with `::` or `<`, a lifetime, a question mark, a `for` keyword or an opening parenthesis. >\n> Beginning in the 2018 edition, `dyn` has been promoted to a strict keyword.",
            "```compile_fail\n  // error[E0262]: invalid lifetime parameter name: \\`'static\\`\n  fn invalid_lifetime_parameter<'static>(s: &'static str) -> &'static str { s }\n  ``",
            "The following keywords are in all editions:\n\n* `as`\n* `break`\n* `const`\n* `continue`\n* `crate`\n* `else`\n* `enum`\n* `extern`\n* `false`\n* `fn`\n* `for`\n* `if`\n* `impl`\n* `in`\n* `let`\n* `loop`\n* `match`\n* `mod`\n* `move`\n* `mut`\n* `pub`\n* `ref`\n* `return`\n* `self`\n* `Self`\n* `static`\n* `struct`\n* `super`\n* `trait`\n* `true`\n* `type`\n* `unsafe`\n* `use`\n* `where`\n* `while`",
            "* `union` is used to declare a [union](items/unions.html) and is only a keyword when used in a\n  union declaratio",
            "* `'static` is used for the static lifetime and cannot be used as a [generic\n  lifetime parameter](items/generics.html) or [loop label](expressions/loop-expr.htm",
            "The following keywords are reserved beginning in the 2018 edition. * `try`",
            "KW\\_GEN : `gen",
            "KW\\_GEN : `gen",
            "* [strict]()\n* [reserved]()\n* [weak]()\n"
          ]
        },
        {
          "title": "Keywords - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/keywords.html",
          "excerpts": [
            "> **<sup>Lexer 2018+</sup>**",
            "> **<sup>Lexer 2018+</sup>**"
          ]
        },
        {
          "title": "Appendix A: Keywords - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/appendix-01-keywords.html",
          "excerpts": [
            "The following list contains keywords that are reserved for current or future\nuse by the Rust language. As such, they cannot be used as identifiers (except\nas raw identifiers as weâ€™ll discuss in the â€œ [Raw\nIdentifiers]() â€ section). Identifiers are names\nof functions, variables, parameters, struct fields, modules, crates, constants,\nmacros, static values, attributes, types, traits, or lifetimes. ### [Keywords Currently in Use]()\n\nThe following is a list of keywords currently in use, with their functionality\ndescribed.\n* `as` \\- perform primitive casting, disambiguate the specific trait containing\n  an item, or rename items in `use` statements\n* `async` \\- return a `Future` instead of blocking the current thread\n* `await` \\- suspend execution until the result of a `Future` is ready\n* `break` \\- exit a loop immediately\n* `const` \\- define constant items or constant raw pointers\n* `continue` \\- continue to the next loop iteration\n* `crate` \\- in a module path, refers to the crate root\n* `dyn` \\- dynamic dispatch to a trait object\n* `else` \\- fallback for `if` and `if let` control flow constructs\n* `enum` \\- define an enumeration\n* `extern` \\- link an external function or variable\n* `false` \\- Boolean false literal\n* `fn` \\- define a function or the function pointer type\n* `for` \\- loop over items from an iterator, implement a trait, or specify a\n  higher-ranked lifetime\n* `if` \\- branch based on the result of a conditional expression\n* `impl` \\- implement inherent or trait functionality\n* `in` \\- part of `for` loop syntax\n* `let` \\- bind a variable\n* `loop` \\- loop unconditionally\n* `match` \\- match a value to patterns\n* `mod` \\- define a module\n* `move` \\- make a closure take ownership of all its captures\n* `mut` \\- denote mutability in references, raw pointers, or pattern bindings\n* `pub` \\- denote public visibility in struct fields, `impl` blocks, or modules\n* `ref` \\- bind by reference\n* `return` \\- return from function\n* `Self` \\- a type alias for the type we are defining or\nimplementing\n* `self` \\- method subject or current module\n* `static` \\- global variable or lifetime lasting the entire program execution\n* `struct` \\- define a structure\n* `super` \\- parent module of the current module\n* `trait` \\- define a trait\n* `true` \\- Boolean true literal\n* `type` \\- define a type alias or associated type\n* `union` \\- define a [union](../reference/items/unions.html) ; is only a keyword when used\n  in a union declaration\n* `unsafe` \\- denote unsafe code, functions, traits, or implementations\n* `use` \\- bring symbols into scope; specify precise captures for generic and\n  lifetime bounds\n* `where` \\- denote clauses that constrain a type\n* `while` \\- loop conditionally based on the result of an expression\n\n### [Keywords Reserved for Future Use]()\n\nThe following keywords do not yet have any functionality but are reserved by\nRust for potential future use. * `abstract`\n* `become`\n* `box`\n* `do`\n* `final`\n* `gen`\n* `macro`\n* `override`\n* `priv`\n* `try`\n* `typeof`\n* `unsized`\n* `virtual`\n* `yield`\n\n### [Raw Identifiers]()\n\n_Raw identifiers_ are the syntax that lets you use keywords where they wouldnâ€™t\nnormally be allowed. You use a raw identifier by prefixing a keyword with `r#` . For example, `match` is a keyword. If you try to compile the following function\nthat uses `match` as its name:\n\nFilename: src/main.rs\n\n```\n! [Image](img/ferris/does_not_compile.svg \"This code does not compile!\")\nfn match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n```\n\nyouâ€™ll get this error:\n\n```\nerror: expected identifier, found keyword \\`match\\`\n --> src/main.rs:4:4\n  |\n4 | fn match(needle: &str, haystack: &str) -> bool {\n  |    ^^^^^ expected identifier, found keyword\n```\n\nThe error shows that you canâ€™t use the keyword `match` as the function\nidentifier. To use `match` as a function name, you need to use the raw\nidentifier syntax, like this:\n\nFilename: src/main.rs\n\n```\n```\nfn r # match (needle: & str , haystack: & str ) -> bool {\n    haystack.contains(needle)\n}\n\nfn main () {\n    assert! (r# match ( \"foo\" , \"foobar\" ));\n}\n```\n```\n\nThis code will compile without any errors. Note the `r#` prefix on the function\nname in its definition as well as where the function is called in `main` . Raw identifiers allow you to use any word you choose as an identifier, even if\nthat word happens to be a reserved keyword. This gives us more freedom to choose\nidentifier names, as well as lets us integrate with programs written in a\nlanguage where these words arenâ€™t keywords. In addition, raw identifiers allow\nyou to use libraries written in a different Rust edition than your crate uses. For example, `try` isnâ€™t a keyword in the 2015 edition but is in the 2018, 2021,\nand 2024 editions.\nIf you depend on a library that is written using the 2015\nedition and has a `try` function, youâ€™ll need to use the raw identifier syntax, `r` in this case, to call that function from your code on later editions. See [Appendix E](appendix-05-editions.html) for more information on editions. [](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\")\n\n[](appendix-00.html \"Previous chapter\") [](appendix-02-operators.html \"Next chapter\"",
            "The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers. The following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers."
          ]
        },
        {
          "title": "Rust By Example - Raw identifiers",
          "url": "https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html",
          "excerpts": [
            " `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n",
            "Rust, like many programming languages, has the concept of \"keywords\". These identifiers mean something to the language, and so you cannot use them in\nplaces like variable names, function names, and other places. Raw identifiers let you use keywords where they would not normally be allowed. This is particularly useful when Rust introduces new keywords, and a library\nusing an older edition of Rust has a variable or function with the same name\nas a keyword introduced in a newer edition. For example, consider a crate `foo` compiled with the 2015 edition of Rust that\nexports a function named `try`. This keyword is reserved for a new feature in\nthe 2018 edition, so without raw identifiers, we would have no way to name the\nfunction.\n```\nextern crate foo;\n\nfn main() {\n    foo::try();\n}\n```\n\nYou'll get this error:\n\n```\nerror: expected identifier, found keyword `try`\n --> src/main.rs:4:4\n  |\n4 | foo::try();\n  |      ^^^ expected identifier, found keyword\n```\n\nYou can write this with a raw identifier:\n\n```\nextern crate foo;\n\nfn main() {\n    foo::r();\n}\n```"
          ]
        },
        {
          "title": "Identifiers - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/identifiers.html",
          "excerpts": [
            "A raw identifier is like a normal identifier, but prefixed by `r#` . (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "RAW\\_IDENTIFIER](identifiers.html) â†’ r# [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html) <sub>except `crate` , `self` , `super` , `Self`</su",
            "It is an error to use the [RESERVED\\_RAW\\_IDENTIFIER](identifiers.html) token `r` in order to avoid confusion with the [WildcardPattern](patterns.html)",
            "Zero width non-joiner (ZWNJ U+200C) and zero width joiner (ZWJ U+200D) characters are not allowed in identifiers.",
            "Identifiers are restricted to the ASCII subset of [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) and [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=) in the following situations:",
            "The profile used from UAX #31 is:\n\n* Start := [`XID_Start`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=) , plus the underscore character (U+005F)\n* Continue := [`XID_Continue`](http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=)\n* Medial := empt",
            "Identifiers starting with an underscore are typically used to indicate an identifier that is intentionally unused, and will silence the unused warning in `rustc` .",
            "Identifiers are normalized using Normalization Form C (NFC) as defined in [Unicode Standard Annex #15](https://www.unicode.org/reports/tr15/tr15-56.html) .",
            "Show Railroad"
          ]
        },
        {
          "title": "The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/",
          "excerpts": [
            "What editions are",
            "Which changes are contained in each edition",
            "How to migrate your code from one edition to another",
            "In this guide, we'll discuss: What editions are; Which changes are contained in each edition; How to migrate your code from one edition to another."
          ]
        },
        {
          "title": "Managing Growing Projects with Packages, Crates, and ...",
          "url": "https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html",
          "excerpts": [
            "Packages: A Cargo feature that lets you build, test, and share crates Â· Crates: A tree of modules that produces a library or executable Â· Modules and use: Let you ..."
          ]
        },
        {
          "title": "Operator expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/operator-expr.html",
          "excerpts": [
            "Operators are defined for built in types by the Rust language. Many of the following operators can also be overloaded using traits in std::ops or std::cmp."
          ]
        },
        {
          "title": "Literal expressions - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/expressions/literal-expr.html",
          "excerpts": [
            "A literal expression is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it ..."
          ]
        },
        {
          "title": "Tokens - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/tokens.html",
          "excerpts": [
            "A non-raw byte string literal is a sequence of ASCII characters and escapes, preceded by the characters U+0062 ( b ) and U+0022 (double-quote), and followed by ... Note that raw identifiers, raw string literals, and raw byte string literals may contain a # character but are not interpreted as containing a reserved prefix."
          ]
        },
        {
          "title": "Features - The Cargo Book",
          "url": "https://doc.rust-lang.org/cargo/reference/features.html",
          "excerpts": [
            "Cargo â€œfeaturesâ€ provide a mechanism to express conditional compilation and optional dependencies. A package defines a set of named features in the [features] ..."
          ]
        },
        {
          "title": "Transitioning an existing project to a new edition",
          "url": "https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html",
          "excerpts": [
            "The Rust Edition Guide ... In order to help transition to the next edition, Cargo includes the cargo fix subcommand to automatically update your source code."
          ]
        },
        {
          "title": "Advanced migrations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/editions/advanced-migrations.html",
          "excerpts": [
            "The lints that cargo fix --edition apply are part of a lint group. For example, when migrating from 2018 to 2021, Cargo uses the rust-2021-compatibility group ..."
          ]
        },
        {
          "title": "Rust Reference: Identifiers",
          "url": "https://doc.rust-lang.org/stable/reference/identifiers.html?highlight=IDENTIFIER",
          "excerpts": [
            "Identifiers may not be a [strict](keywords.html) or [reserved](keywords.html) keyword without the `r#` prefix described below in [raw identifiers]().",
            "A raw identifier is like a normal identifier, but prefixed by `r#`. (Note that\nthe `r#` prefix is not included as part of the actual identifier.)",
            "Unlike a normal identifier, a raw identifier may be any strict or reserved\nkeyword except the ones listed above for `RAW_IDENTIFIER`."
          ]
        },
        {
          "title": "Visibility and Privacy - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/visibility-and-privacy.html",
          "excerpts": [
            "Visibility and privacy - The Rust Reference",
            "By default, everything is _private_ , with two exceptions: Associated\nitems in a `pub` Trait are public by default; Enum variants\nin a `pub` enum are also public by default. When an item is declared as `pub` ,\nit can be thought of as being accessible to the outside world. For example:",
            "```rust\nfn main() {}\n// Declare a private struct\nstruct Foo;\n\n// Declare a public struct with a private field\npub struct Bar {\n    field: i32,\n}\n\n// Declare a public enum with two public variants\npub enum State {\n    PubliclyAccessibleState,\n    PubliclyAccessibleState2,\n}\n```",
            "With the notion of an item being either public or private, Rust allows item\naccesses in two cases:\n\n1. If an item is public, then it can be accessed externally from some module `m` if you can access all the itemâ€™s ancestor modules from `m` . You can\n   also potentially be able to name the item through re-exports. See below. 2. If an item is private, it may be accessed by the current module and its\n   descendants.",
            "## [`pub(in path)` , `pub(crate)` , `pub(super)` , and `pub(self)`]()",
            "* `pub(in path)` makes an item visible within the provided `path` . `path` must be a simple path which resolves to an ancestor module of the item whose visibility is being declared.\nEach identifier in `path` must refer directly to a module (not to a name introduced by a `use` statement).",
            "* `pub(crate)` makes an item visible within the current crate.",
            "* `pub(super)` makes an item visible to the parent module. This is equivalent\n  to `pub(in super)` .",
            "* `pub(self)` makes an item visible to the current module. This is equivalent\n  to `pub(in self)` or not using `pub` at all.",
            "> 2018 Edition differences\n> \n> Starting with the 2018 edition, paths for `pub(in path)` must start with `crate` , `self` , or `super` . The 2015 edition may also use paths starting with `::` or modules from the crate root. Hereâ€™s an example:",
            "```rust\npub mod outer_mod {\n    pub mod inner_mod {\n        // This function is visible within \\`outer_mod\\`\n        pub(in crate::outer_mod) fn outer_mod_visible_fn() {}\n        // Same as above, this is only valid in the 2015 editio"
          ]
        },
        {
          "title": "The Rust Reference - Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes.html?highlight=attribute",
          "excerpts": [
            "Inner attributes_ , written with a bang ( `!` ) after the hash ( `#` ), apply to the\nitem that the attribute is declared within. _Outer attributes_ , written without\nthe bang after the hash, apply to the thing that follows t"
          ]
        },
        {
          "title": "std - Rust",
          "url": "https://doc.rust-lang.org/std/",
          "excerpts": [
            "The Rust Standard Library is the foundation of portable Rust software, a set of minimal and battle-tested shared abstractions for the broader Rust ecosystem."
          ]
        },
        {
          "title": "New keywords - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2018/new-keywords.html",
          "excerpts": [
            "n 2015 it is a [weak keyword](https://doc.rust-lang.org/reference/keywords.html). * `async` and `await` are [strict keywords](https://doc.rust-lang.org/reference/keywords.html). * `try` is a [reserved keyword](https://doc.rust-lang.org/reference/keywords.html). [Motivation]()",
            "The `dyn Trait` feature is the new syntax for using trait objects. In short:\n\n* `Box<Trait>` becomes `Box<dyn Trait>`\n* `&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`",
            "The `try` keyword is reserved for use in `try` blocks, which have not (as of this writing) been stabilized ([tracking issue](https://github.com/rust-lang/rust/issues/31436))"
          ]
        },
        {
          "title": "Preludes - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/names/preludes.html",
          "excerpts": [
            "A *prelude* is a collection of names that are automatically brought into scope\nof every module in a crat",
            "There are several different preludes:",
            "* [Standard library prelud",
            "* [Extern prelud",
            "* [Language prelud",
            "* [`macro_use` prelud",
            "* [Tool prelud",
            "The language prelude includes names of types and attributes that are built-in\nto the language. The language prelude is always in scope.",
            "It includes the following:\n\n* [Type namespace](namespaces.html)\n  + [Boolean type](../types/boolean.html) â€” `bool`\n  + [Textual types](../types/textual.html) â€” `char` and `str`\n  + [Integer types](../types/numeric.html) â€” `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`\n  + [Machine-dependent integer types](../types/numeric.html) â€” `usize` and `isize`\n  + [floating-point types](../types/numeric.html) â€” `f32` and `f64`",
            "d to the crate:\n\n| Edition | `no_std` not applied | `no_std` applied |\n| --- | --- | --- |\n| 2015 | [`std::prelude::rust_2015`](../../std/prelude/rust_2015/index.html) | [`core::prelude::rust_2015`](../../core/prelude/rust_2015/index.html) |\n| 2018 | [`std::prelude::rust_2018`](../../std/prelude/rust_2018/index.html) | [`core::prelude::rust_2018`](../../core/prelude/rust_2018/index.html) |\n| 2021 | [`std::prelude::rust_2021`](../../std/prelude/rust_2021/index.html) | [`core::prelude::rust_2021`](../../core/prelude/rust_2021/index.html) |\n| 2024 | [`std::prelude::rust_2024`](../../std/prelude/rust_2024/index.html) | [`core::prelude::rust_2024`](../../core/prelude/rust_2024/index.html) ",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e](../attributes.html)* may be applied at the crate level to prevent the\n[`std`](../../std/index.html) crate from being automatically added into scope",
            "e` [attribute](../attributes.html)* may be applied at the crate level or\non a module to indicate that it should not automatically bring the [standard\nlibrary prelude](), [extern prelude](), or [tool prelude]() into scope for that\nmodule or any of its descendants."
          ]
        },
        {
          "title": "Higher-Rank Trait Bounds - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/hrtb.html",
          "excerpts": [
            "\nwhere for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n```\n\nAlternatively:\n\n```\nwhere F: for<'a> Fn(&'a (u8, u16)) -> &'a u8,\n```\n\n(Where `Fn(a, b, c) -> d` is itself just sugar for the unstable *real* `Fn`\ntrait)\n\n`for<'a>` can be read as \"for all choices of `'a`\", and basically produces an\n*infinite list* of trait bounds that F must satisfy. Intense. There aren't many\nplaces outside of the `Fn` traits where we encounter HRTBs, and even for\nthose we have a nice magic sugar for the common cases.\n\nIn summary, we can rewrite the original code more explicitly as:\n\n```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n```\n```",
            "Higher-Rank Trait Bounds - The Rustonomicon",
            "Rust's `Fn` traits are a little bit magic. For instance, we can write the",
            "following code:",
            "```\n```\nstruct Closure<F> {\n    data: (u8, u16),\n    func: F,\n}\n\nimpl<F> Closure<F>\n    where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8,\n{\n    fn call(&self) -> &u8 {\n        (self.func)(&self.data)\n    }\n}\n\nfn do_it(data: &(u8, u16)) -> &u8 { &data.0 }\n\nfn main() {\n    let clo = Closure { data: (0, 1), func: do_it };\n    println!(\"{}\", clo.call());\n}\n",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Mutex in std::sync",
          "url": "https://doc.rust-lang.org/std/sync/struct.Mutex.html",
          "excerpts": [
            "For a mutex, this means that the lock and try_lock methods return a Result which indicates whether a mutex has been poisoned or not. Most usage of a mutex will ...",
            "A mutual exclusion primitive useful for protecting shared data. This mutex will block threads waiting for the lock to become available.",
            "let data = Arc::new(Mutex::new( 0 ));",
            "The mutexes in this module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "s module implement a strategy called â€œpoisoningâ€ where a\nmutex is considered poisoned whenever a thread panics while holding the\nmutex.",
            "This mutex will block threads waiting for the lock to become available",
            " The\nmutex can be created via a [`new`](struct.Mutex.html.new \"associated function std::sync::Mutex::new\") constructor.",
            "use std::sync::{Arc, Mutex};",
            "let mutex = Arc::new(Mutex::new( 0 ));",
            " move || -> () {\n    // This thread will acquire the mutex first, unwrapping the result of\n    // \\`lock\\` because the lock has not been poisoned. let _guard = lock2.lock().unwrap();\n\n    "
          ]
        },
        {
          "title": "The Rustonomicon - Ownership and Lifetimes",
          "url": "https://doc.rust-lang.org/nomicon/ownership.html",
          "excerpts": [
            "Ownership is the breakout feature of Rust. It allows Rust to be completely\nmemory-safe and efficient, while avoiding garbage collection.",
            "This is exactly what Rust's ownership system was built to solve.",
            "Rust knows the scope in which the `&s` lives, and as such can prevent it from\nescaping. However this is a simple case that even a C compiler could plausibly\ncatch. Things get more complicated as code gets bigger and pointers get fed through\nvarious functions. Eventually, a C compiler will fall down and won't be able to\nperform sufficient escape analysis to prove your code unsound. It will consequently\nbe forced to accept your program on the assumption that it is correct. This will never happen to Rust. It's up to the programmer to prove to the\ncompiler that everything is sound. Of course, Rust's story around ownership is much more complicated than just\nverifying that references don't escape the scope of their referent.",
            "The Rustonomicon"
          ]
        },
        {
          "title": "Rust By Example: Ownership and moves",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move.html",
          "excerpts": [
            "Because variables are in charge of freeing their own resources,",
            "resources can only have one owner",
            "This prevents resources",
            "from being freed more than once. Note that not all variables own",
            "resources (e.g. [references](../flow_control/match/destructuring/destructure_pointers.html)). When doing assignments (`let x = y`) or passing function arguments by value",
            "When doing assignments (`let x = y`) or passing function arguments by value\n(`foo(x)`), the *ownership* of the resources is transferred. In Rust-speak,\nthis is known as a *move*.",
            "this is known as a *move*. After moving resources, the previous owner can no longer be used. This avoids",
            "creating dangling pointers. ```",
            "// *Copy* `x` into `y` - no resources are moved",
            "    let y = x;",
            "Both values can be independently used"
          ]
        },
        {
          "title": "The Rustonomicon - Ownership Based Resource Management (OBRM)",
          "url": "https://doc.rust-lang.org/nomicon/obrm.html",
          "excerpts": [
            ")\n\nOBRM (AKA RAII: Resource Acquisition Is Initialization) is something you'll\ninteract with a lot in Rust. Especially if you use the standard library. Roughly speaking the pattern is as follows: to acquire a resource, you create an\nobject that manages it. To release the resource, you simply destroy the object,\nand it cleans up the resource for you.",
            "The most common \"resource\" this pattern\nmanages is simply _memory_ . `Box` , `Rc` , and basically everything in `std::collections` is a convenience to enable correctly managing memory.",
            "This is\nparticularly important in Rust because we have no pervasive GC to rely on for\nmemory management. Which is the point, really: Rust is about control."
          ]
        },
        {
          "title": "The Rust Programming Language - References and Borrowing",
          "url": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html",
          "excerpts": [
            " A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable.",
            "Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Here is how you would define and use a `calculate_length` function that has a\nreference to an object as a parameter instead of taking ownership of the value:",
            "fn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println! (\"The length of '{s1}' is {len}.\n\");\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()",
            "First, notice that all the tuple code in the variable declaration and the\nfunction return value is gone. Second, note that we pass `&s1` into `calculate_length` and, in its definition, we take `&String` rather than `String` . These ampersands represent _references_ , and they allow you to refer\nto some value without taking ownership of it.",
            "A _reference_ is like a pointer in that itâ€™s an address we can follow to access\nthe data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a\nparticular type for the life of that reference.",
            "Mutable references have one big restriction: if you have a mutable reference to\na value, you can have no other references to that value."
          ]
        },
        {
          "title": "Lifetimes - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/lifetime.html",
          "excerpts": [
            "A _lifetime_ is a construct the compiler (or more specifically, its _borrow\nchecker_ ) uses to ensure all borrows are valid.",
            "Lifetimes - Rust By Example"
          ]
        },
        {
          "title": "Lifetime Elision - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/lifetime-elision.html",
          "excerpts": [
            "Lifetime positions can appear as either \"input\" or \"output\":",
            "Each elided lifetime in input position becomes a distinct lifetime\n  paramete",
            "If there is exactly one input lifetime position (elided or not), that lifetime\n  is assigned to _all_ elided output lifeti",
            "If there are multiple input lifetime positions, but one of them is `&self` or `&mut self` , the lifetime of `self` is assigned to _all_ elided output lifetime",
            "Elision rules are as follows:",
            "Otherwise, it is an error to elide an output lifetime."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/lifetime-elision.html",
          "excerpts": [
            "Lifetime elision - The Rust Reference",
            "Rust has rules that allow lifetimes to be elided in various places where the\ncompiler can infer a sensible default choice.",
            "The following rules are used to infer lifetime parameters for elided lifetimes.",
            "It is an error to elide lifetime parameters that cannot be inferred.",
            "The placeholder lifetime, `'_` , can also be used to have a lifetime inferred in the\nsame way. For lifetimes in paths, using `'_` is preferred.",
            "These default object lifetime bounds are used instead of the lifetime parameter\nelision rules defined above when the lifetime bound is omitted entirely.",
            "In order to make common patterns more ergonomic, lifetime arguments can be _elided_ in [function item](types/function-item.html) , [function pointer](types/function-pointer.html) , and [closure trait](types/closure.html) signatures. The following rules are used to infer lifetime parameters for elided lifetimes.",
            "Trait object lifetimes follow different rules discussed [below]() .",
            "The assumed lifetime of references held by a [trait object](types/trait-object.html) is called its _default object lifetime bound_ . These were defined in [RFC 599](https://github.com/rust-lang/rfcs/blob/master/text/0599-default-object-bound.md) and amended in [RFC 1156](https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md) .",
            "If `'_` is used as the lifetime bound then the bound follows the usual elision\nrules.",
            "If the trait is defined with a single lifetime _bound_ then that bound is\n  use",
            "If there is more than one bound from the containing type then an explicit\n  bound must be specifi",
            "If neither of those rules apply, then the bounds on the trait are used:",
            "If the trait has no lifetime bounds, then the lifetime is inferred in\n  expressions and is `'static` outside of expression",
            "}\n```\n```\n\n```\n```rust\n#![allow(unused)]\nfn main() {\n// The following examples show situations where it is not allowed to elide the\n// lifetime parameter.\n\ntrait Example {\n// Cannot infer, because there are no parameters to infer from.\nfn get_str() -> &str;                                 // ILLEGAL\n\n// Cannot infer, ambiguous if it is borrowed from the first or second parameter.\nfn frob(s: &str, t: &str) -> &str;                    // ILLEGAL\n}\n}\n```\n"
          ]
        },
        {
          "title": "Stacked Borrows Implemented",
          "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
          "excerpts": [
            "Three months ago, I proposed Stacked Borrows as a model for defining what kinds\nof aliasing are allowed in Rust, and the idea of a [validity invariant](/blog/2018/08/22/two-kinds-of-invariants.html) that has to be maintained by all\ncode at all times.",
            "What Stacked Borrows does is that it defines a semantics for Rust programs such\nthat some things about references always hold true for every valid execution\n(meaning executions where no [undefined behavior](/blog/2017/07/14/undefined-behavior.html) occurred): `&mut` references are unique (we\ncan rely on no accesses by other functions happening to the memory they point\nto), and `&` references are immutable (we can rely on no writes happening to the\nmemory they point to, unless there is an `UnsafeCell` )",
            ". Usually we have the\nborrow checker guarding us against such nefarious violations of reference type\nguarantees, but alas, when we are writing unsafe code, the borrow checker cannot\nhelp us.",
            "To understand these rules better, try going back through the three examples we\nhave seen so far and applying these rules for dereferencing pointers and\naccessing memory to understand how they interact.",
            "Let us look at the two key properties that I set out as design goals, and see\nhow the model guarantees that they hold true in all valid (UB-free) executions.",
            "Stacked Borrows Implemented",
            "We have to define a set of rules that makes sense even for unsafe\ncode. I will explain these rules again in this post.",
            "The most subtle point here is that we make a `Uniq` tag match a `Shr` item and\nalso accept `Uniq` reads on frozen locations.",
            "This is required to make `demo1` work: Rust permits read accesses through mutable references even when they are\nnot currently actually unique.",
            "## 3 Retagging and Creating Raw Pointers",
            "However, before we go\nthere, I would like us to consider one more example:",
            "The question is: Can we move the load of `x` to before the function call? Remember that the entire point of Stacked Borrows is to enforce a certain\ndiscipline when using references, in particular, to enforce uniqueness of\nmutable references.",
            "we should hope that the answer to that question is â€œyesâ€\n(and that, in turn, is good because we might use it for optimizations).",
            "Unfortunately, things are not so easy."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model For Rust",
          "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
          "excerpts": [
            "Stacked Borrows: An Aliasing Model For Rust",
            "* [ralfj.de](/)",
            "*     + [Projects](/projects/)",
            "      + [Blog](/blog/)",
            "      +         - [RSS Feed](/blog/feed.xml)",
            "Aug 7, 2018",
            "8\n\n â€¢ [Internship](/blog/categories/internship.html) , [Rust](/blog/categories/rust.html) â€¢ [Edits](https://git.ralfj.de/web.git/history/refs/heads/master:/personal/_posts/2018-08-07-stacked-borrows.md) â€¢ [Permalink](/blog/2018/08/07/stacked-borrows.html)",
            "# Stacked Borrows: An Aliasing Model For Rust",
            "In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses. This is a long-standing open question of many unsafe code authors, and also by compiler authors who want to add more optimizations. The model I am proposing here is by far not the first attempt at giving a definition: The model is heavily based on ideas by [@arielb1](https://github.com/nikomatsakis/rust-memory-model/issues/26) and [@ubsan](https://github.com/nikomatsakis/rust-memory-model/issues/28) , and of course taking into account the lessons I [learned last year](/blog/2017/08/11/types-as-contracts-evaluation.html) when I took my first stab at defining such a model, dubbed [â€œTypes as Contractsâ€](/blog/2017/07/17/types-as-contracts.html) .",
            " ... ",
            "Now we have everything together. Instead of giving another recap, I will try to give an alternative, more precise description of the model in the form of pseudo Rust code. This is essentially a draft of the code that will hopefully be in Miri soon, to actually dynamically track the borrow stack and enforce the rules.",
            "\nOf course, these tags do not exist on real hardware. But that is besides the point. When _specifying_ program behavior, we can work with an [â€œinstrumented machineâ€](/blog/2017/06/06/MIR-semantics.html) that has extra state which is not present on the real machine, as long as we only use that extra state to define whether a program is UB or not:\nOn real hardware, we can ignore programs that are UB (they may just do whatever), so the extra state does not matter. Tags are something I wanted to avoid in â€œTypes as Contractsâ€ â€“ that was one of the initial design constraints I had put upon myself, in the hope of avoiding the trouble coming with â€œcomplicated pointersâ€. However, I now came to the conclusion that tagging pointers is a price worth paying if it means we can make lifetimes irrelevant.",
            "\nThese are examples of optimizations we would like to be valid, and in fact all three of them are still valid with â€œStacked Borrowsâ€.",
            "I hope you now have a clear idea of the basic structure of the model I am proposing: The stack of borrows, the freeze flag, and references tagged with the time at which they got created. The full model is not quite as simple, but it is not much more complicated either. We need to add just two more concepts: Retagging and barriers. ### 4\\.1 Retaggin",
            "On top of this, barriers encode the fact that, when a reference is passed as an argument to a function, then its lifetime (whatever it is) extends beyond the current function call.",
            "Since the tag can never be changed, this means two\ndifferent variables can never have the same tag â€“ right? Well, unfortunately,\nthings are not so simple: Using\ne.g. [`transmute_copy`](https://doc.rust-lang.org/stable/std/mem/fn.transmute_copy.html) or a `union` , one can make a copy of a reference in a way that Rust does not\neven notice. Still, we would like to make statements about code like this:",
            "When renumbering `x` , we are pushing a barrier. Renumbering `y` would attempt to reactivate `Uniq(y)` , but that can only be behind the barrier, so it cannot be reactivated.",
            "  * x = 42 ;",
            "  * y = 7 ;",
            "Some details have been omitted in the high-level description so far, they should all be in this code.",
            "} ```",
            "The trouble is, we cannot prevent the outside world from passing bogus `&mut` that have the same tag. Does this mean we are back to square one in terms of making aliased mutable references UB? Lucky enough, we are not! We have a lot of machinery at our disposal, we just have to tweak it a little. What we will do is, every time a reference comes â€œintoâ€ our function (this can be a function argument, but also loading it from memory or getting it as the return value of some other function), we perform â€œretaggingâ€:",
            "We change the tags of the mutable references to the current clock value, bumping up the clock after every tag we assign, and then we push those new tags on top of the borrow stack. This way, we can know â€“ without making any assumptions about foreign code â€“ that all references have distinct IDs. In particular, two different references can never be both â€œactiveâ€ for the same location at the same time.",
            "```rust"
          ]
        },
        {
          "title": "Higher-ranked trait bounds - Rust Compiler Development ...",
          "url": "https://rustc-dev-guide.rust-lang.org/traits/hrtb.html",
          "excerpts": [
            "One of the more subtle concepts in trait resolution is higher-ranked trait bounds. An example of such a bound is for<'a> MyTrait<&'a isize>."
          ]
        },
        {
          "title": "Subtyping and Variance - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/subtyping.html",
          "excerpts": [
            "Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes."
          ]
        },
        {
          "title": "Validating References with Lifetimes",
          "url": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html",
          "excerpts": [
            "The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to ... There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &self and announcement their own lifetimes. Then, ..."
          ]
        },
        {
          "title": "Lifetime elision - The Rust Reference",
          "url": "https://web.mit.edu/rust-lang_v1.26.0/arch/amd64_ubuntu1404/share/doc/rust/html/reference/lifetime-elision.html",
          "excerpts": [
            "Rust allows lifetimes to be elided in function item, function pointer and closure trait signatures. The following rules are used to infer lifetime parameters ..."
          ]
        },
        {
          "title": "Introduction - The Rustonomicon",
          "url": "https://doc.rust-lang.org/nomicon/",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "The Rustonomicon - The Dark Arts of Advanced and Unsafe Rust Programming",
          "url": "http://doc.rust-lang.org/nomicon",
          "excerpts": [
            "The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs."
          ]
        },
        {
          "title": "Two-phase borrows",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check/two_phase_borrows.html",
          "excerpts": [
            "s]()\n\nTwo-phase borrows are a more permissive version of mutable borrows that allow\nnested method calls such as `vec.push(vec.len())` . Such borrows first act as\nshared borrows in a \"reservation\" phase and can later be \"activated\" into a\nfull mutable borrow. Only certain implicit mutable borrows can be two-phase, any `&mut` or `ref mut` in the source code is never a two-phase borrow. The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "The cases where we generate a\ntwo-phase borrow are:\n\n1. The autoref borrow when calling a method with a mutable reference receiver. 2. A mutable reborrow in function arguments. 3. The implicit mutable borrow in an overloaded compound assignment operator.",
            "Whether a borrow can be two-phase is tracked by a flag on the [`AutoBorrow`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/adjustment/enum.AutoBorrow.html) after type checking, which is then [converted](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/trait.ToBorrowKind.html.to_borrow_kind) to a [`BorrowKind`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.BorrowKind.html) during MIR\nconstruction. Each two-phase borrow is assigned to a temporary that is only used once. As\nsuch we can define:\n\n* The point where the temporary is assigned to is called the _reservation_ point of the two-phase borrow. * The point where the temporary is used, which is effectively always a\n  function call, is called the _activation_ point.\nThe activation points are found using the [`GatherBorrows`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/visit/trait.Visitor.html.visit_local) visitor. The [`BorrowData`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/borrow_set/struct.BorrowData.html) then holds both the reservation and activation points for the\nborrow. ## [Checking two-phase borrows]()\n\nTwo-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:\n\n1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow. We determine (in [`is_active`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/path_utils/fn.is_active.html) ) if we're at such a point\n   by using the [`Dominators`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html) for the MIR graph. 4. After the activation point, the two-phase borrow acts as a mutable borrow.",
            "Two-phase borrows are treated as if they were mutable borrows with the\nfollowing exceptions:",
            "1. At every location in the MIR we [check](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_borrowck/struct.MirBorrowckCtxt.html.check_activations) if any two-phase borrows are\n   activated at this location. If a live two phase borrow is activated at a\n   location, then we check that there are no borrows that conflict with the\n   two-phase borrow. 2. At the reservation point we error if there are conflicting live _mutable_ borrows. And lint if there are any conflicting shared borrows. 3. Between the reservation and the activation point, the two-phase borrow acts\n   as a shared borrow."
          ]
        },
        {
          "title": "The Rust RFC Book - nested_method_call",
          "url": "https://rust-lang.github.io/rfcs/2025-nested-method-calls.html",
          "excerpts": [
            "Enable â€œnested method callsâ€ where the outer call is an `&mut self` borrow, such as `vec.push(vec.len())` (where `vec: Vec<usize>` ). This\nis done by extending MIR with the concept of a **two-phase borrow** ;\nin this model, select `&mut` borrows are modified so that they begin\nwith a â€œreservationâ€ phase and can later be â€œactivatedâ€ into a full\nmutable borrow. During the reservation phase, reads and shared borrows\nof the borrowed data are permitted (but not mutation), as long as they\nare confined to the reservation period. Once the mutable borrow is\nactivated, it acts like an ordinary mutable borrow. Two-phase borrows in this RFC are only used when desugaring method\ncalls; this is intended as a conservative step.",
            "When desugared into MIR, this would look something like:\n\n```\ntmp0 = &'a mut2 v;   // reservation begins\ntmp1 = &'b v;       // shared borrow begins; allowed, because \\`v\\` is reserved\np = foo(tmp1);\nVec::push(tmp0, 3); // mutable borrow activated\nEndRegion('a);      // mutable borrow ends\ntmp2 = *p;          // shared borrow still valid! use(tmp2) \nEndRegion('b);\n```\n\nNote that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point.",
            "Two-phase borrows would be used in the specific case of desugaring a\ncall to an `&mut self` method.",
            "During the reservation phase before a\nmutable borrow is activated, it acts exactly like a shared borrow â€“\nhence the borrowed value can still be read. As discussed earlier, this RFC itself only introduces these two-phase\nborrows in a limited way. Specifically, we extend the MIR with a new\nkind of borrow (written `mut2` , for two-phase), and we generate those\nnew kinds of borrows when lowering method calls.",
            "#### [Proposed change]()\n\nWhen the borrow checker encounters a `mut2` borrow, it will handle it\nin a slightly different way. Because of the limited places where `mut2` borrows\nare generated, we know that they will only ever be encountered in a statement\nthat assigns them to a MIR temporary:\n\n```\ntmp = &'r mut2 lv\n```\n\nIn that case, the path `lv` would initially be considered **reserved** . The temporary `tmp` will only be used once, as an\nargument to the actual call: at that point, the path `lv` will be\nconsidered **mutably borrowed** . In terms of the safety checks, reservations act just as a shared\nborrow does. Therefore, a write to `lv` at point `P` is illegal if\nthere is any active borrow **or** in-scope reservation of `lv` at the\npoint `P` . Similarly, a read from `lv` at point `P` is legal if there\nexists a reservation (but not with a mutable borrow). There is one new check required.",
            "Note that, here, we created a borrow of `v[0]` _before_ we called `Vec::push()` , and we continue to use it afterwards. This should not\nbe accepted, but it could be without this additional check at the\nactivation point. In particular, at the time that the shared borrow _starts_ , `v` is reserved; the mutable borrow of `v` is activated\nlater, but still within the scope of the shared borrow. (In todayâ€™s\nborrow checker, this cannot happen, so we only check at the start of a\nborrow whether other borrows are in scope.)",
            "\n\nIn the internals thread, arielb1 had [an interesting proposal][ref2]\nthat they called â€œtwo-phase lifetimesâ€. The goal was precisely to take\nthe â€œtwo-phaseâ€ concept but incorporate it into lifetime inference,\nrather than handling it in borrow checking as I present here. The idea\nwas to define a type `RefMut<'r, 'w, T>` (original `Ref2Î¦<'immut, 'mutbl, T>` ) which stands in for a kind of â€œricherâ€ `&mut` type\n(originally, `&T` was unified as well, but that introduces\ncomplications because `&T` types are `Copy` , so Iâ€™m leaving that\nout).\nIn particular, `RefMut` has two lifetimes, not just one:\n\n* `'r` is the â€œreadâ€ lifetime. It includes every point where the reference\n  may later be used. * `'w` is a subset of `'r` (that is, `'r: 'w` ) which indicates the â€œwriteâ€ lifetime. This includes those points where the reference is actively being written."
          ]
        },
        {
          "title": "[blog post] Nested method calls via two-phase borrowing",
          "url": "https://internals.rust-lang.org/t/blog-post-nested-method-calls-via-two-phase-borrowing/4886",
          "excerpts": [
            "Mar 1, 2017 â€” It works by augmenting the borrow checker so that mutable borrows begin as \"reserved\" and then, on first use, convert to active status. WhileÂ ..."
          ]
        },
        {
          "title": "Partial moves - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/scope/move/partial_move.html",
          "excerpts": [
            "A partial move of the variable, which means that parts of the variable will be moved while other parts stay."
          ]
        },
        {
          "title": "Rust Ownership, Borrowing, and Lifetimes",
          "url": "https://www.integralist.co.uk/posts/rust-ownership/",
          "excerpts": [
            "Rust Ownership, Borrowing, and Lifetimes",
            "The rules for ownership are quite simple:",
            "Data is assigned to a variable.",
            "The variable becomes the â€˜ownerâ€™ of the data.",
            "There can only be one owner at a time.",
            "When the owner goes out of scope, the data will be dropped.",
            "Borrowing",
            "The concept of borrowing is designed to make dealing with ownership changes easier. It does this by avoiding the _moving_ of owners. The way it does this is by letting your program provide a â€˜referenceâ€™ to the dat",
            " Lifetimes"
          ]
        },
        {
          "title": "Pin â€” Rust Documentation (std::pin::Pin)",
          "url": "http://doc.rust-lang.org/std/pin/struct.Pin.html",
          "excerpts": [
            "in::Pin\"). [`Pin<Ptr>`](struct.Pin.html \"struct std::pin::Pin\") can wrap any pointer type, forming a promise that the **pointee**\nwill not be *moved* or [otherwise invalidated](index.html \"pin subtle details\").",
            "A pointer which pins its pointee in place.",
            "The vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "If the pointee valueâ€™s type\nimplements [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), we are free to disregard these requirements entirely and can wrap any\npointer to that value in [`Pin`](struct.Pin.html \"struct std::pin::Pin\") directly via [`Pin::new`](struct.Pin.html.new \"associated function std::pin::Pin::new\").",
            "A value, once pinned, must remain pinned until it is dropped (unless its type implements\n`Unpin`).",
            ".html \"Future\") types\nthat donâ€™t have a reason to care about being pinned and therefore implement [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\"), the\n`Pin<&mut Self>` will act exactly like a regular `&mut Self`, allowing direct\naccess to the underlying value.",
            "\nThis requirement for the implementation of `async fn`s means that the [`Future`](../future/trait.Future.html \"Future\") trait\nrequires all calls to [`poll`](../future/trait.Future.html.poll \"Future::poll\") to use a `self: Pin<&mut Self>` parameter instead",
            "\nThe vast majority of Rust types have no reason to ever care about being pinned. These\ntypes implement the [`Unpin`](../marker/trait.Unpin.html \"trait std::marker::Unpin\") trait, which entirely opts all values of that type out of\npinning-related guarantees.",
            "s that implement [`Future`](../future/trait.Future.html \"Future\") for the return value of\n`async fn`s. These compiler-generated [`Future`](../future/trait.Future.html \"Future\")s may contain self-referential pointers, one\nof the most common use cases for [`Pin`](struct.Pin.html \"struct std::pin::Pin\"). "
          ]
        },
        {
          "title": "Aliasing - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/aliasing.html",
          "excerpts": [
            "With that said, here's our working definition: variables and pointers _alias_ if they refer to overlapping regions of memor",
            "In Rust, this optimization should be sound.",
            "We would _like_ to be able to optimize it to the following function:",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis). This is because the optimization relies\non knowing that aliasing doesn't occur, which most languages are fairly liberal\nwith.",
            "In Rust we know this input should be impossible because `&mut` isn't allowed to be\naliased.",
            "In Rust, this optimization should be sound. For almost any other language, it\nwouldn't be (barring global analysis).",
            "This is why alias analysis is important: it lets the compiler perform useful\noptimizations!"
          ]
        },
        {
          "title": "Drop Check - The Rustonomicon",
          "url": "http://doc.rust-lang.org/nomicon/dropck.html",
          "excerpts": [
            "ariables are dropped in the reverse\norder of their definiti",
            "drop order",
            "Drop Check - The Rustonomicon",
            "The left vector is dropped first.",
            "days: Box::new(1),",
            "world.inspector = Some(Inspector(&world.days));",
            "The borrow checker could track fields of tuples separately, but it would\nstill be unable to decide what outlives what in case of vector elements, which\nare dropped manually via pure-library code the borrow checker doesn't\nunderstand.",
            "This program is totally sound and compiles today. The fact that `days` does not\nstrictly outlive `inspector` doesn't matter.",
            "\nSound generic drop is enforced by the _drop checker_",
            "For a generic type to soundly implement drop, its generics arguments must\nstrictly outlive it."
          ]
        },
        {
          "title": "Destructors - The Rust Reference",
          "url": "http://doc.rust-lang.org/reference/destructors.html",
          "excerpts": [
            "When an [initialized](glossary.html) [variable](variables.html) or [temporary](expressions.html) goes out of\n[scope](), its *destructor* is run, or it is *dropped*. [Assignment](expressions/operator-expr.html)\nalso runs the destructor of its left-hand operand, if itâ€™s initialized. If a\nvariable has been partially initialized, only its initialized fields are\ndropped."
          ]
        },
        {
          "title": "Error codes index",
          "url": "https://doc.rust-lang.org/error-index.html",
          "excerpts": [
            "Rust error codes index - Error codes index\n\nIf you are not automatically redirected to the error code index, please [here](./error_codes/error-index.html) ."
          ]
        },
        {
          "title": "E0502 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0502.html",
          "excerpts": [
            "Error code E0502: A variable already borrowed with a certain mutability (either mutable or immutable) was borrowed again with a different mutability."
          ]
        },
        {
          "title": "Stacked Borrows - Learning Rust With Entirely Too Many ...",
          "url": "https://rust-unofficial.github.io/too-many-lists/fifth-stacked-borrows.html",
          "excerpts": [
            "Stacked borrows are still \"experimental\" as a semantic model for Rust, so breaking these rules may not actually mean your program is \"wrong\". In fact they're extra complicated because stacked borrows are trying to be more permissive and let more unsafe code work the way you'd expect it to. This is ..."
          ]
        },
        {
          "title": "Accepting nested method calls with an `&mut self` receiver",
          "url": "https://internals.rust-lang.org/t/accepting-nested-method-calls-with-an-mut-self-receiver/4588",
          "excerpts": [
            "Jan 10, 2017 â€” vec.push(vec.len()) -> Vec::push(&mut vec, Vec::len(&vec)) would take &vec and evaluate the length first, then take the &mut vec and call push ."
          ]
        },
        {
          "title": "Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/borrow_check.html",
          "excerpts": [
            "The borrow check is Rust's \"secret sauce\" â€“ it is tasked with\nenforcing a number of properties:",
            "* That all variables are initialized before they are used. * That you can't move the same value twice. * That you can't move a value while it is borrowed. * That you can't access a place while it is mutably borrowed (except through\n  the reference). * That you can't mutate a place while it is immutably borrowed. * etc",
            "The borrow checker operates on the MIR.",
            "The MIR is _far_ less complex than the HIR; the radical desugaring\n  helps prevent bugs in the borrow checker."
          ]
        },
        {
          "title": "Stacked Borrows: An Aliasing Model for Rust (POPL 2020)",
          "url": "https://plv.mpi-sws.org/rustbelt/stacked-borrows/",
          "excerpts": [
            "In Rust, the type system imposes a strict discipline on pointer aliasing, and it is an express goal of the Rust compiler developers to make use of that alias information for the purpose of program optimizations that reorder memory accesses.",
            "Stacked Borrows defines an aliasing discipline and declares programs violating it to have *undefined behavior*, meaning the compiler does not have to consider such programs when performing optimizations.",
            "this work, we propose *Stacked Borrows*, an operational semantics for memory accesses in Rust.",
            "The problem is that Rust also supports unsafe code, and programmers can write unsafe code that bypasses the usual compiler checks to violate the aliasing discipline.",
            "We also implemented this operational model in an interpreter for Rust and ran large parts of the Rust standard library test suite in the interpreter to validate that the model permits enough real-world unsafe Rust code."
          ]
        },
        {
          "title": "Nested Method Calls via Two-Phase Borrowing",
          "url": "https://smallcultfollowing.com/babysteps/blog/2017/03/01/nested-method-calls-via-two-phase-borrowing/",
          "excerpts": [
            "The key insight is that, today, when we execute the mutable borrow of\n`vec`, we start a borrow **immediately**, even though the reference\n(`arg0`, here) is not going to be used until later:\n\n```\n/* 0 */ tmp0 = &mut vec;   // mutable borrow created here..\n/* 1 */ tmp1 = &vec; // <-- shared borrow overlaps here         |\n/* 2 */ tmp2 = Vec::len(tmp1); //                               |\n/* 3 */ Vec::push(tmp0, tmp2); // ..but not used until here! ```\n\nThe proposal â€“ which I will call **two-phased mutable borrows** â€“ is\nto modify the borrow-checker so that mutable borrows operate in **two\nphases**:\n\n* When an `&mut` reference is first created, but before it is used,\n  the borrowed path (e.g., `vec`) is considered **reserved**. A\n  reserved path is subject to the same restrictions as a shared borrow\n  â€“ reads are ok, but moves and writes are not (except under a\n  `Cell`). * Once you start using the reference in some way, the path is\n  considered **mutably borrowed** and is subject to the usual\n  restrictions. So, in terms of our example, when we execute the MIR statement `tmp0 = &mut vec`, that creates a **reservation** on `vec`, but doesnâ€™t start\nthe actual borrow yet. `tmp0` is not used until line 3, so that means\nthat for lines 1 and 2, `vec` is only reserved. Therefore, itâ€™s ok to\nshare `vec` (as line 1 does) so long as the resulting reference\n(`tmp1`) is dead as we enter line 3. Since `tmp1` is only used to call\n`Vec::len()`, weâ€™re all set!"
          ]
        },
        {
          "title": "Associated Items - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/items/associated-items.html",
          "excerpts": [
            "Associated Items are the items declared in traits or defined in implementations. They are called this because they are defined on an associate type â€” the type ..."
          ]
        },
        {
          "title": "Associated types - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/assoc_items/types.html",
          "excerpts": [
            "The use of \"Associated types\" improves the overall readability of code by moving inner types locally into a trait as output types."
          ]
        },
        {
          "title": "Traits: Defining Shared Behavior - The Rust Programming ...",
          "url": "https://doc.rust-lang.org/book/ch10-02-traits.html",
          "excerpts": [
            "Clearer Trait Bounds with where Clausesâ€‹â€‹ This function's signature is less cluttered: the function name, parameter list, and return type are close together, ... We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior ..."
          ]
        },
        {
          "title": "Where clauses - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/generics/where.html",
          "excerpts": [
            "Where clauses. A bound can also be expressed using a where clause immediately before the opening { , rather than at the type's first mention."
          ]
        },
        {
          "title": "The Rust Programming Language Blog",
          "url": "https://blog.rust-lang.org/",
          "excerpts": [
            "This is the main Rust blog. Rust teams use this blog to announce major developments in the world of Rust. See also: the \"Inside Rust\" blog,Â ..."
          ]
        },
        {
          "title": "The Rust Reference - Traits",
          "url": "https://doc.rust-lang.org/reference/items/traits.html",
          "excerpts": [
            "[[items .traits .dyn-compatible .supertraits]](.traits.dyn-compatible.supertraits \"items.traits.dyn-compatible.supertraits\")\n\n* All [supertraits]() must also be dyn compatible",
            "        - Not have any type parameters (although lifetime parameters are allowed). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver. - Have a receiver with one of the following types:",
            "\n## [Generic traits]()\n\nType parameters can be specified for a trait to make it generic. These appear\nafter the trait name, using the same syntax used in [generic functions](functions.html)",
            "\nTraits are implemented for specific types through separate [implementations](implementations.html)",
            "Trait functions may omit the function body by replacing it with a semicolon.\nThis indicates that the implementation must define the function.",
            "A dyn-compatible trait can be the base trait of a [trait object](../types/trait-object.html) . A trait is _dyn compatible_ if it has the following qualities:",
            "aits.safety.intro\")\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the\ntrait may be [unsafe](../unsafety.html) .",
            "trait may be [unsafe](../unsafety.html) . It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html) must also begin with the `unsafe` keyword. [`Sync`](../special-types-and-traits.html) and [`Send`](../special-types-and-traits.html) are examples of unsafe traits. [[items .traits .params]](.traits.params \"items.traits.params\")",
            "                  * Not be an `async fn` (which has a hidden `Future` type). * Not have a return position `impl Trait` type ( `fn example(&self) -> impl Trait` ). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this). + Explicitly non-dispatchable functions require:",
            "upertraits.intro\")\n\n**Supertraits** are traits that are required to be implemented for a type to\nimplement a specific trait.",
            " [[items .traits .dyn-compatible .sized]](.traits.dyn-compatible.sized \"items.traits.dyn-compatible.sized\")\n\n* `Sized` must not be a [supertrait]() . In other words, it must not require `Self: Sized`",
            "[[items .traits .dyn-compatible .associated-consts]](.traits.dyn-compatible.associated-consts \"items.traits.dyn-compatible.associated-consts\")\n\n* It must not have any associated constants",
            "[[items .traits .dyn-compatible .associated-functions]](.traits.dyn-compatible.associated-functions \"items.traits.dyn-compatible.associated-functions\")",
            "                  * `&Self` (i.e. `&self` )",
            "                  * `&mut Self` (i.e `&mut self` )",
            "                  * [`Box<Self>`](../special-types-and-traits.html)",
            "                  * [`Rc<Self>`](../special-types-and-traits.html)",
            "                  * [`Arc<Self>`](../special-types-and-traits.html)",
            "                  * [`Pin<P>`](../special-types-and-traits.html) where `P` is one of the types above",
            "                - Not have an opaque return type; that is,",
            "                - Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self` ) implies this).",
            "[[items .traits .dyn-compatible .async-traits]](.traits.dyn-compatible.async-traits \"items.traits.dyn-compatible.async-traits\")",
            "The [`AsyncFn`](../../core/ops/async_function/trait.AsyncFn.html) , [`AsyncFnMut`](../../core/ops/async_function/trait.AsyncFnMut.html) , and [`AsyncFnOnce`](../../core/ops/async_function/trait.AsyncFnOnce.html) traits are not dyn-compatible. > Note",
            "> ",
            "> This concept was formerly known as _object safety_ . ```",
            "d). - Be a [method](associated-items.html) that does not use `Self` except in the type of the receiver.",
            "use std::sync::Arc;",
            "use std::pin::Pin;",
            "* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:",
            "    fn by_ref(self: &Self) {}",
            "    fn by_ref_mut(self: &mut Self) {}",
            "    fn by_box(self: Box<Self>) {}",
            "    fn by_rc(self: Rc<Self>) {}",
            "    fn by_arc(self: Arc<Self>) {}",
            "    fn by_pin(self: Pin<&Self>) {}",
            "    fn with_lifetime<'a>(self: &'a Self) {}",
            "    fn nested_pin(self: Pin<Arc<Self>>) {}",
            "ype). * Not have a return position `impl Trait` type (`fn example(&self) -> impl Trait`).",
            "let t: Box<dyn TraitMethods> = Box::new(S);",
            "// This trait is dyn compatible, but these methods cannot be dispatched on a trait object. trait NonDispatchable {",
            "\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable",
            "    // Self type isn't known until runtime. fn returns(&self) -> Self where Self: Sized;",
            "    // \\`other\\` may be a different concrete type of the receiver. fn param(&self, other: Self) where Self: Sized {}",
            "    // Generics are not compatible with vtables.",
            "impl NonDispatchable for S {",
            "`). - Not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).",
            "let obj: Box<dyn NonDispatchable> = Box::new(S);",
            "```\n```rust\n#! [allow(unused)]",
            "// \\`Self: Sized\\` traits are dyn-incompatible. trait TraitWithSize where Self: Sized {}",
            "impl TraitWithSize for S {}",
            "let obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR",
            "```\n\n```\n```rust",
            "```\n\n```\n```rust",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "#! [allow(unused)",
            "// Dyn-incompatible if \\`Self\\` is a type argument.",
            "trait Super<A> {}",
            "trait WithSelf: Super<Self> where Self: Sized {}",
            "struct S;",
            "struct S;",
            "struct S;",
            "struct S;",
            "impl<A> Super<A> for S {}",
            "impl WithSelf for S {}",
            "let obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use \\`Self\\` type parameter",
            "```\n\n[[items .traits .supertraits]](.traits.supertraits \"items.traits.supertraits\")",
            "## [Supertraits]()",
            "[[items .traits .supertraits .intro]](.traits.supertraits.intro \"items.traits.supertraits.intro\")",
            "implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html) is bounded by a trait, it has access to the associated items of its supertraits. [[items .traits .supertraits .decl]](.traits.supertraits.decl \"items.traits.supertraits.decl\")",
            "## [Unsafe traits]()",
            "[[items .traits .safety .intro]](.traits.safety.intro \"items.traits.safety.intro\")",
            "## [Parameter patterns]()",
            "[[items .traits .params .patterns-no-body]](.traits.params.patterns-no-body \"items.traits.params.patterns-no-body\")",
            "Parameters in associated functions without a body only allow [IDENTIFIER](../identifiers.html) or `_` [wild card](../patterns.html) patterns, as well as the form allowed by [SelfParam](functions.html) .",
            "`mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future. ```",
            "Associated types",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "---------------------------------------",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch10-00-generics.html",
          "excerpts": [
            "Generics allow us to replace specific types with a placeholder that represents\nmultiple types to remove code duplication.",
            "We can express the behavior of generics or\nhow they relate to other generics without knowing what will be in their place\nwhen compiling and running the code.",
            "youâ€™ll learn how to use _traits_ to define behavior in a generic way. You\ncan combine traits with generic types to constrain a generic type to accept\nonly those types that have a particular behavior"
          ]
        },
        {
          "title": "Rust Reference - Trait Bounds",
          "url": "https://doc.rust-lang.org/reference/trait-bounds.html",
          "excerpts": [
            "Bounds on an item must be satisfied when using the item.",
            "In trait declarations as [supertraits](items/traits.html): `trait Circle : Shape {}` is\n  equivalent to `trait Circle where Self : Shape {}",
            "In trait declarations as bounds on [associated types](items/associated-items.html):\n  `trait A { type B: Copy; }` is equivalent to\n  `trait A where Self::B: Copy { type B; }`.",
            "There are also shorter forms for\ncertain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):\n  `fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`"
          ]
        },
        {
          "title": "The Rust Unstable Book: trait_upcasting",
          "url": "https://dev-doc.rust-lang.org/beta/unstable-book/language-features/trait-upcasting.html",
          "excerpts": [
            "```\n#! [allow(unused)]\n#! [feature(trait_upcasting)]\n#! [allow(incomplete_features)]\n\nfn main() {\ntrait Foo {}\n\ntrait Bar: Foo {}\n\nimpl Foo for i32 {}\n\nimpl<T: Foo + ?Sized> Bar for T {}\n\nlet bar: &dyn Bar = &123;\nlet foo: &dyn Foo = bar;\n}\n```\n```",
            "The `trait_upcasting` feature adds support for trait upcasting coercion. This allows a\ntrait object of type `dyn Bar` to be cast to a trait object of type `dyn Foo`\nso long as `Bar: Foo`."
          ]
        },
        {
          "title": "The Rust Unstable Book - specialization",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/specialization.html",
          "excerpts": [
            " specialization - The Rust Unstable Book",
            "Allows specialization of implementations (RFC 1210). The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)"
          ]
        },
        {
          "title": "min_specialization - The Rust Unstable Book",
          "url": "https://doc.rust-lang.org/beta/unstable-book/language-features/min-specialization.html",
          "excerpts": [
            "# [`min_specialization`]()",
            "A minimal, sound subset of specialization intended to be used by the standard library until the soundness issues with specialization are fixed. The tracking issue for this feature is: [](https://github.com/rust-lang/rust/issues/31844)",
            "min\\_specialization - The Rust Unstable Boo"
          ]
        },
        {
          "title": "Empowering everyone to build reliable and efficient software. Announcing Rust 1.86.0 | Rust Blog",
          "url": "https://blog.rust-lang.org/2025/04/03/Rust-1.86.0/",
          "excerpts": [
            "What's in 1.86.0 stable\n-----------------------\n\n### Trait upcasting\n\nThis release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:\n\n```\ntrait Trait: Supertrait {}\ntrait Supertrait {}\n\nfn upcast(x: &dyn Trait) -> &dyn Supertrait {\n    x\n}\n```\n\nThe same would work with any other kind of (smart-)pointer, like `Arc<dyn Trait> -> Arc<dyn Supertrait>` or `*const dyn Trait -> *const dyn Supertrait`. Previously this would have required a workaround in the form of an `upcast` method in the `Trait` itself, for example `fn as_supertrait(&self) -> &dyn Supertrait`, and this would work only for one kind of reference/pointer. Such workarounds are not necessary anymore. Note that this means that raw pointers to trait objects carry a non-trivial invariant: \"leaking\" a raw pointer to a trait object with an invalid vtable into safe code may lead to undefined behavior. It is not decided yet whether creating such a raw pointer temporarily in well-controlled circumstances causes immediate undefined behavior, so code should refrain from creating such pointers under any conditions (and Miri enforces that).",
            "This release includes a long awaited feature â€” the ability to upcast trait objects. If a trait has a [supertrait](https://doc.rust-lang.org/reference/items/traits.html) you can coerce a reference to said trait object to a reference to a trait object of the supertrait:",
            "trait Trait: Supertrait {}",
            "trait Supertrait {}",
            "fn upcast(x: &dyn Trait) -> &dyn Supertrait {",
            "    x",
            "```",
            "```",
            "}"
          ]
        },
        {
          "title": "Idea: About soundness in specialization - language design - Rust Internals",
          "url": "https://internals.rust-lang.org/t/idea-about-soundness-in-specialization/16085",
          "excerpts": [
            " [Idea] About soundness in specialization ",
            ") . One rule it describes is that \"each type parameter can only be used once\"",
            "_variables)]\n\ntrait Is<T> {\n    fn is(&self);\n}\n\nimpl<A, B> Is<A> for B {\n    default fn is(&self) {\n        println! (\"no\");\n    }\n}\n\nimpl<T> Is<T> for T {\n    fn is(&self) {\n        println!\n ... ",
            "This topic was automatically closed 90 days after the last reply. New replies are no longer allowed."
          ]
        },
        {
          "title": "Shipping specialization: a story of soundness",
          "url": "https://internals.rust-lang.org/t/shipping-specialization-a-story-of-soundness/5507",
          "excerpts": [
            "Historically, there have been three big blockers to stabilization:\n\n* \n  The interplay between specialization rules and coherence, which I resovled in [an earlier blog post](http://aturon.github.io/blog/2017/02/06/specialization-and-coherence/) . * \n  The precise ways in which specialization employs negative reasoning, which\n  will be resolved by incorporating ideas from [Chalk](https://github.com/nikomatsakis/chalk/) into the compiler. * \n  The soundness of specializationâ€™s interactions with lifetimes.",
            "But we see a viable way to\nship a sound, useful subset of specialization in the meantime. Feel free to jump\nto â€œA modest proposalâ€ in the post if you just want to hear about that. This blog post is an attempt to write up what weâ€™ve learned so far, with the\nhopes that it will clarify that thinking, and maybe open the door to _you_ cracking the nu"
          ]
        },
        {
          "title": "1.86.0 | Rust Changelogs",
          "url": "https://releases.rs/docs/1.86.0/",
          "excerpts": [
            "Apr 3, 2025 â€” Stabilize upcasting trait objects to supertraits. Allow safe functions to be marked with the #[target_feature] attribute. The missing_abi lintÂ ..."
          ]
        },
        {
          "title": "3324-dyn-upcasting - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/3324-dyn-upcasting.html",
          "excerpts": [
            "Summary. Enable upcasts from dyn Trait1 to dyn Trait2 if Trait1 is a subtrait of Trait2 . This RFC does not enable dyn (Trait1 + Trait2) for arbitrary traits. ...",
            "If Trait1 has multiple supertraits, you can upcast to any one of them, but not to all of them. This RFC has already been implemented in the nightly compiler ..."
          ]
        },
        {
          "title": "Rust Deep Dive: Borked Vtables and Barking Cats",
          "url": "https://geo-ant.github.io/blog/2023/rust-dyn-trait-objects-fat-pointers/",
          "excerpts": [
            "Mar 15, 2023 â€” The pointers to dyn Trait objects store both the address of the data as well as a pointer to the vtable. There is one global vtable instance forÂ ...",
            "Mar 15, 2023 â€” We'll get to the specific layout of a vtable below, but for now suffice it to say that a vtable is a contiguous piece of storage in memory thatÂ ..."
          ]
        },
        {
          "title": "Understanding Rust's Trait Objects: Vtables, Dynamic ...",
          "url": "https://www.reddit.com/r/rust/comments/1epc5g6/understanding_rusts_trait_objects_vtables_dynamic/",
          "excerpts": [
            "This article investigates how Rust handles dynamic dispatch using trait objects and vtables. It also explores how the Rust compiler can sometimes optimize tailÂ ..."
          ]
        },
        {
          "title": "Why do blanket implementations for two different traits ...",
          "url": "https://stackoverflow.com/questions/73782573/why-do-blanket-implementations-for-two-different-traits-conflict",
          "excerpts": [
            "Rust has the concept of \"trait coherence\" which is the idea that for any combination of type and trait there should be at most one implementation of that trait."
          ]
        },
        {
          "title": "Confusion about conflicting trait impls",
          "url": "https://users.rust-lang.org/t/confusion-about-conflicting-trait-impls/125808",
          "excerpts": [
            "Here is some simplified example code. It gives an error: error[E0119]: conflicting implementations of trait `HasWidgetId` for type `Box<_>` ..."
          ]
        },
        {
          "title": "Tracking issue for specialization (RFC 1210) #31844",
          "url": "https://github.com/rust-lang/rust/issues/31844",
          "excerpts": [
            "Feb 23, 2016 â€” Note that the specialization feature as implemented currently is unsound, which means that it can cause Undefined Behavior without unsafe code."
          ]
        },
        {
          "title": "Associated const in traits with const generics",
          "url": "https://users.rust-lang.org/t/associated-const-in-traits-with-const-generics/52976",
          "excerpts": [
            "Dec 18, 2020 â€” const generic paramters can't depend on associated constants from traits yet (in a generic context)."
          ]
        },
        {
          "title": "Trait objects - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/trait-object.html",
          "excerpts": [
            "Trait objects are written as the keyword `dyn` followed by a set of trait\nbounds",
            "Due to the opaqueness of which concrete type the value is of, trait objects are [dynamically sized type",
            "Like all DSTs , trait objects are used\nbehind some type of pointer; for example `&dyn SomeTrait` or `Box<dyn SomeTrait>`",
            "The purpose of trait objects is to permit â€œlate bindingâ€ of methods. Calling a\nmethod on a trait object results in virtual dispatch at runtime",
            "A _trait object_ is an opaque value of another type that implements a set of\ntrait"
          ]
        },
        {
          "title": "Coherence",
          "url": "https://rust-lang.github.io/chalk/book/clauses/coherence.html",
          "excerpts": [
            "## [Coherence]()",
            "The idea of trait coherence is that, given a trait and some set of types for its type parameters, there should be exactly one impl that applies. So if we think of the trait `Display` , we want to guarantee that if we have a trait reference like `MyType : Display` , we can uniquely identify a particular impl. > \n> The role of the orphan rules in particular is basically to prevent you from implementing external traits for external types. So continuing our simple example of `Display` , if you are defining your own library, you could not implement `Display` for `Vec<T>` , because both `Display` and `Vec` are defined in the standard library. But you can implement `Display` for `MyType` , because you defined `MyType` . However, if you define your own trait `MyTrait` , then you can implement `MyTrait` for any type you like, including external types like `Vec<T>` . To this end, the orphan rule intuitively says â€œeither the trait must be local or the self-type must be localâ€.\n> \n> \\-- [Little Orphan Impls](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) by Niko Matsak",
            "\nTo check for coherence, the Rust compiler completes two separate but related checks:\n\n* orphan check - ensures that each impl abides by the orphan rules, or in other words, that an impl is potentially implementable by the crate adding it\n      + A consequence of the orphan rules: for every impl that could exist, it only exists in **one** place â€” this is key to having a coherent system\n* overlap check - ensures that no two impls overlap in your program **or** **in any** _**compatible**_ **world**\n      + **compatible** \\- any semver compatible world",
            "# [Resources About Coherence]()",
            "## [Axioms & Properties of Coherence]()",
            "* **Axiom 1:** crates upstream to you should be able to implement their own traits for their own types",
            "* **Axiom 2:** crates downstream from you should be able to implement your traits",
            "* **Property:** Upstream crates must assume that downstream crates will add any impls that compile. Downstream crates are allowed to assume that upstream crates will not add any semver incompatible impls.",
            "# [Chalk: Orphan Check]()",
            "The purpose of the orphan check is to ensure that an impl is only definable in a single crate. This check is what makes it impossible for other crates to define impls of your traits for your types. **We want to capture some rule:** Given `impl<T0â€¦Tn> for Trait<P1â€¦Pn> for P0` , `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is true if and only if this impl is allowed in the current (local) crate. This check is applied to all impls in the current crate. Upstream impls are not checked with this rule.",
            "## [The Orphan Rules]()",
            "[The Orphan Rules]()\n\nIn order to model the orphan check in chalk, we need a precise description of the orphan rules as they are implemented in rustc today. There are several resources which can be used to figure out the orphan rules in rustc.\n* [RFC 1023: Rebalancing Coherence](https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html)\n* [_Trait Implementation Coherence_](https://doc.rust-lang.org/reference/items/implementations.html) [in the](https://doc.rust-lang.org/reference/items/implementations.html) [_Rust Reference_](https://doc.rust-lang.org/reference/items/implementations.html)\n* [E0210: A violation of the orphan rules in the](https://doc.rust-lang.org/error-index.html) [_Rust Error Index_](https://doc.rust-lang.org/error-index.html)\n* [_Little Orphan Impls_](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/) [by Niko Matsakis](https://smallcultfollowing.com/babysteps/blog/2015/01/14/little-orphan-impls/)\n\nOf all of these, RFC 1023 is probably considered the most authoritative source on the orphan rules. The orphan rules as proposed in that RFC are as follows:\n\nGiven an impl `impl<T1...Tn> Trait<P1...Pn> for P0` , either `Trait` must be local to the current crate, or:\n\n1. At least one type must meet the `LT` pattern defined above. Let `Pi` be the first such type. 2. No type parameters `T1...Tn` may appear in the type parameters that precede `Pi` (that is, `Pj` where `j < i` ). The `LT` pattern being referred to basically means that the type is a â€œlocal typeâ€ including the affects of fundamental types. That means that `Ti` is either a local type, or a fundamental type whose first parameter is a local type. This definition is good.\nOnce you read it a few times and it makes sense, it is fairly unambiguous. That being said, the RFC was written quite a while ago and we have since found [unsoundness](https://github.com/rust-lang/rust/issues/43355) in some of the parts of the compiler that were implemented based on that RFC. Thus, it is probably best to look at the only _truly authoritative_ source on the Rust compiler: the rustc source code itself! Indeed, if you think of the rustc source code as an executable specification of how the Rust programming language is meant to work, you can look at it and determine the true behaviour of the orphan rules. ## [The Orphan Check in rustc]()\n\nThe orphan check as implemented today in the Rust compiler takes place in the [`orphan_check`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which is called [for every declared impl](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc_typeck/coherence/orphan.rs) . Since implementations for locally defined traits are always defined, that function returns OK if the trait being implemented is local. Otherwise, it dispatches to the [`orphan_check_trait_ref`](https://github.com/rust-lang/rust/blob/b7c6e8f1805cd8a4b0a1c1f22f17a89e9e2cea23/src/librustc/traits/coherence.rs) function which does the major orphan rules checking. Recall that the impls we are dealing with are in the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` .\nThe `orphan_check_trait_ref` function takes a **trait ref** which is essentially `Trait` and its parameters `P0â€¦Pn` (notice that the `Self` type `P0` is included). The parameters `P0â€¦Pn` are known as the **input types** of the trait. The function goes through each input type from `P0` to `Pn` looking for the first local type `Pi` . For each type parameter `Pj` found before that, the function checks that it does not contain any of the placeholder types `T0â€¦Tn` at any level. That means that `Pj` cannot have any of the types `T0â€¦Tn` at any level recursively. When the first local type `Pi` is found, we check to make sure any type parameters used in it are covered by a local type. Since we donâ€™t have any fundamental types with more than one type parameter, this check is probably extraneous.\n## [The Orphan Rules in rustc]()\n\nThus, based on the source code, the orphan rules in Rust are as follows:\n\nGiven an impl of the form `impl<T0â€¦Tn> Trait<P1â€¦Pn> for P0` , the impl is allowed if:\n\n* `Trait` is local to the current crate\n* `Trait` is upstream to the current crate and:\n      + There is at least one type parameter `Pi` which, taking fundamental types into account, is **local** to the current crate\n      + Within the type `Pi` , all type parameters are covered by `Pi`\n                - This only really applies if we allowed fundamental types with multiple type parameters\n                - Since we donâ€™t do that yet, we can ignore this for the time being\n      + All types `Pj` such that `j < i` do not contain `T0â€¦Tn` at any level of depth (i.e. the types are **fully visible** **â€”** â€œvisibleâ€ meaning that the type is a known type and not a type parameter or variable)\n\n## [Modeling The Orphan Check]()\n\nDetermining how to model these rules in chalk is actually quite straightforward at this point. We have an exact specification of how the rules are meant to work and we can translate that directly. Hereâ€™s how the lowering rules would look:\n\nFor each trait `Trait` ,\n\n* If `Trait` is local to the current crate, we generate: `forall<Self, P1â€¦Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) }` This models that any impls are allowed if the trait is local to the current crate.\n* If `Trait` is upstream to the current crate, we need a rule which models the additional conditions on which impls are allowed:\n\n```ignore\nforall<Self, P1...Pn> { LocalImplAllowed(Self: Trait<P1...Pn>) :- IsLocal(Self) }\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :- IsFullyVisible(Self), IsLocal(P1)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsLocal(P2)\n}\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    IsLocal(P3)\n}\n...\nforall<Self, P1...Pn> {\n  LocalImplAllowed(Self: Trait<P1...Pn>) :-\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    IsFullyVisible(P2),\n    ...\n    IsFullyVisible(Pn-1),\n    IsLocal(Pn)\n}\n```\n\nHere, we have modeled every possible case of `P1` to `Pn` being local and then checked if all prior type parameters are fully visible. This truly is a direct translation of the rules listed above! Now, to complete the orphan check, we can iterate over each impl of the same form as before and check if `LocalImplAllowed(P0: Trait<P1â€¦Pn>)` is provable. # [Chalk: Overlap Check]()\n\n> Note: A key assumption for the overlap check is that the orphan check runs before it. That means that any impl that the overlap check encounters already abides by the orphan rules.\n ... \nThe issue is that there may very well not be any such impl at this current time. In that case, chalk will conclude that these two impls do not overlap. This is an issue because that is certainly an impl that could be added later, so this conclusion may be too strong. Why is that weâ€™re only saying that this conclusion _may_ be too strong? Well weâ€™re using â€œmayâ€ because it depends on what we want to assume about different crates. The orphan rules make it so that upstream crates can add certain impls to themselves in a semver compatible way. In particular, upstream crates can add impls of upstream traits for their own upstream types without having to worry about breaking downstream code. That means that we canâ€™t just assume that upstream type doesnâ€™t implement an upstream trait. This particular assumption is too strong. On the other hand, the orphan rules permit the current crate to add certain impls as well. A property of the orphan rules is that the impls it allows are only allowed to be defined in a single crate. So that means that if the impls allowed by the orphan rules in the current crate donâ€™t exist, it is perfectly safe to assume that they are not there. The conclusion from all of this is that it is perfectly safe to rule out impls that can be defined in the current crate, but we canâ€™t do the same for impls in any other crate.\n ... \nWe can do this by enumerating the possibilities generated from the orphan rules specified above:\n\n```ignore\n// Given a trait MyTrait<P1...Pn> where WCs\n\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,                  // where clauses\n    Compatible,\n    DownstreamType(Self), // local to a downstream crate\n    CannotProve,\n}\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    DownstreamType(P1),\n    CannotProve,\n}\n...\nforall<Self, P1...Pn> {\n  Implemented(Self: MyTrait<P1...Pn>) :-\n    WCs,\n    Compatible,\n    IsFullyVisible(Self),\n    IsFullyVisible(P1),\n    ...,\n    IsFullyVisible(Pn-1),\n    DownstreamType(Pn),\n    CannotProve,\n}\n```\n\nPerhaps somewhat surprisingly, `IsFullyVisible` works here too. This is because our previous definition of the lowering for `IsFullyVisible` was quite broad. By lowering _all_ types in the current crate and in upstream crates with `IsFullyVisible` , that predicate covers the correct set of types here too. The orphan rules only require that there are no types parameters prior to the first local type. Types that are not type parameters and also by definition not downstream types are all of the types in the current crate and in upstream crates. This is exactly what `IsFullyVisible` covers. Fundamental types in both the current crate and in upstream crates can be considered local in a downstream crate if they are provided with a downstream type."
          ]
        },
        {
          "title": "Generic Associated Types to be Stable in Rust 1.65 | Rust Blog",
          "url": "https://blog.rust-lang.org/2022/10/28/gats-stabilization/",
          "excerpts": [
            "Generic associated types to be stable in Rust 1.65",
            "Oct. 28, 2022 Â· Jack Huey",
            "on behalf of [The Types Team](https://github.com/rust-lang/types-team)",
            "As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable â€” over six and a half years after the original [RFC](https://github.com/rust-lang/rfcs/pull/1598) was opened.",
            "This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like `async` or const generics, there are limitations in the initial stabilization that we plan to remove in the future.",
            "The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into."
          ]
        },
        {
          "title": "E0117 - Error codes index",
          "url": "https://doc.rust-lang.org/error_codes/E0117.html",
          "excerpts": [
            "This error indicates a violation of one of Rust's orphan rules for trait implementations. The rule prohibits any implementation of a foreign trait."
          ]
        },
        {
          "title": "Rust Reference: Trait Implementations Coherence and related trait system topics",
          "url": "https://doc.rust-lang.org/reference/items/implementations.html",
          "excerpts": [
            "The *orphan rule* states that a trait implementation is only allowed if either the trait or at least one of the types in the implementation is defined in the current crate. It prevents conflicting trait implementations across different crates and is key to ensuring coherenc",
            "Given `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at\nleast one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html)\n* All of\n  + At least one of the types `T0..=Tn` must ",
            "Two trait implementations overlap when there is a non-empty intersection of the\ntraits the implementation is for, the implementations can be instantiated with\nthe same type."
          ]
        },
        {
          "title": "Rust Trait Coherence, Orphan Rules, and Example E0210 (E0117)",
          "url": "https://doc.rust-lang.org/error_codes/E0210.html",
          "excerpts": [
            "The reason for this is that there are two appearances of type parameter `T` in",
            "the `impl` header, both as parameters for `ForeignTrait2`.",
            "```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```",
            "\nimpl<T> ForeignTrait for MyType<T> { } // Ok\n}\n```\n```\n\nPlease note that a type alias is not sufficient. For another example of an error, suppose there's another trait defined in `foo`\nnamed `ForeignTrait2` that takes two type parameters. Then this `impl` results\nin the same rule violation:\n\n```\nstruct MyType2;\nimpl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n```\n\nThe reason for this is that there are two appearances of type parameter `T` in\nthe `impl` header, both as parameters for `ForeignTrait",
            "```\nimpl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n```\n",
            "where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\nare types. One of the types `T0, ..., Tn` must be a local type (this is another\norphan rule, see the explanation for E0117)."
          ]
        },
        {
          "title": "Coherence - Rust Compiler Development Guide",
          "url": "https://rustc-dev-guide.rust-lang.org/coherence.html",
          "excerpts": [
            "Coherence checking is what detects both of trait impls and inherent impls overlapping with others.",
            "Overlap checks are performed for both inherent impls, and for trait impls.",
            "This uses the same overlap checking code, really done as two separate analyses.",
            "Overlapping is sometimes partially allowed:",
            "1. for marker traits",
            "2. under [specializatio",
            "but normally isn't.",
            "the explicit negative impl check, and the implicit negative impl check. Both try to prove that an overlap is definitely impossible.",
            "ses. Overlap checks always consider pairs of implementations, comparing them to each other. Overlap "
          ]
        },
        {
          "title": "Data Representation and Layout in Rust - OpenGuild",
          "url": "https://openguild.wtf/blog/rust/data-representation-and-layout",
          "excerpts": [
            "Nov 22, 2023 â€” Rust, with its emphasis on control and safety, provides two primary representations: repr(rust) and repr(C) . The former instructs theÂ ..."
          ]
        },
        {
          "title": "2005-match-ergonomics - The Rust RFC Book",
          "url": "https://rust-lang.github.io/rfcs/2005-match-ergonomics.html",
          "excerpts": [
            "This RFC introduces default binding modes used when a reference value is matched by a non-reference pattern."
          ]
        },
        {
          "title": "Idiomatic definition of uninhabited (never) newtypes",
          "url": "https://internals.rust-lang.org/t/idiomatic-definition-of-uninhabited-never-newtypes/20877",
          "excerpts": [
            "May 20, 2024 â€” It's conventional to use an empty enum for an uninhabited type, because that's the only stable way to do it."
          ]
        },
        {
          "title": "Why doesn't the niche optimization work for this enum?",
          "url": "https://users.rust-lang.org/t/why-doesnt-the-niche-optimization-work-for-this-enum/55711",
          "excerpts": [
            "Feb 16, 2021 â€” The only guaranteed niche filling optimization is if you have an enum that fits the template below exactly, and the wrapped type has a niche."
          ]
        },
        {
          "title": "Pre-(Pre-)RFC: niche types - language design",
          "url": "https://internals.rust-lang.org/t/pre-pre-rfc-niche-types/21810",
          "excerpts": [
            "Nov 2, 2024 â€” Niches are bit patterns within a struct or enum which can be repurposed by an enclosing enum or, in the future, an enclosing struct. While thisÂ ..."
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html?highlight=never",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete. [type. never .coercion]. Expressions of type ! can ..."
          ]
        },
        {
          "title": "never patterns, exhaustive matching, and uninhabited types",
          "url": "https://internals.rust-lang.org/t/blog-post-never-patterns-exhaustive-matching-and-uninhabited-types/8197",
          "excerpts": [
            "Aug 14, 2018 â€” Having two traits should solve problem with obscure corner cases with recursive uninhabited types, as they will not implement any of thoseÂ ..."
          ]
        },
        {
          "title": "Rust Reference: Type Layout",
          "url": "https://doc.rust-lang.org/reference/type-layout.html",
          "excerpts": [
            "All user-defined composite types ( `struct` s, `enum` s, and `union` s) have a _representation_ that specifies what the layout is for the type. [[layout .repr .kinds]]",
            ")\n\nThe possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()\n\n[[layout .repr .at",
            "The representation of a type can be changed by applying the `repr` attribute\nto it. The following example shows a struct with a `C` representation.",
            "ntro\")\n\nThe layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout. [[layout .guarantees]](.guarantees",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today.",
            "Type layout can be changed with each compilation. Instead of trying to document\nexactly what is done, we only document what is guaranteed today. Note that even types with the same layout can still differ in how they are passed\nacross function boundaries."
          ]
        },
        {
          "title": "The Rustonomicon - Other reprs",
          "url": "https://doc.rust-lang.org/nomicon/other-reprs.html",
          "excerpts": [
            "`repr(packed(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at most_ `n` . Most commonly used without an explicit `n` , `repr(packed)` is equivalent to `repr(packed(1))` which forces Rust to strip\nany padding, and only align the type to a byte. This may improve the memory\nfootprint, but will likely have other negative side-effects.",
            "This is the most important `repr` . It has fairly simple intent: do what C does. The order, size, and alignment of fields is exactly what you would expect from C\nor C++. The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have `repr(C)` , as C is the lingua-franca of the programming world. This is also\nnecessary to soundly do more elaborate tricks with data layout such as\nreinterpreting values as a different type. We strongly recommend using [rust-bindgen](https://rust-lang.github.io/rust-bindgen/) and/or [cbindgen](https://github.com/eqrion/cbindgen) to manage your FFI\nboundaries fo",
            "The type is also passed across `extern \"C\"` function call boundaries the\nsame way C would pass the corresponding type. Any type you expect to pass through an FFI boundary should have\n`repr(C)`, as C is the lingua-franca of the programming world.",
            "* If `T` is an [FFI-safe non-nullable pointer\n  type](ffi.html),\n  `Option<T>` is guaranteed to have the same layout and ABI as `T` and is\n  therefore also FFI-safe. As of this writing, this covers `&`, `&mut`,\n  and function pointers, all of which can never be null.",
            "`#[repr(transparent)]` can only be used on a struct or single-variant enum that has a single non-zero-sized field (there may be additional zero-sized fields). The effect is that the layout and ABI of the whole struct/enum is guaranteed to be the same as that one field.",
            "`repr(align(n))` (where `n` is a power of two) forces the type to have an\nalignment of _at least_ `n` . This enables several tricks, like making sure neighboring elements of an array\nnever share the same cache line with each other (which may speed up certain\nkinds of concurrent code). This is a modifier on `repr(C)` and `repr(Rust)` . It is incompatible with `repr(packed)` .",
            "The Rustonomicon",
            "\n# [Alternative representations]()",
            "[repr(C)]()",
            "* DST pointers (wide pointers) and tuples are not a concept\n  in C, and as such are never FFI-safe.",
            "## [repr(transparent)]()",
            "Rust allows you to specify alternative data layout strategies from the default. There's also the [unsafe code guidelines](https://rust-lang.github.io/unsafe-code-guidelines/layout.html) (note that it's **NOT** normative). ## [repr(C)]()",
            "## [repr(u\\*), repr(i\\*)]",
            "## [repr(packed), repr(packed(n))]()",
            "## [repr(align(n))]()"
          ]
        },
        {
          "title": "Rust Nomicon: repr-rust (Memory layout and ABI considerations)",
          "url": "https://doc.rust-lang.org/nomicon/repr-rust.html",
          "excerpts": [
            "Rust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)\n\nAn enum is said to be _field-less_ if none of its variants have associated data. By default, composite structures have an alignment equal to the maximum\nof their fields' alignments. Rust will consequently insert padding where\nnecessary to ensure that all fields are properly aligned and that the overall\ntype's size is a multiple of its alignment. For instance:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    b: u32,\n    c: u16,\n}\n}\n```\n```\n\nwill be 32-bit aligned on a target that aligns these primitives to their\nrespective sizes. The whole struct will therefore have a size that is a multiple\nof 32-bits. It may become:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    a: u8,\n    _pad1: [u8; 3], // to align \\`b\\`\n    b: u32,\n    c: u16,\n    _pad2: [u8; 2], // to make overall size multiple of 4\n}\n}\n```\n```\n\nor maybe:\n\n```\n```rust\n#! [allow(unused)]\nfn main() {\nstruct A {\n    b: u32,\n    c: u16,\n    a: u8,\n    _pad: u8,\n}\n}\n```\n```\n\nThere is _no indirection_ for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```rust\n#!",
            "First and foremost, all types have an alignment specified in bytes. The\nalignment of a type specifies what addresses are valid to store the value at. A\nvalue with alignment `n` must only be stored at an address that is a multiple of\n`n`. So alignment 2 means you must be stored at an even address, and 1 means\nthat you can be stored anywhere. Alignment is at least 1, and always a power\nof 2. Primitives are usually aligned to their size, although this is\nplatform-specific behavior. For example, on x86 `u64` and `f64` are often\naligned to 4 bytes (32 bits). A type's size must always be a multiple of its alignment (Zero being a valid size\nfor any alignment). This ensures that an array of that type may always be indexed\nby offsetting by a multiple of its size. Note that the size and alignment of a\ntype may not be known statically in the case of [dynamically sized types](exotic-sizes.html).\nRust gives you the following ways to lay out composite data:\n\n* structs (named product types)\n* tuples (anonymous product types)\n* arrays (homogeneous product types)\n* enums (named sum types -- tagged unions)\n* unions (untagged unions)",
            "\n\nThere is *no indirection* for these types; all data is stored within the struct,\nas you would expect in C. However with the exception of arrays (which are\ndensely packed and in-order), the layout of data is not specified by default. Given the two following struct definitions:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct A {\n    a: i32,\n    b: u64,\n}\n\nstruct B {\n    a: i32,\n    b: u64,\n}\n}\n```\n```\n\nRust *does* guarantee that two instances of A have their data laid out in\nexactly the same way. However Rust *does not* currently guarantee that an\ninstance of A has the same field ordering or padding as an instance of B. With A and B as written, this point would seem to be pedantic, but several other\nfeatures of Rust make it desirable for the language to play with data layout in\ncomplex ways. For instance, consider this struct:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nstruct Foo<T, U> {\n    count: u16,\n    data1: T,\n    data2: U,\n}\n}\n```\n```\n\nNow consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\nRust lays out the fields in the order specified, we expect it to pad the\nvalues in the struct to satisfy their alignment requirements. So if Rust\ndidn't reorder fields, we would expect it to produce the following:\n\n```\nstruct Foo<u16, u32> {\n    count: u16,\n    data1: u16,\n    data2: u32,\n}\n\nstruct Foo<u32, u16> {\n    count: u16,\n    _pad1: u16,\n    data1: u32,\n    data2: u16,\n    _pad2: u16,\n}\n```\n\nThe latter case quite simply wastes space. An optimal use of space\nrequires different monomorphizations to have *different field orderings*. Enums make this consideration even more complicated. Naively, an enum such as:\n\n```\n```\n#! [allow(unused)]\nfn main() {\nenum Foo {\n    A(u32),\n    B(u64),\n    C(u8),\n}\n}\n```\n```\n\nmight be laid out as:\n\n```\n```\n#!\n[allow(unused)]\nfn main() {\nstruct FooRepr {\n    data: u64, // this is either a u64, u32, or u8 based on `tag`\n    tag: u8,   // 0 = A, 1 = B, 2 = C\n}\n}\n```\n```\n\nAnd indeed this is approximately how it would be laid out (modulo the\nsize and position of `tag`). However there are several cases where such a representation is inefficient. The\nclassic case of this is Rust's \"null pointer optimization\": an enum consisting\nof a single outer unit variant (e.g. `None`) and a (potentially nested) non-\nnullable pointer variant (e.g. `Some(&T)`) makes the tag unnecessary. A null\npointer can safely be interpreted as the unit (`None`) variant. The net\nresult is that, for example, `size_of::<Option<&T>>() == size_of::<&T>()`. There are many types in Rust that are, or contain, non-nullable pointers such as\n`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\nnested enums pooling their tags into a single discriminant, as they are by\ndefinition known to have a limited range of valid values. In principle enums could\nuse fairly elaborate algorithms to store bits throughout nested types with\nforbidden values. As such it is *especially* desirable that\nwe leave enum layout unspecified today."
          ]
        },
        {
          "title": "Stack Overflow: Whats the difference between #[repr(Rust)], #[repr(C)] and #[repr(packed)]?",
          "url": "https://stackoverflow.com/questions/79631106/whats-the-difference-between-reprrust-reprc-and-reprpacked",
          "excerpts": [
            "In summary, `#[repr(Rust)]` leaves the representation to the compiler, which will probably do a better job of optimising the representation than you would by hand, and thus it makes the most sense to use for general use (which is why it's the default â€“ it's rare to actually write `#[repr(Rust)]` explicitly).",
            "`#[repr(C)]` exists to allow two sections of code to agree on how data should be represented even if they're compiled independently of each other; its purpose is to be a consistent representation that always stays the same.",
            "the reason is that the structure needs to always have the same layout so that the `select` function can actually access its fields (it's been compiled by the OS vendors, separately from the Rust code, so will be looking at known locations for the fields and Rust needs to put the fields in the same place)."
          ]
        },
        {
          "title": "Rust Reference: Non-exhaustive Attributes",
          "url": "https://doc.rust-lang.org/reference/attributes/type_system.html",
          "excerpts": [
            "The *`non_exhaustive` attribute* indicates that a type or variant may have\nmore fields or variants added in the future.",
            "Outside of the defining crate, types annotated with `non_exhaustive` have limitations that\npreserve backwards compatibility when new fields or variants are added.",
            "Non-exhaustive types cannot be constructed outside of the defining crate:\n\n* Non-exhaustive variants ([`struct`](../items/structs.html) or [`enum` variant](../items/enumerations.html)) cannot be constructed\n  with a [StructExpression](../expressions/struct-expr.html) (including with [functional update syntax](../expressions/struct-expr.html)). * The implicitly defined same-named constant of a [unit-like struct](../items/structs.html),\n  or the same-named constructor function of a [tuple struct](../items/structs.html),\n  has a [visibility](../visibility-and-privacy.html) no greater than `pub(crate)`",
            "There are limitations when matching on non-exhaustive types outside of the defining crate:",
            "The Rust Reference",
            "Type system attributes",
            "The `non_exhaustive` attribute",
            "It can be applied to [`struct`s](../items/structs.html), [`enum`s](../items/enumerations.html), and `enum` variants."
          ]
        },
        {
          "title": "Macros By Example - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/macros-by-example.html",
          "excerpts": [
            "The Rust Reference"
          ]
        },
        {
          "title": "Empty Source Document",
          "url": "https://doc.rust-lang.org/reference/patterns.html",
          "excerpts": [
            "**NOTE**: The provided source document is empty and does not contain any information relevant to the query about Rust's type system, algebraic data types, pattern matching, or type layout concepts.",
            "Patterns are used in:",
            "`let` declarations\n`match` expressions\n`if let` expressions\n`while let` expressions\n`for` expressions\n",
            "Patterns can be used to *destructure* [structs](items/structs.html), [enums](items/enumerations.html), and [tuples](types/tuple.html). Destructuring breaks up a value into its component pieces. The syntax used is almost the same as when creating such values.",
            "wildcard\")\n\nIn a pattern whose [scrutinee](glossary.html) expression has a `struct`, `enum` or `tuple` type, a [wildcard pattern]() (`_`) stands in for a *single* data field, whereas an [et cetera]() or [rest pattern]() (`..`) stands in for *all* the remaining fields of a particular variant."
          ]
        },
        {
          "title": "Rust Type Layout and ABI Details",
          "url": "https://doc.rust-lang.org/std/mem/fn.discriminant.html",
          "excerpts": [
            "\nIf an enum has opted-in to having a [primitive representation](../../reference/type-layout.html) for its discriminant,\nthen itâ€™s possible to use pointers to read the memory location storing the discriminant. That **cannot** be done for enums using the [default representation](../../reference/type-layout.html) , however, as itâ€™s\nundefined what layout the discriminant has and where itâ€™s stored â€” it might not even be\nstored at all!",
            "\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct {"
          ]
        },
        {
          "title": "Refutability: Whether a Pattern Might Fail to Match",
          "url": "https://doc.rust-lang.org/book/ch19-02-refutability.html",
          "excerpts": [
            "Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable."
          ]
        },
        {
          "title": "Defining an Enum - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html",
          "excerpts": [
            "This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include anotherÂ ..."
          ]
        },
        {
          "title": "std::option",
          "url": "https://doc.rust-lang.org/std/option/",
          "excerpts": [
            "Option represents an optional value: every Option is either Some and contains a value, or None, and does not. Option types are very common in Rust code."
          ]
        },
        {
          "title": "std::result",
          "url": "https://doc.rust-lang.org/std/result/",
          "excerpts": [
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n",
            "Pattern matching on [`Result`](enum.Result.html \"enum std::result::Result\") s is clear and straightforward for\nsimple cases, but [`Result`](enum.Result.html \"enum std::result::Result\") comes with some convenience methods\nthat make working with it more succinct. ```\n// The \\`is_ok\\` and \\`is_err\\` methods do what they say. let good_result: Result <i32, i32> = Ok ( 10 );\nlet bad_result: Result <i32, i32> = Err ( 10 );\nassert! (good_result.is_ok() && !good_result.is_err());\nassert! (bad_result.is_err() && !bad_result.is_ok());\n\n// \\`map\\` and \\`map_err\\` consume the \\`Result\\` and produce another.\nlet good_result: Result <i32, i32> = good_result.map(|i| i + 1 );\nlet bad_result: Result <i32, i32> = bad_result.map_err(|i| i - 1 );\nassert_eq! (good_result, Ok ( 11 ));\nassert_eq! (bad_result, Err ( 9 ));\n\n// Use \\`and_then\\` to continue the computation. let good_result: Result <bool, i32> = good_result.and_then(|i| Ok (i == 11 ));\nassert_eq! (good_result, Ok ( true ));\n\n// Use \\`or_else\\` to handle the error. let bad_result: Result <i32, i32> = bad_result.or_else(|i| Ok (i + 20 ));\nassert_eq! (bad_result, Ok ( 29 ));\n\n// Consume the result and return the contents with \\`unwrap\\`. let final_awesome_result = good_result.unwrap();\nassert!\n(final_awesome_result)\n```\n",
            "### [Â§]() Iterating over `Result`\n\nA [`Result`](enum.Result.html \"enum std::result::Result\") can be iterated over. This can be helpful if you need an\niterator that is conditionally empty.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value.",
            "Functions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable.",
            "In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](.",
            " std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides.",
            "Error handling with the `Result` type. [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") is the type used for returning and propagating\nerrors. It is an enum with the variants, [`Ok(T)`](enum.Result.html.Ok \"variant std::result::Result::Ok\") , representing\nsuccess and containing a value, and [`Err(E)`](enum.Result.html.Err \"variant std::result::Result::Err\") , representing error\nand containing an error value. ```\nenum Result <T, E> {\n   Ok (T),\n   Err (E),\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++enum+Result%3CT,+E%3E+%7B%0A+++++++Ok\\(T\\),%0A+++++++Err\\(E\\),%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\nFunctions return [`Result`](enum.Result.html \"enum std::result::Result\") whenever errors are expected and\nrecoverable. In the `std` crate, [`Result`](enum.Result.html \"enum std::result::Result\") is most prominently used\nfor [I/O](../../std/io/index.html) .\n ... \n;\n    Ok (())\n}\n```\n[](https://play.rust-lang.org/?code=%23!%5Ballow\\(unused\\)%5D%0Afn+main\\(\\)+%7B%0A++++use+std::fs::File;%0A++++use+std::io::prelude::*;%0A++++use+std::io;%0A++++%23%5Ballow\\(dead_code\\)%5D%0A++++fn+write_message\\(\\)+-%3E+io::Result%3C\\(\\)%3E+%7B%0A++++++++let+mut+file+=+File::create\\(%22valuable_data.txt%22\\)?;%0A++++++++file.write_all\\(b%22important+message%22\\)? ;%0A++++++++Ok\\(\\(\\)\\)%0A++++%7D%0A%7D&edition=2024 \"Run code\")\n\n## [Â§]() The question mark operator, `?`\n\nWhen writing code that calls many functions that return the [`Result`](enum.Result.html \"enum std::result::Result\") type, the error handling can be tedious. The question mark\noperator, [`?`](../ops/trait.Try.html \"trait std::ops::Try\") , hides some of the boilerplate of propagating errors\nup the call stack. It replaces this:\n\n```\nuse std::fs::File;\nuse std::io::prelude:: * ;\nuse std::io;\n\nstruct Info {\n    name: String,\n    age: i32,\n    rating: i32,\n}\n\nfn write_info(info: & Info) -> io::Result<()> {\n    // Early return on error\n    let mut file = match File::create( \"my_best_friends.txt\" ) {\n           Err (e) => return Err (e),\n           Ok (f) => f,\n    };\n    if let Err (e) = file.write_all( format! ( \"name: {}\\n\" , info.name).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format! ( \"age: {}\\n\" , info.age).as_bytes()) {\n        return Err (e)\n    }\n    if let Err (e) = file.write_all( format!\n ... \n[`?`](../ops/trait.Try.html \"trait std::ops::Try\") can be used in functions that return [`Result`](enum.Result.html \"enum std::result::Result\") because of the\nearly return of [`Err`](enum.Result.html.Err \"variant std::result::Result::Err\") that it provides. ## [Â§]() Representation\n\nIn some cases, [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") will gain the same size, alignment, and ABI\nguarantees as [`Option<U>`](../option/enum.Option.html \"enum std::option::Option\") has. One of either the `T` or `E` type must be a\ntype that qualifies for the `Option` [representation guarantees](../option/index.html \"Option Representation\") ,\nand the _other_ type must meet all of the following conditions:\n\n* Is a zero-sized type with alignment 1 (a â€œ1-ZSTâ€). * Has no fields. * Does not have the `#[non_exhaustive]` attribute. For example, `NonZeroI32` qualifies for the `Option` representation\nguarantees, and `()` is a zero-sized type with alignment 1, no fields, and\nit isnâ€™t `non_exhaustive` . This means that both `Result<NonZeroI32, ()>` and `Result<(), NonZeroI32>` have the same size, alignment, and ABI guarantees\nas `Option<NonZeroI32>` .\n ... \nIf the [`Result`](enum.Result.html \"enum std::result::Result\") is [`Ok`](enum.Result.html.Ok \"variant std::result::Result::Ok\") :\n\n* [`expect_err`](enum.Result.html.expect_err \"method std::result::Result::expect\\_err\") panics with a provided custom message\n* [`unwrap_err`](enum.Result.html.unwrap_err \"method std::result::Result::unwrap\\_err\") panics with a generic message\n* [`unwrap_err_unchecked`](enum.Result.html.unwrap_err_unchecked \"method std::result::Result::unwrap\\_err\\_unchecked\") produces _[undefined behavior](https://doc.rust-lang.org/reference/behavior-considered-undefined.html)_\n\n### [Â§]() Transforming contained values\n\nThese methods transform [`Result`](enum.Result.html \"enum std::result::Result\") to [`Option`](../option/enum.Option.html \"enum std::option::Option\") :\n\n* [`err`](enum.Result.html.err \"method std::result::Result::err\") transforms [`Result<T, E>`](enum.Result.html \"enum std::result::Result\") into [`Option<E>`](../option/enum.Option.html \"enum std::option::Option\") ,\n  mapping [`Err(e)`]"
          ]
        },
        {
          "title": "Never type - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/types/never.html",
          "excerpts": [
            "The never type ! is a type with no values, representing the result of computations that never complete."
          ]
        },
        {
          "title": "Type Layout - The Rust Reference",
          "url": "https://doc.rust-lang.org/reference/type-layout.html?highlight=repr",
          "excerpts": [
            "Type layout - The Rust Reference",
            "The layout of a type is its size, alignment, and the relative offsets of its\nfields. For enums, how the discriminant is laid out and interpreted is also part\nof type layout.",
            "Type layout can be changed with each compilation.",
            "All values have an alignment and size.",
            "Pointers and references have the same layout. Mutability of the pointer or\nreference does not change the layout.",
            "Pointers to sized types have the same size and alignment as `usize`.",
            "Pointers to unsized types are sized. The size and alignment is guaranteed to be\nat least equal to the size and alignment of a pointer.",
            "An array of `[T; N]` has a size of `size_of::<T>() * N` and the same alignment\nof `T`. Arrays are laid out so that the zero-based `nth` element of the array\nis offset from the start of the array by `n * size_of::<T>()` bytes.",
            "String slices are a UTF-8 representation of characters that have the same layout as slices of type `[u8]`.",
            "Tuples are laid out according to the [`Rust` representation]()",
            "The exception to this is the unit tuple (`()`), which is guaranteed as a\nzero-sized type to have a size of 0 and an alignment of 1.",
            "All user-defined composite types (`struct`s, `enum`s, and `union`s) have a\n*representation* that specifies what the layout is for the type.",
            "The possible representations for a type are:\n\n* [`Rust`]() (default)\n* [`C`]()\n* The [primitive representations]()\n* [`transparent`]()",
            "The representation of a type can be changed by applying the `repr` attribute\nto it.",
            "The alignment may be raised or lowered with the `align` and `packed` modifiers\nrespectively. They alter the representation specified in the attribute. If no representation is specified, the default one is altered.",
            "The `Rust` representation is the default representation for nominal types\nwithout a `repr` attribute. Using this representation explicitly through a\n`repr` attribute is guaranteed to be the same as omitting the attribute\nentirely.",
            "The only data layout guarantees made by this representation are those required\nfor soundness. They are:\n\n1. The fields are properly aligned. 2. The fields do not overlap. 3. The alignment of the type is at least the maximum alignment of its fields.",
            "There are no other guarantees of data layout made by this representation.",
            "The `C` representation is designed for dual purposes. One purpose is for\ncreating types that are interoperable with the C Language. The second purpose is\nto create types that you can soundly perform operations on that rely on data\nlayout such as reinterpreting values as a different type.",
            "This representation can be applied to structs, unions, and enums.\nThe exception\nis [zero-variant enums](items/enumerations.html) for which the `C` representation is an error.",
            "The alignment of the struct is the alignment of the most-aligned field in it.",
            "The size and offset of fields is determined by the following algorithm. Start with a current offset of 0 bytes. For each field in declaration order in the struct, first determine the size and\nalignment of the field. If the current offset is not a multiple of the fieldâ€™s\nalignment, then add padding bytes to the current offset until it is a multiple\nof the fieldâ€™s alignment. The offset for the field is what the current offset\nis now. Then increase the current offset by the size of the field. Finally, the size of the struct is the current offset rounded up to the nearest\nmultiple of the structâ€™s alignment.",
            "For [field-less enums](items/enumerations.html), the `C` representation has the size and alignment of\nthe default `enum` size and alignment for the target platformâ€™s C ABI.",
            "The representation of a `repr(C)` enum with fields is a `repr(C)` struct with\ntwo fields, also called a â€œtagged unionâ€ in C:",
            "The *primitive representations* are the representations with the same names as\nthe primitive integer types. That is: `u8`, `u16`, `u32`, `u64`, `u128`,\n`usize`, `i8`, `i16`, `i32`, `i64`, `i128`, and `isize",
            "Primitive representations can only be applied to enumerations and have\ndifferent behavior whether the enum has fields or no fields. It is an error\nfor [zero-variant enums](items/enumerations.html) to have a primitive representation. Combining\ntwo primitive representations together is an error.",
            "For [field-less enums](items/enumerations.html), primitive representations set the size and alignment to\nbe the same as the primitive type of the same name. For example, a field-less\nenum with a `u8` representation can only have discriminants between 0 and 255\ninclusive.",
            "The representation of a primitive representation enum is a `repr(C)` union of\n`repr(C)` structs for each variant with a field. The first field of each struct\nin the union is the primitive representation version of the enum with all fields\nremoved (â€œthe tagâ€) and the remaining fields are the fields of that variant.",
            "For enums with fields, it is also possible to combine `repr(C)` and a\nprimitive representation (e.g., `repr(C, u8)`). This modifies the [`repr(C)`]() by\nchanging the representation of the discriminant enum to the chosen primitive\ninstead. So, if you chose the `u8` representation, then the discriminant enum\nwould have a size and alignment of 1 byte.",
            "The `transparent` representation can only be used on a [`struct`](items/structs.html)\nor an [`enum`](items/enumerations.html) with a single variant that has:\n\n* any number of fields with size 0 and alignment 1 (e.g. [`PhantomData<T>`](special-types-and-traits.html)), and\n* at most one other field.",
            "Structs and enums with this representation have the same layout and ABI\nas the only non-size 0 non-alignment 1 field, if present, or unit otherwise.\nThis is different than the `C` representation because\na struct with the `C` representation will always have the ABI of a `C` `struct`\nwhile, for example, a struct with the `transparent` representation with a\nprimitive field will have the ABI of the primitive field."
          ]
        },
        {
          "title": "The Nullable Pointer Optimization",
          "url": "https://doc.rust-lang.org/nomicon/ffi.html",
          "excerpts": [
            "Certain Rust types are defined to never be `null`. This includes references (`&T`,\n`&mut T`), boxes (`Box<T>`), and function pointers (`extern \"abi\" fn()`). When\ninterfacing with C, pointers that might be `null` are often used, which would seem to\nrequire some messy `transmute`s and/or unsafe code to handle conversions to/from Rust types. However, trying to construct/work with these invalid values **is undefined behavior**,\nso you should use the following workaround instead. As a special case, an `enum` is eligible for the \"nullable pointer optimization\" if it contains\nexactly two variants, one of which contains no data and the other contains a field of one of the\nnon-nullable types listed above. This means no extra space is required for a discriminant; rather,\nthe empty variant is represented by putting a `null` value into the non-nullable field. This is\ncalled an \"optimization\", but unlike other optimizations it is guaranteed to apply to eligible\ntypes. The most common type that takes advantage of the nullable pointer optimization is `Option<T>`,\nwhere `None` corresponds to `null`. So `Option<extern \"C\" fn(c_int) -> c_int>` is a correct way\nto represent a nullable function pointer using the C ABI (corresponding to the C type\n`int (*)(int)`). Here is a contrived example.",
            "If you expect Rust `panic` s or foreign (e.g. C++) exceptions to cross an FFI\nboundary, that boundary must use the appropriate `-unwind` ABI string.",
            "extern \"C-unwind\"",
            "The `extern \"C\"` makes this function adhere to the C calling convention, as discussed below in \" [Foreign Calling Conventions](ffi.html) \". The `no_mangle` attribute turns off Rust's name mangling, so that it has a well defined symbol to link to.",
            "Foreign functions are assumed to be unsafe so calls to them need to be wrapped\nwith `unsafe {}` as a promise to the compiler that everything contained within\ntruly is safe.",
            "The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts\nlike vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe\ninternal details."
          ]
        },
        {
          "title": "Enums and Pattern Matching - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch06-00-enums.html",
          "excerpts": [
            "Enums and Pattern Matching",
            "tching]()\n\nIn this chapter, weâ€™ll look at _enumerations_ , also referred to as _enums_ . Enums allow you to define a type by enumerating its possible _variants_ . First\nweâ€™ll define and use an enum to show how an enum can encode meaning along with\ndata. Next, weâ€™ll explore a particularly useful enum, called `Option` , which\nexpresses that a value can be either something or nothing. Then weâ€™ll look at\nhow pattern matching in the `match` expression makes it easy to run different\ncode for different values of an enum. Finally, weâ€™ll cover how the `if let` construct is another convenient and concise idiom available to handle enums in\nyour code."
          ]
        },
        {
          "title": "Match ergonomics reservations - The Rust Edition Guide",
          "url": "https://doc.rust-lang.org/edition-guide/rust-2024/match-ergonomics.html",
          "excerpts": [
            "Match ergonomics reservations - The Rust Edition Guide",
            "Within `match`, `let`, and other constructs, we match a *pattern* against a *scrutinee*. E.g. :",
            "Such a pattern is called fully explicit because it does not elide (i.e. \"skip\" or \"pass\") any references within the scrutinee.",
            "By contrast, this otherwise-equivalent pattern is not fully explicit:",
            "Patterns such as this are said to be using match ergonomics, originally introduced in [RFC 2005](https://github.com/rust-lang/rfcs/pull/2005). Under match ergonomics, as we incrementally match a pattern against a scrutinee, we keep track of the default binding mode. This mode can be one of `move`, `ref mut`, or `ref`, and it starts as `move`. When we reach a binding, unless an explicit binding mode is provided, the default binding mode is used to decide the binding's type.",
            "### [`mut` restriction]()",
            "Here, because we pass the shared reference in the pattern, the default binding mode switches to `ref`.",
            "But then, in these editions, writing `mut` on the binding resets the default binding mode to `move`. This can be surprising as it's not intuitive that mutability should affect the type. To leave space to fix this, in Rust 2024 it's an error to write `mut` on a binding when the default binding mode is not `move`. That is, `mut` can only be written on a binding when the pattern (leading up to that binding) is fully explicit.",
            "### [`ref` / `ref mut` restriction]()",
            "In Rust 2021 and earlier editions, we allow:",
            "Here, the `ref` explicit binding mode is redundant, as by passing the shared reference (i.e. not mentioning it in the pattern), the binding mode switches to `ref`.",
            "To leave space for other language possibilities, we are disallowing explicit binding modes where they are redundant in Rust 2024.",
            "### [Reference patterns restriction]()",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "In Rust 2021 and earlier editions, we allow this oddity:",
            "Here, the `&` in the pattern both matches against the reference on `&()` and resets the default binding mode to `move`.",
            "This can be surprising because the single `&` in the pattern causes a larger than expected change in the type by removing both layers of references. To leave space to fix this, in Rust 2024 it's an error to write `&` or `&mut` in the pattern when the default binding mode is not `move`. That is, `&` or `&mut` can only be written when the pattern (leading up to that point) is fully explicit.",
            "The [`rust_2024_incompatible_pat`](../../rustc/lints/listing/allowed-by-default.html) lint flags patterns that are not allowed in Rust 2024. This lint is part of the `rust-2024-compatibility` lint group which is automatically applied when running `cargo fix --edition`. This lint will automatically convert affected patterns to fully explicit patterns that work correctly in Rust 2024 and in all prior editions. To migrate your code to be compatible with Rust 2024, run:",
            "```\ncargo fix --edition\n```"
          ]
        },
        {
          "title": "Pattern Syntax - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch19-03-pattern-syntax.html",
          "excerpts": [
            "In this section, we gather all the syntax that is valid in patterns and discuss\nwhy and when you might want to use each one. ### [Matching Literals]()",
            "fn main() {\n    let x = 1;\n\n    match x {\n        1 => println! (\"one\"),\n        2 => println! (\"two\"),\n        3 => println! (\"three\"),\n        _ => println! (\"anything\"),\n    }\n}",
            "Named variables are irrefutable patterns that match any value, and weâ€™ve used\nthem many times in this book. However, there is a complication when you use\nnamed variables in `match`, `if let`, or `while let` expressions. Because each\nof these kinds of expression starts a new scope, variables declared as part of a\npattern inside the expression will shadow those with the same name outside, as\nis the case with all variables.\nIn Listing 19-11, we declare a variable named\n`x` with the value `Some(5)` and a variable `y` with the value `10`. We then\ncreate a `match` expression on the value `x`. Look at the patterns in the match\narms and `println!` at the end, and try to figure out what the code will print\nbefore running this code or reading further. Filename: src/main.rs",
            "fn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) => println! (\"Got 50\"),\n        Some(y) => println! (\"Matched, y = {y}\"),\n        _ => println! (\"Default case, x = {x:? }\"),\n    }\n\n    println! (\"at the end: x = {x:? }, y = {y}\");\n}",
            "[Listing 19-11](): A `match` expression with an arm that introduces a new variable which shadows an existing variable `y`",
            "Similarly, the second arm matches any point on the `y` axis by specifying that\nthe `x` field matches if its value is `0` and creates a variable `y` for the\nvalue of the `y` field. The third arm doesnâ€™t specify any literals, so it\nmatches any other `Point` and creates variables for both the `x` and `y` fields. In this example, the value `p` matches the second arm by virtue of `x`\ncontaining a `0`, so this code will print `On the y axis at 7`. Remember that a `match` expression stops checking arms once it has found the\nfirst matching pattern, so even though `Point { x: 0, y: 0}` is on the `x` axis\nand the `y` axis, this code would only print `On the x axis at 0`.",
            "Weâ€™ve destructured enums in this book (for example, Listing 6-5), but we havenâ€™t\nyet explicitly discussed that the pattern to destructure an enum corresponds to\nthe way the data stored within the enum is defined. As an example, in Listing\n19-15 we use the `Message` enum from Listing 6-2 and write a `match` with\npatterns that will destructure each inner value. Filename: src/main.rs",
            "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit => {\n            println! (\"The Quit variant has no data to destructure. \");\n        }\n        Message::Move { x, y } => {\n            println!\n(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) => {\n            println! (\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) => {\n            println! (\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n    }\n}",
            "[Listing 19-15](): Destructuring enum variants that hold different kinds of values",
            "This code will print `Change color to red 0, green 160, and blue 255`. Try\nchanging the value of `msg` to see the code from the other arms run. For enum variants without any data, like `Message::Quit`, we canâ€™t destructure\nthe value any further. We can only match on the literal `Message::Quit` value,\nand no variables are in that pattern. For struct-like enum variants, such as `Message::Move`, we can use a pattern\nsimilar to the pattern we specify to match structs. After the variant name, we\nplace curly brackets and then list the fields with variables so we break apart\nthe pieces to use in the code for this arm. Here we use the shorthand form as\nwe did in Listing 19-13. For tuple-like enum variants, like `Message::Write` that holds a tuple with one\nelement and `Message::ChangeColor` that holds a tuple with three elements, the\npattern is similar to the pattern we specify to match tuples. The number of\nvariables in the pattern must match the number of elements in the variant weâ€™re\nmatching.",
            "The condition can use variables created in the pattern. Listing 19-26 shows a\n`match` where the first arm has the pattern `Some(x)` and also has a match\nguard of `if x % 2 == 0` (which will be `true` if the number is even).",
            "fn main() {\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 => println! (\"The number {x} is even\"),\n        Some(x) => println! (\"The number {x} is odd\"),\n        None => (),\n    }\n}",
            "[Listing 19-26](): Adding a match guard to a pattern",
            "This example will print `The number 4 is even`. When `num` is compared to the\npattern in the first arm, it matches because `Some(4)` matches `Some(x)`. Then\nthe match guard checks whether the remainder of dividing `x` by 2 is equal to\n0, and because it is, the first arm is selected. If `num` had been `Some(5)` instead, the match guard in the first arm would\nhave been `false` because the remainder of 5 divided by 2 is 1, which is not\nequal to 0. Rust would then go to the second arm, which would match because the\nsecond arm doesnâ€™t have a match guard and therefore matches any `Some` variant. There is no way to express the `if x % 2 == 0` condition within a pattern, so\nthe match guard gives us the ability to express this logic. The downside of\nthis additional expressiveness is that the compiler doesnâ€™t try to check for\nexhaustiveness when match guard expressions are involved. In Listing 19-11, we mentioned that we could use match guards to solve our\npattern-shadowing problem.",
            " #### [Destructuring Enums]"
          ]
        },
        {
          "title": "Option in std",
          "url": "https://doc.rust-lang.org/std/option/enum.Option.html",
          "excerpts": [
            "The map method takes the self argument by value, consuming the original, so this technique uses as_ref to first take an Option to a reference to the valueÂ ... Computes a default function result (if none), or applies a different function to the contained value (if any). Â§Basic examples. let k = 21; let x = Some(\"foo\"); ...",
            "Returns the contained [`Some`](enum.Option.html.Some \"variant std::option::Option::Some\") value, consuming the `self` value. Because this function may panic, its use is generally discouraged. Panics are meant for unrecoverable errors, and\n[may abort the entire program](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html).",
            "[the `?` (try) operator](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)."
          ]
        },
        {
          "title": "Result in std",
          "url": "https://doc.rust-lang.org/beta/std/result/enum.Result.html",
          "excerpts": [
            "Returns true if the result is Err and the value inside of it matches a predicate. Â§Examples. use std::io::{Error, ErrorKind}; let x: Result<u32, Error> ..."
          ]
        },
        {
          "title": "Error handling - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/error.html",
          "excerpts": [
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input would ... Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ...",
            "Error handling is the process of handling the possibility of failure. For example, failing to read a file and then continuing to use that bad input wouldÂ ... When there is a chance that things do go wrong and the caller has to deal with the problem, use Result . You can unwrap and expect them as well (please don't do ..."
          ]
        },
        {
          "title": "Recoverable Errors with Result - The Rust Programming Language",
          "url": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
          "excerpts": [
            "he `Result` enum is defined as having two\nvariants, `Ok` and `Err` , as follows:",
            "```rust",
            "\n#! [allow(unused)]",
            "fn main() {",
            "enum Result<T, E> {",
            "    Ok(T),",
            "    Err(E)",
            "The `?` operator eliminates a lot of boilerplate and makes this functionâ€™s\nimplementation simpler.",
            "```",
            "}",
            "}"
          ]
        },
        {
          "title": "Configuring Rustfmt",
          "url": "https://rust-lang.github.io/rustfmt/",
          "excerpts": [
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "```rust",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "fn main() {",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "```",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}",
            "}"
          ]
        },
        {
          "title": "std::collections::vec_deque",
          "url": "https://doc.rust-lang.org/std/collections/vec_deque/index.html",
          "excerpts": [
            "A double-ended queue (deque) implemented with a growable ring buffer. This queue has O(1) amortized inserts and removals from both ends of the container."
          ]
        },
        {
          "title": "`smallvec-handle`: a faster small vector implementation?",
          "url": "https://www.reddit.com/r/rust/comments/1i5d856/smallvechandle_a_faster_small_vector/",
          "excerpts": [
            "How it works? Small vector optimization usually means storing items inline (without allocation) until a given (small) capacity. However, unlike ..."
          ]
        },
        {
          "title": "Vec - Rust",
          "url": "https://doc.rust-lang.org/std/vec/struct.Vec.html",
          "excerpts": [
            "Emptying a `Vec` and then filling it back up to the same [`len`](struct.Vec.html.len \"method std::vec::Vec::len\") should incur no calls to\nthe allocator. If you wish to free up unused memory, use [`shrink_to_fit`](struct.Vec.html.shrink_to_fit \"method std::vec::Vec::shrink\\_to\\_fit\") or [`shrink_to`](struct.Vec.html.shrink_to \"method std::vec::Vec::shrink\\_to\") . [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") will never (re)allocate if the reported capacity is\nsufficient. [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") and [`insert`](struct.Vec.html.insert \"method std::vec::Vec::insert\") _will_ (re)allocate if `len == capacity` . That is, the reported capacity is completely\naccurate, and can be relied on. It can even be used to manually free the memory\nallocated by a `Vec` if desired. Bulk insertion methods _may_ reallocate, even\nwhen not necessary. `Vec` does not guarantee any particular growth strategy when reallocating\nwhen full, nor when [`reserve`](struct.Vec.html.reserve \"method std::vec::Vec::reserve\") is called. The current strategy is basic\nand it may prove desirable to use a non-constant growth factor. Whatever\nstrategy is used will of course guarantee _O_ (1) amortized [`push`](struct.Vec.html.push \"method std::vec::Vec::push\") . It is guaranteed, in order to respect the intentions of the programmer, that\nall of `vec! [e_1, e_2, ..., e_n]` , `ve"
          ]
        },
        {
          "title": "Rust Standard Library Collections - Performance",
          "url": "https://doc.rust-lang.org/std/collections/index.html",
          "excerpts": [
            "\n### [Â§]()Cost of Collection Operations\n\n|  | get(i) | insert(i) | remove(i) | append(Vec(m)) | split\\_off(i) | range | append |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") | *O*(1) | *O*(*n*-*i*)\\* | *O*(*n*-*i*) | *O*(*m*)\\* | *O*(*n*-*i*) | N/A | N/A |\n| [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") | *O*(1) | *O*(min(*i*, *n*-*i*))\\* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)\\* | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\") | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*)) | *O*(1) | *O*(min(*i*, *n*-*i*)) | N/A | N/A |\n| [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") | *O*(1)~ | *O*(1)~\\* | *O*(1)~ | N/A | N/A | N/A | N/A |\n| [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\") | *O*(log(*n*)) | *O*(log(*n*)) | *O*(log(*n*)) | N/A | N/A | *O*(log(*n*)) | *O*(*n*+*m*) |\n\nNote that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\").",
            "Note that where ties occur, [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\") is generally going to be faster than\n[`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), and [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\") is generally going to be faster than\n[`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\"). For Sets, all operations have the cost of the equivalent Map operation.",
            "Many collections provide several constructors and methods that refer to\nâ€œcapacityâ€. These collections are generally built on top of an array. Optimally, this array would be exactly the right size to fit only the\nelements stored in the collection, but for the collection to do this would\nbe very inefficient. If the backing array was exactly the right size at all\ntimes, then every time an element is inserted, the collection would have to\ngrow the array to fit it. Due to the way memory is allocated and managed on\nmost computers, this would almost surely require allocating an entirely new\narray and copying every single element from the old one into the new one. Hopefully you can see that this wouldnâ€™t be very efficient to do on every\noperation. Most collections therefore use an *amortized* allocation strategy. They\ngenerally let themselves have a fair amount of unoccupied space so that they\nonly have to grow on occasion.",
            "Rustâ€™s collections can be grouped into four major categories:\n\n* Sequences: [`Vec`](../vec/struct.Vec.html \"struct std::vec::Vec\"), [`VecDeque`](struct.VecDeque.html \"struct std::collections::VecDeque\"), [`LinkedList`](struct.LinkedList.html \"struct std::collections::LinkedList\")\n* Maps: [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\"), [`BTreeMap`](struct.BTreeMap.html \"struct std::collections::BTreeMap\")\n* Sets: [`HashSet`](struct.HashSet.html \"struct std::collections::HashSet\"), [`BTreeSet`](struct.BTreeSet.html \"struct std::collections::BTreeSet\")\n* Misc: [`BinaryHeap`](struct.BinaryHeap.html \"struct std::collections::BinaryHeap\")",
            "Choosing the right collection for the job requires an understanding of what\neach collection is good at. Here we briefly summarize the performance of\ndifferent collections for certain important operations. For further details,\nsee each typeâ€™s documentation, and note that the names of actual methods may\ndiffer from the tables below on certain collections. Throughout the documentation, we will adhere to the following conventions\nfor operation notation:",
            "The collectionâ€™s size is denoted by `n`. * If a second collection is involved, its size is denoted by `m`. * Item indices are denoted by `i`. * Operations which have an *amortized* cost are suffixed with a `*`. * Operations with an *expected* cost are suffixed with a `~`. Calling operations that add to a collection will occasionally require a\ncollection to be resized - an extra operation that takes *O*(*n*) time.\n*Amortized* costs are calculated to account for the time cost of such resize\noperations *over a sufficiently large series of operations*. An individual\noperation may be slower or faster due to the sporadic nature of collection\nresizing, however the average cost per operation will approach the amortized\ncost. Rustâ€™s collections never automatically shrink, so removal operations arenâ€™t\namortized. [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") uses *expected* costs. It is theoretically possible, though very\nunlikely, for [`HashMap`](struct.HashMap.html \"struct std::collections::HashMap\") to experience significantly worse performance than\nthe expected cost. This is due to the probabilistic nature of hashing - i.e. it is possible to generate a duplicate hash given some input key that will\nrequires extra computation to correct."
          ]
        },
        {
          "title": "Swisstable, a Quick and Dirty Description - Faultlore",
          "url": "https://faultlore.com/blah/hashbrown-tldr/",
          "excerpts": [
            "Swisstable, a Quick and Dirty Description",
            "Ok hereâ€™s how to implement Swisstable as simply as possible, with a bunch of random notes. Iâ€™m assuming youâ€™re familiar with the basics of an open-addressing hashmap implementation, and will be skipping over all those details. If you want to brush up on those issues, you can read my primer on [the old Rust Robin Hood implementation](https://gankra.github.io/blah/robinhood-part-1/). High level concepts to keep in mind:\n\n* open-addressing\n* searches in parallel using SIMD\n* first-come-first-serve collision resolution\n* chunked (SIMD) triangular (quadratic-ish) probing\n* tombstones to avoid backshifts",
            "Bit fiddling tricks will be omitted because theyâ€™re not that interesting, and I made sure they were really well documented [in hashbrown](https://github.com/rust-lang/hashbrown/tree/master/src/raw) (the Rust impl), so you can just crib the implementations from there (seriously, itâ€™s only 100 lines of code, mostly comments). So if I ever say â€œdo X in parallel (func\\_name)â€ thatâ€™s your cue to check the parallel bit tricks implementation for func\\_name and its detailed documentatio"
          ]
        },
        {
          "title": "Rust HashMap Documentation",
          "url": "https://doc.rust-lang.org/std/collections/struct.HashMap.html",
          "excerpts": [
            "A [hash map](index.html \"mod std::collections\") implemented with quadratic probing and SIMD lookup.",
            "By default, `HashMap` uses a hashing algorithm selected to provide\nresistance against HashDoS attacks.",
            "The hash table implementation is a Rust port of Googleâ€™s [SwissTable](https://abseil.io/blog/20180927-swisstables) .",
            "It is also a logic error for a key to be modified in such a way that the keyâ€™s\nhash, as determined by the [`Hash`](../hash/trait.Hash.html \"trait std::hash::Hash\") trait, or its equality, as determined by\nthe [`Eq`](../cmp/trait.Eq.html \"trait std::cmp::Eq\") trait, changes while it is in the map.",
            "The behavior resulting from either logic error is not specified, but will\nbe encapsulated to the `HashMap` that observed the logic error and not\nresult in undefined behavior. This could include panics, incorrect results,\naborts, memory leaks, and non-termination."
          ]
        },
        {
          "title": "indexmap-rs GitHub Repository",
          "url": "https://github.com/indexmap-rs/indexmap",
          "excerpts": [
            "This was inspired by Python 3.6's new dict implementation (which remembers\nthe insertion order and is fast to iterate, and is compact in memory). Some of those features were translated to Rust, and some were not. The result\nwas indexmap, a hash table that has following properties:\n\n* Order is **independent of hash function** and hash values of keys. * Fast to iterate. * Indexed in compact space. * Preserves insertion order **as long** as you don't call `.remove()` , `.swap_remove()` , or other methods that explicitly change order. The alternate `.shift_remove()` does preserve relative order. * Uses hashbrown for the inner table, just like Rust's libstd `HashMap` does. ## Performance\n\n[]()\n\n`IndexMap` derives a couple of performance facts directly from how it is constructed,\nwhich is roughly:\n\n> A raw hash table of key-value indices, and a vector of key-value pairs. * \n  Iteration is very fast since it is on the dense key-values. * \n  Removal is fast since it moves memory areas only in the table,\n  and uses a single swap in the vector."
          ]
        },
        {
          "title": "A HashMap in Rust - What's a HashMap? - Faultlore",
          "url": "https://faultlore.com/blah/robinhood-part-1/",
          "excerpts": [
            "A HashMap in Rust: What's a HashMap?",
            "This article is really old! Rust has since moved on to SwissTable (hashbrown), which I describe [in this article](../hashbrown-tldr/). That said, this article is still useful because it mostly discusses issues fundamental to any HashMap design.",
            "In contrast to the [previous](../rust-btree-case/) post, which dove into Rustâ€™s BTreeMap and the idea of B-Trees in general, this post will be split up into two posts. In this post we will take a look at the general problems faced by hashtables, as well as the robin hood hashtable scheme. In the next post, we will take a high-to-mid-level look at Rustâ€™s standard HashMap implementation (surprise, itâ€™s a robin hood hashtable), and what it does to be safe and fast.",
            "We hash ~ alpha\\*n elements into a table of size n where each probe is independent and uniformly distributed over the table, and alpha < 1 is a constant. Let M be the maximum search time for any of the elements in the table. We show that with probability tending to one, M is in [log2log n + a, log2log n + b] for some constants *a* and *b* depending upon alpha only. This is an exponential improvement over the maximum search time in case of the standard FCFS collision strategy. So the expected worst-case search time is O(loglog n) if we have at most some constant load factor",
            "For all intents and purposes, weâ€™ve got constant-time searches.",
            "For performance and simplicity, I recommend a robinhood hashmap, which enjoys O(1) expected time per query without the need for chaining.",
            "For security, I recommend SipHash 2-4 as a reasonable *default* hashing algorithm, with some way to override the default for performance."
          ]
        },
        {
          "title": "bitvec - Rust",
          "url": "https://docs.rs/bitvec/latest/bitvec/",
          "excerpts": [
            "bitvec - Rust",
            "bitvec` provides a foundational API for bitfields in Rust. It specializes\nstandard-library data structures (slices, arrays, and vectors of `bool` ) to use\none-bit-per- `bool` storage, similar to [`std::bitset<N>`](https://en.cppreference.com/w/cpp/utility/bitset) and [`std::vector<bool>`](https://en.cppreference.com/w/cpp/container/vector_bool) in C++",
            "If you need to view memory as bit-addressed instead of byte-addressed, then `bitvec` is the fastest, most complete, and Rust-idiomatic crate for you.",
            "It leverages Rustâ€™s\npowerful reference and type systems to create a system that seamlessly bridges\nsingle-bit addressing, precise control of in-memory layout, and Rust-native\nownership and borrowing mechanisms.",
            "Type parameters enable users to select the precise memory representation they\n  desir",
            "A memory model accounts for element-level aliasing and is safe for concurrent\n  us",
            "`BitSlice` cannot be used as a referent type in pointers, such as `Box` , `Rc` ,\n  or `Arc`",
            "`BitSlice` cannot implement `IndexMut` , so `bitslice[index] = true;` does not\n  wor",
            "Minimum Supported Rust Version** : 1.56",
            "Note: `bitvec` supports `#! [no_std]` targets. If you do not have `std` ,\n> disable the default features, and explicitly restore any features that you do\n> h",
            "use type aliases to make names for specific\ninstantiations of `bitvec` type parameters, and use that rather than attempting\nto remain generic over an `<T: BitStore, O: BitOrder>` pair throughout your\nproject.",
            "All data-types have macro\n// constructo",
            "Bit-slices can split anywhere.",
            "the presence of a\ndynamic allocator enables the `BitBox` and `BitVec` buffer types, which can be\nused for more advanced buffer manipulation:",
            "While place expressions like `bits[index] = value;` are not available, `bitvec` instead provides a proxy structure that can be used as _nearly_ an `&mut bit` reference:",
            "The `bitvec` data types implement a complete replacement for their\nstandard-library counterparts, including all of the inherent methods, traits,\nand operator behaviors.",
            "Uses of `bitvec` generally fall into three major genres. * compact, fast, `usize => bit` collections\n* truncated integer storage\n* precise control of memory layout",
            "If your bit-field storage buffers are never serialized for exchange between\nmachines, then you can get away with using the default type parameters and\nunadorned load/store methods.",
            "Many protocols use sub-element fields in order to save space in transport; for\nexample, TCP headers have single-bit and 4-bit fields in order to pack all the\nneeded information into a desirable amount of space.",
            "When using `bitvec` to manage protocol buffers, you will need to select the\nexact type parameters that match your memory layout. For instance, TCP uses `<u8, Msb0>` , while IPv6 on a little-endian machine uses `<u32, Lsb0>` .",
            "`bitvec` has a few Cargo features that govern its API surface. The default\nfeature set is:",
            "`alloc` : This links against the `alloc` distribution crate, and provides the `BitVec` and `BitBox` types. It can be used on `#! [no_std]` targets that\n  possess a dynamic allocator but not an operating syste",
            "`atomic` : This controls whether atomic instructions can be used for aliased\n  memor",
            "`serde` : This enables the de/serialization of `bitvec` buffers through the `serde` system. This can be useful if you need to transmit `usize => bool` collections.",
            "`std` : This provides some `std::io::{Read,Write}` implementations, as well as `std::error::Error` for the various error types. It is otherwise unnecessary.",
            "bitvec/latest/bitvec) explores `bitvec` â€™s usage and implementation in\ngreat detail. In particular, you should read the documentation for the [`order`](https://docs.rs/bitvec/latest/bitvec/order/index.html) , [`store`](https://docs.rs/bitvec/latest/bitvec/store/index.html) , and [`field`](https://docs.rs/bitvec/latest/bitvec/field/index.html) modules, as well as the [`BitSlice`](https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html) and [`BitArray`](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) types.",
            "In addition, the [user guide](https://bitvecto-rs.github.io/bitvec/) explores the philosophical and academic\nconcepts behind `bitvec` â€™s construction, its goals, and the more intricate parts\nof its behavior."
          ]
        },
        {
          "title": "SmallVec::spilled() causing performance overhead on Reddit",
          "url": "https://www.reddit.com/r/rust/comments/1g8o9a6/smallvecspilled_causing_performance_overhead/",
          "excerpts": [
            "I am the author of the [markov\\_str](https://github.com/Brogolem35/markov_str) library and I am trying out the [smallvec](https://github.com/servo/rust-smallvec/tree/v1) to speed up the training of my Markov Chains",
            "But I have encountered this issue while benchmarking with [cargo flamegraph](https://github.com/flamegraph-rs/flamegraph): equivalance checks between `SmallVec`s take too long and almost all the time is spent on `spilled()`.",
            "}\n```\n\nSmallVec struct:\n\n```\npub struct SmallVec<A: Array> {\n    // The capacity field is used to determine which of the storage variants is active:\n    // If capacity <= Self::inline_capacity() then the inline variant is used and capacity holds the current length of the vector (number of elements actually in use)."
          ]
        },
        {
          "title": "VecDeque in std::collections - Rust",
          "url": "https://doc.rust-lang.org/std/collections/struct.VecDeque.html",
          "excerpts": [
            "A double-ended queue implemented with a growable ring buffer. The â€œdefaultâ€ usage of this type as a queue is to use push_back to add to the queue, and ..."
          ]
        },
        {
          "title": "BinaryHeap in std::collections",
          "url": "https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html",
          "excerpts": [
            "The time complexity degrades if elements are pushed in predominantly ascending order. In the worst case, elements are pushed in ascending sorted order and theÂ ..."
          ]
        },
        {
          "title": "std::collections::binary_heap",
          "url": "https://doc.rust-lang.org/std/collections/binary_heap/index.html",
          "excerpts": [
            "Converting a vector to a binary heap can be done in-place, and has O(n) complexity. A binary heap can also be converted to a sorted vector in-place, allowing itÂ ..."
          ]
        },
        {
          "title": "RawVec growth strategy can be more efficient #111307",
          "url": "https://github.com/rust-lang/rust/issues/111307",
          "excerpts": [
            "May 6, 2023 â€” Currently, the RawVec implementation tries to double its internal capacity every time it has to grow, as can be seen in:Â ..."
          ]
        },
        {
          "title": "ahash - Rust",
          "url": "https://rust-lang.github.io/hashbrown/ahash/index.html",
          "excerpts": [
            "How aHash works. aHash uses the hardware AES instruction on x86 processors to provide a keyed hash function. aHash is not a cryptographically secure hash."
          ]
        },
        {
          "title": "aHash is a non-cryptographic hashing algorithm that uses ...",
          "url": "https://github.com/tkaitchuck/aHash",
          "excerpts": [
            "AHash is the fastest, DOS resistant hash currently available in Rust. AHash is intended exclusively for use in in-memory hashmaps."
          ]
        },
        {
          "title": "Noteworthy concurrent data structures? : r/rust",
          "url": "https://www.reddit.com/r/rust/comments/myiokh/noteworthy_concurrent_data_structures/",
          "excerpts": [
            "Here are some crates with useful concurrent data structures: crossbeam. flume. parking_lot. dashmap/evmap/chashmap. arc-swap. atomic-take."
          ]
        },
        {
          "title": "How Go 1.24's Swiss Tables saved us hundreds of gigabytes",
          "url": "https://www.datadoghq.com/blog/engineering/go-swiss-tables/",
          "excerpts": [
            "Higher load factor: Swiss Tables support a higher load factor of 87.5% (versus 81.25% in Go 1.23), requiring fewer total slots. Elimination ..."
          ]
        },
        {
          "title": "SwissMap: A smaller, faster Golang Hash Table",
          "url": "https://dolthub.com/blog/2023-03-28-swiss-map/",
          "excerpts": [
            "SwissMap supports a higher maximum load factor (87.5%) than the built-in map (81.25%), but this difference alone doesn't tell the whole story."
          ]
        },
        {
          "title": "Why does vec allocate new memory and copy values when growing? - The Rust Programming Language Forum",
          "url": "https://users.rust-lang.org/t/why-does-vec-allocate-new-memory-and-copy-values-when-growing/45291",
          "excerpts": [
            "Vectors don't resize every time you call `insert` , they typically allocate extra space so subsequent insertions can be handled without re-allocating and usually they vary the extra space requested as the size of the vector increases. A common pattern is to allocate `2 * current capacity` on re-allocation.",
            "Note that the _exponential_ growth is important. On each reallocation, we have to copy twice as much, but then it takes twice as long to fill up again. These factors cancel out and we get (on average) constant-time `.push()` .",
            "The API of Vec doesn't change at all because of this optimization, and the overall strategy remains the same - double the size, (possibly) reallocating, every time more space is needed.",
            "Vectors fit both of those requirements very well while still being conceptually simple to understand (a useful quality in a common collection type).",
            " In Rust, you can do this by calling `Vec::with_capacity(size)` instead of `Vec::new()`"
          ]
        },
        {
          "title": "evmap crate page (crates.io) - Rust Package Registry",
          "url": "https://crates.io/crates/evmap/5.0.2",
          "excerpts": [
            "A lock-free, eventually consistent, concurrent multi-value map. evmap - crates.io: Rust Package Registry",
            "Reads never take locks on their critical path, and neither\ndo writes assuming there is a single writer (multi-writer is possible using a `Mutex`), which\nsignificantly improves performance under contention.",
            "The map is multi-value, meaning that every key maps to a *collection* of values. This\nintroduces some memory cost by adding a layer of indirection through a `Vec` for each value,\nbut enables more advanced use.",
            "The benchmark\nmeasures the average number of reads and writes per second as the number of\nreaders and writers increases.",
            "results show that `evmap` performs well under contention,\nespecially on the read side. This benchmar",
            "Metadata",
            "pkg:cargo/evmap@5.0.2",
            "Small Vector Optimization",
            "Small Vector Optimization",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`.",
            "By default, the value-set for each key in the map uses the `smallvec` crate to keep a\nmaximum of one element stored inline with the map, as opposed to separately heap-allocated\nwith a plain `Vec`."
          ]
        },
        {
          "title": "expect-test - Crates.io (Rust snapshot testing library)",
          "url": "https://crates.io/crates/expect-test",
          "excerpts": [
            "Metadata"
          ]
        },
        {
          "title": "How does Rust allocate more space for a vector?",
          "url": "https://stackoverflow.com/questions/62685440/how-does-rust-allocate-more-space-for-a-vector",
          "excerpts": [
            "The current strategy is to double the capacity when it must be increased. However, there is a special case: Vec::new() doesn't allocate, but pushing an element ..."
          ]
        },
        {
          "title": "Choosing the Right Rust Collection: A Performance Deep Dive",
          "url": "https://medium.com/@ali-alachkar/choosing-the-right-rust-collection-a-performance-deep-dive-7fc66f3fbdd9",
          "excerpts": [
            "### Vec:\n\n* **Underlying structure:** Contiguous array that can grow.\n* **Time complexities:**\n\n> Indexing: *O(1)*\n>\n> Push at end: Amortized *O(1)*\n>\n> Insert/remove at arbitrary pos: *O(n)*\n\n* **Memory:** Minimal overhead; stores elements ",
            "LinkedList:**\n\n* **Underlying structure:** Doublyâ€‘linked list of heapâ€‘allocated nodes\n* **Time complexities:**\n\n> Insert/remove at known node (via cursor): *O(1)*\n>\n> Push/pop front or back: *O(1)*\n>\n> Indexing/traversal: *O(n)*\n\n* **Memory:** One heap allocation per element + two poin",
            "Rustâ€™s standard library provides a rich set of collection types, each tailored to different useâ€‘cases and performance characteristics.",
            "VecDeque:**\n\n* **Underlying structure:** Grow-able ring buffer of fixedâ€‘size blocks\n* **Time complexities:**\n\n> Push/pop front or back: Amortized *O(1)*\n>\n> Indexing: *O(1)* (slightly slower constant factor)\n>\n> Insert/remove in middle: *O(n)*\n\n* **Memory:** Slight overhead for ring buffer metadata and block poin",
            "### HashMap:\n\n* **Underlying structure:** Hash table with open addressing (or bucketed chaining)\n* **Time complexities:**\n\n> Insert/remove/lookup: Amortized *O(1)*\n>\n> Worstâ€‘case (pathological hash collisions): *O(n)*\n\n* **Memory:** Higher overhead due to buckets and occasionally resi",
            "\n### **BTreeMap:**\n\n* **Underlying structure:** Balanced Bâ€‘tree of sorted keyâ€“value pairs\n* **Time complexities:**\n\n> Insert/remove/lookup: *O(log n)*\n\n* **Memory:** Lower perâ€‘element overhead vs. `HashMap` (no hashing), but tree nodes incur pointers",
            "-------\n\n* **Underlying structure:** Binary maxâ€‘heap in a `Vec`\n* **Time complexities:**\n\n> Push/pop: *O(log n)*\n>\n> Peek max: *O(1)*\n\n* **Memory:** Similar footprint to `Vec` plus heap invariant"
          ]
        },
        {
          "title": "std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/index.html",
          "excerpts": [
            "The heart and soul of this module is the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") trait. The core of [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") looks like this:\n\n```\ntrait Iterator {\n    type Item;\n    fn next( &mut self ) -> Option < Self ::Item>;\n}\n```\n",
            "Iterators are also composable, and itâ€™s common to chain them together to do\nmore complex forms of processing. See the [Adapters]() section\nbelow for more details.\n",
            "Iterators (and iterator [adapters]() ) are _lazy_ . This means that\njust creating an iterator doesnâ€™t _do_ a whole lot. Nothing really happens\nuntil you call [`next`](trait.Iterator.html.next \"method std::iter::Iterator::next\") .",
            "Common iterator adapters include [`map`](trait.Iterator.html.map \"method std::iter::Iterator::map\") , [`take`](trait.Iterator.html.take \"method std::iter::Iterator::take\") , and [`filter`](trait.Iterator.html.filter \"method std::iter::Iterator::filter\") .\nFor more, see their documentation.\n"
          ]
        },
        {
          "title": "DoubleEndedIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html",
          "excerpts": [
            "pub trait DoubleEndedIterator: Iterator {",
            "    // Required method",
            "    fn next_back (&mut self) -> Option <Self:: Item >;",
            "    // Provided methods",
            "    fn advance_back_by (&mut self, n: usize ) -> Result < () , NonZero < usize >> { ... }",
            "    fn nth_back (&mut self, n: usize ) -> Option <Self:: Item > { ... }",
            "    fn try_rfold <B, F, R>(&mut self, init: B, f: F) -> R",
            "             F: FnMut (B, Self:: Item ) -> R,",
            "             R: Try <Output = B> { ... }",
            "    fn rfold <B, F>(self, init: B, f: F) -> B",
            "             F: FnMut (B, Self:: Item ) -> B { ... }",
            "    fn rfind <P>(&mut self, predicate: P) -> Option <Self:: Item >",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "       where Self: Sized ,",
            "             P: FnMut (&Self:: Item ) -> bool { ... }",
            "An iterator able to yield elements from both ends.",
            "Something that implements `DoubleEndedIterator` has one extra capability",
            "over something that implements [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") : the ability to also take `Item` s from the back, as well as the front.",
            "It is important to note that both back and forth work on the same range,",
            "and do not cross: iteration is over when they meet in the middle.",
            "In a similar fashion to the [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") protocol, once a `DoubleEndedIterator` returns [`None`](../option/enum.Option.html#variant.None \"variant std::option::Option::None\") from a [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") , calling it",
            "again may or may not ever return [`Some`](../option/enum.Option.html#variant.Some \"variant std::option::Option::Some\") again. [`next()`](trait.Iterator.html#tymethod.next \"method std::iter::Iterator::next\") and [`next_back()`](trait.DoubleEndedIterator.html#tymethod.next_back \"method std::iter::DoubleEndedIterator::next\\_back\") are interchangeable for this purpose.",
            "\n## Required Methods [Â§](#required-methods)",
            "1\\.0.0 Â· [Source](../../src/core/iter/traits/double_ended.rs.html#94)",
            "#### fn [next\\_back](#tymethod.next_back) (&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\") <Self:: [Item](trait.Iterator.html#associatedtype.Item \"type std::iter::Iterator::Item\") >",
            "Removes and returns an element from the end of the iterator.",
            "Returns `None` when there are no more elements.",
            "The [trait-level](trait.DoubleEndedIterator.html \"trait std::iter::DoubleEndedIterator\") docs contain more details.",
            "##### [Â§](#examples-2) Examples",
            "Basic usage:",
            "```\nlet numbers = vec! [ 1 , 2 , 3 , 4 , 5 , 6 ];\n\nlet mut iter = numbers.iter();\n\nassert_eq! ( Some ( & 1 ), iter.next());\nassert_eq! ( Some ( & 6 ), iter.next_back());\nassert_eq! ( Some ( & 5 ), iter.next_back());\nassert_eq! ( Some ( & 2 ), iter.next());\nassert_eq! ( Some ( & 3 ), iter.next());\nassert_eq! ( Some ( & 4 ), iter.next());\nassert_eq! ( None , iter.next());\nassert_eq! ( None , iter.next_back());\n```\n",
            "}"
          ]
        },
        {
          "title": "Futures Stream trait documentation (docs.rs)",
          "url": "http://docs.rs/futures/latest/futures/stream/trait.Stream.html",
          "excerpts": [
            "    // Required method",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Trait FusedIterator - std::iter (Rust std docs)",
          "url": "http://doc.rust-lang.org/std/iter/trait.FusedIterator.html",
          "excerpts": [
            "pub trait FusedIterator: Iterator { }",
            "An iterator that always continues to yield `None` when exhausted.",
            "Note: In general, you should not use `FusedIterator` in generic bounds if\nyou need a fused iterator. Instead, you should just call [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\") on the iterator. If the iterator is already fused, the additional [`Fuse`](struct.Fuse.html \"struct std::iter::Fuse\") wrapper will be a no-op with no performance penalty.",
            "to return [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") again. This trait should be implemented by all iterators",
            "that behave this way because it allows optimizing [`Iterator::fuse()`](trait.Iterator.html.fuse \"method std::iter::Iterator::fuse\")."
          ]
        },
        {
          "title": "Rust FnOnce Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnOnce.html",
          "excerpts": [
            "FnOnce in std::ops - Rust",
            "pub trait FnOnce<Args>",
            "where\n    Args: Tuple ,",
            "{\n    type Output ;\n\n    // Required method\n    extern \"rust-call\" fn call_once (self, args: Args) -> Self:: Output ;\n}\n",
            "Instances of `FnOnce` can be called, but might not be callable multiple\ntimes. Because of this, if the only thing known about a type is that it\nimplements `FnOnce` , it can only be called once.",
            "FnOnce` is implemented automatically by closures that might consume captured\nvariables, as well as all types that implement [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") , e.g., (safe) [function pointers](../primitive.fn.html \"primitive fn\") (since `FnOnce` is a supertrait of [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") )",
            "Since both [`Fn`](trait.Fn.html \"trait std::ops::Fn\") and [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") are subtraits of `FnOnce` , any instance of [`Fn`](trait.Fn.html \"trait std::ops::Fn\") or [`FnMut`](trait.FnMut.html \"trait std::ops::FnMut\") can be used where a `FnOnce` is expected."
          ]
        },
        {
          "title": "Rust FnMut Trait Documentation",
          "url": "http://doc.rust-lang.org/std/ops/trait.FnMut.html",
          "excerpts": [
            "pub trait FnMut<Args>: FnOnce<Args>\n\nwhere\n    Args: Tuple,\n\n{\n    // Required method\n    extern \"rust-call\" fn call_mut(\n        &mut self,\n        args: Args,\n    ) -> Self::Outpu",
            "Instances of `FnMut` can be called repeatedly and may mutate state.",
            "Additionally, for any type `F` that implements `FnMut`, `&mut F`\nimplements `FnMut`, too."
          ]
        },
        {
          "title": "Fn trait and closures overview - Rust",
          "url": "http://doc.rust-lang.org/std/ops/trait.Fn.html",
          "excerpts": [
            "Instances of `Fn` can be called repeatedly without mutating state.",
            "Fn` is implemented automatically by closures which only take immutable\nreferences to captured variables or donâ€™t capture anything at all, as well\nas (safe) [function pointe",
            "Use `Fn` as a bound when you want to accept a parameter of function-like\ntype and need to call it repeatedly and without mutating state (e.g., when\ncalling it concurrently)."
          ]
        },
        {
          "title": "The Rust Programming Language - Iterators and Closures",
          "url": "http://doc.rust-lang.org/book/ch13-02-iterators.html",
          "excerpts": [
            "In Rust, iterators are _lazy_ , meaning they have no effect until you call\nmethods that consume the iterator to use it up.",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library.",
            "standard library. The definition of the trait looks like this:",
            "All iterators implement a trait named `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this:",
            "pub trait Iterator {",
            "    fn next(&mut self) -> Option<Self::Item>;",
            "    // methods with default implementations elided",
            "amed `Iterator` that is defined in the\nstandard library. The definition of the trait looks like this",
            "### [The `Iterator` Trait and the `next` Method]()",
            "```\n#![allow(unused)]\nfn main() {\npub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // methods with default implementations elided\n}\n}\n```",
            "The `Iterator` trait only requires implementors to define one method: the",
            "`next` method, which returns one item of the iterator at a time, wrapped in",
            "`Some` and, when iteration is over, returns `None`.",
            "We can call the `next` method on iterators directly; Listing 13-12 demonstrates",
            "what values are returned from repeated calls to `next` on the iterator created",
            "from the vector.",
            "Note that we needed to make `v1_iter` mutable: calling the `next` method on an",
            "iterator changes internal state that the iterator uses to keep track of where",
            "it is in the sequence. In other words, this code *consumes*, or uses up, the",
            "iterator.",
            "Also note that the values we get from the calls to `next` are immutable",
            "references to the values in the vector. The `iter` method produces an iterator",
            "over immutable references. If we want to create an iterator that takes",
            "ownership of `v1` and returns owned values, we can call `into_iter` instead of",
            "`iter`. Similarly, if we want to iterate over mutable references, we can call",
            "`iter_mut` instead of `iter`.",
            "### [Methods That Consume the Iterator]()",
            "The `Iterator` trait has a number of different methods with default",
            "implementations provided by the standard library; you can find out about these",
            "methods by looking in the standard library API documentation for the `Iterator`",
            "trait. Some of these methods call the `next` method in their definition, which",
            "is why youâ€™re required to implement the `next` method when implementing the",
            "`Iterator` trait.",
            "Methods that call `next` are called *consuming adapters* because calling them",
            "uses up the iterator. One example is the `sum` method, which takes ownership of",
            "the iterator and iterates through the items by repeatedly calling `next`, thus",
            "consuming the iterator.",
            "### [Methods that Produce Other Iterators]()",
            "*Iterator adapters* are methods defined on the `Iterator` trait that donâ€™t",
            "consume the iterator. Instead, they produce different iterators by changing",
            "some aspect of the original iterator.",
            "In Listing 13-15, we collect the results of iterating over the iterator thatâ€™s",
            "returned from the call to `map` into a vector. This vector will end up",
            "containing each item from the original vector, incremented by 1.",
            "Because `map` takes a closure, we can specify any operation we want to perform",
            "on each item. This is a great example of how closures let you customize some",
            "behavior while reusing the iteration behavior that the `Iterator` trait",
            "provides.",
            "You can chain multiple calls to iterator adapters to perform complex actions in",
            "a readable way. But because all iterators are lazy, you have to call one of the",
            "consuming adapter methods to get results from calls to iterator adapters.",
            "### [Using Closures That Capture Their Environment]()",
            "Many iterator adapters take closures as arguments, and commonly the closures",
            "weâ€™ll specify as arguments to iterator adapters will be closures that capture",
            "their environment.",
            "The `shoes_in_size` function takes ownership of a vector of shoes and a shoe",
            "size as parameters. It returns a vector containing only shoes of the specified",
            "size.",
            "The closure captures the `shoe_size` parameter from the environment and",
            "compares the value with each shoeâ€™s size, keeping only shoes of the size",
            "specified. Finally, calling `collect` gathers the values returned by the",
            "adapted iterator into a vector thatâ€™s returned by the function.",
            "The test shows that when we call `shoes_in_size`, we get back only shoes",
            "that have the same size as the value we specified.",
            "    type Item;",
            "}"
          ]
        },
        {
          "title": "Rust IntoIterator documentation (Rust Standard Library)",
          "url": "http://doc.rust-lang.org/std/iter/trait.IntoIterator.html",
          "excerpts": [
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterato",
            "    type Item;",
            "    type IntoIter: Iterator<Item = Self::Item>;\n",
            "    // Required method\n",
            "    fn into_iter(self) -> Self::IntoIter;",
            "ion\n\nConversion into an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\"). By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind. One benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\"). See also: [`FromIterator`](trait.FromIterator.html \"trait std::iter::FromIterator\"). [Â§]()Examples",
            "By implementing `IntoIterator` for a type, you define how it will be\nconverted to an iterator. This is common for types which describe a\ncollection of some kind.",
            "\n\nOne benefit of implementing `IntoIterator` is that your type will [work\nwith Rustâ€™s `for` loop syntax](index.html \"mod std::iter\").",
            "It is common to use `IntoIterator` as a trait bound. This allows\nthe input collection type to change, so long as it is still an\niterator. Additional bounds can be specified by restricting on\n`Item`:\n",
            "fn collect_as_strings<T>(collection: T) -> Vec<String>\nwhere\n    T: IntoIterator,\n    T::Item: std::fmt::Debug,\n{\n    collection\n        .into_iter()\n        .map(|item| format!(\"{item:?}\"))\n        .collect()\n}",
            "Basic usage:\n\n```\nlet v = [1, 2, 3];\nlet mut iter = v.into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```\n\nImplementing `IntoIterator` for your type:\n\n```\n// A sample collection, that's just a wrapper over Vec<T>\n#[derive(Debug)]\nstruct MyCollection(Vec<i32>);\n\n// Let's give it some methods so we can create one and add things\n// to it.\nimpl MyCollection {\n    fn new() -> MyCollection {\n        MyCollection(Vec::new())\n    }\n\n    fn add(&mut self, elem: i32) {\n        self.0.push(elem);\n    }\n}\n\n// and we'll implement IntoIterator\nimpl IntoIterator for MyCollection {\n    type Item = i32;\n    type IntoIter = std::vec::IntoIter<Self::Item>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.into_iter()\n    }\n}\n\n// Now we can make a new collection...\nlet mut c = MyCollection::new();\n\n// ... add some stuff to it ...\nc.add(0);\nc.add(1);\nc.add(2);\n\n// ... and then turn it into an Iterator:\nfor (i, n) in c.into_iter().enumerate() {\n    assert_eq!(i as i32, n);\n}\n```\n\n",
            "}"
          ]
        },
        {
          "title": "How does for loop implement into_iter - rust",
          "url": "https://stackoverflow.com/questions/72258925/how-does-for-loop-implement-into-iter",
          "excerpts": [
            "The iterable is transformed into an iterator by executing IntoIterator::into_iter(iterable). Each trait, including IntoIterator, has a hidden Self genericÂ ..."
          ]
        },
        {
          "title": "Passing slice as an IntoIterator - rust",
          "url": "https://stackoverflow.com/questions/35144386/passing-slice-as-an-intoiterator",
          "excerpts": [
            "Let's take a look at how IntoIterator is implemented for slices: impl<'a, T> IntoIterator for &'a [T] type Item = &'a T type IntoIter = Iter<'a, T>"
          ]
        },
        {
          "title": "Difference Between into_iter, iter() and iter_mut() in rust",
          "url": "https://blog.coolhead.in/difference-between-intoiter-iter-and-itermut-in-rust",
          "excerpts": [
            "Nov 24, 2023 â€” into_iter() transfers ownership of the collection, iter() borrows the elements immutably, and iter_mut() borrows them mutably."
          ]
        },
        {
          "title": "IntoIter in std::vec",
          "url": "https://doc.rust-lang.org/std/vec/struct.IntoIter.html",
          "excerpts": [
            "An iterator that moves out of a vector. This struct is created by the into_iter method on Vec (provided by the IntoIterator trait)."
          ]
        },
        {
          "title": "Advanced Functions and Closures",
          "url": "https://doc.rust-lang.org/book/ch20-04-advanced-functions-and-closures.html",
          "excerpts": [
            "Function pointers implement all three of the closure traits ( Fn , FnMut , and FnOnce ), meaning you can always pass a function pointer as an argument for aÂ ..."
          ]
        },
        {
          "title": "move",
          "url": "https://doc.rust-lang.org/std/keyword.move.html",
          "excerpts": [
            "Capture a closure's environment by value. move converts any variables captured by reference or mutable reference to variables captured by value. ... Note: move ..."
          ]
        },
        {
          "title": "Capturing - Rust By Example",
          "url": "https://doc.rust-lang.org/rust-by-example/fn/closures/capture.html",
          "excerpts": [
            "Closures are inherently flexible and will do what the functionality requires\nto make the closure work without annotation. This allows capturing to\nflexibly adapt to the use case, sometimes moving and sometimes borrowing. Closures can capture variables:\n\n* by reference: `&T`\n* by mutable reference: `&mut T`\n* by value: `T`",
            "They preferentially capture variables by reference and only go lower when\nrequired. ```"
          ]
        },
        {
          "title": "FromIterator in std::iter - Rust",
          "url": "https://doc.rust-lang.org/std/iter/trait.FromIterator.html",
          "excerpts": [
            "pub trait FromIterator<A>: Sized {\n    // Required method\n    fn from_iter <T>(iter: T) -> Self\n       where T: IntoIterator <Item = A> ;\n}",
            "Conversion from an [`Iterator`](trait.Iterator.html \"trait std::iter::Iterator\") . By implementing `FromIterator` for a type, you define how it will be\ncreated from an iterator. This is common for types which describe a\ncollection of some kind. If you want to create a collection from the contents of an iterator, the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") method is preferred. However, when you need to\nspecify the container type, [`FromIterator::from_iter()`](trait.FromIterator.html.from_iter \"associated function std::iter::FromIterator::from\\_iter\") can be more\nreadable than using a turbofish (e.g. `::<Vec<_>>()` ).\nSee the [`Iterator::collect()`](trait.Iterator.html.collect \"method std::iter::Iterator::collect\") documentation for more examples of its use."
          ]
        },
        {
          "title": "What is the difference between iter and into_iter? (Stack Overflow)",
          "url": "https://stackoverflow.com/questions/34733811/what-is-the-difference-between-iter-and-into-iter",
          "excerpts": [
            "What is the difference between `iter` and `into_iter` ? `into_iter` is a generic method to obtain an iterator, whether this iterator yields values, immutable references or mutable references **is context dependent** and can sometimes be surprising. `iter` and `iter_mut` are inherent methods. Their return type is therefore independent of the context, and will conventionally be iterators yielding immutable references and mutable references, respectively. The author of the Rust by Example post used Rust pre-1.53.0 to illustrate the surprise coming from the dependence on the context (i.e., the type) on which `into_iter` is called, and is also compounding the problem by using the fact that:\n\n1. Back then, `IntoIterator` was not implemented for `[T; N]` , only for `&[T; N]` and `&mut [T; N]` . 2",
            "* `iter()` iterates over the items by reference",
            "* `iter_mut()` iterates over the items, giving a mutable reference to each item",
            "* `into_iter()` iterates over the items, moving them into the new scope",
            "So `for x in my_vec { ... }` is essentially equivalent to `my_vec.into_iter().for_each(|x| ... )` \\- both `move` the elements of `my_vec` into the `...` scope. If you just need to _look at_ the data, use `iter` , if you need to edit/mutate it, use `iter_mut` , and if you need to give it a new owner, use `into_iter` "
          ]
        },
        {
          "title": "ExactSizeIterator in std::iter - Rust",
          "url": "http://doc.rust-lang.org/std/iter/trait.ExactSizeIterator.html",
          "excerpts": [
            "An iterator that knows its exact length.",
            "If an iterator knows how many times it can iterate, providing access to\nthat information can be useful.",
            "This function has the same safety guarantees as the\n[`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\") function.",
            "this trait is a safe trait and as such does *not* and *cannot*\nguarantee that the returned length is correct. This means that `unsafe`\ncode **must not** rely on the correctness of [`Iterator::size_hint`](trait.Iterator.html.size_hint \"method std::iter::Iterator::size_hint\")."
          ]
        },
        {
          "title": "Rust Iterator Documentation",
          "url": "http://doc.rust-lang.org/std/iter/trait.Iterator.html",
          "excerpts": [
            "A trait for dealing with iterators.",
            "This is the main iterator trait. For more about the concept of iterators\ngenerally, please see the [module-level documentation](index.html \"mod std::iter\"). In particular, you\nmay want to know how to [implement `Iterator`](index.html \"mod std::iter\").",
            "The type of the elements being iterated over.",
            "(.next)(&mut self) -> [Option](../option/enum.Option.html \"enum std::option::Option\")<Self::[Item](trait.Iterator.html.Item \"type std::iter::Iterator::Item\")>",
            "Advances the iterator and returns the next value.",
            "Returns [`None`](../option/enum.Option.html.None \"variant std::option::Option::None\") when iteration is finished."
          ]
        },
        {
          "title": "Unwinding -",
          "url": "https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/nomicon/unwinding.html",
          "excerpts": [
            "As such, unwinding into Rust from another language, or unwinding into another language from Rust is Undefined Behavior. You must absolutely catch any panics ..."
          ]
        },
        {
          "title": "Asynchronous clean-up",
          "url": "https://without.boats/blog/asynchronous-clean-up/",
          "excerpts": [
            "Feb 24, 2024 â€” The problem with cooperative cancellation is that if a unit of work doesn't opt into being canceled, it will run to completion even if its workÂ ..."
          ]
        },
        {
          "title": "The Rustonomicon - Unwinding",
          "url": "https://doc.rust-lang.org/nomicon/unwinding.html",
          "excerpts": [
            "Rust has a _tiered_ error-handling scheme:\n\n* If something might reasonably be absent, Option is used. * If something goes wrong and can reasonably be handled, Result is used. * If something goes wrong and cannot reasonably be handled, the thread panics. * If something catastrophic happens, the program aborts. Option and Result are overwhelmingly preferred in most situations, especially\nsince they can be promoted into a panic or abort at the API user's discretion.",
            "Panics cause the thread to halt normal execution and unwind its stack, calling\ndestructors as if every function instantly returned.",
            "There is an API called [`catch_unwind`](https://doc.rust-lang.org/std/panic/fn.catch_unwind.html) that enables catching a panic\nwithout spawning a thread.",
            "Unlike an exception in Java or C++, a panic could not be\ncaught at any time."
          ]
        },
        {
          "title": "Cargo profile panic settings",
          "url": "https://doc.rust-lang.org/cargo/reference/profiles.html",
          "excerpts": [
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic. When set to\n\"unwind\" , the actual value depends on the default of the target\nplatform. For example, the NVPTX platform does not support unwinding, so it\nalways uses\n\"abort\" . Tests, benchmarks, build scripts, and proc macros ignore the\npanic setting. The\nrustc test harness currently requires\nunwind behavior. See the\npanic-abort-tests unstable flag which enables\nabort behavior. Additionally, when using the\nabort strategy and building a test, all of the\ndependencies will also be forced to build with the\nunwind strategy. incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times",
            "Profiles\nProfiles provide a way to alter the compiler settings, influencing things like\noptimizations and debugging symbols. Cargo has 4 built-in profiles:\ndev ,\nrelease ,\ntest , and\nbench .",
            "The default is\n\"none\" . You can also configure this option with the boolean values\ntrue or\nfalse .",
            "release profile is intended for optimized artifacts used for releases\nand in production.",
            "[profile.release] opt-level = 3",
            "The default settings for the\nrelease profile are:\n[profile.release] opt-level = 3 debug = false split-debuginfo = '...' # Platform-specific. strip = \"none\" debug-assertions = false overflow-checks = false lto = false panic = 'unwind' incremental = false codegen-units = 16 rpath = false",
            "The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release .",
            "opt-level = 3",
            "debug = false",
            "strip = \"none\"",
            "lto = false",
            "panic = 'unwind'",
            "codegen-units = 16",
            "The\ncodegen-units setting controls the\n-C codegen-units flag which\ncontrols how many â€œcode generation unitsâ€ a crate will be split into. More\ncode generation units allows more of a crate to be processed in parallel\npossibly reducing compile time, but may produce slower cod",
            "led\n\nlto\nThe\nlto setting controls\nrustc â€™s\n-C lto ,\n-C linker-plugin-lto , and\n-C embed-bitcode options, which control LLVMâ€™s link time optimizations . LTO can produce better optimized code, using whole-program analysis, at the cost\nof longer linking time. The valid options are:\n    * false : Performs â€œthin local LTOâ€ which performs â€œthinâ€ LTO on the local\ncrate only across its codegen units . No LTO is performed\nif codegen units is 1 or opt-level is 0.\n* true or\n\"fat\" : Performs â€œfatâ€ LTO which attempts to perform\noptimizations across all crates within the dependency graph. * \"thin\" : Performs â€œthinâ€ LTO . This is similar to â€œfatâ€, but takes\nsubstantially less time to run while still achieving performance gains\nsimilar to â€œfatâ€. * \"off\" : Disables LTO.",
            "panic\nThe\npanic setting controls the\n-C panic flag which controls which panic\nstrategy to use. The valid options are:\n    * \"unwind\" : Unwind the stack upon panic. * \"abort\" : Terminate the process upon panic.",
            "debug\nThe\ndebug setting controls the\n-C debuginfo flag which controls the\namount of debug information included in the compiled binary. The valid options are:\n    * 0 ,\nfalse , or\n\"none\" : no debug info at all, default for\nrelease",
            "opt-level\nThe\nopt-level setting controls the\n-C opt-level flag which controls the level\nof optimization. Higher optimization levels may produce faster runtime code at\nthe expense of longer compiler times.",
            "incremental\nThe\nincremental setting controls the\n-C incremental flag which controls\nwhether or not incremental compilation is enabled. Incremental compilation\ncauses\nrustc to save additional information to disk which will be reused\nwhen recompiling the crate, improving re-compile times.",
            "Profile selection\nThe profile used depends on the command, the command-line flags like\n--release or\n--profile , and the package (in the case of overrides ). The default profile if none is specified is:\nYou can switch to a different profile using the\n--profile=NAME option which will used the given profile. The\n--release flag is equivalent to\n--profile=release ."
          ]
        },

