# Parseltongue Development Rules

## THE ABSOLUTE TOP: Versioning Philosophy

### ONE FEATURE PER INCREMENT - END TO END - SPIC AND SPAN

**Core Principle**: Each version delivers **EXACTLY ONE complete feature**, fully working end-to-end.

**Version Naming**:
- v0.9.4, v0.9.5, v0.9.6, v0.9.7, v0.9.8, v0.9.9 ‚Üí v1.0.0 ‚Üí v1.0.1, v1.0.2...
- **NO v0.10.0** - we go v0.9.9 then v1.0.0
- Triple-digit minor versions before major bump

**What "END TO END" Means**:
- ‚úÖ Feature works in production binary
- ‚úÖ All tests passing (not just the new feature)
- ‚úÖ Documentation updated (README, PRD, scope docs)
- ‚úÖ Shell scripts updated (.sh files work)
- ‚úÖ Agent prompts updated (if feature changes workflow)
- ‚úÖ Integration tested (not just unit tests)
- ‚úÖ Zero TODOs, zero stubs, zero placeholders
- ‚úÖ Pushed to origin/main

**What "SPIC AND SPAN" Means**:
- ‚úÖ Binary compiles: `cargo build --release` succeeds
- ‚úÖ Tests pass: `cargo test --all` ‚Üí 0 failures
- ‚úÖ No warnings (or explicitly documented if unavoidable)
- ‚úÖ Clean git status after commit
- ‚úÖ Version-wise-scope.md updated
- ‚úÖ User can use the feature IMMEDIATELY

**Forbidden**:
- ‚ùå Partial features ("LPA foundation but no integration")
- ‚ùå Stubs for "future work"
- ‚ùå Breaking existing features to add new ones
- ‚ùå Documentation that says "will be implemented"
- ‚ùå Commits with TODO comments in production code

**Example Good Increments**:
- v0.9.4: LPA clustering foundation (7 tests, production-ready)
- v0.9.5: TEST exclusion from ingestion (binary flag, works end-to-end)
- v0.9.6: Louvain algorithm (compares to LPA, exports work)
- v0.9.7: Triple export system (CozoDB + JSON + TOON all work)

**Example Bad Increments**:
- ‚ùå v0.9.4: "Clustering foundation + export system + visualization"
- ‚ùå v0.9.5: "Three algorithms but exports don't work yet"
- ‚ùå v0.9.6: "Integration with PT01 but tests failing"

**Why This Matters**:
- Users get **working features**, not promises
- Each release is **production-ready**
- No accumulation of technical debt
- Clear progress: "We have X complete features"
- LLMs can verify completion objectively

---

## Core Philosophy

### FUNCTIONAL IDIOMATIC RUST
Write **pure functional code** following Rust idioms:
- ‚úÖ Prefer iterators over loops
- ‚úÖ Use `Result<T, E>` and `Option<T>` - never panic in libraries
- ‚úÖ Pure functions (no side effects unless explicit)
- ‚úÖ Immutability by default (`let` not `let mut`)
- ‚úÖ Trait-based abstractions (dependency injection)
- ‚úÖ RAII resource management (Drop trait)

### TDD-FIRST: STUB ‚Üí RED ‚Üí GREEN ‚Üí REFACTOR
**ALWAYS write tests BEFORE implementation:**
1. **STUB**: Write failing test with expected interface
2. **RED**: Run test, verify it fails correctly
3. **GREEN**: Minimal implementation to make test pass
4. **REFACTOR**: Improve code without breaking tests

### EXECUTABLE SPECIFICATIONS OVER NARRATIVES
Traditional user stories fail LLMs. Use **formal contracts**:
- **Preconditions**: What must be true before execution
- **Postconditions**: What will be true after execution
- **Error conditions**: What failures can occur
- **Performance claims**: Measured, not guessed

**Every claim validated by automated tests.**

---

## Rule #1: FOUR-WORD NAMING CONVENTION

**ALL function names: EXACTLY 4 words** (underscores separate)
**ALL crate names: EXACTLY 4 words** (hyphens separate)

**Why**: LLMs parse by tokenizing. 4 words = optimal semantic density.

**üìö RESEARCH-BACKED**: See `.claude/S03-four-word-naming-thesis.md` for 60-page empirical validation:
- **96% LLM recall** (vs 23% single-word) - proven through testing Claude/GPT-4/Llama
- **44% semantic density** - optimal BPE tokenization efficiency
- **Lowest cognitive load** - validated via fNIRS brain imaging (Miller's Law 4¬±1 chunks)
- **12+ peer-reviewed citations** - ACM, IEEE, arXiv research (2024-2025)
- **$600/year savings** - context window optimization per developer

```rust
‚úÖ filter_implementation_entities_only()
‚úÖ render_box_with_title_unicode()
‚úÖ save_visualization_output_to_file()
‚úÖ pt01-folder-to-cozodb-streamer

‚ùå filter_entities()                    // Too short (2)
‚ùå detect_cycles_in_dependency_graph()  // Too long (5)
```

**Naming pattern**: `verb_constraint_target_qualifier()`
- Verb: `filter`, `render`, `detect`, `save`
- Constraint: `implementation`, `box_with_title`, `visualization_output`
- Target: `entities`, `unicode`, `file`
- Qualifier: `only`, `to`, `in`

---

## Rule #2: NEVER LIE - Verify Everything

**Forbidden** (causes hallucination):
- ‚ùå Claiming "done" when not tested
- ‚ùå Saying tests pass without showing output
- ‚ùå Marking todos complete without verification
- ‚ùå Making up results

**Required**:
- ‚úÖ Run tests ‚Üí Show actual output
- ‚úÖ Build code ‚Üí Show actual output
- ‚úÖ Mark work complete ONLY after verification
- ‚úÖ Use explicit status: "‚úÖ VERIFIED" / "‚ö†Ô∏è UNTESTED" / "‚ùå BROKEN"

---

## Rule #3: NO STUBS IN COMMITS

**Every commit must be production-ready.**

**Forbidden**:
- ‚ùå Committing code with `TODO:` comments
- ‚ùå Committing `unimplemented!()` or `panic!()`
- ‚ùå Shipping releases with stubs
- ‚ùå Open todos in version control

**Required**:
- ‚úÖ Either implement FULLY or DON'T commit
- ‚úÖ Remove ALL todos before commit
- ‚úÖ If incomplete: Say "Cannot complete because [reason]"

---

## Rule #4: Layered Architecture (L1‚ÜíL2‚ÜíL3)

**L1 Core** (no_std compatible):
- Ownership, lifetimes, traits, Result/Option, RAII, newtype pattern

**L2 Standard**:
- Collections, iterators, smart pointers, Send/Sync

**L3 External**:
- Async/await (Tokio), serialization (Serde), databases (CozoDB)

**Never mix layers** - L3 cannot be in L1 core.

---

## Rule #5: Mermaid-Only Diagrams

ALL diagrams must be Mermaid (for GitHub rendering).
- ‚úÖ `graph LR`, `sequenceDiagram`, `classDiagram`
- ‚ùå No ASCII art, no image files, no external tools

---

## Enforcement Checklist

Before ANY commit:
- [ ] Tests written FIRST (TDD cycle)?
- [ ] Tests passing? (show output: `cargo test`)
- [ ] Build passing? (show output: `cargo build --release`)
- [ ] Zero TODOs/STUBs? (show: `grep -r "TODO\|STUB\|PLACEHOLDER"`)
- [ ] All function names = 4 words? (count: `verb_noun_noun_qualifier`)
- [ ] Follows functional idioms? (iterators, immutability, pure functions)
- [ ] Status verified? (not claimed without proof)

**If ANY checkbox unchecked ‚Üí STOP. NOT READY.**

---

## Quick Reference

**TDD Cycle**: STUB (write test) ‚Üí RED (fails) ‚Üí GREEN (minimal impl) ‚Üí REFACTOR (improve)

**Naming**: 4 words always (`action_constraint_target_qualifier`)

**Status markers**:
- ‚úÖ VERIFIED (ran tests, saw output)
- ‚ö†Ô∏è UNTESTED (needs testing)
- üöß INCOMPLETE (missing parts)
- ‚ùå BROKEN (not working)

**Architecture**: L1 (core) ‚Üí L2 (std) ‚Üí L3 (external)

**Never**: Stubs in commits, lies about status, non-4-word names, panic in libraries

**Always**: Tests first, functional style, immutability, proof over claims
