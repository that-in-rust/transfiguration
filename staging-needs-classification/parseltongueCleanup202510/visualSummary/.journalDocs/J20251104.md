# Parseltongue Ultrathink Evolution Journal
**Date:** 2025-11-04
**Branch:** ab20251104
**Session:** Collaborative Ideation

---

## ğŸ¯ Session Goals
- Explore next evolution of Parseltongue Ultrathink
- Partner on architectural vision
- Raw ideas, no filters

---

## ğŸ’¡ Raw Ideas & Brainstorming

### Theme 1: The C/C++ Extraction Crisis (10,203 Failures)

**Context**: When analyzing a large codebase (26,452 files), Parseltongue encountered 10,203 C++ extraction failures (38.5% failure rate).

**Root Cause Hypothesis**:
1. **Preprocessor Blindness**: Tree-sitter parsers don't expand macros
   - Window.h-style header explosions (10 lines â†’ millions of lines)
   - Macro fragments that aren't syntactically valid until after preprocessing
   - Conditional compilation (#ifdef) changes AST structure mid-parse

2. **Template Complexity**: Tree-sitter GLR handles type ambiguities but struggles with:
   - Template specializations and SFINAE patterns
   - Nested template parameter packs
   - Dependent types that require semantic analysis

3. **Header File Hell**:
   - No semantic understanding of #include relationships
   - Can't distinguish between system headers vs local headers
   - Missing transitive dependency analysis

4. **No Semantic Analysis**:
   - Tree-sitter does syntax, not semantics
   - Can't resolve which overload is called
   - Can't track template instantiations
   - No type inference

**The Brutal Truth**: Tree-sitter is fundamentally wrong for C++ at scale. It's designed for **syntax highlighting**, not **semantic analysis**.

---

### Theme 2: Ruby on Rails - The Dynamic Language Problem

**Current Parseltongue Assumption**: Static types â†’ Interface signatures â†’ ISG export

**Rails Reality**:
- Duck typing: Method calls resolved at runtime
- Metaprogramming: `method_missing`, `define_method`, `class_eval`
- Convention over configuration: Implicit relationships (ActiveRecord associations)
- Polymorphic associations: Type relationships only known at DB level

**The ISG Model Breaks Down**:
- Level 0 (edges): Missing dynamic method calls
- Level 1 (signatures): Missing inferred types (RBS/Sorbet needed)
- Level 2 (type system): Doesn't exist in vanilla Rails

**Rails-Specific Challenges**:
1. **ActiveRecord Magic**: `has_many :posts` creates 15+ methods dynamically
2. **Routes as API Surface**: `config/routes.rb` defines HTTP API, not classes
3. **Views Template Soup**: ERB/HAML mixing Ruby + HTML
4. **Concerns and Mixins**: Multiple inheritance via `include`/`extend`
5. **Engine Mounting**: Rails apps can mount sub-apps (implicit dependencies)

---

## ğŸ”¬ Technical Possibilities

### Possibility 1: Multi-Strategy Parser Architecture

**Problem**: One parser can't handle all languages equally well

**Solution**: Parser adapter pattern with language-specific extractors

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   pt01: Language Detection Layer    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                       â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚ Rust   â”‚           â”‚   C/C++    â”‚
â”‚ Python â”‚           â”‚   Strategy â”‚
â”‚ Go     â”‚           â”‚            â”‚
â”‚ Ruby   â”‚           â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        â”‚           â”‚  â”‚ Option Aâ”‚
â”‚ Tree-  â”‚           â”‚  â”‚ libclangâ”‚
â”‚ sitter â”‚           â”‚  â”‚ (99.9%) â”‚
â”‚        â”‚           â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (85%   â”‚           â”‚  â”‚ Option Bâ”‚
â”‚ works) â”‚           â”‚  â”‚ clangd  â”‚
â”‚        â”‚           â”‚  â”‚ LSP     â”‚
â”‚        â”‚           â”‚  â”‚ (remote)â”‚
â”‚        â”‚           â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚        â”‚           â”‚  â”‚ Option Câ”‚
â”‚        â”‚           â”‚  â”‚ Tree-   â”‚
â”‚        â”‚           â”‚  â”‚ sitter  â”‚
â”‚        â”‚           â”‚  â”‚ +Fallbk â”‚
â”‚        â”‚           â”‚  â”‚ (50-60%)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Sketch**:
- `trait ASTExtractor { fn extract(&self, file: &Path) -> Result<Vec<Entity>>; }`
- `struct TreeSitterExtractor` (current implementation)
- `struct LibclangExtractor` (NEW - for C/C++)
- `struct ClangdLSPExtractor` (NEW - remote indexing)
- `struct PrismExtractor` (NEW - for Ruby via Prism gem)

**Trade-offs**:
- âœ… Each language gets best-in-class parser
- âœ… Accuracy jumps from 61.5% â†’ 95%+ for C++
- âŒ Binary size increases (libclang is 50MB+)
- âŒ Dependency complexity (need clang installed)
- âŒ Performance hit (libclang slower than tree-sitter)

---

### Possibility 2: Preprocessor-Aware C/C++ Pipeline

**Problem**: Tree-sitter sees pre-preprocessor code, compiler sees post-preprocessor code

**Solution**: Two-phase extraction

**Phase 1: Preprocessor Expansion** (before parsing)
```bash
# Use clang -E to expand macros
clang -E -I./include -D__MY_PROJECT__ file.cpp > file.expanded.cpp
```

**Phase 2: Parse Expanded Code**
```rust
// Parse expanded code with tree-sitter or libclang
let entities = parser.extract("file.expanded.cpp")?;

// Map entities back to original source locations
let mapped = location_mapper.map_to_original(entities, "file.cpp")?;
```

**Challenges**:
1. **Location Mapping**: Expanded code locations don't match original
   - Need source maps (like JavaScript transpilers)
   - Macro expansions create "synthetic" locations

2. **Build System Integration**: Need compiler flags
   - Parse `compile_commands.json` (CMake/Ninja generate this)
   - Extract `-I`, `-D`, `-std=` flags per file

3. **Explosion Factor**: 10 lines â†’ millions (memory blow-up)
   - Solution: Stream processing, don't load entire expanded file

**Accuracy Gain**: 61.5% â†’ 90%+ (but still missing semantic analysis)

---

### Possibility 3: Semantic Analysis via Language Server Protocol (LSP)

**Problem**: Parseltongue does syntax, not semantics

**Solution**: Delegate semantic analysis to language servers

**Architecture**:
```
Parseltongue pt01
    â†“
Detect file type
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Launch LSP Server            â”‚
â”‚  - clangd (C/C++)             â”‚
â”‚  - rust-analyzer (Rust)       â”‚
â”‚  - Solargraph (Ruby)          â”‚
â”‚  - Pyright (Python)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
Query LSP for semantic info:
  - textDocument/definition
  - textDocument/references
  - textDocument/documentSymbol
  - textDocument/hover (for types)
    â†“
Convert LSP responses â†’ ISG entities
    â†“
Store in CozoDB
```

**What We Gain**:
- **Type inference**: Pyright knows Python types without annotations
- **Template resolution**: clangd tracks instantiations
- **Dynamic method discovery**: Solargraph analyzes Ruby metaprogramming
- **Cross-file analysis**: LSP servers build full project index

**What We Lose**:
- **Speed**: LSP servers take 10-60s to index project
- **Simplicity**: Now depend on 4+ external processes
- **Portability**: Need different LSP server per language

**Hybrid Approach**:
- Use tree-sitter for **fast syntax** (current behavior)
- Use LSP for **semantic enrichment** (optional, when available)
- Store both: `entity.syntactic_signature` vs `entity.semantic_signature`

**Implementation Complexity**: MEDIUM (LSP client in Rust exists: `tower-lsp`)

---

### Possibility 4: Ruby on Rails Domain-Specific Extractors

**Problem**: Rails is NOT just Ruby - it's a framework with conventions

**Solution**: Rails-aware extractors for non-code files

**New Extractor Types**:

1. **Routes Extractor** (`config/routes.rb`)
   ```ruby
   # routes.rb
   resources :posts do
     member { post :publish }
   end

   # ISG Output
   Entity {
     entity_type: "http_endpoint",
     entity_name: "POST /posts/:id/publish",
     dependencies: ["PostsController#publish"],
   }
   ```

2. **ActiveRecord Schema Extractor** (`db/schema.rb`)
   ```ruby
   # schema.rb
   create_table :posts do |t|
     t.references :user, foreign_key: true
   end

   # ISG Output
   Edge {
     from: "Post",
     to: "User",
     edge_type: "BelongsTo",
   }
   ```

3. **View Template Extractor** (`.html.erb`)
   ```erb
   <%= render @posts %>
   <%= link_to 'New Post', new_post_path %>

   # ISG Output
   Entity { entity_name: "posts/index", entity_type: "view" }
   Edge { from: "posts/index", to: "posts/_post", edge_type: "Renders" }
   Edge { from: "posts/index", to: "new_post_path", edge_type: "LinksTo" }
   ```

4. **Metaprogramming Analyzer** (static analysis of `define_method`)
   ```ruby
   # Use RuboCop AST + runtime introspection
   class Post
     [:published, :draft].each do |status|
       define_method "#{status}?" do
         self.status == status.to_s
       end
     end
   end

   # ISG Output (synthesized methods)
   Entity { entity_name: "published?", entity_type: "method" }
   Entity { entity_name: "draft?", entity_type: "method" }
   ```

**Accuracy Gain for Rails**: 40% â†’ 80%+ (convention discovery)

---

### Possibility 5: Hybrid Static + Dynamic Analysis

**Problem**: Static analysis can't see runtime behavior (Ruby metaprogramming, C++ templates)

**Solution**: Optional runtime tracing mode

**Workflow**:
```bash
# Step 1: Static analysis (current)
parseltongue pt01 ./src --db static.db

# Step 2: Run tests with tracing (NEW)
parseltongue pt01-dynamic --trace-tests "bundle exec rspec" --db dynamic.db

# Step 3: Merge graphs
parseltongue pt01-merge static.db dynamic.db --output merged.db
```

**What `pt01-dynamic` Does**:
1. Instruments runtime (TracePoint in Ruby, GDB for C++)
2. Records actual function calls during test execution
3. Captures dynamic method definitions
4. Detects actual template instantiations used

**Example** (Ruby):
```ruby
# Static analysis sees:
class Post
  # ??? Unknown methods
end

# Dynamic analysis captures:
TracePoint.trace(:call) do |tp|
  if tp.defined_class == Post
    record_edge(tp.callee, tp.caller)
  end
end

# After test run, we know:
# - Post#published? exists (defined by metaprogramming)
# - Post#published? is called by PostsController#index
```

**Trade-offs**:
- âœ… 100% accurate call graph (if tests cover code)
- âœ… Discovers dynamic methods
- âŒ Requires running tests (slow, needs working environment)
- âŒ Coverage-dependent (untested code invisible)

---

## ğŸ¤” Open Questions

### Question 1: Should Parseltongue be "correct" or "fast"?

**Current Choice**: Fast (tree-sitter, syntax-only, 88s for 6K files)

**Alternative**: Correct (libclang, semantic, 10-60s for same files)

**Thesis**: For C/C++, "fast but 40% wrong" is worse than "slower but 95% right"
- Users waste hours debugging missing dependencies
- LLM agents make incorrect refactorings based on incomplete data

**Proposal**: Make it configurable
```bash
# Fast mode (default, tree-sitter)
parseltongue pt01 --mode=fast ./src

# Accurate mode (libclang + LSP)
parseltongue pt01 --mode=accurate ./src

# Hybrid mode (fast syntax + lazy semantic on-demand)
parseltongue pt01 --mode=hybrid ./src
```

---

### Question 2: Is the ISG Model Language-Agnostic Enough?

**Current ISG Entity**:
```rust
struct Entity {
  entity_name: String,
  entity_type: EntityType,  // Fn, Struct, Class, etc.
  interface_signature: Signature,
  dependencies: Vec<Dependency>,
}
```

**Works Great For**: Rust, Go, TypeScript (explicit types, static analysis)

**Breaks Down For**:
- **Ruby**: Dynamic types, implicit dependencies (ActiveRecord)
- **Python**: Type hints optional, duck typing
- **C++**: Template instantiations, macro-generated code
- **Rails**: Convention-based dependencies (routes â†’ controllers)

**Proposed: Language-Specific Extensions**

```rust
struct Entity {
  // Universal fields
  entity_name: String,
  entity_type: EntityType,

  // Language-agnostic signature
  interface_signature: GenericSignature,

  // Language-specific metadata (NEW)
  language_metadata: LanguageMetadata,
}

enum LanguageMetadata {
  Rust(RustMetadata),
  Cpp(CppMetadata {
    template_instantiations: Vec<Instantiation>,
    macro_origin: Option<MacroExpansion>,
  }),
  Ruby(RubyMetadata {
    dynamic_methods: Vec<String>,
    included_modules: Vec<String>,
    active_record_associations: Vec<Association>,
  }),
  Rails(RailsMetadata {
    http_routes: Vec<Route>,
    view_dependencies: Vec<String>,
  }),
}
```

**Benefit**: Preserve ISG abstraction while allowing language-specific richness

---

### Question 3: Should Parseltongue Handle Build Systems?

**Current**: Files are parsed in isolation (no build context)

**Problem**: C/C++ can't be parsed without:
- Include paths (`-I/usr/include`)
- Preprocessor defines (`-DNDEBUG`)
- Language standard (`-std=c++20`)

**Proposal**: Build system integration

```bash
# Auto-detect build system
parseltongue pt01 ./src --detect-build

# Detected: CMake
# â†’ Generates compile_commands.json
# â†’ Extracts flags per file
# â†’ Passes to libclang/clangd

# Detected: Cargo
# â†’ Uses Cargo.toml for features
# â†’ Runs cargo metadata

# Detected: Bundler (Rails)
# â†’ Uses Gemfile for dependencies
# â†’ Analyzes gem load paths
```

**Implementation**:
- Parse `compile_commands.json` (CMake, Ninja)
- Run `cargo metadata --format-version 1` (Rust)
- Run `bundle show --paths` (Ruby)

**Complexity**: MEDIUM (parsers exist for these formats)

---

### Question 4: Can We Do Incremental Updates?

**Current**: Full re-index on every change (88s for 6K files)

**Problem**: During active development, only 1-5 files change per edit

**Proposal**: Incremental indexing

```rust
// Watch for file changes
let watcher = FileWatcher::new("./src");

watcher.on_change(|file_path| {
  // Re-parse only changed file
  let entities = extractor.extract(file_path)?;

  // Update CozoDB (delete old, insert new)
  db.transaction(|| {
    db.delete_entities_from_file(file_path)?;
    db.insert_entities(entities)?;
  })?;
});
```

**Challenges**:
1. **Dependency Invalidation**: If `lib.rs` changes interface, all dependents need re-parse
2. **Transitive Updates**: Change to macro affects all call sites
3. **Tombstone Management**: Track deleted entities

**Accuracy Gain**: Near real-time updates (< 1s per file change)

---

## ğŸ“Š Metrics & Observations

### Current Parseltongue Performance (from visualExample/)

| Metric | Value | Notes |
|--------|-------|-------|
| **Files Scanned** | 6,032 | Parseltongue self-analysis |
| **Entities Extracted** | 37,770 | 100% Rust (tree-sitter works well) |
| **Dependency Edges** | 108,113 | |
| **Indexing Time** | 88 seconds | ~68 files/second |
| **L0 Export Time** | 5 seconds | 108K edges â†’ 5K tokens |
| **L1 Export Time** | 40 seconds | 37K entities â†’ 30K tokens |
| **Success Rate** | 100% | Rust is tree-sitter's sweet spot |

### Large C++ Codebase Performance (user's test)

| Metric | Value | Notes |
|--------|-------|-------|
| **Files Scanned** | 26,452 | |
| **Files Processed** | 16,249 | 61.5% success rate |
| **Entities Extracted** | 180,320 | Incomplete graph |
| **Errors** | 10,203 | **38.5% failure rate** |
| **Indexing Time** | 181 seconds | ~146 files/second (2x faster, but incomplete) |

### Failure Rate Analysis

**Hypothesis**: C++ failure rate correlates with:
1. **Macro density**: Headers with heavy macro use (Win32 API, Qt MOC)
2. **Template complexity**: SFINAE, template metaprogramming
3. **Missing includes**: Can't resolve types without full include path

**Critical Threshold**: 38.5% failure rate means ISG graph has massive holes
- Missing edges â†’ incorrect architecture view
- Missing entities â†’ incomplete API surface
- Garbage in â†’ garbage out for LLM reasoning

**Recommendation**: DO NOT use current Parseltongue for C++ codebases until libclang integration is complete.

---

### Ruby on Rails Success Rate (estimated, not yet tested)

**Prediction**:
- **Static Success Rate**: 60-70% (Ruby syntax parses well with tree-sitter-ruby)
- **Semantic Accuracy**: 30-40% (missing dynamic methods, metaprogramming, conventions)

**Why Low Semantic Accuracy**:
- `has_many :posts` creates methods that tree-sitter can't see
- Routes in `config/routes.rb` create implicit controller dependencies
- `method_missing` creates infinite virtual methods
- ERB templates mix Ruby + HTML (tree-sitter-erb exists but incomplete)

**Recommendation**: Rails needs domain-specific extractors (routes, schema, views)

---

### Comparison: Tree-sitter vs Libclang vs LSP

| Feature | Tree-sitter | libclang | clangd (LSP) |
|---------|-------------|----------|--------------|
| **Speed** | âš¡âš¡âš¡ 68 files/s | âš¡ 10-20 files/s | â±ï¸ 5-10 files/s (full index) |
| **Accuracy (C++)** | 60-70% | 95-99% | 99%+ |
| **Macro Support** | âŒ No | âœ… Yes (with -E) | âœ… Yes |
| **Templates** | âš ï¸ Partial | âœ… Full | âœ… Full + instantiations |
| **Semantic Info** | âŒ No | âš ï¸ Partial | âœ… Full (types, refs) |
| **Binary Size** | 2-5 MB | 50-80 MB | 100-150 MB |
| **Dependencies** | None | libclang install | clangd install |
| **Incremental** | âœ… Yes | âŒ No | âœ… Yes |

**Verdict**:
- **Fast prototyping**: tree-sitter
- **Production C++**: libclang or clangd LSP
- **Hybrid**: tree-sitter for Rust/Python/Go, libclang for C/C++

---

## ğŸš€ Next Actions

### Immediate (This Sprint)

1. **[ ] Reproduce C++ Failure Locally**
   - Find public C++ codebase with heavy templates (LLVM, Chromium, Boost)
   - Run current Parseltongue pt01 on it
   - Analyze error logs to categorize failures:
     - Macro-related?
     - Template-related?
     - Include-path-related?
     - Tree-sitter grammar bugs?

2. **[ ] Prototype libclang Integration**
   - Create `pt01-cpp-libclang` binary
   - Use `clang-sys` Rust bindings to libclang
   - Extract entities from simple C++ file
   - Compare output with tree-sitter extractor
   - Measure accuracy gain vs speed loss

3. **[ ] Benchmark Comparison**
   - Same C++ codebase
   - Run with tree-sitter (current)
   - Run with libclang (prototype)
   - Measure:
     - Success rate (% files parsed)
     - Entity count (completeness)
     - Time (performance cost)
     - Memory usage

### Short-term (Next 2-4 Weeks)

4. **[ ] Design Multi-Strategy Parser Architecture**
   - Sketch trait `ASTExtractor`
   - Implement adapters:
     - `TreeSitterExtractor` (refactor current)
     - `LibclangExtractor` (NEW)
     - `PrismExtractor` (for Ruby, using Prism gem)
   - Add language detection logic (file extension â†’ extractor)

5. **[ ] Build System Integration (C++)**
   - Parse `compile_commands.json`
   - Extract `-I`, `-D`, `-std=` flags per file
   - Pass to libclang extractor
   - Test on CMake-based project

6. **[ ] Ruby on Rails Domain Extractors**
   - Routes extractor (`config/routes.rb`)
   - Schema extractor (`db/schema.rb`)
   - ActiveRecord association analyzer
   - Test on real Rails app (Discourse, Gitlab, Spree)

### Medium-term (1-3 Months)

7. **[ ] LSP Integration Layer**
   - Research `tower-lsp` Rust crate
   - Build LSP client that can talk to clangd, rust-analyzer, Solargraph
   - Query for:
     - Document symbols
     - Definition locations
     - Type information
     - References
   - Convert LSP responses â†’ ISG entities
   - Store semantic info alongside syntactic info

8. **[ ] Hybrid Static + Dynamic Analysis**
   - Prototype Ruby runtime tracing (TracePoint)
   - Record method calls during test execution
   - Merge static + dynamic graphs
   - Measure accuracy improvement

9. **[ ] Incremental Indexing**
   - File watcher (notify-rs)
   - Dependency graph invalidation
   - Partial re-indexing on change
   - Benchmark real-time performance

### Long-term (3-6 Months)

10. **[ ] Language-Specific Metadata Extensions**
    - Extend ISG schema with `LanguageMetadata` enum
    - Add C++ template instantiation tracking
    - Add Ruby metaprogramming discovery
    - Add Rails convention analysis

11. **[ ] Multi-Language Project Support**
    - Test on polyglot codebases (Rust + C FFI, Python + C extensions, Rails + React)
    - Handle cross-language boundaries
    - Track FFI/JNI/WASM boundaries as special edges

12. **[ ] Documentation & Case Studies**
    - Write guide: "When to use tree-sitter vs libclang"
    - Benchmark report: C++ accuracy improvements
    - Rails analyzer walkthrough
    - Update README with language support matrix

---

## ğŸ“ Session Notes

### Key Insights from Research

1. **Tree-sitter is Not Broken - It's Just Not Designed for C++**
   - Tree-sitter was built for syntax highlighting in editors (Atom, VS Code)
   - It excels at incremental parsing and error recovery
   - It was NEVER meant to compete with libclang for semantic analysis
   - Using tree-sitter for C++ codebase analysis is like using a hammer for brain surgery

2. **The Preprocessor is the Achilles' Heel of C/C++ Analysis**
   - Every modern tool struggles with this (Semgrep, CodeQL, etc.)
   - Solutions:
     - **Clang -E**: Expand macros, then parse (loses source locations)
     - **Clang AST**: Parse with preprocessor context (slow, complex)
     - **clangd**: Index with full build system integration (requires setup)
   - There is NO silver bullet

3. **Ruby on Rails Needs Framework-Aware Analysis**
   - Generic Ruby parser is not enough
   - Rails is 70% convention, 30% code
   - Routes, schema, and associations are first-class citizens
   - Existing tools (RuboCop, Brakeman) have Rails-specific extractors
   - We should learn from them

4. **Semantic Analysis = Language Server Protocol**
   - LSP is the industry standard for semantic info
   - clangd, rust-analyzer, Pyright, Solargraph all implement LSP
   - We should leverage them instead of reinventing wheels
   - LSP gives us:
     - Type inference (even for dynamic languages)
     - Cross-file references
     - Template instantiation tracking
     - Incremental updates

5. **The 80/20 Rule for Language Support**
   - 80% of codebases are: JavaScript/TypeScript, Python, Java, Go, Rust
   - Tree-sitter handles these GREAT (static or well-typed)
   - 20% are: C/C++, Ruby (non-Rails), assembly, legacy code
   - These need special handling
   - **Recommendation**: Optimize for the 80%, provide escape hatches for the 20%

### Architectural Epiphanies

**Epiphany 1: Parseltongue Should Be a "Parser Orchestrator", Not a "Parser"**

Current mental model:
```
Parseltongue = tree-sitter wrapper
```

Better mental model:
```
Parseltongue = {
  Language detection,
  Build system integration,
  Parser orchestration (tree-sitter | libclang | LSP | custom),
  ISG normalization,
  CozoDB storage
}
```

**Benefits**:
- Each language gets best-in-class parser
- Users don't care about implementation (just API)
- We can swap parsers transparently (tree-sitter â†’ libclang for C++)

---

**Epiphany 2: ISG Should Have "Confidence Scores"**

Problem: Not all extracted entities are equally reliable

Solution: Annotate entities with confidence

```rust
struct Entity {
  entity_name: String,
  // ... other fields ...

  extraction_metadata: ExtractionMetadata,
}

struct ExtractionMetadata {
  extractor: String,  // "tree-sitter-rust" | "libclang" | "clangd-lsp"
  confidence: f32,     // 0.0 - 1.0
  warnings: Vec<String>,  // ["template not fully instantiated", "macro not expanded"]
}
```

**Use Case**:
```bash
# Export only high-confidence entities
parseltongue pt02-level01 --where-clause "extraction_metadata.confidence > 0.8"

# Show low-confidence entities (for debugging)
parseltongue pt02-level01 --where-clause "extraction_metadata.confidence < 0.5"
```

---

**Epiphany 3: C++ Requires "Lazy Semantic Analysis"**

Problem: Full semantic analysis is slow (10-60s)

Solution: Two-tier indexing

**Tier 1: Fast Syntactic Pass** (current, tree-sitter, 88s for 6K files)
- Extract function/class names
- Extract file-level includes
- Build coarse-grained dependency graph
- Export as Level 0 (edges only)

**Tier 2: Lazy Semantic Pass** (on-demand, libclang/LSP)
- Triggered when user queries specific file/entity
- Expand templates for that entity
- Resolve overloads
- Infer types
- Cache results for future queries

**Workflow**:
```bash
# Fast pass (syntactic)
parseltongue pt01 ./src --mode=fast

# User asks about specific function
parseltongue pt02-level01 --where-clause "entity_name = 'calculateFoo'"

# Behind the scenes: Lazy semantic pass for calculateFoo
# â†’ Launch libclang for that file
# â†’ Extract full signature with template params
# â†’ Cache in CozoDB
# â†’ Return enriched result
```

**Benefit**: 95% of the time, syntactic analysis is enough. Only pay for semantic when needed.

---

### Warnings & Risks

**âš ï¸ Warning 1: Scope Creep**
- Adding libclang, LSP, Rails extractors, etc. = 10x complexity
- Current Parseltongue is lean (1,067 entities, 8 crates)
- Proposal adds: 3+ new extractors, LSP client, build system parsers
- **Risk**: Becomes unmaintainable, never ships

**Mitigation**:
- Start with ONE language improvement (C++ via libclang)
- Ship, measure, iterate
- Don't boil the ocean

---

**âš ï¸ Warning 2: Dependency Hell**
- libclang requires clang installed (100+ MB)
- LSP requires language servers installed (clangd, rust-analyzer, etc.)
- Build system integration requires CMake/Cargo/Bundler
- **Risk**: User environment setup becomes nightmare

**Mitigation**:
- Make advanced extractors **optional** (cargo features)
- Provide fallback to tree-sitter if dependencies missing
- Document setup clearly

---

**âš ï¸ Warning 3: Accuracy vs Speed Trade-off**
- Users love that Parseltongue is fast (88s for 6K files)
- libclang is 5-10x slower
- **Risk**: Users reject slower tool even if more accurate

**Mitigation**:
- Default to fast mode (tree-sitter)
- Provide `--mode=accurate` flag for power users
- Show accuracy stats in output:
  ```
  Indexing complete:
  - 6,032 files processed (100% success rate)
  - 37,770 entities extracted
  - Confidence: 99.2% (libclang mode)
  - Time: 420 seconds
  ```

---

### Rabbit Holes to Avoid

1. **Don't Build a Full Compiler**
   - Parseltongue is NOT clang, rustc, or GCC
   - We don't need full type checking
   - We just need "good enough" ISG extraction

2. **Don't Support Every Language**
   - Focus on top 10: Rust, Python, JS/TS, Go, Java, C/C++, Ruby, Swift, Kotlin, C#
   - Everything else: tree-sitter fallback (best effort)

3. **Don't Implement Language-Specific Optimizations**
   - We're not competing with clangd or rust-analyzer
   - Our job: Extract ISG and get out of the way
   - Let language servers do heavy lifting

---

### Quotes to Remember

> "Tree-sitter was never meant to replace semantic analyzers. It's a syntax highlighter that can also give you a parse tree." - Tree-sitter creator

> "The preprocessor is what makes C++ analysis hard. If you can solve the preprocessor problem, you can solve C++." - Clang contributor

> "Ruby doesn't have an AST. It has a runtime. Static analysis is a best-effort approximation." - Sorbet team

> "Rails is a framework, not a language. You can't analyze Rails by analyzing Ruby." - RuboCop maintainer



---

*This is a living document - ideas flow freely here before they crystallize into code.*
