{
  "export_metadata": {
    "level": 1,
    "timestamp": "2025-11-05T08:51:55.624759+00:00",
    "total_entities": 1316,
    "include_code": true,
    "where_filter": "ALL"
  },
  "entities": [
    {
      "current_code": "pub enum AccessModifier {\n    Public,\n    Private,\n    Protected,\n    Package,\n}",
      "current_ind": 1,
      "entity_name": "AccessModifier",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"AccessModifier\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":445,\"end\":450},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:AccessModifier:__crates_parseltongue-core_src_entities_rs:445-450",
      "line_number": 0
    },
    {
      "current_code": "    pub enum AccessSpecifier {\n        Public,\n        Protected,\n        Private,\n    }",
      "current_ind": 1,
      "entity_name": "AccessSpecifier",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"AccessSpecifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":546,\"end\":550},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:AccessSpecifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:546-550",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Association {\n        HasMany { name: String, options: HashMap<String, Value> },\n        HasOne { name: String, options: HashMap<String, Value> },\n        BelongsTo { name: String, options: HashMap<String, Value> },\n        HasAndBelongsToMany { name: String, options: HashMap<String, Value> },\n    }",
      "current_ind": 1,
      "entity_name": "Association",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Association\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":726,\"end\":731},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Association:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:726-731",
      "line_number": 0
    },
    {
      "current_code": "pub enum AttributeValue {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    List(Vec<AttributeValue>),\n    Map(HashMap<String, AttributeValue>),\n}",
      "current_ind": 1,
      "entity_name": "AttributeValue",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"AttributeValue\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":225,\"end\":232},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:AttributeValue:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:225-232",
      "line_number": 0
    },
    {
      "current_code": "    pub enum BaseType {\n        Void,\n        Char,\n        Short,\n        Int,\n        Long,\n        Float,\n        Double,\n        Struct(String),\n        Typedef(String),\n    }",
      "current_ind": 1,
      "entity_name": "BaseType",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"BaseType\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":305,\"end\":315},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:BaseType:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:305-315",
      "line_number": 0
    },
    {
      "current_code": "    pub enum BinaryOp {\n        Add, Sub, Mul, Div, Mod,\n        Eq, Ne, Lt, Le, Gt, Ge,\n        And, Or,\n        Assign,\n    }",
      "current_ind": 1,
      "entity_name": "BinaryOp",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"BinaryOp\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":443,\"end\":448},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:BinaryOp:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:443-448",
      "line_number": 0
    },
    {
      "current_code": "    pub enum CParseError {\n        #[error(\"Lexical error: {0}\")]\n        LexicalError(String),\n        \n        #[error(\"Syntax error: {0}\")]\n        SyntaxError(String),\n        \n        #[error(\"Semantic error: {0}\")]\n        SemanticError(String),\n        \n        #[error(\"Preprocessor error: {0}\")]\n        PreprocessorError(String),\n    }",
      "current_ind": 1,
      "entity_name": "CParseError",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"CParseError\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":347,\"end\":359},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:CParseError:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:347-359",
      "line_number": 0
    },
    {
      "current_code": "    pub enum CStandard {\n        C89,\n        C99,\n        #[default]\n        C11,\n        C17,\n    }",
      "current_ind": 1,
      "entity_name": "CStandard",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"CStandard\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":369,\"end\":375},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:CStandard:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:369-375",
      "line_number": 0
    },
    {
      "current_code": "pub enum ChangeType {\n    Edit,\n    Create,\n    Delete,\n    Refactor,\n}",
      "current_ind": 1,
      "entity_name": "ChangeType",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ChangeType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":398,\"end\":403},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ChangeType:__crates_parseltongue-core_src_interfaces_rs:398-403",
      "line_number": 0
    },
    {
      "current_code": "pub enum ComplexityLevel {\n    Simple,\n    Moderate,\n    Complex,\n}",
      "current_ind": 1,
      "entity_name": "ComplexityLevel",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ComplexityLevel\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":530,\"end\":534},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ComplexityLevel:__crates_parseltongue-core_src_entities_rs:530-534",
      "line_number": 0
    },
    {
      "current_code": "pub enum Conflict {\n    /// Multiple changes to the same entity\n    MultipleChanges {\n        entity: String,\n        changes: Vec<TemporalChange>,\n    },\n    /// Dependency conflict\n    DependencyConflict {\n        entities: Vec<String>,\n        description: String,\n    },\n}",
      "current_ind": 1,
      "entity_name": "Conflict",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Conflict\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":573,\"end\":584},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Conflict:__crates_parseltongue-core_src_temporal_rs:573-584",
      "line_number": 0
    },
    {
      "current_code": "pub enum ConflictResolutionStrategy {\n    /// Fail fast on any conflict\n    FailFast,\n    /// Use latest change\n    UseLatest,\n    /// Use earliest change\n    UseEarliest,\n    /// Merge changes if possible\n    AttemptMerge,\n}",
      "current_ind": 1,
      "entity_name": "ConflictResolutionStrategy",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ConflictResolutionStrategy\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":451,\"end\":460},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ConflictResolutionStrategy:__crates_parseltongue-core_src_temporal_rs:451-460",
      "line_number": 0
    },
    {
      "current_code": "pub enum ContextWriterError {\n    /// Database connection or query error\n    #[error(\"Database error: {reason}\")]\n    DatabaseError { reason: String },\n\n    /// File I/O error during export\n    #[error(\"File I/O error: {reason}\")]\n    IoError { reason: String },\n\n    /// JSON serialization error\n    #[error(\"Serialization error: {reason}\")]\n    SerializationError { reason: String },\n}",
      "current_ind": 1,
      "entity_name": "ContextWriterError",
      "entity_type": "enum",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ContextWriterError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/errors.rs\",\"line_range\":{\"start\":11,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ContextWriterError:__crates_pt02-llm-cozodb-to-context-writer_src_errors_rs:11-23",
      "line_number": 0
    },
    {
      "current_code": "    pub enum CppDeclaration {\n        C(Declaration),  // Inherit C declarations\n        Class(ClassDecl),\n        Template(TemplateDecl),\n        Namespace(NamespaceDecl),\n        Using(UsingDecl),\n    }",
      "current_ind": 1,
      "entity_name": "CppDeclaration",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"CppDeclaration\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":522,\"end\":528},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:CppDeclaration:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:522-528",
      "line_number": 0
    },
    {
      "current_code": "    pub enum CppParseError {\n        #[error(\"C parse error: {0}\")]\n        CError(#[from] CParseError),\n        \n        #[error(\"Template error: {0}\")]\n        TemplateError(String),\n        \n        #[error(\"Overload resolution failed: {0}\")]\n        OverloadError(String),\n    }",
      "current_ind": 1,
      "entity_name": "CppParseError",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"CppParseError\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":598,\"end\":607},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:CppParseError:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:598-607",
      "line_number": 0
    },
    {
      "current_code": "    pub enum CppStandard {\n        Cpp98,\n        Cpp03,\n        Cpp11,\n        Cpp14,\n        Cpp17,\n        #[default]\n        Cpp20,\n        Cpp23,\n    }",
      "current_ind": 1,
      "entity_name": "CppStandard",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"CppStandard\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":616,\"end\":625},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:CppStandard:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:616-625",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Declaration {\n        Function(FunctionDecl),\n        Variable(VariableDecl),\n        Typedef(TypedefDecl),\n        Struct(StructDecl),\n    }",
      "current_ind": 1,
      "entity_name": "Declaration",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Declaration\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":281,\"end\":286},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Declaration:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:281-286",
      "line_number": 0
    },
    {
      "current_code": "pub enum EdgeKind {\n    // Inheritance\n    Extends,\n    Implements,\n    Mixes,\n    \n    // Containment\n    Contains,\n    Declares,\n    Defines,\n    \n    // References\n    Calls,\n    Uses,\n    Imports,\n    Depends,\n    \n    // Data flow\n    Reads,\n    Writes,\n    Assigns,\n    \n    // Rails associations\n    HasMany,\n    BelongsTo,\n    HasOne,\n    HasAndBelongsToMany,\n}",
      "current_ind": 1,
      "entity_name": "EdgeKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EdgeKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":195,\"end\":222},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EdgeKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:195-222",
      "line_number": 0
    },
    {
      "current_code": "pub enum EdgeType {\n    /// Function call relationship (A calls B)\n    Calls,\n    /// Usage relationship (A uses B's type/interface)\n    Uses,\n    /// Trait implementation (A implements trait B)\n    Implements,\n}",
      "current_ind": 1,
      "entity_name": "EdgeType",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EdgeType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":929,\"end\":936},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EdgeType:__crates_parseltongue-core_src_entities_rs:929-936",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityAction {\n    Create,\n    Edit,\n    Delete,\n}",
      "current_ind": 1,
      "entity_name": "EntityAction",
      "entity_type": "enum",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":32,\"end\":36},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityAction:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:32-36",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityClass {\n    /// Test implementation (unit tests, integration tests, etc.)\n    TestImplementation,\n    /// Production code implementation\n    CodeImplementation,\n}",
      "current_ind": 1,
      "entity_name": "EntityClass",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityClass\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":485,\"end\":490},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityClass:__crates_parseltongue-core_src_entities_rs:485-490",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityClass {\n    Code,\n    Test,\n}",
      "current_ind": 1,
      "entity_name": "EntityClass",
      "entity_type": "enum",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityClass\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":9,\"end\":12},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityClass:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:9-12",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityType {\n    Function,\n    Method,\n    Struct,\n    Enum,\n    Trait,\n    Interface,\n    Module,\n    ImplBlock {\n        trait_name: Option<String>,\n        struct_name: String,\n    },\n    Macro,\n    ProcMacro,\n    TestFunction,\n    Class,\n    Variable,\n    Constant,\n}",
      "current_ind": 1,
      "entity_name": "EntityType",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":98,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityType:__crates_parseltongue-core_src_entities_rs:98-116",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityType {\n    Function,\n    Struct,\n    Enum,\n    Trait,\n    Interface,  // Swift protocols, Java/C#/TypeScript interfaces\n    Impl,\n    Module,\n    Class,\n    Method,\n    Typedef,\n    Namespace,\n}",
      "current_ind": 1,
      "entity_name": "EntityType",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":47,\"end\":59},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityType:__crates_parseltongue-core_src_query_extractor_rs:47-59",
      "line_number": 0
    },
    {
      "current_code": "pub enum EntityType {\n    // Functions (all languages)\n    Function,\n\n    // Object-Oriented constructs\n    Class,      // Python, Ruby, JS/TS, Java, C#, Swift, PHP classes\n    Method,     // Methods within classes\n\n    // Rust-specific\n    Struct,     // Rust structs\n    Enum,       // Rust/Swift/Java enums\n    Trait,      // Rust traits\n    Impl,       // Rust impl blocks\n\n    // Module system\n    Module,     // Rust modules, Python modules, Ruby modules\n    Namespace,  // C++, C# namespaces\n\n    // Type system\n    Typedef,    // C/C++ typedefs, type aliases\n\n    // Variables\n    Variable,   // Module-level or global variables\n}",
      "current_ind": 1,
      "entity_name": "EntityType",
      "entity_type": "enum",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"EntityType\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":61,\"end\":84},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:EntityType:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:61-84",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ErbKind {\n        Expression,  // <%= %>\n        Statement,   // <% %>\n        Comment,     // <%# %>\n    }",
      "current_ind": 1,
      "entity_name": "ErbKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ErbKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1045,\"end\":1049},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ErbKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1045-1049",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ExpressionKind {\n        Binary { op: BinaryOp, left: Box<Expression>, right: Box<Expression> },\n        Unary { op: UnaryOp, operand: Box<Expression> },\n        Call { func: Box<Expression>, args: Vec<Expression> },\n        Identifier(String),\n        Literal(Literal),\n    }",
      "current_ind": 1,
      "entity_name": "ExpressionKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ExpressionKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":434,\"end\":440},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ExpressionKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:434-440",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ExpressionKind {\n        Literal(Value),\n        Variable(String),\n        MethodCall(MethodCall),\n        Binary { op: String, left: Box<Expression>, right: Box<Expression> },\n        Unary { op: String, operand: Box<Expression> },\n    }",
      "current_ind": 1,
      "entity_name": "ExpressionKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ExpressionKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":795,\"end\":801},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ExpressionKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:795-801",
      "line_number": 0
    },
    {
      "current_code": "pub enum FileWriterError {\n    #[error(\"File already exists: {path}\")]\n    FileAlreadyExists { path: PathBuf },\n\n    #[error(\"File not found: {path}\")]\n    FileNotFound { path: PathBuf },\n\n    #[error(\"Invalid ISGL1 key format: {key}\")]\n    InvalidIsgl1Key { key: String },\n\n    #[error(\"Future code missing for {action} operation\")]\n    MissingFutureCode { action: String },\n\n    #[error(\"Permission denied: {path}\")]\n    PermissionDenied { path: PathBuf },\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Database error: {0}\")]\n    Database(String),\n}",
      "current_ind": 1,
      "entity_name": "FileWriterError",
      "entity_type": "enum",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"FileWriterError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":6,\"end\":27},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:FileWriterError:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:6-27",
      "line_number": 0
    },
    {
      "current_code": "    pub enum FilterKind {\n        Before,\n        After,\n        Around,\n    }",
      "current_ind": 1,
      "entity_name": "FilterKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"FilterKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1010,\"end\":1014},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:FilterKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1010-1014",
      "line_number": 0
    },
    {
      "current_code": "pub enum HealthStatus {\n    Healthy,\n    Unhealthy { reason: String },\n    Unknown,\n}",
      "current_ind": 1,
      "entity_name": "HealthStatus",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"HealthStatus\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":253,\"end\":257},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:HealthStatus:__crates_parseltongue-core_src_interfaces_rs:253-257",
      "line_number": 0
    },
    {
      "current_code": "    pub enum HttpMethod {\n        Get,\n        Post,\n        Put,\n        Patch,\n        Delete,\n    }",
      "current_ind": 1,
      "entity_name": "HttpMethod",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"HttpMethod\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1076,\"end\":1082},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:HttpMethod:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1076-1082",
      "line_number": 0
    },
    {
      "current_code": "pub enum InterfaceMode {\n    Simple(SimpleUpdateConfig),\n    Advanced(AdvancedQueryConfig),\n}",
      "current_ind": 1,
      "entity_name": "InterfaceMode",
      "entity_type": "enum",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"InterfaceMode\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":150,\"end\":153},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:InterfaceMode:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:150-153",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Keyword {\n        Class,\n        Module,\n        Def,\n        End,\n        If,\n        Unless,\n        While,\n        For,\n        Return,\n    }",
      "current_ind": 1,
      "entity_name": "Keyword",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Keyword\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":926,\"end\":936},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Keyword:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:926-936",
      "line_number": 0
    },
    {
      "current_code": "pub enum Language {\n    Rust,\n    JavaScript,\n    TypeScript,\n    Python,\n    Java,\n    C,\n    Cpp,\n    Go,\n    Ruby,\n    Php,\n    CSharp,\n    Swift,\n    Kotlin,\n    Scala,\n}",
      "current_ind": 1,
      "entity_name": "Language",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Language\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":14,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Language:__crates_parseltongue-core_src_entities_rs:14-29",
      "line_number": 0
    },
    {
      "current_code": "pub enum LanguageSpecificSignature {\n    #[serde(rename = \"rust\")]\n    Rust(RustSignature),\n    #[serde(rename = \"javascript\")]\n    JavaScript(JavascriptSignature),\n    #[serde(rename = \"typescript\")]\n    TypeScript(TypeScriptSignature),\n    #[serde(rename = \"python\")]\n    Python(PythonSignature),\n    #[serde(rename = \"java\")]\n    Java(JavaSignature),\n}",
      "current_ind": 1,
      "entity_name": "LanguageSpecificSignature",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"LanguageSpecificSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":320,\"end\":331},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:LanguageSpecificSignature:__crates_parseltongue-core_src_entities_rs:320-331",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Literal {\n        Integer(i64),\n        Float(f64),\n        String(String),\n        Char(char),\n    }",
      "current_ind": 1,
      "entity_name": "Literal",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Literal\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":456,\"end\":461},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Literal:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:456-461",
      "line_number": 0
    },
    {
      "current_code": "pub enum LlmWriterError {\n    /// LLM API communication errors\n    #[error(\"LLM API error: {status} - {message}\")]\n    LlmApiError {\n        status: u16,\n        message: String,\n    },\n\n    /// Database query errors\n    #[error(\"Database query failed: {query} - {reason}\")]\n    DatabaseQueryError {\n        query: String,\n        reason: String,\n    },\n\n    /// LLM response parsing errors\n    #[error(\"Failed to parse LLM response: {reason}\")]\n    ResponseParseError {\n        reason: String,\n    },\n\n    /// Temporal change validation errors\n    #[error(\"Temporal change validation failed: {field} - {reason}\")]\n    ValidationError {\n        field: String,\n        reason: String,\n    },\n\n    /// Configuration errors\n    #[error(\"Configuration error: {field} - {reason}\")]\n    ConfigurationError {\n        field: String,\n        reason: String,\n    },\n\n    /// Rate limiting errors\n    #[error(\"Rate limit exceeded: retry after {seconds}s\")]\n    RateLimitError {\n        seconds: u64,\n    },\n\n    /// Authentication errors\n    #[error(\"Authentication failed: {reason}\")]\n    AuthenticationError {\n        reason: String,\n    },\n\n    /// Request timeout errors\n    #[error(\"Request timeout after {seconds}s\")]\n    TimeoutError {\n        seconds: u64,\n    },\n}",
      "current_ind": 1,
      "entity_name": "LlmWriterError",
      "entity_type": "enum",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"LlmWriterError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/errors.rs\",\"line_range\":{\"start\":8,\"end\":60},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:LlmWriterError:__crates_pt03-llm-to-cozodb-writer_src_errors_rs:8-60",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Member {\n        Field(FieldDecl),\n        Method(MethodDecl),\n        Constructor(ConstructorDecl),\n        Destructor(DestructorDecl),\n        TypeAlias(TypeAlias),\n    }",
      "current_ind": 1,
      "entity_name": "Member",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Member\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":553,\"end\":559},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Member:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:553-559",
      "line_number": 0
    },
    {
      "current_code": "pub enum NodeType {\n    // C/C++ node types\n    TranslationUnit,\n    Function,\n    Variable,\n    Struct,\n    Class,\n    Template,\n    Namespace,\n    \n    // Ruby/Rails node types\n    Module,\n    RubyClass,\n    Method,\n    Block,\n    Symbol,\n    \n    // Common node types\n    Expression,\n    Statement,\n    Declaration,\n    Identifier,\n    Literal,\n}",
      "current_ind": 1,
      "entity_name": "NodeType",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"NodeType\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":43,\"end\":66},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:NodeType:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:43-66",
      "line_number": 0
    },
    {
      "current_code": "pub enum Operation {\n    /// Create a new file/entity\n    Create,\n    /// Edit an existing file/entity\n    Edit,\n    /// Delete a file/entity\n    Delete,\n}",
      "current_ind": 1,
      "entity_name": "Operation",
      "entity_type": "enum",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Operation\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":105,\"end\":112},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Operation:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:105-112",
      "line_number": 0
    },
    {
      "current_code": "pub enum OptimizationStrategy {\n    BlastRadius,\n    RelevanceBased,\n    SizeBased,\n    PrioritizeTests,\n}",
      "current_ind": 1,
      "entity_name": "OptimizationStrategy",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"OptimizationStrategy\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":407,\"end\":412},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:OptimizationStrategy:__crates_parseltongue-core_src_interfaces_rs:407-412",
      "line_number": 0
    },
    {
      "current_code": "pub enum OutputFormat {\n    /// Human-readable text output\n    Text,\n    /// JSON output for machine parsing\n    Json,\n}",
      "current_ind": 1,
      "entity_name": "OutputFormat",
      "entity_type": "enum",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"OutputFormat\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":46,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:OutputFormat:__crates_pt04-syntax-preflight-validator_src_cli_rs:46-51",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ParameterKind {\n        Required,\n        Optional,\n        Rest,\n        Keyword,\n        Block,\n    }",
      "current_ind": 1,
      "entity_name": "ParameterKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ParameterKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":946,\"end\":952},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ParameterKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:946-952",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ParseError {\n        #[error(\"Unexpected end of input\")]\n        UnexpectedEof,\n        \n        #[error(\"Expected {expected}, found {found}\")]\n        Unexpected { expected: String, found: String },\n        \n        #[error(\"Parse failed: {0}\")]\n        Failed(String),\n    }",
      "current_ind": 1,
      "entity_name": "ParseError",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ParseError\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1133,\"end\":1142},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ParseError:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1133-1142",
      "line_number": 0
    },
    {
      "current_code": "pub enum ParseltongError {\n    /// Database-related errors\n    #[error(\"Database operation '{operation}' failed: {details}\")]\n    DatabaseError {\n        operation: String,\n        details: String,\n    },\n\n    /// Entity not found error\n    #[error(\"Entity not found: {isgl1_key}\")]\n    EntityNotFound {\n        isgl1_key: String,\n    },\n\n    /// File system operation errors\n    #[error(\"File system error: {path} - {source}\")]\n    FileSystemError {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n\n    /// Parsing and syntax errors\n    #[error(\"Parsing failed: {reason} at {location}\")]\n    ParseError {\n        reason: String,\n        location: String,\n    },\n\n    /// Temporal versioning errors\n    #[error(\"Temporal versioning error: {details}\")]\n    TemporalError {\n        details: String,\n    },\n\n    /// ISGL1 key format errors\n    #[error(\"Invalid ISGL1 key format: {key} - {reason}\")]\n    InvalidIsgl1Key {\n        key: String,\n        reason: String,\n    },\n\n    /// LLM communication errors\n    #[error(\"LLM communication failed: {reason}\")]\n    LlmError {\n        reason: String,\n    },\n\n    /// LSP integration errors\n    #[error(\"LSP integration error: {details}\")]\n    LspError {\n        details: String,\n    },\n\n    /// Validation errors\n    #[error(\"Validation failed: {field} - {expected}, got {actual}\")]\n    ValidationError {\n        field: String,\n        expected: String,\n        actual: String,\n    },\n\n    /// Performance constraint violations\n    #[error(\"Performance constraint violated: {constraint} - {details}\")]\n    PerformanceViolation {\n        constraint: String,\n        details: String,\n    },\n\n    /// Configuration errors\n    #[error(\"Configuration error: {details}\")]\n    ConfigurationError {\n        details: String,\n    },\n\n    /// Serialization/deserialization errors\n    #[error(\"Serialization error: {details}\")]\n    SerializationError {\n        details: String,\n    },\n\n    /// Dependency tracking errors\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::error::ParseltongError;\n    ///\n    /// let error = ParseltongError::DependencyError {\n    ///     operation: \"insert_edge\".to_string(),\n    ///     reason: \"source entity does not exist\".to_string(),\n    /// };\n    /// assert!(error.to_string().contains(\"Dependency error\"));\n    /// ```\n    #[error(\"Dependency error: {operation} - {reason}\")]\n    DependencyError {\n        operation: String,\n        reason: String,\n    },\n\n    /// Circular dependency detected\n    #[error(\"Circular dependency detected: {path}\")]\n    CircularDependency {\n        path: String,\n    },\n\n    /// Duplicate dependency edge\n    #[error(\"Duplicate dependency edge: {from_key} -> {to_key} ({edge_type})\")]\n    DuplicateEdge {\n        from_key: String,\n        to_key: String,\n        edge_type: String,\n    },\n\n    /// Missing dependency target\n    #[error(\"Dependency target not found: {to_key} referenced from {from_key}\")]\n    MissingDependencyTarget {\n        from_key: String,\n        to_key: String,\n    },\n}",
      "current_ind": 1,
      "entity_name": "ParseltongError",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ParseltongError\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":13,\"end\":132},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ParseltongError:__crates_parseltongue-core_src_error_rs:13-132",
      "line_number": 0
    },
    {
      "current_code": "    pub enum RailsFile {\n        Model(ModelFile),\n        Controller(ControllerFile),\n        View(ViewFile),\n        Migration(MigrationFile),\n        Routes(RoutesFile),\n        Ruby(RubyFile),\n    }",
      "current_ind": 1,
      "entity_name": "RailsFile",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"RailsFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":706,\"end\":713},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:RailsFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:706-713",
      "line_number": 0
    },
    {
      "current_code": "    pub enum RailsParseError {\n        #[error(\"Ruby parse error: {0}\")]\n        RubyError(String),\n        \n        #[error(\"Rails DSL error: {0}\")]\n        DslError(String),\n        \n        #[error(\"Pattern match failed: {0}\")]\n        PatternError(String),\n    }",
      "current_ind": 1,
      "entity_name": "RailsParseError",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"RailsParseError\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":870,\"end\":879},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:RailsParseError:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:870-879",
      "line_number": 0
    },
    {
      "current_code": "    pub enum RailsVersion {\n        Rails5,\n        Rails6,\n        #[default]\n        Rails7,\n    }",
      "current_ind": 1,
      "entity_name": "RailsVersion",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"RailsVersion\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":888,\"end\":893},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:RailsVersion:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:888-893",
      "line_number": 0
    },
    {
      "current_code": "pub enum RecoveryAction {\n    /// Retry the operation with exponential backoff\n    RetryWithBackoff(std::time::Duration),\n    /// Retry with modified parameters\n    RetryWithModifiedParameters,\n    /// Fall back to alternative implementation\n    UseFallback,\n    /// Skip this operation and continue\n    SkipOperation,\n    /// Abort the entire workflow\n    AbortWorkflow,\n}",
      "current_ind": 1,
      "entity_name": "RecoveryAction",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"RecoveryAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":145,\"end\":156},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:RecoveryAction:__crates_parseltongue-core_src_error_rs:145-156",
      "line_number": 0
    },
    {
      "current_code": "pub enum RiskLevel {\n    Low,\n    Medium,\n    High,\n}",
      "current_ind": 1,
      "entity_name": "RiskLevel",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"RiskLevel\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":538,\"end\":542},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:RiskLevel:__crates_parseltongue-core_src_entities_rs:538-542",
      "line_number": 0
    },
    {
      "current_code": "pub enum SemanticKind {\n    // Types\n    Type { is_primitive: bool },\n    Class { is_abstract: bool },\n    Interface,\n    Trait,\n    \n    // Functions/Methods\n    Function { is_static: bool },\n    Method { is_virtual: bool },\n    Constructor,\n    Destructor,\n    \n    // Variables\n    Variable { is_const: bool },\n    Field { is_static: bool },\n    Parameter,\n    \n    // Namespaces/Modules\n    Namespace,\n    Module,\n    Package,\n    \n    // Rails-specific\n    Model,\n    Controller,\n    Route,\n    Migration,\n}",
      "current_ind": 1,
      "entity_name": "SemanticKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"SemanticKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":152,\"end\":180},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:SemanticKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:152-180",
      "line_number": 0
    },
    {
      "current_code": "pub enum Severity {\n    Hint = 0,\n    Info = 1,\n    Warning = 2,\n    Error = 3,\n}",
      "current_ind": 1,
      "entity_name": "Severity",
      "entity_type": "enum",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Severity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":58,\"end\":63},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Severity:__crates_pt04-syntax-preflight-validator_src_errors_rs:58-63",
      "line_number": 0
    },
    {
      "current_code": "pub enum StateResetError {\n    #[error(\"Database error: {0}\")]\n    Database(String),\n\n    #[error(\"Re-indexing failed: {0}\")]\n    ReindexingFailed(String),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}",
      "current_ind": 1,
      "entity_name": "StateResetError",
      "entity_type": "enum",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"StateResetError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/errors.rs\",\"line_range\":{\"start\":5,\"end\":14},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:StateResetError:__crates_pt06-cozodb-make-future-code-current_src_errors_rs:5-14",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Statement {\n        Expression(Expression),\n        Compound(CompoundStatement),\n        If(IfStatement),\n        While(WhileStatement),\n        Return(Option<Expression>),\n    }",
      "current_ind": 1,
      "entity_name": "Statement",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Statement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":419,\"end\":425},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Statement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:419-425",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Statement {\n        Expression(Expression),\n        Assignment(Assignment),\n        MethodCall(MethodCall),\n        Return(Option<Expression>),\n        If(IfStatement),\n        Unless(UnlessStatement),\n        While(WhileStatement),\n        For(ForStatement),\n        Block(Block),\n    }",
      "current_ind": 1,
      "entity_name": "Statement",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Statement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":777,\"end\":787},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Statement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:777-787",
      "line_number": 0
    },
    {
      "current_code": "pub enum StreamerError {\n    /// File system operation errors\n    #[error(\"File system error: {path} - {source}\")]\n    FileSystemError {\n        path: String,\n        #[source]\n        source: std::io::Error,\n    },\n\n    /// Tree-sitter parsing errors\n    #[error(\"Tree-sitter parsing failed: {file} - {reason}\")]\n    ParsingError {\n        file: String,\n        reason: String,\n    },\n\n    /// ISGL1 key generation errors\n    #[error(\"ISGL1 key generation failed: {input} - {reason}\")]\n    KeyGenerationError {\n        input: String,\n        reason: String,\n    },\n\n    /// Database storage errors\n    #[error(\"Database storage error: {details}\")]\n    StorageError {\n        details: String,\n    },\n\n    /// Configuration errors\n    #[error(\"Configuration error: {field} - {reason}\")]\n    ConfigurationError {\n        field: String,\n        reason: String,\n    },\n\n    /// File too large errors\n    #[error(\"File too large: {path} ({size} bytes > {limit} bytes)\")]\n    FileTooLarge {\n        path: String,\n        size: usize,\n        limit: usize,\n    },\n\n    /// Unsupported file type\n    #[error(\"Unsupported file type: {path}\")]\n    UnsupportedFileType {\n        path: String,\n    },\n}",
      "current_ind": 1,
      "entity_name": "StreamerError",
      "entity_type": "enum",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"StreamerError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/errors.rs\",\"line_range\":{\"start\":8,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:StreamerError:__crates_pt01-folder-to-cozodb-streamer_src_errors_rs:8-57",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Symbol {\n        Type(Type),\n        Variable(Type),\n        Function(FunctionDecl),\n    }",
      "current_ind": 1,
      "entity_name": "Symbol",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Symbol\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":394,\"end\":398},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Symbol:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:394-398",
      "line_number": 0
    },
    {
      "current_code": "pub enum TaskType {\n    ChangeReasoning,\n    ValidationCheck,\n    ContextGeneration,\n    DependencyAnalysis,\n}",
      "current_ind": 1,
      "entity_name": "TaskType",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TaskType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":306,\"end\":311},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TaskType:__crates_parseltongue-core_src_interfaces_rs:306-311",
      "line_number": 0
    },
    {
      "current_code": "    pub enum TemplateParameter {\n        Type { name: String, default: Option<Type> },\n        NonType { ty: Type, name: String, default: Option<Expression> },\n        Template { parameters: Vec<TemplateParameter>, name: String },\n    }",
      "current_ind": 1,
      "entity_name": "TemplateParameter",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TemplateParameter\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":569,\"end\":573},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TemplateParameter:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:569-573",
      "line_number": 0
    },
    {
      "current_code": "    pub enum TemplateType {\n        Html,\n        Erb,\n        Haml,\n        Slim,\n    }",
      "current_ind": 1,
      "entity_name": "TemplateType",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TemplateType\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1030,\"end\":1035},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TemplateType:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1030-1035",
      "line_number": 0
    },
    {
      "current_code": "pub enum TemporalAction {\n    Create,\n    Edit,\n    Delete,\n}",
      "current_ind": 1,
      "entity_name": "TemporalAction",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TemporalAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":120,\"end\":124},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TemporalAction:__crates_parseltongue-core_src_entities_rs:120-124",
      "line_number": 0
    },
    {
      "current_code": "pub enum TestabilityLevel {\n    High,\n    Medium,\n    Low,\n}",
      "current_ind": 1,
      "entity_name": "TestabilityLevel",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TestabilityLevel\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":522,\"end\":526},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TestabilityLevel:__crates_parseltongue-core_src_entities_rs:522-526",
      "line_number": 0
    },
    {
      "current_code": "    pub enum TokenType {\n        Keyword(Keyword),\n        Identifier,\n        Symbol,\n        String,\n        Integer,\n        Float,\n        Operator,\n    }",
      "current_ind": 1,
      "entity_name": "TokenType",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TokenType\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":915,\"end\":923},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TokenType:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:915-923",
      "line_number": 0
    },
    {
      "current_code": "pub enum ToolInput {\n    /// Index a folder (Tool 1)\n    IndexFolder {\n        path: PathBuf,\n        language_filter: Option<Language>,\n    },\n\n    /// Apply temporal changes (Tool 2)\n    ApplyTemporalChanges {\n        changes: Vec<TemporalChange>,\n    },\n\n    /// Generate context (Tool 3)\n    GenerateContext {\n        query: ContextQuery,\n    },\n\n    /// Validate code (Tool 4)\n    ValidateCode {\n        validation_level: ValidationLevel,\n    },\n\n    /// Write code changes (Tool 5)\n    WriteChanges {\n        changes: Vec<CodeChange>,\n        validate_before_write: bool,\n    },\n\n    /// Reset temporal state (Tool 6)\n    ResetTemporalState {\n        reindex_path: Option<PathBuf>,\n    },\n}",
      "current_ind": 1,
      "entity_name": "ToolInput",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ToolInput\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":30,\"end\":62},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ToolInput:__crates_parseltongue-core_src_interfaces_rs:30-62",
      "line_number": 0
    },
    {
      "current_code": "pub enum ToolOutput {\n    /// Indexing completed\n    IndexingComplete {\n        entities_count: usize,\n        duration_ms: u64,\n    },\n\n    /// Temporal changes applied\n    TemporalChangesApplied {\n        changes_count: usize,\n        affected_entities: Vec<String>,\n    },\n\n    /// Context generated\n    ContextGenerated {\n        context: CodeGraphContext,\n        token_count: usize,\n    },\n\n    /// Validation results\n    ValidationResults {\n        level: ValidationLevel,\n        results: Vec<ValidationResult>,\n        success: bool,\n    },\n\n    /// Code write results\n    WriteResults {\n        files_written: Vec<PathBuf>,\n        files_modified: Vec<PathBuf>,\n        files_deleted: Vec<PathBuf>,\n    },\n\n    /// Reset completed\n    ResetComplete {\n        entities_reset: usize,\n        reindexed: bool,\n    },\n}",
      "current_ind": 1,
      "entity_name": "ToolOutput",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ToolOutput\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":66,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ToolOutput:__crates_parseltongue-core_src_interfaces_rs:66-104",
      "line_number": 0
    },
    {
      "current_code": "    pub enum TypeQualifier {\n        Const,\n        Volatile,\n        Restrict,\n    }",
      "current_ind": 1,
      "entity_name": "TypeQualifier",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"TypeQualifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":318,\"end\":322},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:TypeQualifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:318-322",
      "line_number": 0
    },
    {
      "current_code": "    pub enum UnaryOp {\n        Negate, Not, Address, Deref,\n    }",
      "current_ind": 1,
      "entity_name": "UnaryOp",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"UnaryOp\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":451,\"end\":453},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:UnaryOp:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:451-453",
      "line_number": 0
    },
    {
      "current_code": "pub enum ValidationError {\n    #[error(\"Syntax error at line {line}, column {column}: {message}\")]\n    SyntaxError {\n        line: usize,\n        column: usize,\n        message: String,\n        code_snippet: Option<String>,\n    },\n\n    #[error(\"Type error at line {line}, column {column}: expected {expected}, found {found}\")]\n    TypeError {\n        line: usize,\n        column: usize,\n        expected: String,\n        found: String,\n        message: String,\n    },\n\n    #[error(\"Borrow checker error at line {line}, column {column}: {message}\")]\n    BorrowError {\n        line: usize,\n        column: usize,\n        message: String,\n        borrow_kind: String,\n    },\n\n    #[error(\"Compilation error: {message}\")]\n    CompilationError {\n        message: String,\n        help_text: Option<String>,\n        error_code: Option<String>,\n    },\n\n    #[error(\"Test failure: {test_name} - {message}\")]\n    TestError {\n        test_name: String,\n        message: String,\n        stdout: Option<String>,\n        stderr: Option<String>,\n    },\n\n    #[error(\"Validation timeout after {timeout_ms}ms\")]\n    Timeout { timeout_ms: u64 },\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Parse error: {0}\")]\n    Parse(String),\n}",
      "current_ind": 1,
      "entity_name": "ValidationError",
      "entity_type": "enum",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":5,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationError:__crates_pt04-syntax-preflight-validator_src_errors_rs:5-54",
      "line_number": 0
    },
    {
      "current_code": "    pub enum ValidationKind {\n        Presence,\n        Uniqueness,\n        Length,\n        Format,\n        Inclusion,\n        Custom(String),\n    }",
      "current_ind": 1,
      "entity_name": "ValidationKind",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationKind\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":741,\"end\":748},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationKind:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:741-748",
      "line_number": 0
    },
    {
      "current_code": "pub enum ValidationLevel {\n    Syntax,\n    Build,\n    Test,\n}",
      "current_ind": 1,
      "entity_name": "ValidationLevel",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationLevel\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":464,\"end\":468},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationLevel:__crates_parseltongue-core_src_interfaces_rs:464-468",
      "line_number": 0
    },
    {
      "current_code": "pub enum ValidationStatus {\n    Valid,\n    Invalid { errors: Vec<ValidationError> },\n    Unknown,\n}",
      "current_ind": 1,
      "entity_name": "ValidationStatus",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationStatus\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":348,\"end\":352},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationStatus:__crates_parseltongue-core_src_interfaces_rs:348-352",
      "line_number": 0
    },
    {
      "current_code": "pub enum ValidationType {\n    /// Basic syntax validation using parser\n    Syntax,\n    /// Type checking and type inference validation\n    Type,\n    /// Borrow checker validation (Rust-specific)\n    BorrowChecker,\n    /// Full compilation validation\n    Compilation,\n    /// Test suite execution\n    Test,\n}",
      "current_ind": 1,
      "entity_name": "ValidationType",
      "entity_type": "enum",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationType\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":9,\"end\":20},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationType:__crates_pt04-syntax-preflight-validator_src_types_rs:9-20",
      "line_number": 0
    },
    {
      "current_code": "pub enum ValidationTypeArg {\n    /// Run all validations\n    All,\n    /// Syntax validation only\n    Syntax,\n    /// Type validation only\n    Type,\n    /// Borrow checker validation only\n    BorrowChecker,\n    /// Compilation validation only\n    Compilation,\n    /// Test validation only\n    Test,\n}",
      "current_ind": 1,
      "entity_name": "ValidationTypeArg",
      "entity_type": "enum",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"ValidationTypeArg\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":30,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:ValidationTypeArg:__crates_pt04-syntax-preflight-validator_src_cli_rs:30-43",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Value {\n        Nil,\n        Boolean(bool),\n        Integer(i64),\n        Float(f64),\n        String(String),\n        Symbol(String),\n        Array(Vec<Value>),\n        Hash(HashMap<Value, Value>),\n    }",
      "current_ind": 1,
      "entity_name": "Value",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Value\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":804,\"end\":813},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Value:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:804-813",
      "line_number": 0
    },
    {
      "current_code": "    pub enum Visibility {\n        Public,\n        Protected,\n        Private,\n    }",
      "current_ind": 1,
      "entity_name": "Visibility",
      "entity_type": "enum",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Visibility\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":765,\"end\":769},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Visibility:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:765-769",
      "line_number": 0
    },
    {
      "current_code": "pub enum Visibility {\n    Public,\n    Private,\n    Protected,\n    Crate,\n    Module,\n}",
      "current_ind": 1,
      "entity_name": "Visibility",
      "entity_type": "enum",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"Visibility\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":267,\"end\":273},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:Visibility:__crates_parseltongue-core_src_entities_rs:267-273",
      "line_number": 0
    },
    {
      "current_code": "pub enum WriteOperation {\n    /// Created a new file\n    Create,\n    /// Modified an existing file\n    Edit,\n    /// Deleted a file\n    Delete,\n    /// No operation performed\n    NoOp,\n}",
      "current_ind": 1,
      "entity_name": "WriteOperation",
      "entity_type": "enum",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Enum\",\"name\":\"WriteOperation\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":47,\"end\":56},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:enum:WriteOperation:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:47-56",
      "line_number": 0
    },
    {
      "current_code": "fn analyze_swift_declaration_types() {\n    let swift_code = r#\"\nclass MyClass {\n    var x: Int\n}\n\nstruct MyStruct {\n    var y: Int\n}\n\nenum MyEnum {\n    case first\n}\n\nprotocol MyProtocol {\n    func test()\n}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n    let root = tree.root_node();\n\n    println!(\"\\n=== Swift Declaration Analysis ===\");\n\n    let mut cursor = root.walk();\n    for child in root.children(&mut cursor) {\n        if child.kind() == \"class_declaration\" || child.kind() == \"protocol_declaration\" {\n            println!(\"\\nNode: {}\", child.kind());\n\n            // Find the keyword child\n            for i in 0..child.child_count() {\n                if let Some(sub_child) = child.child(i) {\n                    let kind = sub_child.kind();\n                    let text = &swift_code[sub_child.byte_range()];\n                    println!(\"  Child {}: {} = \\\"{}\\\"\", i, kind, text.trim());\n\n                    // Stop after first few children\n                    if i > 5 {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "analyze_swift_declaration_types",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_declaration_analysis.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"analyze_swift_declaration_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_declaration_analysis.rs\",\"line_range\":{\"start\":5,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:analyze_swift_declaration_types:__crates_parseltongue-core_tests_swift_declaration_analysis_rs:5-53",
      "line_number": 0
    },
    {
      "current_code": "    fn benchmark_parsing(c: &mut Criterion) {\n        let input = include_str!(\"../testdata/large_file.c\");\n        \n        c.bench_function(\"parse_c_10k_loc\", |b| {\n            b.iter(|| {\n                let parser = c::CParser::new();\n                black_box(parser.parse(input.to_string()));\n            });\n        });\n    }",
      "current_ind": 1,
      "entity_name": "benchmark_parsing",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"benchmark_parsing\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1380,\"end\":1389},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:benchmark_parsing:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1380-1389",
      "line_number": 0
    },
    {
      "current_code": "fn build_cli() -> Command {\n    Command::new(\"parseltongue\")\n        .version(env!(\"CARGO_PKG_VERSION\"))\n        .author(\"Parseltongue Team\")\n        .about(\"Ultra-minimalist CLI toolkit for code analysis and modification\")\n        .subcommand_required(false)\n        .arg_required_else_help(false)\n        .subcommand(\n            Command::new(\"pt01-folder-to-cozodb-streamer\")\n                .about(\"Tool 1: Stream folder contents to CozoDB with ISGL1 keys\")\n                .long_about(\n                    \"Examples:\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer .            # Index current directory\\n  \\\n                    parseltongue pt01-folder-to-cozodb-streamer ./src --db rocksdb:analysis.db --verbose\"\n                )\n                .arg(\n                    Arg::new(\"directory\")\n                        .help(\"Directory to index [default: current directory]\")\n                        .default_value(\".\")\n                        .index(1),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Enable verbose output\")\n                        .action(clap::ArgAction::SetTrue),\n                )\n                .arg(\n                    Arg::new(\"quiet\")\n                        .long(\"quiet\")\n                        .short('q')\n                        .help(\"Suppress output\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt02-level00\")\n                .about(\"Tool 2a: Export pure edge list (Level 0 - ~2-5K tokens) [RECOMMENDED]\")\n                .long_about(\"Export dependency edges only for graph visualization and dependency analysis.\\n\\nExample:\\n  parseltongue pt02-level00 --where-clause \\\"ALL\\\" --output edges.json\")\n                .arg(\n                    Arg::new(\"where-clause\")\n                        .long(\"where-clause\")\n                        .help(\"Datalog WHERE clause (use 'ALL' for everything)\")\n                        .long_help(\"Datalog WHERE clause or 'ALL' (MANDATORY)\\n\\nExamples:\\n  --where-clause \\\"ALL\\\"\\n  --where-clause \\\"edge_type = 'depends_on'\\\"\\n  --where-clause \\\"from_key ~ 'rust:fn'\\\"\\n\\nDatalog syntax:\\n  - AND: Use comma (,)     NOT &&\\n  - OR: Use semicolon (;)  NOT ||\\n  - Equality: Use =        NOT ==\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file path\")\n                        .default_value(\"ISGLevel00.json\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show progress and token estimates\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt02-level01\")\n                .about(\"Tool 2b: Export entities with ISG + temporal (Level 1 - ~30K tokens)\")\n                .long_about(\"Export entities with Interface Signature Graph and temporal state.\\n\\nExamples:\\n  # Signatures only (CHEAP - ~30K tokens)\\n  parseltongue pt02-level01 --include-code 0 --where-clause \\\"ALL\\\" --output entities.json\\n\\n  # With code (EXPENSIVE - 100 more tokens)\\n  parseltongue pt02-level01 --include-code 1 --where-clause \\\"future_action != null\\\" --output changes.json\")\n                .arg(\n                    Arg::new(\"include-code\")\n                        .long(\"include-code\")\n                        .help(\"Include current_code field: 0=signatures only (cheap), 1=with code (expensive)\")\n                        .value_parser([\"0\", \"1\"])\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"where-clause\")\n                        .long(\"where-clause\")\n                        .help(\"Datalog WHERE clause (use 'ALL' for everything)\")\n                        .long_help(\"Datalog WHERE clause or 'ALL' (MANDATORY)\\n\\nExamples:\\n  --where-clause \\\"ALL\\\"\\n  --where-clause \\\"is_public = true, entity_type = 'fn'\\\"\\n  --where-clause \\\"future_action != null\\\"\\n\\nDatalog syntax:\\n  - AND: Use comma (,)\\n  - OR: Use semicolon (;)\\n  - Equality: Use =\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file path\")\n                        .default_value(\"ISGLevel01.json\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show progress and token estimates\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt02-level02\")\n                .about(\"Tool 2c: Export entities with type system (Level 2 - ~60K tokens)\")\n                .long_about(\"Export entities with full type system information for type-safe refactoring.\\n\\nExamples:\\n  # Find async functions\\n  parseltongue pt02-level02 --include-code 0 --where-clause \\\"is_async = true\\\" --output async.json\\n\\n  # Find unsafe code\\n  parseltongue pt02-level02 --include-code 0 --where-clause \\\"is_unsafe = true\\\" --output unsafe.json\")\n                .arg(\n                    Arg::new(\"include-code\")\n                        .long(\"include-code\")\n                        .help(\"Include current_code field: 0=signatures only (cheap), 1=with code (expensive)\")\n                        .value_parser([\"0\", \"1\"])\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"where-clause\")\n                        .long(\"where-clause\")\n                        .help(\"Datalog WHERE clause (use 'ALL' for everything)\")\n                        .long_help(\"Datalog WHERE clause or 'ALL' (MANDATORY)\\n\\nExamples:\\n  --where-clause \\\"ALL\\\"\\n  --where-clause \\\"is_async = true\\\"\\n  --where-clause \\\"is_unsafe = true\\\"\\n  --where-clause \\\"is_public = true\\\"\\n\\nDatalog syntax:\\n  - AND: Use comma (,)\\n  - OR: Use semicolon (;)\\n  - Equality: Use =\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file path\")\n                        .default_value(\"ISGLevel02.json\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show progress and token estimates\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt03-llm-to-cozodb-writer\")\n                .about(\"Tool 3: Write LLM-proposed changes to temporal state\")\n                .arg(\n                    Arg::new(\"entity\")\n                        .long(\"entity\")\n                        .help(\"ISGL1 key of entity\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"action\")\n                        .long(\"action\")\n                        .help(\"Action type: create, edit, or delete\")\n                        .value_parser([\"create\", \"edit\", \"delete\"])\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"future-code\")\n                        .long(\"future-code\")\n                        .help(\"Future code content (required for create/edit)\"),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt04-syntax-preflight-validator\")\n                .about(\"Tool 4: Validate syntax of proposed changes\")\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                )\n                .arg(\n                    Arg::new(\"verbose\")\n                        .long(\"verbose\")\n                        .short('v')\n                        .help(\"Show detailed errors\")\n                        .action(clap::ArgAction::SetTrue),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt05-llm-cozodb-to-diff-writer\")\n                .about(\"Tool 5: Generate CodeDiff.json from temporal state\")\n                .arg(\n                    Arg::new(\"output\")\n                        .long(\"output\")\n                        .short('o')\n                        .help(\"Output JSON file\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"pt06-cozodb-make-future-code-current\")\n                .about(\"Tool 6: Make future code current and reset temporal state\")\n                .arg(\n                    Arg::new(\"project\")\n                        .long(\"project\")\n                        .help(\"Project root directory\")\n                        .required(true),\n                )\n                .arg(\n                    Arg::new(\"db\")\n                        .long(\"db\")\n                        .help(\"Database file path\")\n                        .default_value(\"parseltongue.db\"),\n                ),\n        )\n}",
      "current_ind": 1,
      "entity_name": "build_cli",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"build_cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":199,\"end\":429},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:build_cli:__crates_parseltongue_src_main_rs:199-429",
      "line_number": 0
    },
    {
      "current_code": "fn build_create_entity(isgl1_key: &str, future_code: String) -> Result<CodeEntity> {\n    // Parse file path and entity name from ISGL1 key\n    let (file_path, entity_name, language) = parse_isgl1_key_components(isgl1_key)?;\n\n    // Calculate hash before consuming future_code\n    let content_hash = calculate_hash(&future_code);\n    let now = chrono::Utc::now();\n\n    // Construct entity using functional composition\n    let entity = CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        temporal_state: TemporalState::create(),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function, // Default to Function\n            name: entity_name,\n            visibility: Visibility::Public,\n            file_path,\n            line_range: LineRange::new(1, 1)?, // Placeholder until actual insertion\n            module_path: vec![],\n            documentation: None,\n            language_specific: build_default_language_signature(language),\n        },\n        current_code: None, // CREATE action means no current code\n        future_code: Some(future_code),\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Medium,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        metadata: EntityMetadata {\n            created_at: now,\n            modified_at: now,\n            content_hash,\n            additional: HashMap::new(),\n        },\n        // v0.9.0: Add mandatory entity_class field\n        entity_class: parseltongue_core::EntityClass::CodeImplementation,\n    };\n\n    Ok(entity)\n}",
      "current_ind": 1,
      "entity_name": "build_create_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"build_create_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":42,\"end\":87},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:build_create_entity:__crates_parseltongue_src_main_rs:42-87",
      "line_number": 0
    },
    {
      "current_code": "fn build_default_language_signature(language: Language) -> LanguageSpecificSignature {\n    match language {\n        Language::Rust => LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n        _ => LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }), // Default to Rust signature for now\n    }\n}",
      "current_ind": 1,
      "entity_name": "build_default_language_signature",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"build_default_language_signature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":118,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:build_default_language_signature:__crates_parseltongue_src_main_rs:118-135",
      "line_number": 0
    },
    {
      "current_code": "fn calculate_hash(content: &str) -> String {\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    content.hash(&mut hasher);\n    format!(\"{:x}\", hasher.finish())\n}",
      "current_ind": 1,
      "entity_name": "calculate_hash",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"calculate_hash\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":138,\"end\":145},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:calculate_hash:__crates_parseltongue_src_main_rs:138-145",
      "line_number": 0
    },
    {
      "current_code": "    fn code_entity_validation() {\n        let mut entity = CodeEntity::new(\n            \"src/main.rs-main-main\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"main\".to_string(),\n                visibility: Visibility::Public,\n                file_path: PathBuf::from(\"src/main.rs\"),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![\"main\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n        entity.future_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        match entity.validate() {\n            Ok(()) => (),\n            Err(e) => {\n                println!(\"Validation error: {:?}\", e);\n                panic!(\"Entity validation failed: {:?}\", e);\n            }\n        }\n\n        // Test temporal change\n        entity.apply_temporal_change(\n            TemporalAction::Edit,\n            Some(\"fn main() { println!(\\\"Hello\\\"); }\".to_string()),\n        ).unwrap();\n\n        assert!(entity.is_modified());\n        assert!(entity.effective_code().is_some());\n    }",
      "current_ind": 1,
      "entity_name": "code_entity_validation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"code_entity_validation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1148,\"end\":1194},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:code_entity_validation:__crates_parseltongue-core_src_entities_rs:1148-1194",
      "line_number": 0
    },
    {
      "current_code": "    fn conflict_detection() {\n        let resolver = ConflictResolver::new(ConflictResolutionStrategy::FailFast);\n\n        let changes = vec![\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Edit,\n                future_code: Some(\"fn test() {}\".to_string()),\n                updated_signature: None,\n            },\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Delete,\n                future_code: None,\n                updated_signature: None,\n            },\n        ];\n\n        let conflicts = resolver.detect_conflicts(&changes);\n        assert_eq!(conflicts.len(), 1);\n\n        let result = resolver.resolve_conflicts(changes);\n        assert!(result.is_err());\n    }",
      "current_ind": 1,
      "entity_name": "conflict_detection",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"conflict_detection\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":662,\"end\":685},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:conflict_detection:__crates_parseltongue-core_src_temporal_rs:662-685",
      "line_number": 0
    },
    {
      "current_code": "fn create_config(level: u8, include_code: bool, where_filter: &str, output_path: PathBuf) -> ExportConfig {\n    ExportConfig {\n        level,\n        include_code,\n        where_filter: where_filter.to_string(),\n        output_path,\n        db_path: \"mem\".to_string(),\n        // v0.9.0: Dual output fields for code/test separation\n        code_output_path: None,\n        tests_output_path: None,\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_config",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":220,\"end\":231},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_config:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:220-231",
      "line_number": 0
    },
    {
      "current_code": "fn create_indexed_entity(\n    name: &str,\n    file: &str,\n    lines: (u32, u32),\n    entity_class: EntityClass,\n) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\n        \"rust:fn:{}:{}:{}-{}\",\n        name,\n        file.replace('/', \"_\").replace('.', \"_\"),\n        lines.0,\n        lines.1\n    );\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n    entity.tdd_classification.entity_class = entity_class;\n\n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_indexed_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_indexed_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/end_to_end_workflow.rs\",\"line_range\":{\"start\":336,\"end\":372},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_indexed_entity:__crates_parseltongue-core_tests_end_to_end_workflow_rs:336-372",
      "line_number": 0
    },
    {
      "current_code": "fn create_indexed_entity_from_project(project: &TempDir) -> Result<CodeEntity> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project.path().join(\"src/lib.rs\"))?;\n\n    let mut entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), signature)?;\n    entity.current_code = Some(current_code);\n    entity.future_code = Some(\"\".to_string());  // Will be filled by Tool 2\n    entity.temporal_state = TemporalState::unchanged();\n\n    Ok(entity)\n}",
      "current_ind": 1,
      "entity_name": "create_indexed_entity_from_project",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_indexed_entity_from_project\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":253,\"end\":281},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_indexed_entity_from_project:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:253-281",
      "line_number": 0
    },
    {
      "current_code": "fn create_simple_test_entity(key: &str) -> CodeEntity {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"test\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n    entity.current_code = Some(\"fn test() {}\".to_string());\n    entity.future_code = Some(\"\".to_string());\n    entity.temporal_state = TemporalState::unchanged();\n\n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_simple_test_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_simple_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":339,\"end\":365},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_simple_test_entity:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:339-365",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_config(level: u8, where_filter: &str) -> ExportConfig {\n    ExportConfig {\n        level,\n        include_code: false,  // N/A for Level 0\n        where_filter: where_filter.to_string(),\n        output_path: PathBuf::from(\"test.json\"),\n        db_path: \"mem\".to_string(),\n        // v0.9.0: Dual output fields for code/test separation\n        code_output_path: None,\n        tests_output_path: None,\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_config",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":95,\"end\":106},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_config:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:95-106",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_config(include_code: bool, where_filter: &str) -> ExportConfig {\n    ExportConfig {\n        level: 1,\n        include_code,\n        where_filter: where_filter.to_string(),\n        output_path: PathBuf::from(\"test.json\"),\n        db_path: \"mem\".to_string(),\n        // v0.9.0: Dual output fields for code/test separation\n        code_output_path: None,\n        tests_output_path: None,\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_config",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":119,\"end\":130},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_config:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:119-130",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_config(include_code: bool, where_filter: &str) -> ExportConfig {\n    ExportConfig {\n        level: 2,\n        include_code,\n        where_filter: where_filter.to_string(),\n        output_path: PathBuf::from(\"test.json\"),\n        db_path: \"mem\".to_string(),\n        // v0.9.0: Dual output fields for code/test separation\n        code_output_path: None,\n        tests_output_path: None,\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_config",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":101,\"end\":112},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_config:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:101-112",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_edge(from: &str, to: &str, edge_type: &str) -> Edge {\n    Edge {\n        from_key: from.to_string(),\n        to_key: to.to_string(),\n        edge_type: edge_type.to_string(),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_edge",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_edge\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":87,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_edge:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:87-93",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(file_path: &str, code: &str, entity_class: EntityClass) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: if entity_class == EntityClass::TestImplementation {\n            EntityType::TestFunction\n        } else {\n            EntityType::Function\n        },\n        name: \"test_function\".to_string(),\n        visibility: crate::entities::Visibility::Public,\n        file_path: std::path::PathBuf::from(file_path),\n        line_range: crate::entities::LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: crate::entities::LanguageSpecificSignature::Rust(\n            crate::entities::RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }\n        ),\n    };\n\n    let mut entity = CodeEntity::new(\n        format!(\"{}-test_function-fn-abc123\", file_path.replace(\"/\", \"_\").replace(\".\", \"_\")),\n        signature,\n        entity_class,\n    ).unwrap();\n\n    // Set current code for more realistic entity\n    entity.current_code = Some(code.to_string());\n    \n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":388,\"end\":422},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_parseltongue-core_src_entity_class_specifications_rs:388-422",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity() -> CodeEntity {\n    create_test_entity_with_key(\"test-file-rs-TestStruct\")\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":10,\"end\":12},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:10-12",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":21,\"end\":45},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:21-45",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(file_path: &str, entity_class: &str) -> Entity {\n    Entity {\n        isgl1_key: format!(\"rust:fn:test:{}:10\", file_path.replace(\"/\", \"_\").replace(\".\", \"_\")),\n        forward_deps: vec![],\n        reverse_deps: vec![],\n        current_ind: 1,\n        future_ind: 1,\n        future_action: None,\n        future_code: Some(\"fn test() {}\".to_string()),\n        current_code: Some(\"fn test() {}\".to_string()),\n        entity_name: \"test\".to_string(),\n        entity_type: \"Function\".to_string(),\n        file_path: file_path.to_string(),\n        line_number: 10,\n        interface_signature: \"fn test()\".to_string(),\n        doc_comment: None,\n        entity_class: entity_class.to_string(), // v0.9.0: EntityClass field\n        return_type: None,\n        param_types: None,\n        param_names: None,\n        generic_constraints: None,\n        trait_impls: None,\n        is_public: Some(true),\n        is_async: Some(false),\n        is_unsafe: Some(false),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":133,\"end\":159},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:133-159",
      "line_number": 0
    },
    {
      "current_code": "    fn create_test_entity() -> Entity {\n        Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![\"rust:fn:helper:src_lib_rs:20\".to_string()],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: Some(\"pub fn test() { }\".to_string()),\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub fn test()\".to_string(),\n            doc_comment: Some(\"Test function\".to_string()),\n            // v0.9.0: EntityClass for code/test separation\n            entity_class: \"CODE\".to_string(),\n            // Level 2 fields (not used in Level 1, but present in Entity)\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: Some(true),\n            is_async: None,\n            is_unsafe: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":236,\"end\":264},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:236-264",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(isgl1_key: &str, has_future_action: bool) -> Entity {\n    Entity {\n        isgl1_key: isgl1_key.to_string(),\n        forward_deps: vec![\"rust:fn:dependency1:src_lib_rs:100\".to_string()],\n        reverse_deps: vec![\"rust:fn:caller1:src_lib_rs:200\".to_string()],\n        current_ind: 1,\n        future_ind: if has_future_action { 1 } else { 0 },\n        future_action: if has_future_action { Some(\"Edit\".to_string()) } else { None },\n        future_code: if has_future_action {\n            Some(\"pub fn updated() { /* new code */ }\".to_string())\n        } else {\n            None\n        },\n        current_code: Some(\"pub fn original() { /* old code */ }\".to_string()),\n        entity_name: \"test_function\".to_string(),\n        entity_type: \"fn\".to_string(),\n        file_path: \"src/lib.rs\".to_string(),\n        line_number: 42,\n        interface_signature: \"pub fn test_function() -> Result<()>\".to_string(),\n        doc_comment: Some(\"Test function documentation\".to_string()),\n        // v0.9.0: EntityClass for code/test separation\n        entity_class: \"CODE\".to_string(),\n        // Level 2 fields (None for Level 1)\n        return_type: None,\n        param_types: None,\n        param_names: None,\n        generic_constraints: None,\n        trait_impls: None,\n        is_public: Some(true),\n        is_async: Some(false),\n        is_unsafe: Some(false),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":85,\"end\":117},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:85-117",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(name: &str, file: &str, lines: (u32, u32)) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: name.to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(file),\n        line_range: LineRange::new(lines.0, lines.1).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:{}:{}:{}-{}\", name, file.replace('/', \"_\"), lines.0, lines.1);\n\n    let mut entity = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity.current_code = Some(format!(\"fn {}() {{\\n    // Original code\\n}}\", name));\n\n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":21,\"end\":45},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:21-45",
      "line_number": 0
    },
    {
      "current_code": "    fn create_test_entity(isgl1_key: &str, future_code: Option<String>, temporal_state: TemporalState) -> CodeEntity {\n        CodeEntity {\n            isgl1_key: isgl1_key.to_string(),\n            temporal_state,\n            interface_signature: InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"test_func\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange { start: 1, end: 10 },\n                module_path: vec![\"test\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            current_code: None,\n            future_code,\n            tdd_classification: TddClassification {\n                entity_class: parseltongue_core::EntityClass::CodeImplementation,\n                testability: TestabilityLevel::High,\n                complexity: ComplexityLevel::Simple,\n                dependencies: 0,\n                test_coverage_estimate: 0.0,\n                critical_path: false,\n                change_risk: RiskLevel::Low,\n            },\n            lsp_metadata: None,\n            metadata: EntityMetadata {\n                created_at: Utc::now(),\n                modified_at: Utc::now(),\n                content_hash: \"test_hash\".to_string(),\n                additional: HashMap::new(),\n            },\n            // v0.9.0: Add mandatory entity_class field\n            entity_class: parseltongue_core::EntityClass::CodeImplementation,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":119,\"end\":160},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:119-160",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(isgl1_key: &str, future_code: Option<&str>, action: TemporalAction) -> CodeEntity {\n    use parseltongue_core::entities::{\n        ComplexityLevel, EntityClass, EntityMetadata, EntityType, InterfaceSignature,\n        LanguageSpecificSignature, LineRange, RiskLevel, RustSignature, TddClassification, TestabilityLevel,\n        Visibility,\n    };\n    use std::path::PathBuf;\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: Some(\"old code\".to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: isgl1_key.to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/test.rs\"),\n            line_range: LineRange {\n                start: 1,\n                end: 10,\n            },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: match action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        },\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":217,\"end\":265},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:217-265",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity(\n    isgl1_key: &str,\n    current_code: Option<&str>,\n    future_code: Option<&str>,\n    temporal_state: TemporalState,\n) -> CodeEntity {\n    // Extract file path from ISGL1 key (matching diff_generator logic)\n    let file_path = if isgl1_key.contains(\":\") {\n        // Line-based key: rust:fn:name:src_lib_rs:10-20\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 4 {\n            let sanitized_path = parts[3];\n            desanitize_path(sanitized_path)\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    } else {\n        // Hash-based key: src_lib_rs-name-type-hash\n        let parts: Vec<&str> = isgl1_key.split('-').collect();\n        if !parts.is_empty() {\n            desanitize_path(parts[0])\n        } else {\n            PathBuf::from(\"src/lib.rs\")\n        }\n    };\n\n    CodeEntity {\n        isgl1_key: isgl1_key.to_string(),\n        current_code: current_code.map(|s| s.to_string()),\n        future_code: future_code.map(|s| s.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path,\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![\"test\".to_string()],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Low,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state,\n        metadata: EntityMetadata::new().unwrap(),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":368,\"end\":427},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:368-427",
      "line_number": 0
    },
    {
      "current_code": "    fn create_test_entity(key: &str) -> CodeEntity {\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        };\n\n        CodeEntity::new(key.to_string(), signature, parseltongue_core::EntityClass::CodeImplementation).unwrap()\n    }",
      "current_ind": 1,
      "entity_name": "create_test_entity",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":101,\"end\":120},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:101-120",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_entity_with_key(key: &str) -> CodeEntity {\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Struct,\n        name: \"TestStruct\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"test/file.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![\"test\".to_string()],\n        documentation: Some(\"Test documentation\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[derive(Debug)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut entity = CodeEntity::new(key.to_string(), signature).unwrap();\n\n    // Set code to satisfy validation requirements\n    entity.current_code = Some(\"struct TestStruct {}\".to_string());\n    entity.future_code = Some(\"struct TestStruct {}\".to_string());\n\n    entity\n}",
      "current_ind": 1,
      "entity_name": "create_test_entity_with_key",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity_with_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":15,\"end\":40},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity_with_key:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:15-40",
      "line_number": 0
    },
    {
      "current_code": "    fn create_test_entity_with_types() -> Entity {\n        Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: Some(\"pub async fn test(name: &str) -> Result<()> { Ok(()) }\".to_string()),\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub async fn test(name: &str) -> Result<()>\".to_string(),\n            doc_comment: Some(\"Test function\".to_string()),\n            // v0.9.0: EntityClass for code/test separation\n            entity_class: \"CODE\".to_string(),\n            // Level 2 type system fields\n            return_type: Some(\"Result<()>\".to_string()),\n            param_types: Some(vec![\"&str\".to_string()]),\n            param_names: Some(vec![\"name\".to_string()]),\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: Some(true),\n            is_async: Some(true),\n            is_unsafe: Some(false),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create_test_entity_with_types",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_entity_with_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":211,\"end\":239},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_entity_with_types:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:211-239",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_project_with_subtraction_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with bug\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be + not -\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
      "current_ind": 1,
      "entity_name": "create_test_project_with_subtraction_bug",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_project_with_subtraction_bug\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":215,\"end\":253},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_project_with_subtraction_bug:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:215-253",
      "line_number": 0
    },
    {
      "current_code": "fn create_test_rust_project_with_bug() -> Result<TempDir> {\n    let temp_dir = TempDir::new()?;\n    let project_path = temp_dir.path();\n\n    // Create src directory\n    std::fs::create_dir(project_path.join(\"src\"))?;\n\n    // Create Cargo.toml\n    std::fs::write(\n        project_path.join(\"Cargo.toml\"),\n        r#\"[package]\nname = \"test-project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#,\n    )?;\n\n    // Create src/lib.rs with a bug (subtract instead of add)\n    std::fs::write(\n        project_path.join(\"src/lib.rs\"),\n        r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a - b  // BUG: Should be a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will fail!\n    }\n}\n\"#,\n    )?;\n\n    Ok(temp_dir)\n}",
      "current_ind": 1,
      "entity_name": "create_test_rust_project_with_bug",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_test_rust_project_with_bug\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":192,\"end\":230},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_test_rust_project_with_bug:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:192-230",
      "line_number": 0
    },
    {
      "current_code": "fn create_typed_entity(isgl1_key: &str) -> Entity {\n    Entity {\n        isgl1_key: isgl1_key.to_string(),\n        forward_deps: vec![],\n        reverse_deps: vec![],\n        current_ind: 1,\n        future_ind: 0,\n        future_action: None,\n        future_code: None,\n        current_code: Some(\"pub fn test() -> Result<()> { Ok(()) }\".to_string()),\n        entity_name: \"test_function\".to_string(),\n        entity_type: \"fn\".to_string(),\n        file_path: \"src/lib.rs\".to_string(),\n        line_number: 42,\n        interface_signature: \"pub fn test_function() -> Result<()>\".to_string(),\n        doc_comment: Some(\"Test function\".to_string()),\n        // v0.9.0: EntityClass for code/test separation\n        entity_class: \"CODE\".to_string(),\n        // Level 2 fields (type system)\n        return_type: Some(\"Result<()>\".to_string()),\n        param_types: Some(vec![\"&str\".to_string(), \"i32\".to_string()]),\n        param_names: Some(vec![\"name\".to_string(), \"count\".to_string()]),\n        generic_constraints: Some(vec![\"T: Clone\".to_string()]),\n        trait_impls: Some(vec![\"Debug\".to_string(), \"Clone\".to_string()]),\n        is_public: Some(true),\n        is_async: Some(false),\n        is_unsafe: Some(false),\n    }\n}",
      "current_ind": 1,
      "entity_name": "create_typed_entity",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_typed_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":71,\"end\":99},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_typed_entity:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:71-99",
      "line_number": 0
    },
    {
      "current_code": "fn create_zero_dependency_file(dir: &PathBuf) -> PathBuf {\n    let file_path = dir.join(\"simple.rs\");\n    let content = r#\"\n// Simple function with NO dependencies (doesn't call anything)\npub fn standalone() -> i32 {\n    42\n}\n\n// Another standalone function\nfn helper() -> bool {\n    true\n}\n\"#;\n    fs::write(&file_path, content).expect(\"Failed to write test file\");\n    file_path\n}",
      "current_ind": 1,
      "entity_name": "create_zero_dependency_file",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"create_zero_dependency_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs\",\"line_range\":{\"start\":35,\"end\":50},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:create_zero_dependency_file:__crates_parseltongue-core_tests_pt02_level00_zero_dependencies_test_rs:35-50",
      "line_number": 0
    },
    {
      "current_code": "fn debug_full_swift_code() {\n    let swift_code = r#\"\n// Test Swift file for entity extraction\nimport Foundation\n\n// Function\nfunc calculateSum(a: Int, b: Int) -> Int {\n    return a + b\n}\n\n// Class\nclass UserManager {\n    var users: [String] = []\n\n    func addUser(name: String) {\n        users.append(name)\n    }\n}\n\n// Struct\nstruct Point {\n    var x: Double\n    var y: Double\n\n    func distance(to other: Point) -> Double {\n        let dx = x - other.x\n        let dy = y - other.y\n        return sqrt(dx * dx + dy * dy)\n    }\n}\n\n// Enum\nenum Direction {\n    case north\n    case south\n    case east\n    case west\n}\n\n// Protocol\nprotocol Drawable {\n    func draw()\n}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n\n    println!(\"\\n=== Swift Parse Tree (Top Level) ===\");\n    let root = tree.root_node();\n    let mut cursor = root.walk();\n\n    for child in root.children(&mut cursor) {\n        let text_snippet = &swift_code[child.byte_range()];\n        let first_line = text_snippet.lines().next().unwrap_or(\"\");\n        println!(\n            \"{} at lines {}-{}: {}\",\n            child.kind(),\n            child.start_position().row + 1,\n            child.end_position().row + 1,\n            first_line.chars().take(60).collect::<String>()\n        );\n    }\n\n    // Now test the query\n    let swift_query = include_str!(\"../../../entity_queries/swift.scm\");\n    let query = Query::new(&swift_lang, swift_query).unwrap();\n\n    let mut query_cursor = QueryCursor::new();\n    let mut matches = query_cursor.matches(&query, tree.root_node(), swift_code.as_bytes());\n\n    println!(\"\\n=== Query Matches ===\");\n    while let Some(m) = matches.next() {\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &swift_code[capture.node.byte_range()];\n\n            if *capture_name == \"name\" {\n                let def_type = m.captures.iter()\n                    .find(|c| query.capture_names()[c.index as usize].starts_with(\"definition.\"))\n                    .map(|c| &query.capture_names()[c.index as usize])\n                    .unwrap_or(&\"unknown\");\n\n                println!(\"{}: {} (line {})\", def_type, text.trim(), capture.node.start_position().row + 1);\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "debug_full_swift_code",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_full_code_debug.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"debug_full_swift_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_full_code_debug.rs\",\"line_range\":{\"start\":5,\"end\":95},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:debug_full_swift_code:__crates_parseltongue-core_tests_swift_full_code_debug_rs:5-95",
      "line_number": 0
    },
    {
      "current_code": "fn debug_protocol_ast() {\n    let swift_code = r#\"\nprotocol Drawable {\n    func draw()\n}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n    let root = tree.root_node();\n\n    println!(\"\\n=== Swift Protocol AST ===\");\n    print_tree(root, swift_code, 0);\n}",
      "current_ind": 1,
      "entity_name": "debug_protocol_ast",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_protocol_debug.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"debug_protocol_ast\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_protocol_debug.rs\",\"line_range\":{\"start\":5,\"end\":21},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:debug_protocol_ast:__crates_parseltongue-core_tests_swift_protocol_debug_rs:5-21",
      "line_number": 0
    },
    {
      "current_code": "async fn demo_5_line_code_change() {\n    println!(\"\\n\");\n    println!(\"         Tool 5 Demo: 5-Line Code Change                      \");\n    println!(\"\\n\");\n\n    // Setup: In-memory CozoDB\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    println!(\" Scenario: Editing a simple function in src/lib.rs\");\n    println!();\n\n    // CURRENT CODE (before) - 5 lines\n    let current_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // TODO: Add error handling\n    a + b\n}\"#;\n\n    // FUTURE CODE (after) - 5 lines with improvement\n    let future_code = r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    // Added validation for overflow\n    a.checked_add(b).unwrap_or(i32::MAX)\n}\"#;\n\n    println!(\" CURRENT CODE (lines 10-14 in src/lib.rs):\");\n    println!(\"\");\n    println!(\"{}\", current_code);\n    println!();\n\n    println!(\" FUTURE CODE (improved version):\");\n    println!(\"\");\n    println!(\"{}\", future_code);\n    println!();\n\n    // Create entity representing this change\n    let entity = CodeEntity {\n        isgl1_key: \"rust:fn:calculate_sum:src_lib_rs:10-14\".to_string(),\n        current_code: Some(current_code.to_string()),\n        future_code: Some(future_code.to_string()),\n        interface_signature: InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"calculate_sum\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"src/lib.rs\"),\n            line_range: LineRange { start: 10, end: 14 },\n            module_path: vec![\"crate\".to_string()],\n            documentation: Some(\"Calculates sum with overflow protection\".to_string()),\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        },\n        tdd_classification: TddClassification {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::High,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.8,\n            critical_path: false,\n            change_risk: RiskLevel::Low,\n        },\n        lsp_metadata: None,\n        temporal_state: TemporalState::edit(),\n        metadata: EntityMetadata::new().unwrap(),\n    };\n\n    // Insert into CozoDB\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate CodeDiff.json using Tool 5\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    println!(\" Tool 5 Output Summary:\");\n    println!(\"\");\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  Edit operations: {}\", diff.metadata.edit_count);\n    println!(\"  Generated at: {}\", diff.metadata.generated_at);\n    println!();\n\n    println!(\" Generated CodeDiff.json:\");\n    println!(\"\\n\");\n    let json = diff.to_json_pretty().unwrap();\n    println!(\"{}\", json);\n    println!();\n    println!(\"\\n\");\n\n    println!(\" Key Features Demonstrated:\");\n    println!(\"   current_code     Shows exactly what to replace\");\n    println!(\"   future_code      Shows the improved version\");\n    println!(\"   line_range       Precise location (lines 10-14)\");\n    println!(\"   operation: EDIT  LLM knows this is a modification\");\n    println!();\n    println!(\" LLM can now make surgical edits without touching the rest of the file!\");\n    println!();\n\n    // Validate the output\n    assert_eq!(diff.changes.len(), 1);\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, pt05_llm_cozodb_to_diff_writer::Operation::Edit);\n    assert!(change.current_code.is_some());\n    assert!(change.future_code.is_some());\n    assert!(change.line_range.is_some());\n    assert_eq!(change.line_range.unwrap().start, 10);\n    assert_eq!(change.line_range.unwrap().end, 14);\n}",
      "current_ind": 1,
      "entity_name": "demo_5_line_code_change",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/demo_5_line_change.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"demo_5_line_code_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/demo_5_line_change.rs\",\"line_range\":{\"start\":14,\"end\":122},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:demo_5_line_code_change:__crates_pt05-llm-cozodb-to-diff-writer_tests_demo_5_line_change_rs:14-122",
      "line_number": 0
    },
    {
      "current_code": "fn desanitize_path(sanitized: &str) -> PathBuf {\n    // Common file extensions\n    let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n    // Find and replace extension suffix\n    for ext in extensions {\n        if let Some(idx) = sanitized.rfind(ext) {\n            if idx + ext.len() == sanitized.len() {\n                // Found extension at end\n                let path_part = &sanitized[..idx]; // \"src_lib\"\n                let ext_part = &ext[1..]; // \"rs\"\n                let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                return PathBuf::from(file_path);\n            }\n        }\n    }\n\n    // No known extension found, treat as-is\n    PathBuf::from(sanitized.replace('_', \"/\"))\n}",
      "current_ind": 1,
      "entity_name": "desanitize_path",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"desanitize_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":443,\"end\":462},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:desanitize_path:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:443-462",
      "line_number": 0
    },
    {
      "current_code": "fn detect_test_from_content(path: &std::path::Path, content: &str) -> bool {\n    use crate::test_detector::{TestDetector, DefaultTestDetector, EntityClass};\n    \n    let detector = DefaultTestDetector::new();\n    let result = detector.detect_test_from_path_and_name(path, content);\n    \n    matches!(result, EntityClass::Test)\n}",
      "current_ind": 1,
      "entity_name": "detect_test_from_content",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"detect_test_from_content\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":354,\"end\":361},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:detect_test_from_content:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:354-361",
      "line_number": 0
    },
    {
      "current_code": "    fn entity_creation_and_modification() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Create entity\n        let mut entity = CodeEntity::new(\n            \"test.rs-compute_result\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"calculate_value\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange::new(1, 5).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            crate::entities::EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn test() {}\".to_string());\n        entity.future_code = Some(\"fn test() {}\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        manager.add_entity(entity).unwrap();\n\n        // Apply edit change\n        let changes = vec![TemporalChange {\n            isgl1_key: \"test.rs-compute_result\".to_string(),\n            action: TemporalAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            updated_signature: None,\n        }];\n\n        let affected = manager.apply_changes(changes).unwrap();\n        assert_eq!(affected.len(), 1);\n        assert_eq!(affected[0], \"test.rs-compute_result\");\n\n        let changed_entities = manager.get_changed_entities();\n        assert_eq!(changed_entities.len(), 1);\n    }",
      "current_ind": 1,
      "entity_name": "entity_creation_and_modification",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"entity_creation_and_modification\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":597,\"end\":646},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:entity_creation_and_modification:__crates_parseltongue-core_src_temporal_rs:597-646",
      "line_number": 0
    },
    {
      "current_code": "    fn error_chain_preserves_context() {\n        let io_error = std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            \"file not found\"\n        );\n\n        let parseltong_error = ParseltongError::FileSystemError {\n            path: \"test.txt\".to_string(),\n            source: io_error,\n        };\n\n        // The error should contain both the path and the underlying IO error\n        let error_string = parseltong_error.to_string();\n        assert!(error_string.contains(\"test.txt\"));\n        assert!(error_string.contains(\"file not found\"));\n    }",
      "current_ind": 1,
      "entity_name": "error_chain_preserves_context",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"error_chain_preserves_context\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":182,\"end\":197},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:error_chain_preserves_context:__crates_parseltongue-core_src_error_rs:182-197",
      "line_number": 0
    },
    {
      "current_code": "    fn error_formatting_provides_clear_context() {\n        let error = ParseltongError::ParseError {\n            reason: \"unexpected token\".to_string(),\n            location: \"src/main.rs:42\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Parsing failed\"));\n        assert!(formatted.contains(\"unexpected token\"));\n        assert!(formatted.contains(\"src/main.rs:42\"));\n    }",
      "current_ind": 1,
      "entity_name": "error_formatting_provides_clear_context",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"error_formatting_provides_clear_context\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":169,\"end\":179},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:error_formatting_provides_clear_context:__crates_parseltongue-core_src_error_rs:169-179",
      "line_number": 0
    },
    {
      "current_code": "fn explore_calls_in_control_flow() {\n    let source = r#\"\nfn main() {\n    if validate(5) {\n        process(5)\n    } else {\n        fallback()\n    }\n}\n\"#;\n\n    let mut parser = Parser::new();\n    parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();\n    let tree = parser.parse(source, None).unwrap();\n\n    println!(\"\\n=== AST for calls in control flow ===\");\n    print_tree(tree.root_node(), source, 0, 15);\n\n    let dep_query = r#\"\n(call_expression\n  function: (identifier) @reference.call) @dependency.call\n\"#;\n\n    println!(\"\\n=== Query Matches ===\");\n    let query = Query::new(&tree_sitter_rust::LANGUAGE.into(), dep_query).unwrap();\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n\n    let mut match_count = 0;\n    while let Some(m) = matches.next() {\n        match_count += 1;\n        println!(\"Match #{}:\", match_count);\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &source[capture.node.byte_range()];\n            println!(\"  {} = \\\"{}\\\" at line {}\", capture_name, text, capture.node.start_position().row);\n        }\n    }\n\n    println!(\"\\nTotal matches: {} (expected 3: validate, process, fallback)\", match_count);\n    assert_eq!(match_count, 3, \"Should capture all three function calls\");\n}",
      "current_ind": 1,
      "entity_name": "explore_calls_in_control_flow",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/ast_exploration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"explore_calls_in_control_flow\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/ast_exploration_test.rs\",\"line_range\":{\"start\":203,\"end\":244},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:explore_calls_in_control_flow:__crates_parseltongue-core_tests_ast_exploration_test_rs:203-244",
      "line_number": 0
    },
    {
      "current_code": "fn explore_macro_invocations() {\n    let source = r#\"\nfn main() {\n    println!(\"{:?}\", config.get(\"test\"));\n    vec![create_item(), create_item()];\n}\n\"#;\n\n    let mut parser = Parser::new();\n    parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();\n    let tree = parser.parse(source, None).unwrap();\n\n    println!(\"\\n=== AST for macro invocations ===\");\n    print_tree(tree.root_node(), source, 0, 15);\n\n    // Check if macro_invocation nodes exist\n    let macro_query = r#\"\n(macro_invocation\n  macro: (identifier) @macro_name) @macro\n\"#;\n\n    println!(\"\\n=== Macro Invocation Matches ===\");\n    let query = Query::new(&tree_sitter_rust::LANGUAGE.into(), macro_query).unwrap();\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n\n    let mut match_count = 0;\n    while let Some(m) = matches.next() {\n        match_count += 1;\n        println!(\"Match #{}:\", match_count);\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &source[capture.node.byte_range()];\n            println!(\"  {} = \\\"{}\\\" at line {}\", capture_name, text, capture.node.start_position().row);\n        }\n    }\n\n    println!(\"\\nTotal macro matches: {}\", match_count);\n\n    // Now check for calls WITHIN macros\n    let call_query = r#\"\n(call_expression\n  function: [\n    (identifier) @reference.call\n    (field_expression\n      field: (field_identifier) @reference.call)\n  ]) @dependency.call\n\"#;\n\n    println!(\"\\n=== Call Expressions (including within macros) ===\");\n    let query = Query::new(&tree_sitter_rust::LANGUAGE.into(), call_query).unwrap();\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n\n    let mut match_count = 0;\n    while let Some(m) = matches.next() {\n        match_count += 1;\n        println!(\"Match #{}:\", match_count);\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &source[capture.node.byte_range()];\n            println!(\"  {} = \\\"{}\\\" at line {}\", capture_name, text, capture.node.start_position().row);\n        }\n    }\n\n    println!(\"\\nTotal call matches: {}\", match_count);\n}",
      "current_ind": 1,
      "entity_name": "explore_macro_invocations",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/ast_exploration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"explore_macro_invocations\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/ast_exploration_test.rs\",\"line_range\":{\"start\":134,\"end\":200},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:explore_macro_invocations:__crates_parseltongue-core_tests_ast_exploration_test_rs:134-200",
      "line_number": 0
    },
    {
      "current_code": "fn explore_method_calls_in_chain() {\n    let source = r#\"\nfn main() {\n    let users = vec![1, 2, 3];\n    let result: Vec<i32> = users.iter().map(|x| validate(*x)).collect();\n}\n\nfn validate(x: i32) -> bool {\n    x > 0\n}\n\"#;\n\n    let mut parser = Parser::new();\n    parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();\n    let tree = parser.parse(source, None).unwrap();\n\n    println!(\"\\n=== AST for chained method calls ===\");\n    print_tree(tree.root_node(), source, 0, 15);\n\n    let dep_query = r#\"\n(call_expression\n  function: [\n    (identifier) @reference.call\n    (field_expression\n      field: (field_identifier) @reference.call)\n    (scoped_identifier\n      name: (identifier) @reference.call)\n  ]) @dependency.call\n\"#;\n\n    println!(\"\\n=== Query Matches for Method Chains ===\");\n    let query = Query::new(&tree_sitter_rust::LANGUAGE.into(), dep_query).unwrap();\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n\n    let mut match_count = 0;\n    while let Some(m) = matches.next() {\n        match_count += 1;\n        println!(\"Match #{}:\", match_count);\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &source[capture.node.byte_range()];\n            println!(\"  {} = \\\"{}\\\" at line {}\", capture_name, text, capture.node.start_position().row);\n        }\n    }\n\n    println!(\"\\nTotal matches: {}\", match_count);\n}",
      "current_ind": 1,
      "entity_name": "explore_method_calls_in_chain",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/ast_exploration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"explore_method_calls_in_chain\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/ast_exploration_test.rs\",\"line_range\":{\"start\":84,\"end\":131},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:explore_method_calls_in_chain:__crates_parseltongue-core_tests_ast_exploration_test_rs:84-131",
      "line_number": 0
    },
    {
      "current_code": "fn explore_nested_call_in_struct_construction() {\n    let source = r#\"\nimpl Config {\n    fn new() -> Self {\n        Self {\n            settings: create_defaults(),\n        }\n    }\n}\n\"#;\n\n    let mut parser = Parser::new();\n    parser.set_language(&tree_sitter_rust::LANGUAGE.into()).unwrap();\n    let tree = parser.parse(source, None).unwrap();\n\n    println!(\"\\n=== AST for nested call in struct construction ===\");\n    print_tree(tree.root_node(), source, 0, 15);\n\n    // Test our current query\n    let dep_query = r#\"\n(call_expression\n  function: [\n    (identifier) @reference.call\n    (field_expression\n      field: (field_identifier) @reference.call)\n    (scoped_identifier\n      name: (identifier) @reference.call)\n  ]) @dependency.call\n\"#;\n\n    println!(\"\\n=== Current Query Matches ===\");\n    let query = Query::new(&tree_sitter_rust::LANGUAGE.into(), dep_query).unwrap();\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n\n    let mut match_count = 0;\n    while let Some(m) = matches.next() {\n        match_count += 1;\n        println!(\"Match #{}:\", match_count);\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &source[capture.node.byte_range()];\n            println!(\"  {} = \\\"{}\\\" at line {}\", capture_name, text, capture.node.start_position().row);\n        }\n    }\n\n    assert!(match_count > 0, \"Should capture the create_defaults() call\");\n}",
      "current_ind": 1,
      "entity_name": "explore_nested_call_in_struct_construction",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/ast_exploration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"explore_nested_call_in_struct_construction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/ast_exploration_test.rs\",\"line_range\":{\"start\":34,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:explore_nested_call_in_struct_construction:__crates_parseltongue-core_tests_ast_exploration_test_rs:34-81",
      "line_number": 0
    },
    {
      "current_code": "fn explore_swift_ast_node_types() {\n    let swift_code = r#\"\n// Swift test code\nfunc myFunction() {\n    print(\"Hello\")\n}\n\nclass MyClass {\n    var name: String\n}\n\nstruct MyStruct {\n    var id: Int\n}\n\nprotocol MyProtocol {\n    func doSomething()\n}\n\nenum MyEnum {\n    case first\n    case second\n}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n    let root = tree.root_node();\n\n    println!(\"\\n=== Swift AST Structure ===\");\n    print_tree(root, swift_code, 0);\n}",
      "current_ind": 1,
      "entity_name": "explore_swift_ast_node_types",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_ast_explorer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"explore_swift_ast_node_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_ast_explorer.rs\",\"line_range\":{\"start\":5,\"end\":39},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:explore_swift_ast_node_types:__crates_parseltongue-core_tests_swift_ast_explorer_rs:5-39",
      "line_number": 0
    },
    {
      "current_code": "async fn extract_dependencies(source: &str) -> Vec<DependencyEdge> {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"test.rs\");\n    std::fs::write(&test_file, source).unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    storage.get_all_dependencies().await.unwrap()\n}",
      "current_ind": 1,
      "entity_name": "extract_dependencies",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"extract_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":348,\"end\":371},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:extract_dependencies:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:348-371",
      "line_number": 0
    },
    {
      "current_code": "fn extract_optional_string(row: &[cozo::DataValue], index: usize) -> Option<String> {\n    match &row[index] {\n        cozo::DataValue::Str(s) => Some(s.to_string()),\n        cozo::DataValue::Null => None,\n        _ => None,\n    }\n}",
      "current_ind": 1,
      "entity_name": "extract_optional_string",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"extract_optional_string\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":224,\"end\":230},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:extract_optional_string:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:224-230",
      "line_number": 0
    },
    {
      "current_code": "fn extract_string(row: &[cozo::DataValue], index: usize) -> Result<String> {\n    match &row[index] {\n        cozo::DataValue::Str(s) => Ok(s.to_string()),\n        other => Err(anyhow!(\"Expected string at index {}, got {:?}\", index, other)),\n    }\n}",
      "current_ind": 1,
      "entity_name": "extract_string",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"extract_string\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":216,\"end\":221},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:extract_string:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:216-221",
      "line_number": 0
    },
    {
      "current_code": "fn extract_u8(row: &[cozo::DataValue], index: usize) -> Result<u8> {\n    match &row[index] {\n        cozo::DataValue::Bool(b) => Ok(if *b { 1 } else { 0 }),\n        other => Err(anyhow!(\"Expected bool at index {}, got {:?}\", index, other)),\n    }\n}",
      "current_ind": 1,
      "entity_name": "extract_u8",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"extract_u8\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":233,\"end\":238},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:extract_u8:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:233-238",
      "line_number": 0
    },
    {
      "current_code": "fn find_call_source(deps: &[DependencyEdge], target: &str) -> Option<String> {\n    deps.iter()\n        .find(|d| d.to_key.as_str().contains(target))\n        .map(|d| d.from_key.as_str().to_string())\n}",
      "current_ind": 1,
      "entity_name": "find_call_source",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"find_call_source\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":377,\"end\":381},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:find_call_source:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:377-381",
      "line_number": 0
    },
    {
      "current_code": "fn generate_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n    }\n}\n\"#\n    .to_string()\n}",
      "current_ind": 1,
      "entity_name": "generate_fixed_code",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"generate_fixed_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":321,\"end\":338},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:generate_fixed_code:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:321-338",
      "line_number": 0
    },
    {
      "current_code": "async fn generate_large_graph(\n    db: &CozoDbStorage,\n    num_nodes: usize,\n    avg_edges_per_node: usize,\n) -> Vec<String> {\n    let mut nodes = Vec::new();\n    let mut edges = Vec::new();\n\n    // Generate nodes\n    for i in 0..num_nodes {\n        let key = format!(\"rust:fn:node_{}:perf_test_rs:{}-{}\", i, i * 10, i * 10 + 5);\n        nodes.push(key.clone());\n    }\n\n    // Generate edges with realistic graph structure (not fully connected)\n    for i in 0..num_nodes {\n        let num_edges = avg_edges_per_node.min(num_nodes - i - 1);\n        for j in 1..=num_edges {\n            if i + j < num_nodes {\n                let edge = DependencyEdge::builder()\n                    .from_key(&nodes[i])\n                    .to_key(&nodes[i + j])\n                    .edge_type(EdgeType::Calls)\n                    .build()\n                    .unwrap();\n                edges.push(edge);\n            }\n        }\n    }\n\n    // Batch insert all edges\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    nodes\n}",
      "current_ind": 1,
      "entity_name": "generate_large_graph",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"generate_large_graph\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":861,\"end\":895},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:generate_large_graph:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:861-895",
      "line_number": 0
    },
    {
      "current_code": "fn generate_rust_code(lines: usize) -> String {\n    (0..lines)\n        .map(|i| format!(\"fn func_{}() {{ println!(\\\"test\\\"); }}\", i))\n        .collect::<Vec<_>>()\n        .join(\"\\n\")\n}",
      "current_ind": 1,
      "entity_name": "generate_rust_code",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"generate_rust_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":164,\"end\":169},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:generate_rust_code:__crates_parseltongue-core_tests_query_based_extraction_test_rs:164-169",
      "line_number": 0
    },
    {
      "current_code": "fn get_fixed_code() -> String {\n    r#\"/// Calculate the sum of two numbers\npub fn add(a: i32, b: i32) -> i32 {\n    a + b  // FIXED: Changed from a - b to a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);  // This will pass!\n    }\n}\n\"#\n    .to_string()\n}",
      "current_ind": 1,
      "entity_name": "get_fixed_code",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"get_fixed_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":233,\"end\":250},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:get_fixed_code:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:233-250",
      "line_number": 0
    },
    {
      "current_code": "fn group_changes_by_file(changes: &[Change]) -> HashMap<PathBuf, Vec<&Change>> {\n    let mut grouped: HashMap<PathBuf, Vec<&Change>> = HashMap::new();\n    for change in changes {\n        grouped\n            .entry(change.file_path.clone())\n            .or_insert_with(Vec::new)\n            .push(change);\n    }\n    grouped\n}",
      "current_ind": 1,
      "entity_name": "group_changes_by_file",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"group_changes_by_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":430,\"end\":439},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:group_changes_by_file:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:430-439",
      "line_number": 0
    },
    {
      "current_code": "fn has_call(deps: &[DependencyEdge], target: &str) -> bool {\n    deps.iter().any(|d| d.to_key.as_str().contains(target))\n}",
      "current_ind": 1,
      "entity_name": "has_call",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"has_call\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":373,\"end\":375},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:has_call:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:373-375",
      "line_number": 0
    },
    {
      "current_code": "    pub fn identifier<'a>() -> impl ParserCombinator<'a, &'a str> {\n        Identifier\n    }",
      "current_ind": 1,
      "entity_name": "identifier",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"identifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1323,\"end\":1325},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:identifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1323-1325",
      "line_number": 0
    },
    {
      "current_code": "    fn invalid_temporal_state() {\n        let invalid_state = TemporalState {\n            current_ind: false,\n            future_ind: false,\n            future_action: None,\n        };\n\n        assert!(invalid_state.validate().is_err());\n    }",
      "current_ind": 1,
      "entity_name": "invalid_temporal_state",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"invalid_temporal_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1111,\"end\":1119},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:invalid_temporal_state:__crates_parseltongue-core_src_entities_rs:1111-1119",
      "line_number": 0
    },
    {
      "current_code": "fn is_under_git_subdirectory(path: &std::path::Path, project_root: &std::path::Path) -> bool {\n    let mut current = path;\n    \n    // Walk up parent directories looking for .git\n    while let Some(parent) = current.parent() {\n        // Stop at project root (don't exclude project root itself)\n        if parent == project_root {\n            break;\n        }\n        \n        // Don't go beyond project root\n        if !parent.starts_with(project_root) {\n            break;\n        }\n\n        // Check if this parent directory contains .git\n        if parent.join(\".git\").exists() {\n            return true; // Found nested git repo\n        }\n\n        current = parent;\n    }\n\n    false\n}",
      "current_ind": 1,
      "entity_name": "is_under_git_subdirectory",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"is_under_git_subdirectory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":327,\"end\":351},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:is_under_git_subdirectory:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:327-351",
      "line_number": 0
    },
    {
      "current_code": "    fn language_detection() {\n        let rust_path = PathBuf::from(\"src/main.rs\");\n        assert_eq!(Language::from_file_path(&rust_path), Some(Language::Rust));\n\n        let js_path = PathBuf::from(\"app.js\");\n        assert_eq!(Language::from_file_path(&js_path), Some(Language::JavaScript));\n\n        let unknown_path = PathBuf::from(\"file.xyz\");\n        assert_eq!(Language::from_file_path(&unknown_path), None);\n    }",
      "current_ind": 1,
      "entity_name": "language_detection",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"language_detection\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1136,\"end\":1145},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:language_detection:__crates_parseltongue-core_src_entities_rs:1136-1145",
      "line_number": 0
    },
    {
      "current_code": "    fn line_range_validation() {\n        let valid_range = LineRange::new(1, 5).unwrap();\n        assert_eq!(valid_range.span(), 5);\n        assert!(valid_range.contains(3));\n        assert!(!valid_range.contains(6));\n\n        // Invalid range (start > end)\n        assert!(LineRange::new(10, 5).is_err());\n\n        // Invalid range (zero-based)\n        assert!(LineRange::new(0, 5).is_err());\n    }",
      "current_ind": 1,
      "entity_name": "line_range_validation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"line_range_validation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1122,\"end\":1133},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:line_range_validation:__crates_parseltongue-core_src_entities_rs:1122-1133",
      "line_number": 0
    },
    {
      "current_code": "fn list_all_swift_node_types() {\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n\n    println!(\"\\n=== All Swift Grammar Node Types ===\");\n    for i in 0..swift_lang.node_kind_count() {\n        if let Some(node_type) = swift_lang.node_kind_for_id(i as u16) {\n            println!(\"{}: {}\", i, node_type);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "list_all_swift_node_types",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_ast_explorer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"list_all_swift_node_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_ast_explorer.rs\",\"line_range\":{\"start\":66,\"end\":75},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:list_all_swift_node_types:__crates_parseltongue-core_tests_swift_ast_explorer_rs:66-75",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    let matches = build_cli().get_matches();\n\n    match matches.subcommand() {\n        Some((\"pt01-folder-to-cozodb-streamer\", sub_matches)) => {\n            run_folder_to_cozodb_streamer(sub_matches).await\n        }\n        Some((\"pt02-level00\", sub_matches)) => {\n            run_pt02_level00(sub_matches).await\n        }\n        Some((\"pt02-level01\", sub_matches)) => {\n            run_pt02_level01(sub_matches).await\n        }\n        Some((\"pt02-level02\", sub_matches)) => {\n            run_pt02_level02(sub_matches).await\n        }\n        Some((\"pt03-llm-to-cozodb-writer\", sub_matches)) => {\n            run_llm_to_cozodb_writer(sub_matches).await\n        }\n        Some((\"pt04-syntax-preflight-validator\", sub_matches)) => {\n            run_rust_preflight_code_simulator(sub_matches).await\n        }\n        Some((\"pt05-llm-cozodb-to-diff-writer\", sub_matches)) => {\n            run_llm_cozodb_to_diff_writer(sub_matches).await\n        }\n        Some((\"pt06-cozodb-make-future-code-current\", sub_matches)) => {\n            run_cozodb_make_future_code_current(sub_matches).await\n        }\n        _ => {\n            println!(\"{}\", style(\"Parseltongue CLI Toolkit\").blue().bold());\n            println!(\"{}\", style(\"Ultra-minimalist code analysis and modification toolkit\").blue());\n            println!();\n            println!(\"Use --help for more information\");\n            println!();\n            println!(\"Available commands:\");\n            println!(\"  pt01-folder-to-cozodb-streamer       - Index codebase into CozoDB (Tool 1: Ingest)\");\n            println!(\"\");\n            println!(\"  PT02: Export from CozoDB (Progressive Disclosure)\");\n            println!(\"    pt02-level00                       - Pure edge list (~2-5K tokens) [RECOMMENDED]\");\n            println!(\"    pt02-level01                       - Entity + ISG + Temporal (~30K tokens)\");\n            println!(\"    pt02-level02                       - + Type system (~60K tokens)\");\n            println!(\"\");\n            println!(\"  pt03-llm-to-cozodb-writer            - Write LLM changes to temporal state (Tool 3: Edit)\");\n            println!(\"  pt04-syntax-preflight-validator      - Validate syntax of proposed changes (Tool 4: Validate)\");\n            println!(\"  pt05-llm-cozodb-to-diff-writer       - Generate CodeDiff.json (Tool 5: Diff)\");\n            println!(\"  pt06-cozodb-make-future-code-current - Reset database state (Tool 6: Reset)\");\n            Ok(())\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":148,\"end\":197},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_parseltongue_src_main_rs:148-197",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            let config = CliConfig::parse_config(&matches);\n\n            // Handle quiet/verbose flags\n            let quiet = matches.get_flag(\"quiet\");\n            let verbose = matches.get_flag(\"verbose\");\n\n            if !quiet {\n                println!(\n                    \"{}\",\n                    style(\"Parseltongue Tool 01: folder-to-cozoDB-streamer\")\n                        .blue()\n                        .bold()\n                );\n                println!(\"{}\", style(\"Ultra-minimalist code streaming to CozoDB\").blue());\n                println!();\n            }\n\n            // Create and run streamer\n            match run_streamer(&config, verbose, quiet).await {\n                Ok(result) => {\n                    if !quiet {\n                        println!(\n                            \"{}\",\n                            style(\" Streaming completed successfully!\").green().bold()\n                        );\n                        if result.errors.is_empty() {\n                            println!(\"{}\", style(\"No errors encountered.\").green());\n                        } else {\n                            println!(\n                                \"{}\",\n                                style(format!(\" {} warnings encountered\", result.errors.len()))\n                                    .yellow()\n                            );\n                        }\n                    }\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/main.rs\",\"line_range\":{\"start\":15,\"end\":72},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt01-folder-to-cozodb-streamer_src_main_rs:15-72",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Validate and get configuration\n    let config = cli.validate()?;\n\n    // Verbose logging\n    cli.verbose_print(\"Starting PT02 Level 0 export (Pure Edge List)\");\n    cli.verbose_print(&format!(\"Database: {}\", config.db_path));\n    cli.verbose_print(&format!(\"Output: {:?}\", config.output_path));\n    cli.verbose_print(&format!(\"WHERE filter: {}\", config.where_filter));\n\n    // Create exporter\n    let exporter = Level0Exporter::new();\n    cli.verbose_print(&format!(\"Estimated tokens: ~{}\", exporter.estimated_tokens()));\n\n    // TODO: Connect to real CozoDB and export\n    // For now, this is a stub showing the binary structure\n    println!(\"PT02 Level 0 binary created successfully!\");\n    println!(\"TODO: Connect to CozoDB at {}\", config.db_path);\n    println!(\"TODO: Export edges to {:?}\", config.output_path);\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs\",\"line_range\":{\"start\":116,\"end\":140},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level00_rs:116-140",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Validate and get configuration\n    let config = cli.validate()?;\n\n    // Verbose logging\n    cli.verbose_print(\"Starting PT02 Level 1 export (Entity + ISG + Temporal)\");\n    cli.verbose_print(&format!(\"Database: {}\", config.db_path));\n    cli.verbose_print(&format!(\"Output: {:?}\", config.output_path));\n    cli.verbose_print(&format!(\"WHERE filter: {}\", config.where_filter));\n    cli.verbose_print(&format!(\n        \"Include code: {}\",\n        if config.include_code { \"YES (expensive)\" } else { \"NO (cheap)\" }\n    ));\n\n    // Create exporter\n    let exporter = Level1Exporter::new();\n    let base_tokens = exporter.estimated_tokens();\n    let estimated = if config.include_code {\n        base_tokens * 20  // Rough estimate: code adds 20x tokens\n    } else {\n        base_tokens\n    };\n    cli.verbose_print(&format!(\"Estimated tokens: ~{}\", estimated));\n\n    // TODO: Connect to real CozoDB and export\n    println!(\"PT02 Level 1 binary created successfully!\");\n    println!(\"TODO: Connect to CozoDB at {}\", config.db_path);\n    println!(\"TODO: Export entities to {:?}\", config.output_path);\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs\",\"line_range\":{\"start\":108,\"end\":141},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level01_rs:108-141",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Validate and get configuration\n    let config = cli.validate()?;\n\n    // Verbose logging\n    cli.verbose_print(\"Starting PT02 Level 2 export (Entity + ISG + Temporal + Type System)\");\n    cli.verbose_print(&format!(\"Database: {}\", config.db_path));\n    cli.verbose_print(&format!(\"Output: {:?}\", config.output_path));\n    cli.verbose_print(&format!(\"WHERE filter: {}\", config.where_filter));\n    cli.verbose_print(&format!(\n        \"Include code: {}\",\n        if config.include_code { \"YES (expensive)\" } else { \"NO (cheap)\" }\n    ));\n\n    // Create exporter\n    let exporter = Level2Exporter::new();\n    let base_tokens = exporter.estimated_tokens();\n    let estimated = if config.include_code {\n        base_tokens * 15  // Rough estimate: code adds 15x tokens (slightly less than L1 due to more metadata)\n    } else {\n        base_tokens\n    };\n    cli.verbose_print(&format!(\"Estimated tokens: ~{}\", estimated));\n\n    // TODO: Connect to real CozoDB and export\n    println!(\"PT02 Level 2 binary created successfully!\");\n    println!(\"TODO: Connect to CozoDB at {}\", config.db_path);\n    println!(\"TODO: Export entities with type info to {:?}\", config.output_path);\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs\",\"line_range\":{\"start\":113,\"end\":146},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level02_rs:113-146",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = Cli::parse();\n\n    // Validate and get configuration\n    let config = cli.validate()?;\n\n    // Verbose logging\n    cli.verbose_print(&format!(\"Starting PT02 Level {} export\", config.level));\n    cli.verbose_print(&format!(\"Database: {}\", config.db_path));\n    cli.verbose_print(&format!(\"Output: {:?}\", config.output_path));\n    cli.verbose_print(&format!(\"WHERE filter: {}\", config.where_filter));\n\n    if config.level > 0 {\n        cli.verbose_print(&format!(\n            \"Include code: {}\",\n            if config.include_code { \"YES (expensive)\" } else { \"NO (cheap)\" }\n        ));\n    }\n\n    // Execute export based on level\n    // TODO: Phase 3 (GREEN) - Implement actual export logic\n    match config.level {\n        0 => {\n            cli.verbose_print(\"Exporting Level 0: Pure edge list\");\n            todo!(\"Level 0 export implementation (Phase 3)\")\n        }\n        1 => {\n            cli.verbose_print(\"Exporting Level 1: Node-centric + ISG + Temporal\");\n            todo!(\"Level 1 export implementation (Phase 3)\")\n        }\n        2 => {\n            cli.verbose_print(\"Exporting Level 2: + Type system essentials\");\n            todo!(\"Level 2 export implementation (Phase 4)\")\n        }\n        _ => unreachable!(\"CLI validation should prevent invalid levels\"),\n    }\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/main.rs\",\"line_range\":{\"start\":20,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt02-llm-cozodb-to-context-writer_src_main_rs:20-57",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    // Parse CLI arguments\n    let cli = CliConfig::build_cli();\n    let matches = cli.try_get_matches();\n\n    match matches {\n        Ok(matches) => {\n            // Parse interface mode (Simple or Advanced)\n            let mode = CliConfig::parse_interface_mode(&matches);\n\n            println!(\n                \"{}\",\n                style(\"Running Tool 2: llm-to-cozodb-writer\").cyan()\n            );\n\n            // Execute based on interface mode\n            match run_writer(mode).await {\n                Ok(()) => {\n                    println!(\n                        \"{}\",\n                        style(\" Entity updated successfully\").green().bold()\n                    );\n                    Ok(())\n                }\n                Err(e) => {\n                    eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n                    std::process::exit(1);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"{} {}\", style(\"Error:\").red().bold(), e);\n            CliConfig::print_usage();\n            std::process::exit(1);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/main.rs\",\"line_range\":{\"start\":17,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt03-llm-to-cozodb-writer_src_main_rs:17-53",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 04: Simplified Syntax Validator\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    // Get entities with future_code (Create or Edit operations)\n    let changed_entities = storage\n        .get_changed_entities()\n        .await\n        .context(\"Failed to get changed entities from CozoDB\")?;\n\n    if changed_entities.is_empty() {\n        println!(\n            \"{}\",\n            style(\"No entities with future_code found. Nothing to validate.\")\n                .yellow()\n        );\n        return Ok(());\n    }\n\n    println!(\n        \"\\n{} entities with future_code found\",\n        style(changed_entities.len()).bold()\n    );\n\n    // Create validator\n    let mut validator =\n        SimpleSyntaxValidator::new().context(\"Failed to create syntax validator\")?;\n\n    // Validate each entity\n    let mut valid_count = 0;\n    let mut invalid_count = 0;\n    let mut error_details = Vec::new();\n\n    for entity in &changed_entities {\n        if let Some(future_code) = &entity.future_code {\n            // Extract language from ISGL1 key (format: language:type:name:path:range)\n            let language = entity.isgl1_key.split(':').next()\n                .and_then(|lang_str| match lang_str {\n                    \"rust\" => Some(Language::Rust),\n                    _ => Some(Language::Rust), // Default to Rust for now\n                })\n                .unwrap_or(Language::Rust);\n\n            match validator.validate_syntax(future_code, language) {\n                Ok(result) => {\n                    if result.is_valid {\n                        valid_count += 1;\n                        if cli.verbose {\n                            println!(\"  {} {}\", style(\"\").green(), entity.isgl1_key);\n                        }\n                    } else {\n                        invalid_count += 1;\n                        println!(\"  {} {}\", style(\"\").red(), entity.isgl1_key);\n                        for error in &result.errors {\n                            println!(\"    {}\", style(error).red().dim());\n                            error_details.push((entity.isgl1_key.clone(), error.clone()));\n                        }\n                    }\n                }\n                Err(e) => {\n                    invalid_count += 1;\n                    println!(\n                        \"  {} {} - Validation error: {}\",\n                        style(\"\").red(),\n                        entity.isgl1_key,\n                        style(e).red()\n                    );\n                }\n            }\n        }\n    }\n\n    // Print summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total entities: {}\", changed_entities.len());\n    println!(\"  {} Valid syntax: {}\", style(\"\").green(), valid_count);\n    println!(\"  {} Invalid syntax: {}\", style(\"\").red(), invalid_count);\n\n    if invalid_count > 0 {\n        println!(\n            \"\\n{}\",\n            style(\"Syntax validation failed. Fix errors and retry.\")\n                .red()\n                .bold()\n        );\n        std::process::exit(1);\n    } else {\n        println!(\n            \"\\n{}\",\n            style(\" All syntax checks passed! Ready for file writes (Tool 5).\")\n                .green()\n                .bold()\n        );\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/main.rs\",\"line_range\":{\"start\":26,\"end\":133},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt04-syntax-preflight-validator_src_main_rs:26-133",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    let cli = Cli::parse();\n\n    println!(\n        \"\\n{}\",\n        style(\"Parseltongue Tool 05: LLM-cozoDB-to-diff-writer\")\n            .bold()\n            .cyan()\n    );\n    println!(\"{}\", style(\"CodeDiff.json Generator\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    // Connect to CozoDB\n    let storage = CozoDbStorage::new(&cli.database)\n        .await\n        .context(\"Failed to connect to CozoDB\")?;\n\n    if cli.verbose {\n        println!(\"\\n{}\", style(\"Configuration:\").bold());\n        println!(\"  Database: {}\", cli.database);\n        println!(\"  Output: {}\", cli.output.display());\n    }\n\n    // Generate diff (with dependency injection)\n    let storage = Arc::new(storage);\n    let generator = DiffGenerator::new(storage);\n    let diff = generator\n        .generate_diff()\n        .await\n        .context(\"Failed to generate CodeDiff\")?;\n\n    // Display summary\n    println!(\"\\n{}\", style(\"Summary:\").bold());\n    println!(\"  Total changes: {}\", diff.metadata.total_changes);\n    println!(\"  {} Create: {}\", style(\"\").green(), diff.metadata.create_count);\n    println!(\"  {} Edit: {}\", style(\" \").yellow(), diff.metadata.edit_count);\n    println!(\"  {} Delete: {}\", style(\" \").red(), diff.metadata.delete_count);\n\n    if cli.verbose && !diff.changes.is_empty() {\n        println!(\"\\n{}\", style(\"Changes:\").bold());\n        for change in &diff.changes {\n            let icon = match change.operation {\n                pt05_llm_cozodb_to_diff_writer::Operation::Create => style(\"\").green(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Edit => style(\" \").yellow(),\n                pt05_llm_cozodb_to_diff_writer::Operation::Delete => style(\" \").red(),\n            };\n            println!(\"  {} {}\", icon, change.file_path.display());\n            if cli.verbose {\n                println!(\"     ISGL1: {}\", change.isgl1_key);\n            }\n        }\n    }\n\n    // Write JSON to file\n    let json = diff\n        .to_json_pretty()\n        .context(\"Failed to serialize CodeDiff\")?;\n    std::fs::write(&cli.output, json).context(\"Failed to write CodeDiff.json\")?;\n\n    println!(\n        \"\\n{}\",\n        style(format!(\" CodeDiff.json written to: {}\", cli.output.display()))\n            .green()\n            .bold()\n    );\n\n    println!(\"\\n{}\", style(\"Next Steps:\").bold().cyan());\n    println!(\"  1. LLM reads CodeDiff.json\");\n    println!(\"  2. LLM applies changes to codebase files\");\n    println!(\"  3. Run cargo build to verify compilation\");\n    println!(\"  4. Run cargo test to verify functionality\");\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/main.rs\",\"line_range\":{\"start\":31,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt05-llm-cozodb-to-diff-writer_src_main_rs:31-104",
      "line_number": 0
    },
    {
      "current_code": "async fn main() -> Result<()> {\n    let cli = cli::Cli::parse_args();\n\n    println!(\"\\n{}\", style(\"Parseltongue Tool 06: cozoDB-make-future-code-current\").bold().cyan());\n    println!(\"{}\", style(\"Ultra-Minimalist State Reset Manager\").dim());\n    println!(\"{}\", style(\"=\".repeat(60)).dim());\n\n    println!(\"\\n{}\", style(\"Configuration:\").bold());\n    println!(\"  Database: {}\", cli.database);\n    println!(\"  Project: {}\", cli.project_path.display());\n\n    println!(\"\\n{}\", style(\"Ultra-Minimalist Principles:\").bold().yellow());\n    println!(\"  {} NO BACKUP METADATA - Direct table deletion\", style(\"\").green());\n    println!(\"  {} NO CONFIGURATION - Single deterministic operation\", style(\"\").green());\n    println!(\"  {} NO ROLLBACK - Permanent state reset\", style(\"\").green());\n    println!(\"  {} NO COMPLEXITY - Delete  Recreate  Re-index\", style(\"\").green());\n\n    // Initialize CozoDB storage\n    println!(\"\\n{}\", style(\"Initializing storage...\").bold());\n    // Accept database backend prefix from CLI (rocksdb: or sqlite:)\n    let storage = CozoDbStorage::new(&cli.database).await?;\n    if cli.verbose {\n        println!(\"  {} Storage initialized\", style(\"\").green());\n    }\n\n    // Create state reset manager\n    let manager = StateResetManager::new(storage);\n\n    // Perform state reset\n    println!(\"\\n{}\", style(\"Performing state reset...\").bold().yellow());\n    println!(\"  {} Deleting CodeGraph table\", style(\"\").cyan());\n    println!(\"  {} Recreating schema\", style(\"\").cyan());\n\n    let result = manager.reset(&cli.project_path).await?;\n\n    // Display results\n    println!(\"\\n{}\", style(\"Reset Complete!\").bold().green());\n    println!(\"  Success: {}\", if result.success { style(\"\").green() } else { style(\"\").red() });\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { style(\"\").green() } else { style(\"\").red() });\n\n    // PRD-compliant re-indexing (call Tool 1 directly - NO config duplication)\n    if cli.reindex {\n        println!(\"\\n{}\", style(\"Re-indexing project (Tool 1)...\").bold().yellow());\n\n        // S01 Ultra-minimalist: Just call pt01 binary with same DB\n        // NO config duplication - Tool 1 owns its own configuration\n        let pt01_status = std::process::Command::new(\"parseltongue\")\n            .arg(\"pt01-folder-to-cozodb-streamer\")\n            .arg(&cli.project_path)\n            .arg(\"--db\")\n            .arg(&cli.database)\n            .arg(if cli.verbose { \"--verbose\" } else { \"--quiet\" })\n            .status()?;\n\n        if !pt01_status.success() {\n            eprintln!(\"{}\", style(\" Re-indexing failed\").red().bold());\n            std::process::exit(1);\n        }\n\n        println!(\"\\n{}\", style(\"Complete Cycle Finished!\").bold().green());\n        println!(\"  {} Reset complete\", style(\"\").green());\n        println!(\"  {} Re-indexing complete\", style(\"\").green());\n        println!(\"  {} Ready for next iteration\", style(\"\").green());\n    } else {\n        println!(\"\\n{}\", style(\"Next Steps (Manual):\").bold().yellow());\n        println!(\"  1. Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\",\n                 cli.project_path.display(), cli.database);\n        println!(\"  2. Continue with workflow...\");\n    }\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "main",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"main\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/main.rs\",\"line_range\":{\"start\":10,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:main:__crates_pt06-cozodb-make-future-code-current_src_main_rs:10-82",
      "line_number": 0
    },
    {
      "current_code": "        fn many1(self) -> Many1<Self> {\n            Many1 { parser: self }\n        }",
      "current_ind": 1,
      "entity_name": "many1",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"many1\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1183,\"end\":1185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:many1:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1183-1185",
      "line_number": 0
    },
    {
      "current_code": "        fn many(self) -> Many<Self> {\n            Many { parser: self }\n        }",
      "current_ind": 1,
      "entity_name": "many",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"many\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1178,\"end\":1180},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:many:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1178-1180",
      "line_number": 0
    },
    {
      "current_code": "        fn map<U, F>(self, f: F) -> Map<Self, F>\n        where\n            F: Fn(T) -> U,\n        {\n            Map { parser: self, mapper: f }\n        }",
      "current_ind": 1,
      "entity_name": "map",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"map\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1149,\"end\":1154},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:map:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1149-1154",
      "line_number": 0
    },
    {
      "current_code": "    async fn mock_tool_implementation() {\n        let mock_tool = MockTool::new(\"test\")\n            .with_execute_result(Ok(ToolOutput::IndexingComplete {\n                entities_count: 42,\n                duration_ms: 1000,\n            }));\n\n        let input = ToolInput::IndexFolder {\n            path: PathBuf::from(\"test\"),\n            language_filter: None,\n        };\n\n        let result = mock_tool.execute(input).await.unwrap();\n        match result {\n            ToolOutput::IndexingComplete { entities_count, .. } => {\n                assert_eq!(entities_count, 42);\n            }\n            _ => panic!(\"Unexpected output type\"),\n        }\n\n        assert!(mock_tool.validate_input(&input).is_ok());\n        assert_eq!(mock_tool.metadata().name, \"test\");\n    }",
      "current_ind": 1,
      "entity_name": "mock_tool_implementation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"mock_tool_implementation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":658,\"end\":680},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:mock_tool_implementation:__crates_parseltongue-core_src_interfaces_rs:658-680",
      "line_number": 0
    },
    {
      "current_code": "        fn optional(self) -> Optional<Self> {\n            Optional { parser: self }\n        }",
      "current_ind": 1,
      "entity_name": "optional",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"optional\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1173,\"end\":1175},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:optional:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1173-1175",
      "line_number": 0
    },
    {
      "current_code": "        fn or<P>(self, other: P) -> Or<Self, P>\n        where\n            P: ParserCombinator<'a, T>,\n        {\n            Or { first: self, second: other }\n        }",
      "current_ind": 1,
      "entity_name": "or",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"or\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1165,\"end\":1170},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:or:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1165-1170",
      "line_number": 0
    },
    {
      "current_code": "fn parse_edges_from_query_result(result: &cozo::NamedRows) -> Result<Vec<Edge>> {\n    let mut edges = Vec::new();\n\n    for row in &result.rows {\n        let edge = Edge {\n            from_key: extract_string(row, 0)?,\n            to_key: extract_string(row, 1)?,\n            edge_type: extract_string(row, 2)?,\n        };\n\n        edges.push(edge);\n    }\n\n    Ok(edges)\n}",
      "current_ind": 1,
      "entity_name": "parse_edges_from_query_result",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"parse_edges_from_query_result\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":199,\"end\":213},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:parse_edges_from_query_result:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:199-213",
      "line_number": 0
    },
    {
      "current_code": "fn parse_entities_from_query_result(result: &cozo::NamedRows) -> Result<Vec<Entity>> {\n    let mut entities = Vec::new();\n\n    for row in &result.rows {\n        let entity = Entity {\n            isgl1_key: extract_string(row, 0)?,\n            interface_signature: extract_string(row, 1)?,\n            entity_type: extract_string(row, 2)?,\n            file_path: extract_string(row, 3)?,\n            current_code: extract_optional_string(row, 4),\n            future_code: extract_optional_string(row, 5),\n            current_ind: extract_u8(row, 6)?,\n            future_ind: extract_u8(row, 7)?,\n            future_action: extract_optional_string(row, 8),\n\n            // Parse entity name and line number from ISGL1 key\n            entity_name: parse_entity_name_from_key(&extract_string(row, 0)?),\n            line_number: parse_line_number_from_key(&extract_string(row, 0)?),\n\n            // Default empty values for dependencies (will compute later if needed)\n            forward_deps: Vec::new(),\n            reverse_deps: Vec::new(),\n            doc_comment: None,\n\n            // v0.9.0: Extract entity_class from database (column 9)\n            entity_class: extract_string(row, 9)?,\n\n            // Level 2 fields (not in database yet)\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: None,\n            is_async: None,\n            is_unsafe: None,\n        };\n\n        entities.push(entity);\n    }\n\n    Ok(entities)\n}",
      "current_ind": 1,
      "entity_name": "parse_entities_from_query_result",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"parse_entities_from_query_result\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":154,\"end\":196},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:parse_entities_from_query_result:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:154-196",
      "line_number": 0
    },
    {
      "current_code": "fn parse_entity_name_from_key(key: &str) -> String {\n    let parts: Vec<&str> = key.split(':').collect();\n    if parts.len() >= 3 {\n        parts[2].to_string()\n    } else {\n        \"unknown\".to_string()\n    }\n}",
      "current_ind": 1,
      "entity_name": "parse_entity_name_from_key",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"parse_entity_name_from_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":243,\"end\":250},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:parse_entity_name_from_key:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:243-250",
      "line_number": 0
    },
    {
      "current_code": "fn parse_isgl1_key_components(key: &str) -> Result<(PathBuf, String, Language)> {\n    // Support both simple \"filepath-filename-interface\" and full ISGL1 formats\n    let parts: Vec<&str> = key.split(':').collect();\n\n    let (file_str, name) = if parts.len() >= 4 {\n        // Full format: \"rust:fn:name:file_path:start-end\"\n        (parts[3], parts[2].to_string())\n    } else {\n        // Simple format: \"filepath-filename-interface\" - parse backwards\n        let segments: Vec<&str> = key.rsplitn(3, '-').collect();\n        if segments.len() < 2 {\n            anyhow::bail!(\"Invalid ISGL1 key format. Expected 'filepath-filename-interface' or 'lang:type:name:path:range'\");\n        }\n        let interface = segments[0];\n        let filepath = segments[2];\n        (filepath, interface.to_string())\n    };\n\n    let file_path = PathBuf::from(file_str);\n\n    // Infer language from file extension\n    let language = Language::from_file_path(&file_path)\n        .unwrap_or(Language::Rust); // Default to Rust if cannot infer\n\n    Ok((file_path, name, language))\n}",
      "current_ind": 1,
      "entity_name": "parse_isgl1_key_components",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"parse_isgl1_key_components\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":90,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:parse_isgl1_key_components:__crates_parseltongue_src_main_rs:90-115",
      "line_number": 0
    },
    {
      "current_code": "fn parse_line_number_from_key(key: &str) -> u32 {\n    let parts: Vec<&str> = key.split(':').collect();\n    if parts.len() >= 5 {\n        parts[4].parse().unwrap_or(0)\n    } else {\n        0\n    }\n}",
      "current_ind": 1,
      "entity_name": "parse_line_number_from_key",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"parse_line_number_from_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":255,\"end\":262},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:parse_line_number_from_key:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:255-262",
      "line_number": 0
    },
    {
      "current_code": "fn print_dependencies(deps: &[DependencyEdge]) {\n    println!(\"Dependencies ({})\", deps.len());\n    for (i, dep) in deps.iter().enumerate() {\n        let edge_type = match dep.edge_type {\n            parseltongue_core::entities::EdgeType::Calls => \"Calls\",\n            parseltongue_core::entities::EdgeType::Uses => \"Uses\",\n            parseltongue_core::entities::EdgeType::Implements => \"Implements\",\n        };\n        println!(\"  {}. {} -> {} ({})\",\n            i + 1,\n            dep.from_key.as_str().split(':').nth(2).unwrap_or(\"?\"),\n            dep.to_key.as_str().split(':').nth(2).unwrap_or(\"?\"),\n            edge_type\n        );\n    }\n}",
      "current_ind": 1,
      "entity_name": "print_dependencies",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"print_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":383,\"end\":398},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:print_dependencies:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:383-398",
      "line_number": 0
    },
    {
      "current_code": "fn print_tree(node: tree_sitter::Node, source: &str, indent: usize, max_indent: usize) {\n    if indent > max_indent {\n        return;\n    }\n\n    let kind = node.kind();\n    let text = if node.child_count() == 0 && node.byte_range().len() < 50 {\n        format!(\" \\\"{}\\\"\", &source[node.byte_range()])\n    } else {\n        String::new()\n    };\n\n    println!(\"{}{} [{}:{}]{}\",\n        \"  \".repeat(indent),\n        kind,\n        node.start_position().row,\n        node.start_position().column,\n        text\n    );\n\n    if node.child_count() > 0 {\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            print_tree(child, source, indent + 1, max_indent);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "print_tree",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/ast_exploration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"print_tree\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/ast_exploration_test.rs\",\"line_range\":{\"start\":5,\"end\":31},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:print_tree:__crates_parseltongue-core_tests_ast_exploration_test_rs:5-31",
      "line_number": 0
    },
    {
      "current_code": "fn print_tree(node: tree_sitter::Node, source: &str, depth: usize) {\n    let indent = \"  \".repeat(depth);\n    let kind = node.kind();\n\n    // Print node kind and optionally its text if it's small\n    if node.child_count() == 0 {\n        let text = &source[node.byte_range()];\n        if text.len() < 50 {\n            println!(\"{}{}  \\\"{}\\\"\", indent, kind, text.replace('\\n', \"\\\\n\"));\n        } else {\n            println!(\"{}{}\", indent, kind);\n        }\n    } else {\n        println!(\"{}{}\", indent, kind);\n    }\n\n    // Recursively print children\n    for i in 0..node.child_count() {\n        if let Some(child) = node.child(i) {\n            print_tree(child, source, depth + 1);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "print_tree",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_ast_explorer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"print_tree\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_ast_explorer.rs\",\"line_range\":{\"start\":41,\"end\":63},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:print_tree:__crates_parseltongue-core_tests_swift_ast_explorer_rs:41-63",
      "line_number": 0
    },
    {
      "current_code": "fn print_tree(node: tree_sitter::Node, source: &str, depth: usize) {\n    let indent = \"  \".repeat(depth);\n    let kind = node.kind();\n\n    if node.child_count() == 0 {\n        let text = &source[node.byte_range()];\n        if text.len() < 50 {\n            println!(\"{}{}  \\\"{}\\\"\", indent, kind, text.replace('\\n', \"\\\\n\"));\n        } else {\n            println!(\"{}{}\", indent, kind);\n        }\n    } else {\n        println!(\"{}{}\", indent, kind);\n    }\n\n    for i in 0..node.child_count() {\n        if let Some(child) = node.child(i) {\n            print_tree(child, source, depth + 1);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "print_tree",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_protocol_debug.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"print_tree\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_protocol_debug.rs\",\"line_range\":{\"start\":23,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:print_tree:__crates_parseltongue-core_tests_swift_protocol_debug_rs:23-43",
      "line_number": 0
    },
    {
      "current_code": "        fn prop_roundtrip(ast: TestAst) -> bool {\n            let printed = ast.to_string();\n            let parsed = TestParser.parse(printed.clone());\n            match parsed {\n                Ok(parsed_ast) => parsed_ast == ast,\n                Err(_) => false,\n            }\n        }",
      "current_ind": 1,
      "entity_name": "prop_roundtrip",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"prop_roundtrip\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1365,\"end\":1372},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:prop_roundtrip:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1365-1372",
      "line_number": 0
    },
    {
      "current_code": "    fn recovery_action_default_is_sensible() {\n        let default_action = RecoveryAction::default();\n        assert!(matches!(default_action, RecoveryAction::RetryWithBackoff(_)));\n    }",
      "current_ind": 1,
      "entity_name": "recovery_action_default_is_sensible",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"recovery_action_default_is_sensible\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":200,\"end\":203},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:recovery_action_default_is_sensible:__crates_parseltongue-core_src_error_rs:200-203",
      "line_number": 0
    },
    {
      "current_code": "async fn run_cozodb_make_future_code_current(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt06_cozodb_make_future_code_current::StateResetManager;\n    use std::path::Path;\n\n    let project = matches.get_one::<String>(\"project\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 6: pt06-cozodb-make-future-code-current\").cyan());\n    println!(\"  Project: {}\", project);\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create state reset manager\n    let reset_manager = StateResetManager::new(storage);\n\n    // Reset database state (delete all entities, recreate schema)\n    let result = reset_manager.reset(Path::new(project))\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to reset database state: {}\", e))?;\n\n    println!(\"{}\", style(\" Database reset completed\").green().bold());\n    println!(\"  Entities deleted: {}\", result.entities_deleted);\n    println!(\"  Schema recreated: {}\", if result.schema_recreated { \"yes\" } else { \"no\" });\n    println!();\n    println!(\"{}\", style(\"Next step: Re-index the codebase\").cyan());\n    println!(\"  Run: parseltongue pt01-folder-to-cozodb-streamer {} --db {}\", project, db);\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_cozodb_make_future_code_current",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_cozodb_make_future_code_current\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":903,\"end\":936},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_cozodb_make_future_code_current:__crates_parseltongue_src_main_rs:903-936",
      "line_number": 0
    },
    {
      "current_code": "async fn run_folder_to_cozodb_streamer(matches: &ArgMatches) -> Result<()> {\n    let directory = matches.get_one::<String>(\"directory\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n    let quiet = matches.get_flag(\"quiet\");\n\n    println!(\"{}\", style(\"Running Tool 1: folder-to-cozodb-streamer\").cyan());\n\n    // Create config (S01 ultra-minimalist: let tree-sitter decide what to parse)\n    let config = pt01_folder_to_cozodb_streamer::StreamerConfig {\n        root_dir: std::path::PathBuf::from(directory),\n        db_path: db.clone(),\n        max_file_size: 100 * 1024 * 1024,  // 100MB - no artificial limits\n        include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n        exclude_patterns: vec![\n            \"target\".to_string(),\n            \"node_modules\".to_string(),\n            \".git\".to_string(),\n            \"build\".to_string(),\n            \"dist\".to_string(),\n            \"__pycache__\".to_string(),\n            \".venv\".to_string(),\n            \"venv\".to_string(),\n        ],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Create and run streamer\n    let streamer = pt01_folder_to_cozodb_streamer::ToolFactory::create_streamer(config.clone()).await?;\n    let result = streamer.stream_directory().await?;\n\n    if !quiet {\n        println!(\"{}\", style(\" Indexing completed\").green().bold());\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        if verbose {\n            println!(\"  Duration: {:?}\", result.duration);\n        }\n    }\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_folder_to_cozodb_streamer",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_folder_to_cozodb_streamer\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":431,\"end\":473},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_folder_to_cozodb_streamer:__crates_parseltongue_src_main_rs:431-473",
      "line_number": 0
    },
    {
      "current_code": "async fn run_llm_cozodb_to_diff_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt05_llm_cozodb_to_diff_writer::DiffGenerator;\n    use std::sync::Arc;\n\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 5: pt05-llm-cozodb-to-diff-writer\").cyan());\n    println!(\"  Database: {}\", db);\n    println!(\"  Output: {}\", output);\n\n    // Connect to database\n    let storage = Arc::new(\n        CozoDbStorage::new(db)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?\n    );\n\n    // Create diff generator with dependency injection\n    let generator = DiffGenerator::new(storage);\n\n    // Generate CodeDiff from changed entities\n    let diff = generator.generate_diff()\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to generate diff: {}\", e))?;\n\n    if diff.changes.is_empty() {\n        println!(\"{}\", style(\" No changes found in database\").yellow());\n        return Ok(());\n    }\n\n    // Serialize to JSON\n    let json = diff.to_json_pretty()\n        .map_err(|e| anyhow::anyhow!(\"Failed to serialize diff to JSON: {}\", e))?;\n\n    // Write to file\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write to file: {}\", e))?;\n\n    println!(\"{}\", style(\" CodeDiff.json generated\").green());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Changes included: {}\", diff.changes.len());\n\n    // Print summary by operation\n    let mut creates = 0;\n    let mut edits = 0;\n    let mut deletes = 0;\n    for change in &diff.changes {\n        match change.operation {\n            pt05_llm_cozodb_to_diff_writer::Operation::Create => creates += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Edit => edits += 1,\n            pt05_llm_cozodb_to_diff_writer::Operation::Delete => deletes += 1,\n        }\n    }\n    println!(\"    Creates: {}\", creates);\n    println!(\"    Edits: {}\", edits);\n    println!(\"    Deletes: {}\", deletes);\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_llm_cozodb_to_diff_writer",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_llm_cozodb_to_diff_writer\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":841,\"end\":901},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_llm_cozodb_to_diff_writer:__crates_parseltongue_src_main_rs:841-901",
      "line_number": 0
    },
    {
      "current_code": "async fn run_llm_to_cozodb_writer(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use parseltongue_core::entities::TemporalAction;\n\n    let entity_key = matches.get_one::<String>(\"entity\").unwrap();\n    let action = matches.get_one::<String>(\"action\").unwrap();\n    let future_code = matches.get_one::<String>(\"future-code\");\n    let db = matches.get_one::<String>(\"db\").unwrap();\n\n    println!(\"{}\", style(\"Running Tool 3: pt03-llm-to-cozodb-writer\").cyan());\n\n    // Validate future-code requirement\n    if (action == \"create\" || action == \"edit\") && future_code.is_none() {\n        eprintln!(\"{}\", style(\"Error: --future-code required for create/edit actions\").red());\n        std::process::exit(1);\n    }\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Process action\n    match action.as_str() {\n        \"create\" => {\n            println!(\"  Creating entity: {}\", entity_key);\n            let future_code_content = future_code.unwrap().clone();\n            println!(\"  Future code: {} bytes\", future_code_content.len());\n\n            // Build new entity using functional composition\n            let entity = build_create_entity(&entity_key, future_code_content)\n                .with_context(|| format!(\"Failed to construct entity from key: {}\", entity_key))?;\n\n            // Persist to database\n            storage.insert_entity(&entity)\n                .await\n                .with_context(|| \"Failed to insert new entity into database\")?;\n\n            println!(\"{}\", style(\" Entity created successfully\").green());\n            println!(\"  Temporal state: Create pending (current_ind=false, future_ind=true)\");\n            println!(\"  Entity type: {:?}\", entity.interface_signature.entity_type);\n            println!(\"  File path: {}\", entity.interface_signature.file_path.display());\n        }\n        \"edit\" => {\n            println!(\"  Editing entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Update future_code\n            entity.future_code = Some(future_code.unwrap().clone());\n\n            // Set temporal action\n            entity.temporal_state.future_action = Some(TemporalAction::Edit);\n            entity.temporal_state.future_ind = true;\n\n            // Persist updated entity back to database\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to persist entity changes: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity updated with future code\").green());\n            println!(\"  Temporal state: Edit pending (future_ind=true)\");\n        }\n        \"delete\" => {\n            println!(\"  Deleting entity: {}\", entity_key);\n\n            // Fetch existing entity\n            let mut entity = storage.get_entity(entity_key)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to fetch entity: {}\", e))?;\n\n            // Mark for deletion via temporal state\n            entity.temporal_state.future_ind = false;\n            entity.temporal_state.future_action = Some(TemporalAction::Delete);\n\n            // Persist updated entity\n            storage.update_entity_internal(&entity)\n                .await\n                .map_err(|e| anyhow::anyhow!(\"Failed to mark for deletion: {}\", e))?;\n\n            println!(\"{}\", style(\" Entity marked for deletion\").green());\n            println!(\"  Temporal state: Delete pending (future_ind=false)\");\n        }\n        _ => unreachable!(\"clap validation should prevent this\"),\n    }\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_llm_to_cozodb_writer",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_llm_to_cozodb_writer\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":475,\"end\":565},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_llm_to_cozodb_writer:__crates_parseltongue_src_main_rs:475-565",
      "line_number": 0
    },
    {
      "current_code": "async fn run_pt02_level00(matches: &ArgMatches) -> Result<()> {\n    use pt02_llm_cozodb_to_context_writer::{CozoDbAdapter, Level0Exporter, LevelExporter, ExportConfig};\n    use std::path::PathBuf;\n\n    let where_clause = matches.get_one::<String>(\"where-clause\").unwrap();\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running PT02 Level 0: Pure Edge List Export\").cyan());\n    if verbose {\n        println!(\"  Database: {}\", db);\n        println!(\"  WHERE clause: {}\", where_clause);\n        println!(\"  Output: {}\", output);\n    }\n\n    // Connect to CozoDB\n    let db_adapter = CozoDbAdapter::connect(db).await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create exporter and config\n    let exporter = Level0Exporter::new();\n    let output_path = PathBuf::from(output);\n    let config = ExportConfig {\n        level: 0,\n        include_code: false,\n        where_filter: where_clause.to_string(),\n        output_path,\n        // v0.9.0: Dual outputs for code/test separation (handled in level00 binary)\n        code_output_path: None,\n        tests_output_path: None,\n        db_path: matches.get_one::<String>(\"db\").unwrap().clone(),\n    };\n\n    if verbose {\n        println!(\"  Estimated tokens: ~{}\", exporter.estimated_tokens());\n    }\n\n    // Execute export\n    let export_output = exporter.export(&db_adapter, &config).await\n        .map_err(|e| anyhow::anyhow!(\"Export failed: {}\", e))?;\n\n    // Write to JSON file\n    let json = serde_json::to_string_pretty(&export_output)\n        .map_err(|e| anyhow::anyhow!(\"JSON serialization failed: {}\", e))?;\n\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write file: {}\", e))?;\n\n    println!(\"{}\", style(\" PT02 Level 0 export completed\").green().bold());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Edges exported: {}\", export_output.export_metadata.total_edges.unwrap_or(0));\n    println!(\"  Token estimate: ~{} tokens\", exporter.estimated_tokens());\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_pt02_level00",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_pt02_level00\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":567,\"end\":622},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_pt02_level00:__crates_parseltongue_src_main_rs:567-622",
      "line_number": 0
    },
    {
      "current_code": "async fn run_pt02_level01(matches: &ArgMatches) -> Result<()> {\n    use pt02_llm_cozodb_to_context_writer::{CozoDbAdapter, Level1Exporter, LevelExporter, ExportConfig};\n    use std::path::PathBuf;\n\n    let include_code = matches.get_one::<String>(\"include-code\").unwrap();\n    let where_clause = matches.get_one::<String>(\"where-clause\").unwrap();\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running PT02 Level 1: Entity + ISG + Temporal Export\").cyan());\n    if verbose {\n        println!(\"  Database: {}\", db);\n        println!(\"  Include code: {}\", if include_code == \"1\" { \"YES (expensive)\" } else { \"NO (cheap)\" });\n        println!(\"  WHERE clause: {}\", where_clause);\n        println!(\"  Output: {}\", output);\n    }\n\n    // Connect to CozoDB\n    let db_adapter = CozoDbAdapter::connect(db).await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create exporter and config\n    let exporter = Level1Exporter::new();\n    let config = ExportConfig {\n        level: 1,\n        include_code: include_code == \"1\",\n        where_filter: where_clause.clone(),\n        output_path: PathBuf::from(output),\n        // v0.9.0: Dual outputs for code/test separation (None for level01)\n        code_output_path: None,\n        tests_output_path: None,\n        db_path: db.clone(),\n    };\n\n    let base_tokens = exporter.estimated_tokens();\n    let estimated = if config.include_code { base_tokens * 20 } else { base_tokens };\n\n    if verbose {\n        println!(\"  Estimated tokens: ~{}\", estimated);\n    }\n\n    // Execute export\n    let export_output = exporter.export(&db_adapter, &config).await\n        .map_err(|e| anyhow::anyhow!(\"Export failed: {}\", e))?;\n\n    // Write to JSON file\n    let json = serde_json::to_string_pretty(&export_output)\n        .map_err(|e| anyhow::anyhow!(\"JSON serialization failed: {}\", e))?;\n\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write file: {}\", e))?;\n\n    println!(\"{}\", style(\" PT02 Level 1 export completed\").green().bold());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Entities exported: {}\", export_output.export_metadata.total_entities.unwrap_or(0));\n    println!(\"  Token estimate: ~{} tokens\", estimated);\n    println!(\"  Fields per entity: 14 (isgl1_key, forward_deps, reverse_deps, temporal state, etc.)\");\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_pt02_level01",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_pt02_level01\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":624,\"end\":684},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_pt02_level01:__crates_parseltongue_src_main_rs:624-684",
      "line_number": 0
    },
    {
      "current_code": "async fn run_pt02_level02(matches: &ArgMatches) -> Result<()> {\n    use pt02_llm_cozodb_to_context_writer::{CozoDbAdapter, Level2Exporter, LevelExporter, ExportConfig};\n    use std::path::PathBuf;\n\n    let include_code = matches.get_one::<String>(\"include-code\").unwrap();\n    let where_clause = matches.get_one::<String>(\"where-clause\").unwrap();\n    let output = matches.get_one::<String>(\"output\").unwrap();\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running PT02 Level 2: Entity + ISG + Temporal + Type System Export\").cyan());\n    if verbose {\n        println!(\"  Database: {}\", db);\n        println!(\"  Include code: {}\", if include_code == \"1\" { \"YES (expensive)\" } else { \"NO (cheap)\" });\n        println!(\"  WHERE clause: {}\", where_clause);\n        println!(\"  Output: {}\", output);\n    }\n\n    // Connect to CozoDB\n    let db_adapter = CozoDbAdapter::connect(db).await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Create exporter and config\n    let exporter = Level2Exporter::new();\n    let config = ExportConfig {\n        level: 2,\n        include_code: include_code == \"1\",\n        where_filter: where_clause.clone(),\n        output_path: PathBuf::from(output),\n        // v0.9.0: Dual outputs for code/test separation (None for level02)\n        code_output_path: None,\n        tests_output_path: None,\n        db_path: db.clone(),\n    };\n\n    let base_tokens = exporter.estimated_tokens();\n    let estimated = if config.include_code { base_tokens * 20 } else { base_tokens };\n\n    if verbose {\n        println!(\"  Estimated tokens: ~{}\", estimated);\n    }\n\n    // Execute export\n    let export_output = exporter.export(&db_adapter, &config).await\n        .map_err(|e| anyhow::anyhow!(\"Export failed: {}\", e))?;\n\n    // Write to JSON file\n    let json = serde_json::to_string_pretty(&export_output)\n        .map_err(|e| anyhow::anyhow!(\"JSON serialization failed: {}\", e))?;\n\n    std::fs::write(output, json)\n        .map_err(|e| anyhow::anyhow!(\"Failed to write file: {}\", e))?;\n\n    println!(\"{}\", style(\" PT02 Level 2 export completed\").green().bold());\n    println!(\"  Output file: {}\", output);\n    println!(\"  Entities exported: {}\", export_output.export_metadata.total_entities.unwrap_or(0));\n    println!(\"  Token estimate: ~{} tokens\", estimated);\n    println!(\"  Fields per entity: 22 (all L1 + return_type, param_types, trait_impls, is_async, is_unsafe, etc.)\");\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_pt02_level02",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_pt02_level02\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":686,\"end\":746},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_pt02_level02:__crates_parseltongue_src_main_rs:686-746",
      "line_number": 0
    },
    {
      "current_code": "async fn run_rust_preflight_code_simulator(matches: &ArgMatches) -> Result<()> {\n    use parseltongue_core::storage::CozoDbStorage;\n    use pt04_syntax_preflight_validator::SimpleSyntaxValidator;\n\n    let db = matches.get_one::<String>(\"db\").unwrap();\n    let verbose = matches.get_flag(\"verbose\");\n\n    println!(\"{}\", style(\"Running Tool 4: pt04-syntax-preflight-validator\").cyan());\n    println!(\"  Database: {}\", db);\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    // Fetch changed entities (those with future_action set)\n    let entities = storage.get_changed_entities().await?;\n\n    if entities.is_empty() {\n        println!(\"{}\", style(\" No entities with pending changes found\").yellow());\n        return Ok(());\n    }\n\n    println!(\"  Validating {} changed entities...\", entities.len());\n\n    // Create syntax validator\n    let mut validator = SimpleSyntaxValidator::new()\n        .map_err(|e| anyhow::anyhow!(\"Failed to create validator: {}\", e))?;\n\n    let mut total_validated = 0;\n    let mut total_errors = 0;\n    let mut validation_details = Vec::new();\n\n    // Validate each entity's future_code\n    for entity in &entities {\n        if let Some(future_code) = &entity.future_code {\n            total_validated += 1;\n\n            // Extract language from ISGL1 key (format: language:type:name:path:range)\n            let language = entity.isgl1_key.split(':').next()\n                .and_then(|lang_str| match lang_str {\n                    \"rust\" => Some(Language::Rust),\n                    _ => Some(Language::Rust), // Default to Rust for now\n                })\n                .unwrap_or(Language::Rust);\n\n            let result = validator.validate_syntax(future_code, language)\n                .map_err(|e| anyhow::anyhow!(\"Validation failed for {}: {}\", entity.isgl1_key, e))?;\n\n            if !result.is_valid {\n                total_errors += 1;\n\n                if verbose {\n                    eprintln!(\"{} {}\", style(\"\").red(), entity.isgl1_key);\n                    for error in &result.errors {\n                        eprintln!(\"  {}\", style(error).red());\n                    }\n                }\n\n                validation_details.push((entity.isgl1_key.clone(), result.errors));\n            } else if verbose {\n                println!(\"{} {}\", style(\"\").green(), entity.isgl1_key);\n            }\n        }\n    }\n\n    // Print summary\n    println!();\n    if total_errors == 0 {\n        println!(\"{}\", style(\" All syntax validations passed\").green().bold());\n        println!(\"  Entities validated: {}\", total_validated);\n    } else {\n        eprintln!(\"{}\", style(\" Syntax validation failed\").red().bold());\n        eprintln!(\"  Entities validated: {}\", total_validated);\n        eprintln!(\"  Entities with errors: {}\", total_errors);\n\n        if !verbose {\n            eprintln!();\n            eprintln!(\"Failed entities:\");\n            for (key, errors) in &validation_details {\n                eprintln!(\"  {} {}\", style(\"\").red(), key);\n                for error in errors {\n                    eprintln!(\"    {}\", error);\n                }\n            }\n        }\n\n        return Err(anyhow::anyhow!(\"Syntax validation failed for {} entities\", total_errors));\n    }\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_rust_preflight_code_simulator",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_rust_preflight_code_simulator\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":748,\"end\":839},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_rust_preflight_code_simulator:__crates_parseltongue_src_main_rs:748-839",
      "line_number": 0
    },
    {
      "current_code": "async fn run_streamer(\n    config: &StreamerConfig,\n    verbose: bool,\n    quiet: bool,\n) -> Result<pt01_folder_to_cozodb_streamer::StreamResult, StreamerError> {\n    // Create streamer instance using factory (now async)\n    let streamer = ToolFactory::create_streamer(config.clone()).await?;\n\n    if verbose && !quiet {\n        println!(\"Configuration:\");\n        println!(\"  Root directory: {}\", config.root_dir.display());\n        println!(\"  Database path: {}\", config.db_path);\n        println!(\"  Max file size: {} bytes\", config.max_file_size);\n        println!(\"  Include patterns: {:?}\", config.include_patterns);\n        println!(\"  Exclude patterns: {:?}\", config.exclude_patterns);\n        println!();\n    }\n\n    // Run streaming\n    let result = streamer.stream_directory().await?;\n\n    // Print detailed results if verbose\n    if verbose && !quiet {\n        println!(\"\\nDetailed Results:\");\n        println!(\"  Files scanned: {}\", result.total_files);\n        println!(\"  Files processed: {}\", result.processed_files);\n        println!(\"  Entities created: {}\", result.entities_created);\n        println!(\"  Processing time: {:?}\", result.duration);\n\n        if !result.errors.is_empty() {\n            println!(\"\\nErrors:\");\n            for error in &result.errors {\n                println!(\"  {}\", style(error).yellow());\n            }\n        }\n    }\n\n    Ok(result)\n}",
      "current_ind": 1,
      "entity_name": "run_streamer",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_streamer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/main.rs\",\"line_range\":{\"start\":75,\"end\":113},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_streamer:__crates_pt01-folder-to-cozodb-streamer_src_main_rs:75-113",
      "line_number": 0
    },
    {
      "current_code": "async fn run_writer(mode: InterfaceMode) -> Result<()> {\n    // Extract database path and query based on interface mode\n    let (db_path, query) = match &mode {\n        InterfaceMode::Simple(config) => {\n            println!(\"  Using Simple Interface (Create/Edit/Delete)\");\n            println!(\"  Entity: {}\", config.entity_key);\n            println!(\"  Action: {:?}\", config.action);\n            let query = config.to_datalog();\n            (&config.db_path, query)\n        }\n        InterfaceMode::Advanced(config) => {\n            println!(\"  Using Advanced Interface (Raw Datalog)\");\n            (&config.db_path, config.query.clone())\n        }\n    };\n\n    // Connect to database\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Failed to connect to database: {}\", e))?;\n\n    println!(\"  Executing Datalog query...\");\n\n    // Execute Datalog query via CozoDB (S01: trust the user)\n    storage\n        .execute_query(&query)\n        .await\n        .map_err(|e| anyhow::anyhow!(\"Query execution failed: {}\", e))?;\n\n    println!(\n        \"{}\",\n        style(\" Datalog query executed successfully\").green()\n    );\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "run_writer",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"run_writer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/main.rs\",\"line_range\":{\"start\":62,\"end\":96},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:run_writer:__crates_pt03-llm-to-cozodb-writer_src_main_rs:62-96",
      "line_number": 0
    },
    {
      "current_code": "fn separate_by_entity_class(entities: Vec<Entity>) -> (Vec<Entity>, Vec<Entity>) {\n    let mut code_entities = Vec::new();\n    let mut test_entities = Vec::new();\n    \n    for entity in entities {\n        if entity.entity_class == \"CODE\" {\n            code_entities.push(entity);\n        } else if entity.entity_class == \"TEST\" {\n            test_entities.push(entity);\n        }\n    }\n    \n    (code_entities, test_entities)\n}",
      "current_ind": 1,
      "entity_name": "separate_by_entity_class",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"separate_by_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":162,\"end\":175},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:separate_by_entity_class:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:162-175",
      "line_number": 0
    },
    {
      "current_code": "fn should_exclude_path(path: &std::path::Path, patterns: &[String]) -> bool {\n    let path_str = path.to_string_lossy();\n    \n    // Check each pattern for substring match\n    for pattern in patterns {\n        if path_str.contains(pattern) {\n            return true;\n        }\n    }\n    \n    false\n}",
      "current_ind": 1,
      "entity_name": "should_exclude_path",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"should_exclude_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":313,\"end\":324},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:should_exclude_path:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:313-324",
      "line_number": 0
    },
    {
      "current_code": "fn simulate_test_execution(code: &str) -> Result<bool> {\n    // Simulate: add(2, 3) should equal 5\n    // Check if code contains 'a + b' which would make this pass\n    Ok(code.contains(\"a + b\"))\n}",
      "current_ind": 1,
      "entity_name": "simulate_test_execution",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"simulate_test_execution\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":359,\"end\":363},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:simulate_test_execution:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:359-363",
      "line_number": 0
    },
    {
      "current_code": "async fn simulate_tool1_indexing(\n    project_path: &PathBuf,\n    storage: &CozoDbStorage,\n) -> Result<Vec<CodeEntity>> {\n    use parseltongue_core::entities::{InterfaceSignature, LineRange, LanguageSpecificSignature, RustSignature};\n\n    let mut entities = Vec::new();\n\n    // Index the 'add' function\n    let add_signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"add\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(2, 4).unwrap(),\n        module_path: vec![],\n        documentation: Some(\"Calculate the sum of two numbers\".to_string()),\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let current_code = std::fs::read_to_string(project_path.join(\"src/lib.rs\"))?;\n    let mut add_entity = CodeEntity::new(\"src-lib-rs-add\".to_string(), add_signature)?;\n    add_entity.current_code = Some(current_code.clone());\n    add_entity.future_code = Some(\"\".to_string());\n    add_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&add_entity).await?;\n    entities.push(add_entity);\n\n    // Index the test module\n    let test_signature = InterfaceSignature {\n        entity_type: EntityType::Module,\n        name: \"tests\".to_string(),\n        visibility: Visibility::Private,\n        file_path: PathBuf::from(\"src/lib.rs\"),\n        line_range: LineRange::new(6, 13).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![\"#[cfg(test)]\".to_string()],\n            trait_impl: None,\n        }),\n    };\n\n    let mut test_entity = CodeEntity::new(\"src-lib-rs-tests\".to_string(), test_signature)?;\n    test_entity.current_code = Some(current_code);\n    test_entity.future_code = Some(\"\".to_string());\n    test_entity.temporal_state = TemporalState::unchanged();\n\n    storage.insert_entity(&test_entity).await?;\n    entities.push(test_entity);\n\n    Ok(entities)\n}",
      "current_ind": 1,
      "entity_name": "simulate_tool1_indexing",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"simulate_tool1_indexing\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":256,\"end\":318},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:simulate_tool1_indexing:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:256-318",
      "line_number": 0
    },
    {
      "current_code": "    pub fn tag<'a>(expected: &'a str) -> impl ParserCombinator<'a, &'a str> {\n        Tag { expected }\n    }",
      "current_ind": 1,
      "entity_name": "tag",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"tag\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1301,\"end\":1303},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:tag:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1301-1303",
      "line_number": 0
    },
    {
      "current_code": "    fn temporal_query_creation() {\n        let query = TemporalQuery {\n            base_entities: vec![\"test.rs-test-function\".to_string()],\n            hop_depth: 2,\n            future_only: true,\n            entity_type_filter: Some(EntityType::Function),\n            language_filter: Some(Language::Rust),\n        };\n\n        assert_eq!(query.base_entities.len(), 1);\n        assert_eq!(query.hop_depth, 2);\n        assert!(query.future_only);\n    }",
      "current_ind": 1,
      "entity_name": "temporal_query_creation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"temporal_query_creation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":642,\"end\":654},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:temporal_query_creation:__crates_parseltongue-core_src_interfaces_rs:642-654",
      "line_number": 0
    },
    {
      "current_code": "    fn temporal_state_validation() {\n        let state = TemporalState::unchanged();\n        assert!(state.validate().is_ok());\n        assert!(!state.is_changed());\n\n        let edit_state = TemporalState::edit();\n        assert!(edit_state.validate().is_ok());\n        assert!(edit_state.is_changed());\n    }",
      "current_ind": 1,
      "entity_name": "temporal_state_validation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"temporal_state_validation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1100,\"end\":1108},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:temporal_state_validation:__crates_parseltongue-core_src_entities_rs:1100-1108",
      "line_number": 0
    },
    {
      "current_code": "    fn temporal_state_validation() {\n        let manager = TemporalVersioningManager::new();\n        assert!(manager.validate_state().is_ok());\n    }",
      "current_ind": 1,
      "entity_name": "temporal_state_validation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"temporal_state_validation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":591,\"end\":594},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:temporal_state_validation:__crates_parseltongue-core_src_temporal_rs:591-594",
      "line_number": 0
    },
    {
      "current_code": "    fn temporal_transition_builder() {\n        let transition = TemporalTransitionBuilder::new(\"test.rs-test\".to_string())\n            .action(TemporalAction::Create)\n            .future_code(\"fn test() {}\".to_string())\n            .build()\n            .unwrap();\n\n        assert_eq!(transition.isgl1_key, \"test.rs-test\");\n        assert_eq!(transition.action, TemporalAction::Create);\n        assert_eq!(transition.future_code, Some(\"fn test() {}\".to_string()));\n    }",
      "current_ind": 1,
      "entity_name": "temporal_transition_builder",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"temporal_transition_builder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":649,\"end\":659},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:temporal_transition_builder:__crates_parseltongue-core_src_temporal_rs:649-659",
      "line_number": 0
    },
    {
      "current_code": "    fn test_add_change_updates_metadata() {\n        let mut diff = CodeDiff::new();\n\n        let change = Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None, // Create operations have no current code\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None, // Hash-based keys have no line range\n            interface_signature: \"fn test()\".to_string(),\n        };\n\n        diff.add_change(change);\n\n        assert_eq!(diff.changes.len(), 1);\n        assert_eq!(diff.metadata.total_changes, 1);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 0);\n        assert_eq!(diff.metadata.delete_count, 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_add_change_updates_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_add_change_updates_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":179,\"end\":199},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_add_change_updates_metadata:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:179-199",
      "line_number": 0
    },
    {
      "current_code": "    fn test_advanced_interface_mode() {\n        let config = AdvancedQueryConfig {\n            query: \"?[a] := [[1]]\".to_string(),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Advanced(config);\n\n        match mode {\n            InterfaceMode::Advanced(c) => {\n                assert_eq!(c.query, \"?[a] := [[1]]\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Advanced mode\"),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_advanced_interface_mode",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_advanced_interface_mode\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/main.rs\",\"line_range\":{\"start\":124,\"end\":139},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_advanced_interface_mode:__crates_pt03-llm-to-cozodb-writer_src_main_rs:124-139",
      "line_number": 0
    },
    {
      "current_code": "fn test_all_languages_extract_nonzero_entities() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    // Minimal valid code samples for each language\n    // Note: Swift excluded due to query file issue (tracked separately)\n    let test_cases = vec![\n        (Path::new(\"test.rb\"), \"class Foo\\n  def bar\\n  end\\nend\", \"Ruby\"),\n        (Path::new(\"test.py\"), \"class Foo:\\n    def bar(self):\\n        pass\", \"Python\"),\n        (Path::new(\"test.js\"), \"class Foo { bar() {} }\", \"JavaScript\"),\n        (Path::new(\"test.ts\"), \"class Foo { bar(): void {} }\", \"TypeScript\"),\n        (Path::new(\"test.go\"), \"package main\\ntype Foo struct {}\\nfunc Bar() {}\", \"Go\"),\n        (Path::new(\"test.java\"), \"class Foo { void bar() {} }\", \"Java\"),\n        (Path::new(\"test.php\"), \"<?php class Foo { function bar() {} }\", \"PHP\"),\n        (Path::new(\"test.cs\"), \"class Foo { void Bar() {} }\", \"C#\"),\n        // Swift: Temporarily excluded - query file needs fixing (separate issue)\n    ];\n\n    let mut failures = Vec::new();\n\n    for (path, code, lang_name) in test_cases {\n        match generator.parse_source(code, path) {\n            Ok((entities, _)) => {\n                if entities.is_empty() {\n                    failures.push(format!(\"{}: 0 entities extracted\", lang_name));\n                }\n            }\n            Err(e) => {\n                failures.push(format!(\"{}: parse error - {}\", lang_name, e));\n            }\n        }\n    }\n\n    // RED: This will show which languages fail\n    assert!(\n        failures.is_empty(),\n        \"FAILURE: Multiple languages failed extraction:\\n{}\",\n        failures.join(\"\\n\")\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_all_languages_extract_nonzero_entities",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_all_languages_extract_nonzero_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":232,\"end\":270},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_all_languages_extract_nonzero_entities:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:232-270",
      "line_number": 0
    },
    {
      "current_code": "async fn test_batch_insert_edges() {\n    // RED: Batch insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:helper:src_helper_rs:5-20\")\n            .to_key(\"rust:fn:util:src_util_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:struct:Config:src_config_rs:1-20\")\n            .edge_type(EdgeType::Uses)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
      "current_ind": 1,
      "entity_name": "test_batch_insert_edges",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_batch_insert_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":321,\"end\":348},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_batch_insert_edges:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:321-348",
      "line_number": 0
    },
    {
      "current_code": "async fn test_batch_insert_empty_slice() {\n    // Test: Batch insert with empty slice should succeed (no-op)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges: Vec<DependencyEdge> = vec![];\n    db.insert_edges_batch(&edges).await.unwrap();\n}",
      "current_ind": 1,
      "entity_name": "test_batch_insert_empty_slice",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_batch_insert_empty_slice\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":351,\"end\":358},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_batch_insert_empty_slice:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:351-358",
      "line_number": 0
    },
    {
      "current_code": "async fn test_batch_insert_performance_contract() {\n    // Performance Contract: Batch insert (100 edges) <50ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 100 edges\n    let edges: Vec<DependencyEdge> = (0..100)\n        .map(|i| {\n            DependencyEdge::builder()\n                .from_key(format!(\"entity_{}\", i))\n                .to_key(format!(\"entity_{}\", i + 1))\n                .edge_type(EdgeType::Calls)\n                .build()\n                .unwrap()\n        })\n        .collect();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edges_batch(&edges).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 50,\n        \"Batch insert (100 edges) took {:?}, expected <50ms\",\n        elapsed\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_batch_insert_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_batch_insert_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":391,\"end\":420},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_batch_insert_performance_contract:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:391-420",
      "line_number": 0
    },
    {
      "current_code": "async fn test_blast_radius_branching() {\n    // Test diamond pattern: A -> B, A -> C, B -> D, C -> D\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B, C at distance 1, and D at distance 2 (min distance)\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 3, \"Should find 3 entities (B, C, D)\");\n\n    // D should have minimum distance of 2 (even though reachable via two paths)\n    let d = affected.iter().find(|(k, _)| k.contains(\"fn:D:\"));\n    assert!(d.is_some(), \"Should find D\");\n    assert_eq!(d.unwrap().1, 2, \"D should be at minimum distance 2\");\n}",
      "current_ind": 1,
      "entity_name": "test_blast_radius_branching",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_blast_radius_branching\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":503,\"end\":546},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_blast_radius_branching:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:503-546",
      "line_number": 0
    },
    {
      "current_code": "async fn test_blast_radius_multi_hop() {\n    // RED: Multi-hop blast radius\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 2-hop from A should return B and C\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 2).await.unwrap();\n\n    assert_eq!(affected.len(), 2, \"Should find 2 entities within 2 hops\");\n\n    // Check we have B at distance 1 and C at distance 2\n    let b = affected.iter().find(|(k, _)| k.contains(\"fn:B:\"));\n    let c = affected.iter().find(|(k, _)| k.contains(\"fn:C:\"));\n\n    assert!(b.is_some(), \"Should find B\");\n    assert_eq!(b.unwrap().1, 1, \"B should be at distance 1\");\n\n    assert!(c.is_some(), \"Should find C\");\n    assert_eq!(c.unwrap().1, 2, \"C should be at distance 2\");\n}",
      "current_ind": 1,
      "entity_name": "test_blast_radius_multi_hop",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_blast_radius_multi_hop\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":457,\"end\":500},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_blast_radius_multi_hop:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:457-500",
      "line_number": 0
    },
    {
      "current_code": "async fn test_blast_radius_performance_10k_nodes() {\n    // RED: Validate performance contract - <50ms for 5-hop on 10k nodes (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 3 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let graph_start = Instant::now();\n    let nodes = generate_large_graph(&db, 10_000, 3).await;\n    let graph_time = graph_start.elapsed();\n    println!(\"Graph generation took: {:?}\", graph_time);\n\n    // Warm up query (first query may be slower due to CozoDB internal setup)\n    let _ = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n\n    // Performance test: 5-hop blast radius from first node\n    println!(\"Running blast radius query (5 hops on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.calculate_blast_radius(&nodes[0], 5).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Blast radius query returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance contract: <50ms for 5-hop on 10k nodes (D10 PRD requirement)\n    // Note: Run with --release for production performance (debug builds ~5-10x slower)\n    assert!(\n        elapsed < Duration::from_millis(50),\n        \"Performance contract violated: 5-hop blast radius took {:?}, expected <50ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness: Should find nodes within 5 hops\n    assert!(\n        result.len() >= 5,\n        \"Should find at least direct dependencies in graph\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_blast_radius_performance_10k_nodes",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_blast_radius_performance_10k_nodes\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":899,\"end\":939},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_blast_radius_performance_10k_nodes:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:899-939",
      "line_number": 0
    },
    {
      "current_code": "async fn test_blast_radius_single_hop() {\n    // RED: Blast radius query not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create test graph: A -> B -> C\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: 1-hop from A should return only B\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 1).await.unwrap();\n\n    assert_eq!(affected.len(), 1, \"Should find 1 entity within 1 hop\");\n    assert_eq!(affected[0].0, \"rust:fn:B:test_rs:10-15\");\n    assert_eq!(affected[0].1, 1, \"Distance should be 1\");\n}",
      "current_ind": 1,
      "entity_name": "test_blast_radius_single_hop",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_blast_radius_single_hop\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":425,\"end\":454},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_blast_radius_single_hop:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:425-454",
      "line_number": 0
    },
    {
      "current_code": "async fn test_blast_radius_zero_hops() {\n    // Edge case: 0 hops should return empty\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let affected = db.calculate_blast_radius(\"rust:fn:A:test_rs:1-5\", 0).await.unwrap();\n\n    assert_eq!(affected.len(), 0, \"0 hops should return empty\");\n}",
      "current_ind": 1,
      "entity_name": "test_blast_radius_zero_hops",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_blast_radius_zero_hops\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":549,\"end\":557},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_blast_radius_zero_hops:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:549-557",
      "line_number": 0
    },
    {
      "current_code": "async fn test_both_schemas_can_coexist() {\n    // Test: CodeGraph and DependencyEdges tables can both exist\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create both schemas\n    db.create_schema().await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify both relations exist\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n    assert!(relations.contains(&\"DependencyEdges\".to_string()));\n\n    // Verify we have exactly 2 relations (plus any system relations)\n    let user_relations: Vec<_> = relations\n        .iter()\n        .filter(|r| !r.starts_with(':'))\n        .collect();\n    assert_eq!(\n        user_relations.len(),\n        2,\n        \"Should have exactly 2 user relations. Found: {:?}\",\n        user_relations\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_both_schemas_can_coexist",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_both_schemas_can_coexist\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":237,\"end\":261},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_both_schemas_can_coexist:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:237-261",
      "line_number": 0
    },
    {
      "current_code": "async fn test_calls_in_closure_bodies() {\n    let source = r#\"\nfn transform_all(items: Vec<i32>) -> Vec<i32> {\n    items.iter().map(|x| {\n        let validated = validate(*x);\n        let processed = process(validated);\n        finalize(processed)\n    }).collect()\n}\n\nfn validate(x: i32) -> i32 { x }\nfn process(x: i32) -> i32 { x }\nfn finalize(x: i32) -> i32 { x }\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Calls in Closure Bodies ===\");\n    print_dependencies(&deps);\n\n    assert!(has_call(&deps, \"validate\"), \"Should capture validate() in closure\");\n    assert!(has_call(&deps, \"process\"), \"Should capture process() in closure\");\n    assert!(has_call(&deps, \"finalize\"), \"Should capture finalize() in closure\");\n}",
      "current_ind": 1,
      "entity_name": "test_calls_in_closure_bodies",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_calls_in_closure_bodies\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":217,\"end\":240},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_calls_in_closure_bodies:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:217-240",
      "line_number": 0
    },
    {
      "current_code": "async fn test_calls_in_if_else_branches() {\n    let source = r#\"\nfn handle_request(status: i32) -> i32 {\n    if validate(status) {\n        process(status)\n    } else {\n        fallback()\n    }\n}\n\nfn validate(x: i32) -> bool { true }\nfn process(x: i32) -> i32 { x }\nfn fallback() -> i32 { 0 }\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Calls in If/Else Branches ===\");\n    print_dependencies(&deps);\n\n    assert!(has_call(&deps, \"validate\"), \"Should capture validate() in condition\");\n    assert!(has_call(&deps, \"process\"), \"Should capture process() in if branch\");\n    assert!(has_call(&deps, \"fallback\"), \"Should capture fallback() in else branch\");\n}",
      "current_ind": 1,
      "entity_name": "test_calls_in_if_else_branches",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_calls_in_if_else_branches\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":93,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_calls_in_if_else_branches:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:93-116",
      "line_number": 0
    },
    {
      "current_code": "async fn test_calls_in_loop_bodies() {\n    let source = r#\"\nfn batch_process(items: &[i32]) {\n    for item in items {\n        validate(item);\n        transform(item);\n        store(item);\n    }\n}\n\nfn validate(x: &i32) {}\nfn transform(x: &i32) {}\nfn store(x: &i32) {}\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Calls in Loop Bodies ===\");\n    print_dependencies(&deps);\n\n    assert!(has_call(&deps, \"validate\"), \"Should capture validate() in loop\");\n    assert!(has_call(&deps, \"transform\"), \"Should capture transform() in loop\");\n    assert!(has_call(&deps, \"store\"), \"Should capture store() in loop\");\n}",
      "current_ind": 1,
      "entity_name": "test_calls_in_loop_bodies",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_calls_in_loop_bodies\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":159,\"end\":182},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_calls_in_loop_bodies:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:159-182",
      "line_number": 0
    },
    {
      "current_code": "async fn test_calls_in_match_arms() {\n    let source = r#\"\nenum Status {\n    Ok,\n    Error,\n    Pending,\n}\n\nfn handle(status: Status) {\n    match status {\n        Status::Ok => process_success(),\n        Status::Error => handle_error(),\n        Status::Pending => queue_retry(),\n    }\n}\n\nfn process_success() {}\nfn handle_error() {}\nfn queue_retry() {}\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Calls in Match Arms ===\");\n    print_dependencies(&deps);\n\n    assert!(has_call(&deps, \"process_success\"), \"Should capture process_success() in match arm\");\n    assert!(has_call(&deps, \"handle_error\"), \"Should capture handle_error() in match arm\");\n    assert!(has_call(&deps, \"queue_retry\"), \"Should capture queue_retry() in match arm\");\n}",
      "current_ind": 1,
      "entity_name": "test_calls_in_match_arms",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_calls_in_match_arms\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":123,\"end\":152},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_calls_in_match_arms:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:123-152",
      "line_number": 0
    },
    {
      "current_code": "    fn test_chained_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    a();\n}\n\nfn a() {\n    b();\n}\n\nfn b() {\n    c();\n}\n\nfn c() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->a, a->b, b->c\n        assert_eq!(dependencies.len(), 3);\n\n        // Verify the chain\n        let main_to_a = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"main\") && e.to_key.as_ref().contains(\"a\")\n        );\n        assert!(main_to_a.is_some(), \"Should have main -> a edge\");\n\n        let a_to_b = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:a:\") && e.to_key.as_ref().contains(\"fn:b:\")\n        );\n        assert!(a_to_b.is_some(), \"Should have a -> b edge\");\n\n        let b_to_c = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:b:\") && e.to_key.as_ref().contains(\"fn:c:\")\n        );\n        assert!(b_to_c.is_some(), \"Should have b -> c edge\");\n    }",
      "current_ind": 1,
      "entity_name": "test_chained_function_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_chained_function_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":600,\"end\":642},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_chained_function_calls:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:600-642",
      "line_number": 0
    },
    {
      "current_code": "async fn test_chained_method_calls() {\n    let source = r#\"\nfn process_users(users: Vec<User>) -> Vec<String> {\n    users\n        .iter()\n        .filter(|u| validate(u))\n        .map(|u| transform(u))\n        .collect()\n}\n\nfn validate(u: &User) -> bool { true }\nfn transform(u: &User) -> String { String::new() }\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Chained Method Calls ===\");\n    print_dependencies(&deps);\n\n    // All method calls should be captured\n    assert!(has_call(&deps, \"iter\"), \"Should capture iter()\");\n    assert!(has_call(&deps, \"filter\"), \"Should capture filter()\");\n    assert!(has_call(&deps, \"map\"), \"Should capture map()\");\n    assert!(has_call(&deps, \"collect\"), \"Should capture collect()\");\n\n    // Calls inside closures should also be captured\n    assert!(has_call(&deps, \"validate\"), \"Should capture validate() in closure\");\n    assert!(has_call(&deps, \"transform\"), \"Should capture transform() in closure\");\n}",
      "current_ind": 1,
      "entity_name": "test_chained_method_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_chained_method_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":58,\"end\":86},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_chained_method_calls:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:58-86",
      "line_number": 0
    },
    {
      "current_code": "async fn test_changes_grouped_by_file() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert multiple entities from same file\n    let entity1 = create_test_entity(\n        \"rust:fn:func_a:src_lib_rs:10-20\",\n        Some(\"fn func_a() {}\"),\n        Some(\"fn func_a_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    let entity2 = create_test_entity(\n        \"rust:fn:func_b:src_lib_rs:30-40\",\n        Some(\"fn func_b() {}\"),\n        Some(\"fn func_b_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    // Entity from different file\n    let entity3 = create_test_entity(\n        \"rust:fn:other:src_models_user_rs:50-60\",\n        Some(\"fn other() {}\"),\n        Some(\"fn other_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Changes should be grouped by file path\n    // Convert to file-grouped structure for validation\n    let grouped = group_changes_by_file(&diff.changes);\n\n    assert_eq!(grouped.len(), 2, \"Should have changes from 2 files\");\n\n    let lib_changes = grouped.get(&PathBuf::from(\"src/lib.rs\"));\n    assert!(lib_changes.is_some(), \"Should have changes for src/lib.rs\");\n    assert_eq!(\n        lib_changes.unwrap().len(),\n        2,\n        \"Should have 2 changes for src/lib.rs\"\n    );\n\n    let user_changes = grouped.get(&PathBuf::from(\"src/models/user.rs\"));\n    assert!(\n        user_changes.is_some(),\n        \"Should have changes for src/models/user.rs\"\n    );\n    assert_eq!(\n        user_changes.unwrap().len(),\n        1,\n        \"Should have 1 change for src/models/user.rs\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_changes_grouped_by_file",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_changes_grouped_by_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":178,\"end\":239},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_changes_grouped_by_file:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:178-239",
      "line_number": 0
    },
    {
      "current_code": "    fn test_circular_dependency_error() {\n        let error = ParseltongError::CircularDependency {\n            path: \"A -> B -> C -> A\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Circular dependency detected\"));\n        assert!(formatted.contains(\"A -> B -> C -> A\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_circular_dependency_error",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_circular_dependency_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":221,\"end\":229},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_circular_dependency_error:__crates_parseltongue-core_src_error_rs:221-229",
      "line_number": 0
    },
    {
      "current_code": "    fn test_classification_performance_contract() {\n        // Arrange: Test file for classification\n        let file_path = \"src/test_module.rs\";\n        let start_time = std::time::Instant::now();\n\n        // Act: Perform classification (simulating PT01 logic)\n        let is_test_file = file_path.contains(\"test\") || \n                          file_path.starts_with(\"tests/\") || \n                          file_path.starts_with(\"test/\");\n        \n        let entity_class = if is_test_file {\n            EntityClass::TestImplementation\n        } else {\n            EntityClass::CodeImplementation\n        };\n\n        let elapsed = start_time.elapsed();\n\n        // Assert: Classification completes within performance contract\n        assert!(elapsed.as_micros() < 50, \n               \"Classification should complete within 50s, took {}s\", \n               elapsed.as_micros());\n        \n        assert_eq!(entity_class, EntityClass::TestImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_classification_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_classification_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":230,\"end\":254},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_classification_performance_contract:__crates_parseltongue-core_src_entity_class_specifications_rs:230-254",
      "line_number": 0
    },
    {
      "current_code": "async fn test_claude_orchestrates_bug_fix_workflow() -> Result<()> {\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" CLAUDE CODE AS AGENT ORCHESTRATOR\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    // ========================================\n    // PHASE 0: SETUP - Create project with bug\n    // ========================================\n    println!(\"\\n PHASE 0: Setting up test project...\");\n    let test_project = create_test_project_with_subtraction_bug()?;\n    let project_path = test_project.path().to_path_buf();\n\n    println!(\" Created test project at: {:?}\", project_path);\n    println!(\"   Bug: 'add' function uses subtraction instead of addition\");\n\n    // ========================================\n    // PHASE 1: INDEX (Tool 1) - Scan codebase\n    // ========================================\n    println!(\"\\n PHASE 1: Indexing codebase (Tool 1)...\");\n    println!(\"    Claude Decision: Scan src/ directory to build code graph\");\n\n    let start_index = Instant::now();\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Simulate Tool 1 output\n    let indexed_entities = simulate_tool1_indexing(&project_path, &storage).await?;\n\n    println!(\" Indexed {} entities in {:?}\", indexed_entities.len(), start_index.elapsed());\n    for entity in &indexed_entities {\n        println!(\"   - {} ({:?})\", entity.isgl1_key, entity.interface_signature.entity_type);\n    }\n\n    // ========================================\n    // PHASE 2: REASONING (Tool 2) - Identify bug and propose fix\n    // ========================================\n    println!(\"\\n PHASE 2: LLM Reasoning and Change Proposal (Tool 2)...\");\n    println!(\"    Claude Analysis:\");\n    println!(\"      - Function 'add' has doc comment 'Calculate the sum'\");\n    println!(\"      - Implementation uses subtraction: a - b\");\n    println!(\"      - Test expects: add(2, 3) == 5\");\n    println!(\"      - Current output would be: -1\");\n    println!(\"    Claude Decision: Propose fix - change 'a - b' to 'a + b'\");\n\n    let mut storage_mut = storage;\n\n    // Find the add function entity\n    let add_entity = indexed_entities.iter()\n        .find(|e| e.isgl1_key.contains(\"add\"))\n        .expect(\"Should have indexed 'add' function\");\n\n    // Claude reasons about the fix\n    let fixed_code = generate_fixed_code();\n\n    // Apply temporal change (Tool 2 operation)\n    let mut modified_entity = add_entity.clone();\n    modified_entity.future_code = Some(fixed_code.clone());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n    modified_entity.temporal_state.future_ind = true;\n\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    println!(\" Temporal change recorded in CozoDB\");\n    println!(\"   - future_action: Edit\");\n    println!(\"   - future_code: Changed 'a - b' to 'a + b'\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: CONTEXT EXTRACTION (Tool 3) - Get context for validation\n    // ========================================\n    println!(\"\\n PHASE 3: Extracting context for validation (Tool 3)...\");\n    println!(\"    Claude Decision: Query changed entities for next reasoning cycle\");\n\n    let changed_entities = storage.get_changed_entities().await?;\n\n    println!(\" Extracted {} changed entities\", changed_entities.len());\n    println!(\"   Context includes:\");\n    println!(\"   - Current code (buggy version)\");\n    println!(\"   - Proposed code (fixed version)\");\n    println!(\"   - Interface signature\");\n    println!(\"   - Temporal state\");\n\n    // ========================================\n    // PHASE 4: VALIDATION (Tool 4) - Verify proposed changes\n    // ========================================\n    println!(\"\\n PHASE 4: Validating proposed changes (Tool 4)...\");\n    println!(\"    Claude Decision: Run preflight checks on proposed code\");\n\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n\n    // Syntax validation\n    print!(\"   - Syntax check: \");\n    let syntax_valid = validate_rust_syntax(future_code)?;\n    println!(\"{}\", if syntax_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Semantic validation\n    print!(\"   - Semantic check: \");\n    let semantic_valid = validate_semantics(future_code)?;\n    println!(\"{}\", if semantic_valid { \" PASS\" } else { \" FAIL\" });\n\n    // Test simulation\n    print!(\"   - Test simulation: \");\n    let test_would_pass = simulate_test_execution(future_code)?;\n    println!(\"{}\", if test_would_pass { \" PASS\" } else { \" FAIL\" });\n\n    println!(\" All validation checks passed\");\n    println!(\"    Claude Decision: Proceed to write phase (confidence: 95%)\");\n\n    // ========================================\n    // PHASE 5: WRITING (Tool 5) - Apply validated changes\n    // ========================================\n    println!(\"\\n PHASE 5: Writing validated changes to files (Tool 5)...\");\n    println!(\"    Claude Decision: Write future_code to filesystem\");\n\n    let target_file = project_path.join(\"src/lib.rs\");\n    tokio::fs::write(&target_file, future_code).await?;\n\n    println!(\" Wrote changes to: {}\", target_file.display());\n    println!(\"   - Replaced 'a - b' with 'a + b'\");\n\n    // Verify the fix by running actual tests\n    println!(\"   Running actual cargo test...\");\n    let test_output = std::process::Command::new(\"cargo\")\n        .args(&[\"test\", \"--manifest-path\"])\n        .arg(project_path.join(\"Cargo.toml\"))\n        .output()?;\n\n    let test_passed = test_output.status.success();\n    println!(\"   Test result: {}\", if test_passed { \" PASS\" } else { \" FAIL\" });\n\n    assert!(test_passed, \"Tests should pass after bug fix\");\n\n    // ========================================\n    // PHASE 6: RESET (Tool 6) - Clean database state\n    // ========================================\n    println!(\"\\n PHASE 6: Resetting database state (Tool 6)...\");\n    println!(\"    Claude Decision: Drop CodeGraph table, ready for next cycle\");\n\n    // Simulate Tool 6 state reset\n    drop(storage); // Release database handle\n    println!(\" Database state reset complete\");\n\n    // ========================================\n    // FINAL SUMMARY\n    // ========================================\n    println!(\"\\n{}\", \"=\".repeat(70));\n    println!(\" ORCHESTRATION COMPLETE - BUG FIXED!\");\n    println!(\"{}\", \"=\".repeat(70));\n    println!(\"\\n Orchestration Summary:\");\n    println!(\"    Phase 0: Test project setup\");\n    println!(\"    Phase 1: Codebase indexed (2 entities)\");\n    println!(\"    Phase 2: Bug identified and fix proposed\");\n    println!(\"    Phase 3: Context extracted for validation\");\n    println!(\"    Phase 4: All validation checks passed\");\n    println!(\"    Phase 5: Fix applied to filesystem\");\n    println!(\"    Phase 6: Database state reset\");\n    println!(\"\\n Claude Code successfully orchestrated the complete workflow!\");\n    println!(\"{}\", \"=\".repeat(70));\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "test_claude_orchestrates_bug_fix_workflow",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_claude_orchestrates_bug_fix_workflow\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":47,\"end\":208},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_claude_orchestrates_bug_fix_workflow:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:47-208",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_builds() {\n        let cli = build_cli();\n        // Verify all subcommands are present (v0.8.5: PT02 progressive disclosure)\n        let subcommands: Vec<&str> = cli.get_subcommands().map(|cmd| cmd.get_name()).collect();\n        assert!(subcommands.contains(&\"pt01-folder-to-cozodb-streamer\"));\n        assert!(subcommands.contains(&\"pt02-level00\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt02-level01\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt02-level02\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt03-llm-to-cozodb-writer\"));\n        assert!(subcommands.contains(&\"pt04-syntax-preflight-validator\"));\n        assert!(subcommands.contains(&\"pt05-llm-cozodb-to-diff-writer\"));\n        assert!(subcommands.contains(&\"pt06-cozodb-make-future-code-current\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_builds",
      "entity_type": "function",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_builds\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":943,\"end\":955},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_builds:__crates_parseltongue_src_main_rs:943-955",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"/test/dir\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"/test/dir\"));\n        assert_eq!(config.db_path, \"test.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_config_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_config_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":143,\"end\":167},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_config_parsing:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:143-167",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[a] := [[1]]\",\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[a] := [[1]]\");\n        assert_eq!(config.db_path, \"test.db\");\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_config_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_config_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":187,\"end\":203},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_config_parsing:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:187-203",
      "line_number": 0
    },
    {
      "current_code": "fn test_cli_mutual_exclusion() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    // Attempt to use both interfaces simultaneously\n    let result = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\", \"?[x] := [[1]]\",\n        \"--entity\", \"rust:fn:test:lib_rs:1-5\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"fn test() {}\",\n    ]);\n\n    // Error condition: Mutual exclusion violated\n    assert!(result.is_err(), \"Should reject both --query and --entity\");\n}",
      "current_ind": 1,
      "entity_name": "test_cli_mutual_exclusion",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_mutual_exclusion\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":99,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_mutual_exclusion:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:99-115",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_parsing() {\n        let cli = Cli {\n            database: PathBuf::from(\"./parseltongue.db\"),\n            root: PathBuf::from(\"./project\"),\n            dry_run: false,\n            verbose: false,\n        };\n\n        assert_eq!(cli.database, PathBuf::from(\"./parseltongue.db\"));\n        assert_eq!(cli.root, PathBuf::from(\"./project\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs\",\"line_range\":{\"start\":37,\"end\":47},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_parsing:__crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:37-47",
      "line_number": 0
    },
    {
      "current_code": "fn test_cli_parsing_default_db() {\n    let cli = CliConfig::build_cli();\n\n    // Test with only --query (should use default db)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[x] := [[42]]\",\n    ]);\n\n    assert!(matches.is_ok());\n\n    let config = CliConfig::parse_config(&matches.unwrap());\n    assert_eq!(config.db_path, \"parseltongue.db\", \"Should use default database path\");\n}",
      "current_ind": 1,
      "entity_name": "test_cli_parsing_default_db",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_parsing_default_db\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":72,\"end\":86},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_parsing_default_db:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:72-86",
      "line_number": 0
    },
    {
      "current_code": "fn test_cli_parsing_missing_query() {\n    let cli = CliConfig::build_cli();\n\n    // Test with missing --query (should fail)\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--db\",\n        \"test.db\",\n    ]);\n\n    assert!(matches.is_err(), \"CLI should require --query argument\");\n}",
      "current_ind": 1,
      "entity_name": "test_cli_parsing_missing_query",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_parsing_missing_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":90,\"end\":101},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_parsing_missing_query:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:90-101",
      "line_number": 0
    },
    {
      "current_code": "fn test_cli_parsing_query_interface() {\n    let cli = CliConfig::build_cli();\n\n    // Test with both arguments\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--query\",\n        \"?[a, b, c] := [[1, 2, 3]]\",\n        \"--db\",\n        \"rocksdb:test.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse valid arguments\");\n\n    let matches = matches.unwrap();\n    let config = CliConfig::parse_config(&matches);\n\n    assert_eq!(config.query, \"?[a, b, c] := [[1, 2, 3]]\");\n    assert_eq!(config.db_path, \"rocksdb:test.db\");\n}",
      "current_ind": 1,
      "entity_name": "test_cli_parsing_query_interface",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_parsing_query_interface\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":49,\"end\":68},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_parsing_query_interface:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:49-68",
      "line_number": 0
    },
    {
      "current_code": "fn test_cli_simple_interface_parsing() {\n    use pt03_llm_to_cozodb_writer::cli::CliConfig;\n\n    let cli = CliConfig::build_cli();\n\n    let matches = cli.try_get_matches_from(&[\n        \"llm-to-cozodb-writer\",\n        \"--entity\", \"rust:fn:hello:greeter_src_lib_rs:4-6\",\n        \"--action\", \"edit\",\n        \"--future-code\", \"pub fn hello() -> &'static str { \\\"Hello!\\\" }\",\n        \"--db\", \"rocksdb:demo.db\",\n    ]);\n\n    assert!(matches.is_ok(), \"CLI should parse simple interface\");\n\n    let matches = matches.unwrap();\n    let mode = CliConfig::parse_interface_mode(&matches);\n\n    match mode {\n        InterfaceMode::Simple(config) => {\n            assert_eq!(config.entity_key, \"rust:fn:hello:greeter_src_lib_rs:4-6\");\n            assert!(matches!(config.action, EntityAction::Edit));\n            assert_eq!(config.db_path, \"rocksdb:demo.db\");\n        }\n        _ => panic!(\"Expected Simple interface mode\"),\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_cli_simple_interface_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_simple_interface_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":119,\"end\":145},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_simple_interface_parsing:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:119-145",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_validation_requires_input() {\n        // Create CLI without code snippet or file\n        let cli = Cli {\n            code_snippet: None,\n            file: None,\n            validation_type: ValidationTypeArg::All,\n            verbose: false,\n            output_format: OutputFormat::Text,\n        };\n\n        assert!(cli.validate().is_err());\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_validation_requires_input",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_validation_requires_input\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":73,\"end\":84},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_validation_requires_input:__crates_pt04-syntax-preflight-validator_src_cli_rs:73-84",
      "line_number": 0
    },
    {
      "current_code": "    fn test_cli_validation_with_code_snippet() {\n        let cli = Cli {\n            code_snippet: Some(\"fn main() {}\".to_string()),\n            file: None,\n            validation_type: ValidationTypeArg::Syntax,\n            verbose: false,\n            output_format: OutputFormat::Json,\n        };\n\n        assert!(cli.validate().is_ok());\n    }",
      "current_ind": 1,
      "entity_name": "test_cli_validation_with_code_snippet",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cli_validation_with_code_snippet\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":87,\"end\":97},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cli_validation_with_code_snippet:__crates_pt04-syntax-preflight-validator_src_cli_rs:87-97",
      "line_number": 0
    },
    {
      "current_code": "async fn test_code_diff_json_output() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    let entity = create_test_entity(\n        \"src_lib_rs-test-fn-abc\",\n        Some(\"fn test() {}\"),\n        TemporalAction::Create,\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator.generate_diff().await.unwrap();\n\n    let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n\n    // Verify JSON structure\n    assert!(json.contains(\"\\\"changes\\\"\"));\n    assert!(json.contains(\"\\\"metadata\\\"\"));\n    assert!(json.contains(\"\\\"CREATE\\\"\"));\n    assert!(json.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json.contains(\"\\\"file_path\\\"\"));\n    assert!(json.contains(\"\\\"future_code\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_code_diff_json_output",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_code_diff_json_output\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":190,\"end\":214},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_code_diff_json_output:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:190-214",
      "line_number": 0
    },
    {
      "current_code": "    fn test_code_entity_creation_requires_entity_class() {\n        // Arrange: Valid entity creation parameters\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"test.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create entity with mandatory EntityClass\n        let entity = CodeEntity::new(\n            \"test.rs-test_function-fn-abc123\".to_string(),\n            signature,\n            EntityClass::CodeImplementation, // v0.9.0: mandatory parameter\n        );\n\n        // Assert: Entity created successfully with EntityClass\n        assert!(entity.is_ok(), \"Entity creation should succeed with EntityClass\");\n        let entity = entity.unwrap();\n        assert_eq!(entity.entity_class, EntityClass::CodeImplementation);\n        assert_eq!(entity.isgl1_key, \"test.rs-test_function-fn-abc123\");\n    }",
      "current_ind": 1,
      "entity_name": "test_code_entity_creation_requires_entity_class",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_code_entity_creation_requires_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":19,\"end\":52},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_code_entity_creation_requires_entity_class:__crates_parseltongue-core_src_entity_class_specifications_rs:19-52",
      "line_number": 0
    },
    {
      "current_code": "async fn test_codegraph_repository_trait() {\n    // Test: CodeGraphRepository trait implementation\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n    let mut db: Box<dyn CodeGraphRepository> = Box::new(storage);\n\n    let entity = create_test_entity();\n\n    // Test trait methods\n    db.store_entity(entity.clone()).await.unwrap();\n\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert!(retrieved.is_some());\n    assert_eq!(retrieved.unwrap().isgl1_key, \"test-file-rs-TestStruct\");\n}",
      "current_ind": 1,
      "entity_name": "test_codegraph_repository_trait",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_codegraph_repository_trait\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":172,\"end\":186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_codegraph_repository_trait:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:172-186",
      "line_number": 0
    },
    {
      "current_code": "async fn test_complete_6_tool_workflow() -> Result<()> {\n    // ========================================\n    // SETUP: Create test project with bug\n    // ========================================\n    let test_project = create_test_rust_project_with_bug()?;\n\n    // ========================================\n    // PHASE 1: Tool 1 - Index codebase\n    // ========================================\n    println!(\"\\n Phase 1: Indexing codebase...\");\n    let start_indexing = Instant::now();\n\n    // Initialize database (use in-memory for tests)\n    let storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Index test project (simulating Tool 1 output)\n    let test_entity = create_indexed_entity_from_project(&test_project)?;\n    storage.insert_entity(&test_entity).await?;\n\n    let indexing_duration = start_indexing.elapsed();\n    println!(\" Indexed 1 entity in {:?}\", indexing_duration);\n\n    // **Contract**: Indexing should be fast (<1s for small project)\n    assert!(\n        indexing_duration.as_secs() < 1,\n        \"Indexing took {:?}, expected <1s for small project\",\n        indexing_duration\n    );\n\n    // **Contract**: Entity should exist with correct temporal state\n    let retrieved = storage.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // ========================================\n    // PHASE 2: Tool 2 - Apply temporal changes\n    // ========================================\n    println!(\"\\n  Phase 2: Applying temporal changes...\");\n\n    // Simulate LLM reasoning: Mark entity for modification\n    let mut modified_entity = retrieved.clone();\n    modified_entity.future_code = Some(get_fixed_code());\n    modified_entity.temporal_state.future_action = Some(TemporalAction::Edit);\n\n    let mut storage_mut = storage;\n    storage_mut.update_entity(modified_entity.clone()).await?;\n\n    // **Contract**: Temporal flags should be set correctly\n    let after_tool2 = storage_mut.get_entity(&test_entity.isgl1_key).await?;\n    assert_eq!(after_tool2.temporal_state.current_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_ind, true);\n    assert_eq!(after_tool2.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert!(after_tool2.future_code.is_some());\n    println!(\" Temporal state updated correctly\");\n\n    let storage = storage_mut;\n\n    // ========================================\n    // PHASE 3: Tool 3 - Generate context\n    // ========================================\n    println!(\"\\n Phase 3: Generating context...\");\n    let start_context = Instant::now();\n\n    // Query entities with changes (simulating Tool 3)\n    let changed_entities = storage.get_changed_entities().await?;\n\n    let context_duration = start_context.elapsed();\n    println!(\" Generated context for {} entities in {:?}\",\n             changed_entities.len(), context_duration);\n\n    // **Contract**: Context generation should be fast (<100ms)\n    assert!(\n        context_duration.as_millis() < 100,\n        \"Context generation took {:?}, expected <100ms\",\n        context_duration\n    );\n\n    // **Contract**: Should only return changed entities\n    assert_eq!(changed_entities.len(), 1);\n    assert_eq!(changed_entities[0].temporal_state.future_action, Some(TemporalAction::Edit));\n\n    // ========================================\n    // PHASE 4: Tool 4 - Validate changes\n    // ========================================\n    println!(\"\\n Phase 4: Validating changes...\");\n\n    // Simulate validation (Tool 4 would run syntax/build/test checks)\n    let future_code = changed_entities[0].future_code.as_ref().unwrap();\n    let validation_result = validate_rust_syntax(future_code)?;\n\n    println!(\" Validation passed: {:?}\", validation_result);\n\n    // **Contract**: Validation should pass for fixed code\n    assert!(validation_result.is_valid);\n    assert!(validation_result.errors.is_empty());\n\n    // ========================================\n    // PHASE 5: Tool 5 - Write files\n    // ========================================\n    println!(\"\\n Phase 5: Writing changes to files...\");\n\n    // Simulate file writing (Tool 5)\n    let file_path = test_project.path().join(\"src/lib.rs\");\n    tokio::fs::write(&file_path, future_code).await?;\n\n    println!(\" Written changes to {}\", file_path.display());\n\n    // **Contract**: File should exist and contain new code\n    let written_content = tokio::fs::read_to_string(&file_path).await?;\n    assert_eq!(written_content, *future_code);\n\n    // ========================================\n    // PHASE 6: Tool 6 - Reset state\n    // ========================================\n    println!(\"\\n Phase 6: Resetting database state...\");\n\n    // Simulate state reset (Tool 6 would delete table and re-index)\n    // In a real implementation, Tool 6 would:\n    // 1. Drop/delete the CodeGraph table\n    // 2. Recreate schema\n    // 3. Trigger Tool 1 to re-index\n    //\n    // For this test, we verify the workflow completes successfully\n    // The schema already exists from Phase 1, which is fine for this test\n\n    println!(\" Database state reset completed\");\n\n    // **Contract**: Workflow completed successfully through all 6 phases\n    // (In production, Tool 6 would reset the database and trigger Tool 1 re-indexing)\n\n    // ========================================\n    // FINAL VALIDATION\n    // ========================================\n    println!(\"\\n Complete 6-tool workflow PASSED!\");\n    println!(\"    Phase 1: Indexing\");\n    println!(\"    Phase 2: Temporal updates\");\n    println!(\"    Phase 3: Context generation\");\n    println!(\"    Phase 4: Validation\");\n    println!(\"    Phase 5: File writing\");\n    println!(\"    Phase 6: State reset\");\n\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "test_complete_6_tool_workflow",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_complete_6_tool_workflow\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":41,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_complete_6_tool_workflow:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:41-185",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_complete_reset_cycle() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Add entities\n        storage.insert_entity(&create_test_entity(\"entity-1\")).await.unwrap();\n        storage.insert_entity(&create_test_entity(\"entity-2\")).await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        // Execute reset\n        let result = manager.reset(&project_path).await.unwrap();\n\n        // Postconditions\n        assert!(result.success, \"Reset should succeed\");\n        assert!(result.schema_recreated, \"Schema should be recreated\");\n\n        // Verify entities deleted\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 0, \"All entities should be deleted\");\n    }",
      "current_ind": 1,
      "entity_name": "test_complete_reset_cycle",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_complete_reset_cycle\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":283,\"end\":306},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_complete_reset_cycle:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:283-306",
      "line_number": 0
    },
    {
      "current_code": "async fn test_cozo_connection() {\n    // Test: Real CozoDB connection works\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    // Create schema first to ensure database is properly initialized\n    db.create_schema().await.unwrap();\n    assert!(db.is_connected().await);\n}",
      "current_ind": 1,
      "entity_name": "test_cozo_connection",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_cozo_connection\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":43,\"end\":49},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_cozo_connection:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:43-49",
      "line_number": 0
    },
    {
      "current_code": "fn test_create_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog:\\n{}\", datalog);\n\n    // Postcondition: current_ind=0, future_ind=1, Future_Action=\"Create\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"current_ind: false\") || datalog.contains(\"false\"), \"Missing current_ind=false\");\n    assert!(datalog.contains(\"future_ind: true\") || datalog.contains(\"true\"), \"Missing future_ind=true\");\n    assert!(datalog.contains(\"Future_Action: \\\"Create\\\"\") || datalog.contains(\"\\\"Create\\\"\"), \"Missing Future_Action\");\n    assert!(datalog.contains(\"rust:fn:new_func:src_lib_rs:10-15\"));\n    assert!(datalog.contains(\"pub fn new_func() {}\"));\n}",
      "current_ind": 1,
      "entity_name": "test_create_action_generates_datalog",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_create_action_generates_datalog\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":12,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_create_action_generates_datalog:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:12-30",
      "line_number": 0
    },
    {
      "current_code": "async fn test_create_code_graph_schema() {\n    // RED: Schema creation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Verify CodeGraph relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(relations.contains(&\"CodeGraph\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_create_code_graph_schema",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_create_code_graph_schema\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":52,\"end\":60},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_create_code_graph_schema:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:52-60",
      "line_number": 0
    },
    {
      "current_code": "async fn test_create_dependency_edges_schema() {\n    // RED: DependencyEdges schema creation not yet implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Verify DependencyEdges relation exists\n    let relations = db.list_relations().await.unwrap();\n    assert!(\n        relations.contains(&\"DependencyEdges\".to_string()),\n        \"DependencyEdges table should exist after schema creation. Found: {:?}\",\n        relations\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_create_dependency_edges_schema",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_create_dependency_edges_schema\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":191,\"end\":205},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_create_dependency_edges_schema:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:191-205",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_create_new_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n\n        let entity = create_test_entity(\n            \"src-utils-rs-helper_function\",\n            Some(\"fn helper() {}\".to_string()),\n            TemporalState::create(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n\n        let file_path = temp_dir.path().join(\"src/utils.rs\");\n        assert!(file_path.exists());\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn helper() {}\");\n    }",
      "current_ind": 1,
      "entity_name": "test_create_new_file",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_create_new_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":165,\"end\":184},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_create_new_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:165-184",
      "line_number": 0
    },
    {
      "current_code": "fn test_create_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: None, // ERROR: Create requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
      "current_ind": 1,
      "entity_name": "test_create_requires_future_code",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_create_requires_future_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":72,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_create_requires_future_code:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:72-81",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_database_query_selects_entity_class() {\n        // This test will fail initially - queries don't select entity_class\n        // Mock the database to verify the query includes entity_class\n        \n        // Arrange: Create mock storage that captures queries\n        // Act: Query entities \n        // Assert: Query includes entity_class in SELECT and FROM clauses\n        \n        // For now, this is a placeholder that will be implemented\n        // when we have the proper mock infrastructure\n        assert!(true, \"Placeholder - will implement actual query verification\");\n    }",
      "current_ind": 1,
      "entity_name": "test_database_query_selects_entity_class",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_database_query_selects_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":55,\"end\":66},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_database_query_selects_entity_class:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:55-66",
      "line_number": 0
    },
    {
      "current_code": "    fn test_database_schema_includes_entity_class() {\n        // This test verifies the CozoDB schema includes entity_class\n        // The actual schema is tested in storage/cozo_client.rs\n        // Here we verify the entity_class field is part of the struct\n        \n        // Arrange: Create an entity\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Struct,\n            name: \"TestStruct\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"test.rs\"),\n            line_range: crate::entities::LineRange::new(1, 5).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create entity\n        let entity = CodeEntity::new(\n            \"test.rs-TestStruct-struct-jkl012\".to_string(),\n            signature,\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Assert: entity_class field exists and is accessible\n        assert_eq!(entity.entity_class.to_string(), \"CODE\");\n        assert_eq!(format!(\"{}\", entity.entity_class), \"CODE\");\n    }",
      "current_ind": 1,
      "entity_name": "test_database_schema_includes_entity_class",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_database_schema_includes_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":120,\"end\":155},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_database_schema_includes_entity_class:__crates_parseltongue-core_src_entity_class_specifications_rs:120-155",
      "line_number": 0
    },
    {
      "current_code": "async fn test_deeply_nested_calls() {\n    let source = r#\"\nfn compute() -> i32 {\n    outer(middle(inner(leaf())))\n}\n\nfn outer(x: i32) -> i32 { x }\nfn middle(x: i32) -> i32 { x }\nfn inner(x: i32) -> i32 { x }\nfn leaf() -> i32 { 42 }\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Deeply Nested Calls ===\");\n    print_dependencies(&deps);\n\n    assert!(has_call(&deps, \"outer\"), \"Should capture outer()\");\n    assert!(has_call(&deps, \"middle\"), \"Should capture middle()\");\n    assert!(has_call(&deps, \"inner\"), \"Should capture inner()\");\n    assert!(has_call(&deps, \"leaf\"), \"Should capture leaf()\");\n}",
      "current_ind": 1,
      "entity_name": "test_deeply_nested_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_deeply_nested_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":189,\"end\":210},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_deeply_nested_calls:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:189-210",
      "line_number": 0
    },
    {
      "current_code": "    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \".\",  // Directory is now required (positional argument)\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI defaults\n        assert_eq!(config.root_dir, PathBuf::from(\".\"));\n        assert_eq!(config.db_path, \"mem\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
      "current_ind": 1,
      "entity_name": "test_default_config",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_default_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":170,\"end\":192},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_default_config:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:170-192",
      "line_number": 0
    },
    {
      "current_code": "    fn test_default_db_path() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[b] := [[2]]\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[b] := [[2]]\");\n        assert_eq!(config.db_path, \"parseltongue.db\"); // Default value\n    }",
      "current_ind": 1,
      "entity_name": "test_default_db_path",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_default_db_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":206,\"end\":220},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_default_db_path:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:206-220",
      "line_number": 0
    },
    {
      "current_code": "fn test_delete_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:old_func:src_lib_rs:20-25\".to_string(),\n        action: EntityAction::Delete,\n        future_code: None, // Optional for Delete\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=0, Future_Action=\"Delete\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing current_ind=true\");\n    assert!(datalog.contains(\"false\"), \"Missing future_ind=false\");\n    assert!(datalog.contains(\"\\\"Delete\\\"\"), \"Missing Delete action\");\n}",
      "current_ind": 1,
      "entity_name": "test_delete_action_generates_datalog",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_delete_action_generates_datalog\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":52,\"end\":67},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_delete_action_generates_datalog:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:52-67",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_delete_codegraph_table_removes_all_entities() {\n        // Setup: Create database with test entities\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Insert 3 test entities\n        let entities = vec![\n            create_test_entity(\"test-1\"),\n            create_test_entity(\"test-2\"),\n            create_test_entity(\"test-3\"),\n        ];\n        for entity in &entities {\n            storage.insert_entity(entity).await.unwrap();\n        }\n\n        let before_count = storage.get_all_entities().await.unwrap().len();\n        assert_eq!(before_count, 3, \"Precondition: Should have 3 entities\");\n\n        // Execute: Delete table\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n        assert!(result.is_ok(), \"Delete operation should succeed\");\n\n        // Postcondition: Verify ALL entities deleted\n        let after_count = manager.storage.get_all_entities().await.unwrap().len();\n        assert_eq!(\n            after_count, 0,\n            \"Postcondition: Should have 0 entities after deletion, found {}\",\n            after_count\n        );\n    }",
      "current_ind": 1,
      "entity_name": "test_delete_codegraph_table_removes_all_entities",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_delete_codegraph_table_removes_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":135,\"end\":165},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_delete_codegraph_table_removes_all_entities:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:135-165",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_delete_empty_table_succeeds() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Verify empty\n        let before = storage.get_all_entities().await.unwrap();\n        assert_eq!(before.len(), 0, \"Precondition: Database should be empty\");\n\n        // Execute\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n\n        // Postcondition: Should succeed\n        assert!(result.is_ok(), \"Delete on empty table should succeed\");\n    }",
      "current_ind": 1,
      "entity_name": "test_delete_empty_table_succeeds",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_delete_empty_table_succeeds\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":176,\"end\":190},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_delete_empty_table_succeeds:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:176-190",
      "line_number": 0
    },
    {
      "current_code": "async fn test_delete_entity() {\n    // RED: Delete operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Delete entity\n    db.delete_entity(\"test-file-rs-TestStruct\").await.unwrap();\n\n    // Verify deletion - should return None\n    let result = db.get_entity(\"test-file-rs-TestStruct\").await;\n    assert!(result.is_err() || result.unwrap().isgl1_key.is_empty());\n}",
      "current_ind": 1,
      "entity_name": "test_delete_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_delete_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":154,\"end\":169},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_delete_entity:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:154-169",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_delete_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/delete_me.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn to_delete() {}\")\n            .await\n            .unwrap();\n        assert!(file_path.exists());\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-delete_me-rs-ToDelete\",\n            None,\n            TemporalState::delete(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Delete);\n        assert!(!file_path.exists());\n    }",
      "current_ind": 1,
      "entity_name": "test_delete_file",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_delete_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":215,\"end\":238},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_delete_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:215-238",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_builder() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n        assert_eq!(edge.source_location, None);\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_builder",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_builder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1465,\"end\":1477},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_builder:__crates_parseltongue-core_src_entities_rs:1465-1477",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_builder_missing_field() {\n        // Missing to_key\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when to_key is missing\");\n\n        // Missing from_key\n        let result = DependencyEdge::builder()\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when from_key is missing\");\n\n        // Missing edge_type\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .build();\n\n        assert!(result.is_err(), \"Should fail when edge_type is missing\");\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_builder_missing_field",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_builder_missing_field\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1493,\"end\":1517},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_builder_missing_field:__crates_parseltongue-core_src_entities_rs:1493-1517",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_builder_with_location() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_main_rs:20-30\")\n            .edge_type(EdgeType::Calls)\n            .source_location(\"src/main.rs:5\")\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.source_location, Some(\"src/main.rs:5\".to_string()));\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_builder_with_location",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_builder_with_location\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1480,\"end\":1490},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_builder_with_location:__crates_parseltongue-core_src_entities_rs:1480-1490",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_new() {\n        let edge = DependencyEdge::new(\n            \"from\",\n            \"to\",\n            EdgeType::Uses,\n            Some(\"location\".to_string()),\n        ).unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Uses);\n        assert_eq!(edge.source_location, Some(\"location\".to_string()));\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_new",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1520,\"end\":1532},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_new:__crates_parseltongue-core_src_entities_rs:1520-1532",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_rejects_empty_keys() {\n        // Empty from_key\n        let result = DependencyEdge::new(\n            \"\",\n            \"to\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty from_key\");\n\n        // Empty to_key\n        let result = DependencyEdge::new(\n            \"from\",\n            \"\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty to_key\");\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_rejects_empty_keys",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_rejects_empty_keys\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1535,\"end\":1553},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_rejects_empty_keys:__crates_parseltongue-core_src_entities_rs:1535-1553",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_serialization() {\n        // Test that DependencyEdge can be serialized/deserialized\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        let json = serde_json::to_string(&edge).unwrap();\n        let deserialized: DependencyEdge = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, edge);\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_serialization",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_serialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1556,\"end\":1569},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_serialization:__crates_parseltongue-core_src_entities_rs:1556-1569",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_edge_serialization() {\n        let edge = DependencyEdge {\n            from_key: \"rust:fn:foo:src_lib_rs:10\".to_string(),\n            to_key: \"rust:fn:bar:src_lib_rs:20\".to_string(),\n            edge_type: \"depends_on\".to_string(),\n        };\n\n        let json = serde_json::to_string(&edge).unwrap();\n        assert!(json.contains(\"rust:fn:foo\"));\n        assert!(json.contains(\"depends_on\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_edge_serialization",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edge_serialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":295,\"end\":305},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edge_serialization:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:295-305",
      "line_number": 0
    },
    {
      "current_code": "async fn test_dependency_edges_missing_table_error() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"missing_table_test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Try to query DependencyEdges WITHOUT creating the schema first\n    let query = r#\"\n        ?[from_key, to_key, edge_type] :=\n        *DependencyEdges{from_key, to_key, edge_type}\n    \"#;\n\n    let result = storage.raw_query(query).await;\n\n    // Should fail with specific error\n    assert!(result.is_err(), \"Should fail when DependencyEdges table doesn't exist\");\n\n    let error_msg = result.unwrap_err().to_string();\n    assert!(\n        error_msg.contains(\"DependencyEdges\") || error_msg.contains(\"not found\") || error_msg.contains(\"does not exist\"),\n        \"Error should mention missing table: {}\",\n        error_msg\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_dependency_edges_missing_table_error",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edges_missing_table_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs\",\"line_range\":{\"start\":175,\"end\":200},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edges_missing_table_error:__crates_parseltongue-core_tests_pt02_level00_zero_dependencies_test_rs:175-200",
      "line_number": 0
    },
    {
      "current_code": "async fn test_dependency_edges_schema_can_be_created_explicitly() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"schema_test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Verify we can create DependencyEdges schema explicitly\n    let result = storage.create_dependency_edges_schema().await;\n    assert!(result.is_ok(), \"Should be able to create DependencyEdges schema\");\n\n    // Verify we can query the empty table\n    let query = r#\"\n        ?[from_key, to_key, edge_type] :=\n        *DependencyEdges{from_key, to_key, edge_type}\n    \"#;\n\n    let result = storage.raw_query(query).await;\n    assert!(result.is_ok(), \"Should be able to query empty DependencyEdges table\");\n\n    if let Ok(data) = result {\n        assert_eq!(data.rows.len(), 0, \"Empty table should return zero rows\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_dependency_edges_schema_can_be_created_explicitly",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edges_schema_can_be_created_explicitly\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs\",\"line_range\":{\"start\":147,\"end\":171},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edges_schema_can_be_created_explicitly:__crates_parseltongue-core_tests_pt02_level00_zero_dependencies_test_rs:147-171",
      "line_number": 0
    },
    {
      "current_code": "async fn test_dependency_edges_schema_is_idempotent() {\n    // Test: Schema creation should be idempotent (can call multiple times)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n\n    // Create schema twice\n    db.create_dependency_edges_schema().await.unwrap();\n    let result = db.create_dependency_edges_schema().await;\n\n    // CozoDB may error on duplicate :create - this is expected behavior\n    // The important thing is the schema exists after first call\n    match result {\n        Ok(_) => {\n            // Some CozoDB versions allow duplicate creates\n            println!(\"CozoDB allows duplicate schema creation\");\n        }\n        Err(e) => {\n            // Most CozoDB versions error on duplicate creates - this is expected\n            println!(\"CozoDB errored on duplicate create (expected): {}\", e);\n            // Verify schema still exists despite error\n            let relations = db.list_relations().await.unwrap();\n            assert!(\n                relations.contains(&\"DependencyEdges\".to_string()),\n                \"Schema should still exist even if second create errors\"\n            );\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_dependency_edges_schema_is_idempotent",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_edges_schema_is_idempotent\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":208,\"end\":234},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_edges_schema_is_idempotent:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:208-234",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_error_formatting() {\n        let error = ParseltongError::DependencyError {\n            operation: \"insert_edge\".to_string(),\n            reason: \"source entity does not exist\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency error\"));\n        assert!(formatted.contains(\"insert_edge\"));\n        assert!(formatted.contains(\"source entity does not exist\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_error_formatting",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_error_formatting\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":208,\"end\":218},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_error_formatting:__crates_parseltongue-core_src_error_rs:208-218",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dependency_error_is_error_trait() {\n        let error = ParseltongError::DependencyError {\n            operation: \"query_dependencies\".to_string(),\n            reason: \"invalid hop count\".to_string(),\n        };\n\n        // Verify it implements std::error::Error\n        let _: &dyn std::error::Error = &error;\n    }",
      "current_ind": 1,
      "entity_name": "test_dependency_error_is_error_trait",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_error_is_error_trait\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":261,\"end\":269},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_error_is_error_trait:__crates_parseltongue-core_src_error_rs:261-269",
      "line_number": 0
    },
    {
      "current_code": "async fn test_dependency_extraction_performance() {\n    use std::time::Instant;\n\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"large.rs\");\n\n    // Generate 100 functions with call chains\n    let mut code = String::new();\n    for i in 0..100 {\n        code.push_str(&format!(\n            \"fn func_{i}() -> i32 {{\\n\",\n            i = i\n        ));\n        if i > 0 {\n            code.push_str(&format!(\"    let x = func_{}();\\n\", i - 1));\n        }\n        code.push_str(\"    42\\n}\\n\\n\");\n    }\n\n    std::fs::write(&test_file, code).unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    let start = Instant::now();\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n    let elapsed = start.elapsed();\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // Performance contract: <500ms for 100 functions with calls\n    assert!(\n        elapsed.as_millis() < 500,\n        \"Dependency extraction too slow: {:?} for 100 functions\",\n        elapsed\n    );\n\n    // Should have ~99 call edges (func_0 has no calls, rest call predecessor)\n    assert!(\n        dependencies.len() >= 90,\n        \"Should extract most function call dependencies. Found: {}\",\n        dependencies.len()\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_dependency_extraction_performance",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dependency_extraction_performance\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":313,\"end\":368},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dependency_extraction_performance:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:313-368",
      "line_number": 0
    },
    {
      "current_code": "async fn test_diff_format_matches_spec() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:test:src_lib_rs:10-20\",\n        Some(\"fn test() {}\"),\n        Some(\"fn test_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff and serialize to JSON\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n    let json = diff.to_json_pretty().unwrap();\n\n    // EXPECTATION: JSON should have enhanced structure\n    assert!(json.contains(\"\\\"current_code\\\"\"), \"Must have current_code field\");\n    assert!(json.contains(\"\\\"future_code\\\"\"), \"Must have future_code field\");\n    assert!(json.contains(\"\\\"line_range\\\"\"), \"Must have line_range field\");\n    assert!(json.contains(\"\\\"start\\\"\"), \"line_range must have start\");\n    assert!(json.contains(\"\\\"end\\\"\"), \"line_range must have end\");\n\n    // Should have operation type\n    assert!(json.contains(\"\\\"EDIT\\\"\"), \"Must have operation type\");\n\n    // Should have metadata\n    assert!(json.contains(\"\\\"metadata\\\"\"), \"Must have metadata\");\n    assert!(json.contains(\"\\\"total_changes\\\"\"), \"Must have total_changes\");\n    assert!(json.contains(\"\\\"generated_at\\\"\"), \"Must have timestamp\");\n}",
      "current_ind": 1,
      "entity_name": "test_diff_format_matches_spec",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_diff_format_matches_spec\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":329,\"end\":363},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_diff_format_matches_spec:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:329-363",
      "line_number": 0
    },
    {
      "current_code": "async fn test_diff_includes_current_and_future_code() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    let entity = create_test_entity(\n        \"rust:fn:calculate:src_lib_rs:42-56\",\n        Some(\"fn calculate(a: i32) -> i32 { a + 1 }\"),\n        Some(\"fn calculate(a: i32, b: i32) -> i32 { a + b }\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Diff should INCLUDE current_code for Edit operations\n    // (Opposite of Tool 3 which EXCLUDES code!)\n    let change = &diff.changes[0];\n    assert!(\n        change.current_code.is_some(),\n        \"Edit operation must include current_code\"\n    );\n    assert!(\n        change.future_code.is_some(),\n        \"Edit operation must include future_code\"\n    );\n\n    // Verify content\n    let current = change.current_code.as_ref().unwrap();\n    let future = change.future_code.as_ref().unwrap();\n    assert!(\n        current.contains(\"a + 1\"),\n        \"current_code should contain old implementation\"\n    );\n    assert!(\n        future.contains(\"a + b\"),\n        \"future_code should contain new implementation\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_diff_includes_current_and_future_code",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_diff_includes_current_and_future_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":98,\"end\":140},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_diff_includes_current_and_future_code:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:98-140",
      "line_number": 0
    },
    {
      "current_code": "async fn test_diff_includes_line_ranges() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Entity with line-based ISGL1 key\n    let entity = create_test_entity(\n        \"rust:fn:example:src_lib_rs:100-150\",\n        Some(\"fn example() {}\"),\n        Some(\"fn example_updated() {}\"),\n        TemporalState::edit(),\n    );\n\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: line_range should be extracted from ISGL1 key\n    let change = &diff.changes[0];\n    assert!(\n        change.line_range.is_some(),\n        \"Edit operation must include line_range\"\n    );\n\n    let line_range = change.line_range.as_ref().unwrap();\n    assert_eq!(line_range.start, 100, \"Line start should match ISGL1 key\");\n    assert_eq!(line_range.end, 150, \"Line end should match ISGL1 key\");\n}",
      "current_ind": 1,
      "entity_name": "test_diff_includes_line_ranges",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_diff_includes_line_ranges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":144,\"end\":174},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_diff_includes_line_ranges:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:144-174",
      "line_number": 0
    },
    {
      "current_code": "    fn test_dual_output_uses_entity_class() {\n        // This test will fail initially - dual output logic not implemented\n        // Arrange: Mixed entities\n        let entities = vec![\n            create_test_entity(\"src/main.rs\", \"CODE\"),\n            create_test_entity(\"tests/integration.rs\", \"TEST\"),\n        ];\n        \n        // Act: Separate by entity_class\n        let (code_entities, test_entities) = separate_by_entity_class(entities);\n        \n        // Assert: Proper separation for dual outputs\n        assert_eq!(code_entities.len(), 1);\n        assert_eq!(test_entities.len(), 1);\n        assert!(code_entities[0].file_path.contains(\"src/\"));\n        assert!(test_entities[0].file_path.contains(\"tests/\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_dual_output_uses_entity_class",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_dual_output_uses_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":93,\"end\":109},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_dual_output_uses_entity_class:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:93-109",
      "line_number": 0
    },
    {
      "current_code": "    fn test_duplicate_edge_error() {\n        let error = ParseltongError::DuplicateEdge {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:helper:src_helper_rs:5-20\".to_string(),\n            edge_type: \"Calls\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Duplicate dependency edge\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n        assert!(formatted.contains(\"rust:fn:helper:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"Calls\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_duplicate_edge_error",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_duplicate_edge_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":232,\"end\":244},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_duplicate_edge_error:__crates_parseltongue-core_src_error_rs:232-244",
      "line_number": 0
    },
    {
      "current_code": "async fn test_e2e_error_propagation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User provides invalid query\n    let config = LlmWriterConfig {\n        query: \"INVALID DATALOG GARBAGE !!!\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute should fail and propagate error\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_err(), \"Invalid query should fail\");\n\n    let err = result.unwrap_err();\n    let err_msg = format!(\"{:?}\", err);\n    assert!(\n        err_msg.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog failure\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_e2e_error_propagation",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_e2e_error_propagation\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":160,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_e2e_error_propagation:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:160-185",
      "line_number": 0
    },
    {
      "current_code": "async fn test_e2e_multiple_sequential_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // User runs multiple sequential queries:\n    // 1. List relations\n    let query1 = \"::relations\";\n    let result1 = storage.execute_query(query1).await;\n    assert!(result1.is_ok(), \"First query should succeed\");\n\n    // 2. Query all entities\n    let query2 = r#\"\n        ?[ISGL1_key] :=\n        *CodeGraph{ ISGL1_key }\n    \"#;\n    let result2 = storage.execute_query(query2).await;\n    assert!(result2.is_ok(), \"Second query should succeed\");\n\n    // 3. Query with filter\n    let query3 = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{ ISGL1_key, current_ind },\n        current_ind == true\n    \"#;\n    let result3 = storage.execute_query(query3).await;\n    assert!(result3.is_ok(), \"Third query should succeed\");\n}",
      "current_ind": 1,
      "entity_name": "test_e2e_multiple_sequential_queries",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_e2e_multiple_sequential_queries\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":189,\"end\":226},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_e2e_multiple_sequential_queries:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:189-226",
      "line_number": 0
    },
    {
      "current_code": "async fn test_e2e_simple_create_workflow() {\n    use parseltongue_core::storage::CozoDbStorage;\n    use tempfile::TempDir;\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Create action via simple interface\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:new_func:src_lib_rs:10-15\".to_string(),\n        action: EntityAction::Create,\n        future_code: Some(\"pub fn new_func() {}\".to_string()),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Generate and execute Datalog\n    let datalog = config.to_datalog();\n    println!(\"Generated Datalog for E2E test:\\n{}\", datalog);\n\n    let result = storage.execute_query(&datalog).await;\n\n    if let Err(e) = &result {\n        eprintln!(\"Error executing query: {:?}\", e);\n    }\n    assert!(result.is_ok(), \"Simple interface Create should succeed: {:?}\", result);\n\n    // Verify postcondition: Entity exists with correct temporal state\n    let verify_query = r#\"\n        ?[ISGL1_key, current_ind, future_ind, Future_Action] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind, Future_Action\n        },\n        ISGL1_key == \"rust:fn:new_func:src_lib_rs:10-15\"\n    \"#;\n\n    let result = storage.execute_query(verify_query).await;\n    assert!(result.is_ok(), \"Verification query should succeed\");\n    // Note: Full verification would parse result and check values\n}",
      "current_ind": 1,
      "entity_name": "test_e2e_simple_create_workflow",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_e2e_simple_create_workflow\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":149,\"end\":193},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_e2e_simple_create_workflow:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:149-193",
      "line_number": 0
    },
    {
      "current_code": "async fn test_e2e_simple_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    // Setup: Create database\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // Insert test entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Simulate user running: llm-to-cozodb-writer --query \"...\" --db <path>\n    let config = LlmWriterConfig {\n        query: r#\"\n            ?[ISGL1_key, current_ind] :=\n            *CodeGraph{\n                ISGL1_key, current_ind\n            }\n        \"#.to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    // Execute query (this is what main.rs does)\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"E2E query execution should succeed\");\n}",
      "current_ind": 1,
      "entity_name": "test_e2e_simple_query_via_config",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_e2e_simple_query_via_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":105,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_e2e_simple_query_via_config:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:105-135",
      "line_number": 0
    },
    {
      "current_code": "async fn test_e2e_system_query_via_config() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n    storage.create_schema().await.unwrap();\n\n    // User runs: llm-to-cozodb-writer --query \"::relations\" --db <path>\n    let config = LlmWriterConfig {\n        query: \"::relations\".to_string(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n    };\n\n    let result = storage.execute_query(&config.query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
      "current_ind": 1,
      "entity_name": "test_e2e_system_query_via_config",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_e2e_system_query_via_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/cli_integration.rs\",\"line_range\":{\"start\":139,\"end\":156},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_e2e_system_query_via_config:__crates_pt03-llm-to-cozodb-writer_tests_cli_integration_rs:139-156",
      "line_number": 0
    },
    {
      "current_code": "    fn test_edge_type_display() {\n        assert_eq!(format!(\"{}\", EdgeType::Calls), \"Calls\");\n        assert_eq!(format!(\"{}\", EdgeType::Uses), \"Uses\");\n        assert_eq!(format!(\"{}\", EdgeType::Implements), \"Implements\");\n    }",
      "current_ind": 1,
      "entity_name": "test_edge_type_display",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_edge_type_display\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1458,\"end\":1462},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_edge_type_display:__crates_parseltongue-core_src_entities_rs:1458-1462",
      "line_number": 0
    },
    {
      "current_code": "    fn test_edge_type_roundtrip() {\n        use std::str::FromStr;\n\n        // Test all variants\n        for edge_type in [EdgeType::Calls, EdgeType::Uses, EdgeType::Implements] {\n            let s = edge_type.as_str();\n            let parsed = EdgeType::from_str(s).unwrap();\n            assert_eq!(parsed, edge_type);\n\n            // Test String conversion\n            let string: String = edge_type.into();\n            assert_eq!(string, s);\n        }\n\n        // Invalid edge type\n        assert!(EdgeType::from_str(\"Invalid\").is_err());\n    }",
      "current_ind": 1,
      "entity_name": "test_edge_type_roundtrip",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_edge_type_roundtrip\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1439,\"end\":1455},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_edge_type_roundtrip:__crates_parseltongue-core_src_entities_rs:1439-1455",
      "line_number": 0
    },
    {
      "current_code": "fn test_edit_action_generates_datalog() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: Some(\"pub fn existing() { /* modified */ }\".to_string()),\n        db_path: \"test.db\".to_string(),\n    };\n\n    let datalog = config.to_datalog();\n\n    // Postcondition: current_ind=1, future_ind=1, Future_Action=\"Edit\"\n    assert!(datalog.contains(\":put CodeGraph\"));\n    assert!(datalog.contains(\"true\"), \"Missing temporal indicators\");\n    assert!(datalog.contains(\"\\\"Edit\\\"\"), \"Missing Edit action\");\n}",
      "current_ind": 1,
      "entity_name": "test_edit_action_generates_datalog",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_edit_action_generates_datalog\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":34,\"end\":48},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_edit_action_generates_datalog:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:34-48",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_edit_existing_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/existing.rs\");\n\n        // Create directory and file\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn old() {}\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-existing-rs-NewFunc\",\n            Some(\"fn new() {}\".to_string()),\n            TemporalState::edit(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Edit);\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn new() {}\");\n    }",
      "current_ind": 1,
      "entity_name": "test_edit_existing_file",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_edit_existing_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":187,\"end\":212},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_edit_existing_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:187-212",
      "line_number": 0
    },
    {
      "current_code": "fn test_edit_requires_future_code() {\n    let config = SimpleUpdateConfig {\n        entity_key: \"rust:fn:existing:src_lib_rs:5-10\".to_string(),\n        action: EntityAction::Edit,\n        future_code: None, // ERROR: Edit requires code\n        db_path: \"test.db\".to_string(),\n    };\n\n    config.to_datalog(); // Should panic\n}",
      "current_ind": 1,
      "entity_name": "test_edit_requires_future_code",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_edit_requires_future_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/tests/simple_interface_tests.rs\",\"line_range\":{\"start\":86,\"end\":95},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_edit_requires_future_code:__crates_pt03-llm-to-cozodb-writer_tests_simple_interface_tests_rs:86-95",
      "line_number": 0
    },
    {
      "current_code": "    fn test_empty_code_diff() {\n        let diff = CodeDiff::new();\n        assert_eq!(diff.changes.len(), 0);\n        assert_eq!(diff.metadata.total_changes, 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_empty_code_diff",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_empty_code_diff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":172,\"end\":176},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_empty_code_diff:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:172-176",
      "line_number": 0
    },
    {
      "current_code": "    fn test_empty_where_clause_fails() {\n        let cli = Cli {\n            level: 1,\n            include_code: Some(0),\n            where_clause: \"\".to_string(),  // Empty!\n            output: None,\n            db: \"test.db\".to_string(),\n            verbose: false,\n        };\n\n        let result = cli.validate();\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"WHERE clause cannot be empty\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_empty_where_clause_fails",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_empty_where_clause_fails\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":291,\"end\":305},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_empty_where_clause_fails:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:291-305",
      "line_number": 0
    },
    {
      "current_code": "async fn test_end_to_end_tool1_tool2_tool3_pipeline() {\n    println!(\"\\n\");\n    println!(\"   END-TO-END WORKFLOW TEST: Tool 1  Tool 2  Tool 3    \");\n    println!(\"   Testing on: Parseltongue Repository (Self-Hosting)    \");\n    println!(\"\\n\");\n\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"e2e_test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .expect(\"Failed to create test database\");\n\n    // Create schema\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // \n    // PHASE 1: Tool 1 - Index Parseltongue Codebase\n    // \n    println!(\"\");\n    println!(\" PHASE 1: Tool 1 - Index Codebase                       \");\n    println!(\"\");\n\n    // Simulate Tool 1 indexing by creating sample entities\n    // (In real scenario, folder-to-cozodb-streamer would parse files)\n    let entity1 = create_indexed_entity(\n        \"calculate_sum\",\n        \"src/lib.rs\",\n        (10, 20),\n        EntityClass::CodeImplementation,\n    );\n    let entity2 = create_indexed_entity(\n        \"test_calculate_sum\",\n        \"src/lib.rs\",\n        (30, 40),\n        EntityClass::TestImplementation,\n    );\n    let entity3 = create_indexed_entity(\n        \"process_data\",\n        \"src/processor.rs\",\n        (50, 70),\n        EntityClass::CodeImplementation,\n    );\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    let indexed_count = storage.get_all_entities().await.unwrap().len();\n    println!(\" Tool 1 indexed {} entities\", indexed_count);\n    println!(\"  - Entity 1: {} (Code)\", key1);\n    println!(\"  - Entity 2: {} (Test)\", key2);\n    println!(\"  - Entity 3: {} (Code)\", key3);\n\n    // Verify initial state: All entities (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true, \"Should exist in current\");\n        assert_eq!(e.temporal_state.future_ind, false, \"Future unknown initially\");\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n    println!(\" All entities start with state (current_ind=1, future_ind=0, future_action=None)\");\n\n    // \n    // PHASE 2: Tool 2 - Apply Temporal Changes (Simulate LLM Reasoning)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 2: Tool 2 - Temporal Operations                  \");\n    println!(\"\");\n\n    // Operation 1: Edit existing function (1,1,Edit)\n    println!(\"\\n Edit Operation: {}\", key1);\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    let mut edited = storage.get_entity(&key1).await.unwrap();\n    edited.future_code = Some(\"fn calculate_sum() {\\n    // LLM-improved implementation\\n}\".to_string());\n    storage.update_entity(edited).await.unwrap();\n\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true);\n    assert_eq!(e1.temporal_state.future_ind, true);\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit));\n    println!(\" State: (current_ind=1, future_ind=1, future_action=Edit)\");\n    println!(\" future_code populated\");\n\n    // Operation 2: Delete existing function (1,0,Delete)\n    println!(\"\\n  Delete Operation: {}\", key3);\n    storage\n        .update_temporal_state(&key3, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, Some(TemporalAction::Delete));\n    println!(\" State: (current_ind=1, future_ind=0, future_action=Delete)\");\n\n    // Operation 3: Create new function with hash-based ISGL1 key (0,1,Create)\n    println!(\"\\n Create Operation: new_awesome_function\");\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    let e_new = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e_new.temporal_state.current_ind, false);\n    assert_eq!(e_new.temporal_state.future_ind, true);\n    assert_eq!(e_new.temporal_state.future_action, Some(TemporalAction::Create));\n    println!(\" Hash-based ISGL1 key: {}\", new_key);\n    println!(\" State: (current_ind=0, future_ind=1, future_action=Create)\");\n    println!(\" future_code populated\");\n\n    // Verify changed entities count\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 changed entities\");\n    println!(\"\\n Tool 2 created {} temporal changes (1 Edit, 1 Delete, 1 Create)\", changed.len());\n\n    // \n    // PHASE 3: Tool 3 - Extract Context (Ultra-Minimalist per PRD)\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 3: Tool 3 - Context Extraction                   \");\n    println!(\"\");\n\n    // Extract base context: Only current_ind=1 entities (per PRD P01:122)\n    let all_entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"\\n Context Statistics:\");\n    println!(\"  - Total entities in database: {}\", all_entities.len());\n    println!(\"  - Entities with current_ind=1: {}\", current_entities.len());\n    println!(\"  - Entities with future_action!=None: {}\", changed.len());\n\n    // Create ultra-minimalist context per PRD P01:128\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class),\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        })\n        .collect();\n\n    // Estimate token count\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"\\n Context Output:\");\n    println!(\"  - JSON size: {} bytes\", json_output.len());\n    println!(\"  - Estimated tokens: {}\", estimated_tokens);\n    println!(\"  - Tokens per entity: {}\", estimated_tokens / context_entities.len());\n\n    // Verify PRD compliance\n    println!(\"\\n PRD Compliance Verification:\");\n\n    // 1. Token limit\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens\",\n        estimated_tokens\n    );\n    println!(\"   Token count < 100k limit ({})\", estimated_tokens);\n\n    // 2. No code fields\n    assert!(!json_output.contains(\"\\\"current_code\\\":\"));\n    assert!(!json_output.contains(\"\\\"future_code\\\":\"));\n    println!(\"   current_code excluded\");\n    println!(\"   future_code excluded\");\n\n    // 3. Required fields present\n    assert!(json_output.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json_output.contains(\"\\\"interface_signature\\\"\"));\n    assert!(json_output.contains(\"\\\"entity_class\\\"\"));\n    println!(\"   isgl1_key present\");\n    println!(\"   interface_signature present\");\n    println!(\"   entity_class present\");\n\n    // 4. Only current_ind=1 in base context\n    assert_eq!(\n        current_entities.len(),\n        3,\n        \"Base context should have 3 current entities (new entity not in current)\"\n    );\n    println!(\"   Only current_ind=1 entities in base context ({})\", current_entities.len());\n\n    // \n    // PHASE 4: Verify Temporal State Transitions\n    // \n    println!(\"\\n\");\n    println!(\" PHASE 4: Temporal State Validation                     \");\n    println!(\"\");\n\n    println!(\"\\n Entity States After Tool 2 Operations:\");\n\n    let e1_final = storage.get_entity(&key1).await.unwrap();\n    println!(\"\\n  Entity 1 ({}): EDITED\", e1_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e1_final.temporal_state.current_ind,\n             e1_final.temporal_state.future_ind,\n             e1_final.temporal_state.future_action);\n    assert_eq!(e1_final.temporal_state.current_ind, true);\n    assert_eq!(e1_final.temporal_state.future_ind, true);\n    assert_eq!(e1_final.temporal_state.future_action, Some(TemporalAction::Edit));\n\n    let e2_final = storage.get_entity(&key2).await.unwrap();\n    println!(\"\\n  Entity 2 ({}): UNCHANGED\", e2_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e2_final.temporal_state.current_ind,\n             e2_final.temporal_state.future_ind,\n             e2_final.temporal_state.future_action);\n    assert_eq!(e2_final.temporal_state.current_ind, true);\n    assert_eq!(e2_final.temporal_state.future_ind, false);\n    assert_eq!(e2_final.temporal_state.future_action, None);\n\n    let e3_final = storage.get_entity(&key3).await.unwrap();\n    println!(\"\\n  Entity 3 ({}): DELETED\", e3_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e3_final.temporal_state.current_ind,\n             e3_final.temporal_state.future_ind,\n             e3_final.temporal_state.future_action);\n    assert_eq!(e3_final.temporal_state.current_ind, true);\n    assert_eq!(e3_final.temporal_state.future_ind, false);\n    assert_eq!(e3_final.temporal_state.future_action, Some(TemporalAction::Delete));\n\n    let e_new_final = storage.get_entity(&new_key).await.unwrap();\n    println!(\"\\n  Entity 4 ({}): CREATED\", e_new_final.interface_signature.name);\n    println!(\"    State: (current_ind={}, future_ind={}, future_action={:?})\",\n             e_new_final.temporal_state.current_ind,\n             e_new_final.temporal_state.future_ind,\n             e_new_final.temporal_state.future_action);\n    assert_eq!(e_new_final.temporal_state.current_ind, false);\n    assert_eq!(e_new_final.temporal_state.future_ind, true);\n    assert_eq!(e_new_final.temporal_state.future_action, Some(TemporalAction::Create));\n\n    // \n    // FINAL SUMMARY\n    // \n    println!(\"\\n\");\n    println!(\"             END-TO-END TEST:  PASSED                   \");\n    println!(\"\");\n\n    println!(\"\\n Tool 1: Indexed {} entities with ISGL1 keys\", indexed_count);\n    println!(\" Tool 2: Applied {} temporal changes (Edit/Delete/Create)\", changed.len());\n    println!(\" Tool 3: Generated context with {} tokens (<100k limit)\", estimated_tokens);\n    println!(\" PRD Compliance: All requirements validated\");\n    println!(\" Temporal States: All transitions correct\\n\");\n}",
      "current_ind": 1,
      "entity_name": "test_end_to_end_tool1_tool2_tool3_pipeline",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_end_to_end_tool1_tool2_tool3_pipeline\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/end_to_end_workflow.rs\",\"line_range\":{\"start\":49,\"end\":333},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_end_to_end_tool1_tool2_tool3_pipeline:__crates_parseltongue-core_tests_end_to_end_workflow_rs:49-333",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_class_enum() {\n        // Test that EntityClass enum exists with correct variants\n        let test_class = EntityClass::TestImplementation;\n        let code_class = EntityClass::CodeImplementation;\n\n        assert_eq!(test_class, EntityClass::TestImplementation);\n        assert_eq!(code_class, EntityClass::CodeImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_class_enum",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_class_enum\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1381,\"end\":1388},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_class_enum:__crates_parseltongue-core_src_entities_rs:1381-1388",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_class_filtering_performance() {\n        // This test validates performance contract: <10ms for 10K entities\n        let start = std::time::Instant::now();\n        \n        // Arrange: Create 10K test entities\n        let entities: Vec<Entity> = (0..10000)\n            .map(|i| create_test_entity(&format!(\"file{}.rs\", i), if i % 2 == 0 { \"CODE\" } else { \"TEST\" }))\n            .collect();\n        \n        // Act: Filter by entity_class\n        let _code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"CODE\")\n            .collect();\n        \n        let duration = start.elapsed();\n        assert!(duration.as_millis() < 10, \"EntityClass filtering took {:?}, expected <10ms\", duration);\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_class_filtering_performance",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_class_filtering_performance\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":113,\"end\":129},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_class_filtering_performance:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:113-129",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_class_is_always_present() {\n        // Arrange: Create entities with different classifications\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"code_fn\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"code.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        let test_signature = InterfaceSignature {\n            entity_type: EntityType::TestFunction,\n            name: \"test_fn\".to_string(),\n            visibility: crate::entities::Visibility::Private,\n            file_path: std::path::PathBuf::from(\"code.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create both code and test entities\n        let code_entity = CodeEntity::new(\n            \"code.rs-code_fn-fn-def456\".to_string(),\n            signature,\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        let test_entity = CodeEntity::new(\n            \"code.rs-test_fn-test-ghi012\".to_string(),\n            test_signature,\n            EntityClass::TestImplementation,\n        ).unwrap();\n\n        // Assert: Both entities have definitive EntityClass (no Option/None)\n        assert_eq!(code_entity.entity_class, EntityClass::CodeImplementation);\n        assert_eq!(test_entity.entity_class, EntityClass::TestImplementation);\n        \n        // Verify EntityClass has Copy trait and can be compared directly\n        assert!(code_entity.entity_class == EntityClass::CodeImplementation);\n        assert!(test_entity.entity_class == EntityClass::TestImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_class_is_always_present",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_class_is_always_present\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":56,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_class_is_always_present:__crates_parseltongue-core_src_entity_class_specifications_rs:56-116",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_class_serialization() {\n        // Test that EntityClass can be serialized/deserialized\n        let test_impl = EntityClass::TestImplementation;\n        let json = serde_json::to_string(&test_impl).unwrap();\n        let deserialized: EntityClass = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, EntityClass::TestImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_class_serialization",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_class_serialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1400,\"end\":1407},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_class_serialization:__crates_parseltongue-core_src_entities_rs:1400-1407",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_debug() {\n        let entity = Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: None,\n            entity_name: \"test\".to_string(),\n            entity_type: \"Function\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"fn test()\".to_string(),\n            doc_comment: None,\n            entity_class: \"CODE\".to_string(),\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: None,\n            is_async: None,\n            is_unsafe: None,\n        };\n\n        let debug_str = format!(\"{:?}\", entity);\n        assert!(debug_str.contains(\"rust:fn:test\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_debug",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_debug\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":188,\"end\":217},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_debug:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:188-217",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_level1_null_skipping() {\n        let entity = EntityExportLevel1 {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],  // Should be skipped\n            reverse_deps: vec![],  // Should be skipped\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,  // Should be skipped\n            future_code: None,    // Should be skipped\n            current_code: None,   // Should be skipped\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub fn test()\".to_string(),\n            doc_comment: None,  // Should be skipped\n        };\n\n        let json = serde_json::to_string(&entity).unwrap();\n\n        // Verify null-skipping works (field names should NOT appear)\n        assert!(!json.contains(\"future_action\"));\n        assert!(!json.contains(\"future_code\"));\n        assert!(!json.contains(\"doc_comment\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_level1_null_skipping",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_level1_null_skipping\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":308,\"end\":332},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_level1_null_skipping:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:308-332",
      "line_number": 0
    },
    {
      "current_code": "    fn test_entity_struct_includes_entity_class() {\n        // This test will fail initially - Entity struct missing entity_class\n        let entity = Entity {\n            isgl1_key: \"test\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 1,\n            future_action: None,\n            future_code: None,\n            current_code: None,\n            entity_name: \"test\".to_string(),\n            entity_type: \"Function\".to_string(),\n            file_path: \"test.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"fn test()\".to_string(),\n            doc_comment: None,\n            entity_class: \"CODE\".to_string(), // v0.9.0: This field should exist\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: None,\n            is_async: None,\n            is_unsafe: None,\n        };\n        \n        assert_eq!(entity.entity_class, \"CODE\");\n    }",
      "current_ind": 1,
      "entity_name": "test_entity_struct_includes_entity_class",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_entity_struct_includes_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":22,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_entity_struct_includes_entity_class:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:22-51",
      "line_number": 0
    },
    {
      "current_code": "    fn test_error_display() {\n        let err = FileWriterError::file_already_exists(PathBuf::from(\"test.rs\"));\n        assert!(err.to_string().contains(\"test.rs\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_error_display",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_error_display\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":51,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_error_display:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:51-54",
      "line_number": 0
    },
    {
      "current_code": "    fn test_error_display() {\n        let err = StateResetError::Database(\"connection failed\".to_string());\n        assert!(err.to_string().contains(\"Database error\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_error_display",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_error_display\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/errors.rs\",\"line_range\":{\"start\":21,\"end\":24},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_error_display:__crates_pt06-cozodb-make-future-code-current_src_errors_rs:21-24",
      "line_number": 0
    },
    {
      "current_code": "    fn test_error_line_extraction() {\n        let type_err = ValidationError::TypeError {\n            line: 42,\n            column: 10,\n            expected: \"i32\".to_string(),\n            found: \"String\".to_string(),\n            message: \"type mismatch\".to_string(),\n        };\n        assert_eq!(type_err.line(), Some(42));\n    }",
      "current_ind": 1,
      "entity_name": "test_error_line_extraction",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_error_line_extraction\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":107,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_error_line_extraction:__crates_pt04-syntax-preflight-validator_src_errors_rs:107-116",
      "line_number": 0
    },
    {
      "current_code": "    fn test_error_severity() {\n        let syntax_err = ValidationError::SyntaxError {\n            line: 1,\n            column: 5,\n            message: \"unexpected token\".to_string(),\n            code_snippet: None,\n        };\n        assert_eq!(syntax_err.severity(), Severity::Error);\n    }",
      "current_ind": 1,
      "entity_name": "test_error_severity",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_error_severity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":96,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_error_severity:__crates_pt04-syntax-preflight-validator_src_errors_rs:96-104",
      "line_number": 0
    },
    {
      "current_code": "    fn test_exclusion_patterns_cli_contract() {\n        // Test REQ-V090-001.0: Exclusion patterns CLI support\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"./src\",\n            \"-e\", \".ref\",\n            \"-e\", \"archive\",\n            \"-e\", \"tmp/**\",\n        ]);\n\n        assert!(matches.is_ok(), \"CLI with exclusion patterns should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        \n        // Verify default patterns are present\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert!(config.exclude_patterns.contains(&\".git\".to_string()));\n        \n        // Verify user-specified patterns are added\n        assert!(config.exclude_patterns.contains(&\".ref\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"archive\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"tmp/**\".to_string()));\n        \n        // Verify total count (defaults + user patterns)\n        assert_eq!(config.exclude_patterns.len(), 11); // 8 defaults + 3 user\n    }",
      "current_ind": 1,
      "entity_name": "test_exclusion_patterns_cli_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_exclusion_patterns_cli_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":219,\"end\":247},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_exclusion_patterns_cli_contract:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:219-247",
      "line_number": 0
    },
    {
      "current_code": "async fn test_execute_query_invalid_syntax() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: Invalid Datalog query\n    let invalid_query = \"THIS IS NOT VALID DATALOG SYNTAX !!!\";\n\n    let result = storage.execute_query(invalid_query).await;\n\n    // Verify: Returns DatabaseError with details\n    assert!(result.is_err(), \"Invalid Datalog should return error\");\n\n    let err = result.unwrap_err();\n    let err_string = format!(\"{:?}\", err);\n    assert!(\n        err_string.contains(\"DatabaseError\") || err_string.contains(\"execute_query\"),\n        \"Error should be DatabaseError from execute_query operation\"\n    );\n    assert!(\n        err_string.contains(\"Datalog query failed\"),\n        \"Error should mention Datalog query failure\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_execute_query_invalid_syntax",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_execute_query_invalid_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":374,\"end\":401},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_execute_query_invalid_syntax:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:374-401",
      "line_number": 0
    },
    {
      "current_code": "async fn test_execute_query_list_relations() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Execute: CozoDB system query to list all relations\n    let query = \"::relations\";\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"System query should execute successfully\");\n}",
      "current_ind": 1,
      "entity_name": "test_execute_query_list_relations",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_execute_query_list_relations\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":354,\"end\":368},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_execute_query_list_relations:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:354-368",
      "line_number": 0
    },
    {
      "current_code": "async fn test_execute_query_simple_query() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Simple read query to verify execute_query works\n    let query = r#\"\n        ?[ISGL1_key, current_ind, future_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind, future_ind\n        }\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Valid Datalog read query should execute successfully\");\n}",
      "current_ind": 1,
      "entity_name": "test_execute_query_simple_query",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_execute_query_simple_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":328,\"end\":348},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_execute_query_simple_query:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:328-348",
      "line_number": 0
    },
    {
      "current_code": "async fn test_execute_query_with_filter() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entities\n    let entity1 = create_test_entity(\"fn1\", \"src/a.rs\", (1, 5));\n    let entity2 = create_test_entity(\"fn2\", \"src/b.rs\", (10, 15));\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n\n    // Execute: Query with filter (find entities where current_ind is true)\n    let query = r#\"\n        ?[ISGL1_key, current_ind] :=\n        *CodeGraph{\n            ISGL1_key, current_ind\n        },\n        current_ind == true\n    \"#;\n\n    let result = storage.execute_query(query).await;\n    assert!(result.is_ok(), \"Filtered query should execute successfully\");\n}",
      "current_ind": 1,
      "entity_name": "test_execute_query_with_filter",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_execute_query_with_filter\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":407,\"end\":433},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_execute_query_with_filter:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:407-433",
      "line_number": 0
    },
    {
      "current_code": "    fn test_export_metadata_for_level0() {\n        let metadata = ExportMetadata::for_level0(100, \"ALL\".to_string());\n\n        assert_eq!(metadata.level, 0);\n        assert_eq!(metadata.total_edges, Some(100));\n        assert_eq!(metadata.total_entities, None);\n        assert_eq!(metadata.include_code, None);\n    }",
      "current_ind": 1,
      "entity_name": "test_export_metadata_for_level0",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_export_metadata_for_level0\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":335,\"end\":342},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_export_metadata_for_level0:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:335-342",
      "line_number": 0
    },
    {
      "current_code": "    fn test_export_metadata_for_level1() {\n        let metadata = ExportMetadata::for_entities(1, 590, false, \"ALL\".to_string());\n\n        assert_eq!(metadata.level, 1);\n        assert_eq!(metadata.total_edges, None);\n        assert_eq!(metadata.total_entities, Some(590));\n        assert_eq!(metadata.include_code, Some(false));\n    }",
      "current_ind": 1,
      "entity_name": "test_export_metadata_for_level1",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_export_metadata_for_level1\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":345,\"end\":352},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_export_metadata_for_level1:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:345-352",
      "line_number": 0
    },
    {
      "current_code": "    fn test_extracts_function_call_dependencies() {\n        // RED PHASE: This test will FAIL until we implement call_expression extraction\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    helper();\n}\n\nfn helper() {\n    println!(\"Helper called\");\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities (main, helper)\n        assert_eq!(entities.len(), 2);\n\n        // Should extract 1 dependency: main -> helper (Calls)\n        assert_eq!(dependencies.len(), 1, \"Expected 1 dependency edge (main calls helper)\");\n\n        let edge = &dependencies[0];\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n\n        // The keys should reference main and helper\n        assert!(\n            edge.from_key.as_ref().contains(\"main\"),\n            \"from_key should contain 'main', got: {:?}\",\n            edge.from_key\n        );\n        assert!(\n            edge.to_key.as_ref().contains(\"helper\"),\n            \"to_key should contain 'helper', got: {:?}\",\n            edge.to_key\n        );\n    }",
      "current_ind": 1,
      "entity_name": "test_extracts_function_call_dependencies",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_extracts_function_call_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":501,\"end\":537},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_extracts_function_call_dependencies:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:501-537",
      "line_number": 0
    },
    {
      "current_code": "    fn test_extracts_multiple_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    foo();\n    bar();\n    baz();\n}\n\nfn foo() {}\nfn bar() {}\nfn baz() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities (main, foo, bar, baz)\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->foo, main->bar, main->baz\n        assert_eq!(dependencies.len(), 3, \"Expected 3 call edges from main\");\n\n        // Verify all are Calls edges from main\n        for edge in &dependencies {\n            assert_eq!(edge.edge_type, EdgeType::Calls);\n            assert!(edge.from_key.as_ref().contains(\"main\"));\n        }\n\n        // Check we have edges to each function\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"foo\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"bar\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"baz\")));\n    }",
      "current_ind": 1,
      "entity_name": "test_extracts_multiple_function_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_extracts_multiple_function_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":540,\"end\":573},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_extracts_multiple_function_calls:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:540-573",
      "line_number": 0
    },
    {
      "current_code": "    fn test_filter_entities_by_entity_class() {\n        // Arrange: Create mixed entities\n        let code_entity = create_test_entity(\"code.rs\", \"CODE\");\n        let test_entity = create_test_entity(\"test.rs\", \"TEST\");\n        let entities = vec![code_entity, test_entity];\n        \n        // Act: Filter by entity_class\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"CODE\")\n            .collect();\n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"TEST\")\n            .collect();\n        \n        // Assert: Proper separation\n        assert_eq!(code_entities.len(), 1);\n        assert_eq!(test_entities.len(), 1);\n        assert_eq!(code_entities[0].entity_class, \"CODE\");\n        assert_eq!(test_entities[0].entity_class, \"TEST\");\n    }",
      "current_ind": 1,
      "entity_name": "test_filter_entities_by_entity_class",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_filter_entities_by_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":70,\"end\":89},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_filter_entities_by_entity_class:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:70-89",
      "line_number": 0
    },
    {
      "current_code": "async fn test_forward_dependencies_empty() {\n    // RED: Test entity with no forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no outgoing edges\n    let deps = db.get_forward_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no outgoing edges should return empty\");\n}",
      "current_ind": 1,
      "entity_name": "test_forward_dependencies_empty",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_forward_dependencies_empty\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":682,\"end\":691},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_forward_dependencies_empty:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:682-691",
      "line_number": 0
    },
    {
      "current_code": "async fn test_forward_dependencies_multiple() {\n    // RED: Test multiple forward dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B, A -> C, A -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: A should depend on B, C, D\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"A should depend on 3 entities\");\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(deps.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_forward_dependencies_multiple",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_forward_dependencies_multiple\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":606,\"end\":641},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_forward_dependencies_multiple:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:606-641",
      "line_number": 0
    },
    {
      "current_code": "async fn test_forward_dependencies_performance_10k_nodes() {\n    // RED: Validate 1-hop query performance at scale (release mode only)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 10k node graph with average 5 edges per node\n    println!(\"Generating 10k node test graph...\");\n    let nodes = generate_large_graph(&db, 10_000, 5).await;\n\n    // Warm up\n    let _ = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n\n    // Performance test: Simple 1-hop query should be very fast\n    println!(\"Running forward dependencies query (1-hop on 10k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_forward_dependencies(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Forward dependencies returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <20ms for simple 1-hop query on 10k nodes (release mode)\n    // Note: Debug builds may be 5-10x slower - performance contracts are for release builds\n    assert!(\n        elapsed < Duration::from_millis(20),\n        \"1-hop query took {:?}, expected <20ms (release mode)\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find forward dependencies for first node\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_forward_dependencies_performance_10k_nodes",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_forward_dependencies_performance_10k_nodes\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":982,\"end\":1019},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_forward_dependencies_performance_10k_nodes:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:982-1019",
      "line_number": 0
    },
    {
      "current_code": "async fn test_forward_dependencies_single() {\n    // RED: Test forward dependencies (outgoing edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: A's forward dependencies should return [B]\n    let deps = db.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"A should depend on 1 entity\");\n    assert_eq!(deps[0], \"rust:fn:B:test_rs:10-15\");\n}",
      "current_ind": 1,
      "entity_name": "test_forward_dependencies_single",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_forward_dependencies_single\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":562,\"end\":581},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_forward_dependencies_single:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:562-581",
      "line_number": 0
    },
    {
      "current_code": "fn test_full_swift_query() {\n    let swift_code = r#\"\nfunc myFunc() {}\nclass MyClass {}\nstruct MyStruct {}\nprotocol MyProtocol {}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n\n    let full_query = include_str!(\"../../../entity_queries/swift.scm\");\n\n    println!(\"\\n=== Testing Full Swift Query ===\");\n\n    let query = Query::new(&swift_lang, full_query).unwrap();\n\n    let mut cursor = QueryCursor::new();\n    let mut matches = cursor.matches(&query, tree.root_node(), swift_code.as_bytes());\n\n    println!(\"\\n=== Matches ===\");\n    while let Some(m) = matches.next() {\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let text = &swift_code[capture.node.byte_range()];\n\n            if *capture_name == \"name\" {\n                println!(\"Entity: {}\", text.trim());\n            } else if capture_name.starts_with(\"definition.\") {\n                println!(\"  Type: {}\", capture_name);\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_full_swift_query",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_protocol_query_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_full_swift_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_protocol_query_test.rs\",\"line_range\":{\"start\":58,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_full_swift_query:__crates_parseltongue-core_tests_swift_protocol_query_test_rs:58-94",
      "line_number": 0
    },
    {
      "current_code": "async fn test_function_call_dependencies_extracted_via_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"caller.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\nfn calculate_total(items: &[Item]) -> i32 {\n    let sum = add_numbers(10, 20);\n    let validated = validate_input(sum);\n    validated\n}\n\nfn add_numbers(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nfn validate_input(x: i32) -> i32 {\n    if x > 0 { x } else { 0 }\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // Should have 3 functions\n    assert_eq!(entities.len(), 3, \"Should extract 3 function entities\");\n\n    // RED: This will initially work with manual extraction\n    // But we need to verify it continues working after migration to queries\n    assert!(\n        dependencies.len() >= 2,\n        \"Should have at least 2 dependency edges (calculate_total calls add_numbers and validate_input)\"\n    );\n\n    // Verify specific call graph structure\n    let calculate_fn = entities.iter()\n        .find(|e| e.interface_signature.name == \"calculate_total\")\n        .expect(\"Should find calculate_total function\");\n\n    let add_fn = entities.iter()\n        .find(|e| e.interface_signature.name == \"add_numbers\")\n        .expect(\"Should find add_numbers function\");\n\n    let has_call = dependencies.iter().any(|dep| {\n        dep.from_key.as_str().contains(\"calculate_total\") && dep.to_key.as_str().contains(\"add_numbers\")\n    });\n\n    assert!(\n        has_call,\n        \"Should have dependency edge: calculate_total -> add_numbers\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_function_call_dependencies_extracted_via_queries",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_function_call_dependencies_extracted_via_queries\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":46,\"end\":117},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_function_call_dependencies_extracted_via_queries:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:46-117",
      "line_number": 0
    },
    {
      "current_code": "    fn test_function_detection() {\n        // v0.8.9: QueryBasedExtractor doesn't parse Rust attributes (#[test])\n        // This is an acceptable trade-off to get all 11 languages working\n        // Future: Add attribute parsing in v0.9.0 for Rust-specific features\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\n#[test]\nfn test_something() {\n    assert_eq!(1, 1);\n}\n\nfn regular_function() {\n    println!(\"Hello\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn another_test() {\n        assert!(true);\n    }\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, _dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Debug: print all entities\n        println!(\"\\nExtracted {} entities:\", entities.len());\n        for (i, entity) in entities.iter().enumerate() {\n            println!(\"  {}. {} (type: {:?})\",\n                i, entity.name, entity.entity_type);\n        }\n\n        // Verify all functions and modules are extracted\n        let test_fn = entities.iter().find(|e| e.name == \"test_something\");\n        let regular_fn = entities.iter().find(|e| e.name == \"regular_function\");\n        let tests_mod = entities.iter().find(|e| e.name == \"tests\");\n        let another_test = entities.iter().find(|e| e.name == \"another_test\");\n\n        assert!(test_fn.is_some(), \"Should find test_something function\");\n        assert!(regular_fn.is_some(), \"Should find regular_function\");\n        assert!(tests_mod.is_some(), \"Should find tests module\");\n        assert!(another_test.is_some(), \"Should find another_test function\");\n\n        // v0.8.9 MVP: No attribute parsing, so no is_test metadata\n        // This is acceptable - test classification can happen at analysis layer\n        // Verify entities are extracted (main goal), metadata is secondary\n        assert_eq!(entities.len(), 4, \"Should extract 2 functions + 1 module + 1 nested function\");\n    }",
      "current_ind": 1,
      "entity_name": "test_function_detection",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_function_detection\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":447,\"end\":496},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_function_detection:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:447-496",
      "line_number": 0
    },
    {
      "current_code": "async fn test_function_with_test_attribute_classified_correctly() {\n    // Setup: Create temp directory with Rust test file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[test]\nfn test_example() {\n    assert_eq!(1 + 1, 2);\n}\n\nfn regular_function() {\n    println!(\"Not a test\");\n}\n\"#,\n    )\n    .unwrap();\n\n    // Setup database\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    // Execute: Index with Tool 1\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    // Verify: Check classifications\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    // Should have 2 entities: 1 test, 1 code\n    assert_eq!(entities.len(), 2, \"Should have exactly 2 entities\");\n\n    // Find test function\n    let test_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"test_example\")\n        .expect(\"Should find test_example function\");\n\n    // RED: This will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"Test function should be classified as TEST_IMPLEMENTATION\"\n    );\n\n    // Find regular function\n    let code_entity = entities\n        .iter()\n        .find(|e| e.interface_signature.name == \"regular_function\")\n        .expect(\"Should find regular_function\");\n\n    assert_eq!(\n        code_entity.tdd_classification.entity_class,\n        EntityClass::CodeImplementation,\n        \"Regular function should be classified as CODE_IMPLEMENTATION\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_function_with_test_attribute_classified_correctly",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_function_with_test_attribute_classified_correctly\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs\",\"line_range\":{\"start\":29,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_function_with_test_attribute_classified_correctly:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_classification_test_rs:29-98",
      "line_number": 0
    },
    {
      "current_code": "async fn test_generate_diff_for_create_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Create action\n    let entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc123\",\n        Some(\"fn new_feature() { println!(\\\"New!\\\"); }\"),\n        TemporalAction::Create,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 0);\n    assert_eq!(diff.metadata.delete_count, 0);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Create);\n    assert!(change.future_code.is_some());\n}",
      "current_ind": 1,
      "entity_name": "test_generate_diff_for_create_operations",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_diff_for_create_operations\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":12,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_diff_for_create_operations:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:12-43",
      "line_number": 0
    },
    {
      "current_code": "async fn test_generate_diff_for_delete_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Delete action\n    let mut entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:100-110\",\n        None, // No future_code for delete\n        TemporalAction::Delete,\n    );\n    entity.future_code = None; // Delete doesn't need future code\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Delete);\n    assert!(change.future_code.is_none());\n}",
      "current_ind": 1,
      "entity_name": "test_generate_diff_for_delete_operations",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_diff_for_delete_operations\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":80,\"end\":110},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_diff_for_delete_operations:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:80-110",
      "line_number": 0
    },
    {
      "current_code": "async fn test_generate_diff_for_edit_operations() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert entity with Edit action\n    let entity = create_test_entity(\n        \"rust:fn:calculate_sum:src_lib_rs:42-56\",\n        Some(\"fn calculate_sum(a: i32, b: i32) -> i32 { a + b /* fixed */ }\"),\n        TemporalAction::Edit,\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n\n    let change = &diff.changes[0];\n    assert_eq!(change.operation, Operation::Edit);\n    assert!(change.future_code.is_some());\n}",
      "current_ind": 1,
      "entity_name": "test_generate_diff_for_edit_operations",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_diff_for_edit_operations\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":47,\"end\":76},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_diff_for_edit_operations:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:47-76",
      "line_number": 0
    },
    {
      "current_code": "async fn test_generate_diff_from_real_cozodb() {\n    // Setup: Use in-memory database\n    let storage = CozoDbStorage::new(\"mem\")\n        .await\n        .expect(\"Failed to create storage\");\n    storage\n        .create_schema()\n        .await\n        .expect(\"Failed to create schema\");\n\n    // Insert test entity with Future_Action = Edit\n    let entity = create_test_entity(\n        \"rust:fn:test_function:src_lib_rs:10-20\",\n        Some(\"fn test_function() { /* old */ }\"),\n        Some(\"fn test_function() { /* new */ }\"),\n        TemporalState::edit(),\n    );\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Create diff generator with dependency injection\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n\n    // Generate diff\n    let result = generator.generate_diff().await;\n\n    // EXPECTATION: Should successfully read from CozoDB\n    assert!(\n        result.is_ok(),\n        \"Should successfully generate diff from real CozoDB: {:?}\",\n        result.err()\n    );\n\n    let diff = result.unwrap();\n    assert_eq!(\n        diff.metadata.total_changes, 1,\n        \"Should have 1 change (entity with Future_Action)\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_generate_diff_from_real_cozodb",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_diff_from_real_cozodb\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":52,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_diff_from_real_cozodb:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:52-94",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_basic() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp\n        );\n\n        // Should follow format: filepath-name-type-hash8\n        assert!(key.contains(\"src_lib_rs\"));\n        assert!(key.contains(\"new_feature\"));\n        assert!(key.contains(\"-fn-\"));\n\n        // Hash should be 8 characters\n        let parts: Vec<&str> = key.split('-').collect();\n        assert!(parts.len() >= 4, \"Key should have at least 4 parts separated by hyphens\");\n        let hash_part = parts.last().unwrap();\n        assert_eq!(hash_part.len(), 8, \"Hash should be exactly 8 characters\");\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_basic",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_basic\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1197,\"end\":1218},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_basic:__crates_parseltongue-core_src_entities_rs:1197-1218",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_different_types() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test Function type\n        let fn_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_fn\",\n            &EntityType::Function,\n            timestamp\n        );\n        assert!(fn_key.contains(\"-fn-\"));\n\n        // Test Struct type\n        let struct_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestStruct\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(struct_key.contains(\"-struct-\"));\n\n        // Test Enum type\n        let enum_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestEnum\",\n            &EntityType::Enum,\n            timestamp\n        );\n        assert!(enum_key.contains(\"-enum-\"));\n\n        // Test Trait type\n        let trait_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestTrait\",\n            &EntityType::Trait,\n            timestamp\n        );\n        assert!(trait_key.contains(\"-trait-\"));\n\n        // Test Module type\n        let mod_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_module\",\n            &EntityType::Module,\n            timestamp\n        );\n        assert!(mod_key.contains(\"-mod-\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_different_types",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_different_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1221,\"end\":1270},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_different_types:__crates_parseltongue-core_src_entities_rs:1221-1270",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_format() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n\n        // Expected format: src_models_user_rs-UserProfile-struct-abc12345\n        let parts: Vec<&str> = key.split('-').collect();\n\n        // Should have exactly 4 parts: path, name, type, hash\n        assert_eq!(parts.len(), 4, \"Key should have exactly 4 hyphen-separated parts\");\n\n        // Verify each part\n        assert_eq!(parts[0], \"src_models_user_rs\");\n        assert_eq!(parts[1], \"UserProfile\");\n        assert_eq!(parts[2], \"struct\");\n        assert_eq!(parts[3].len(), 8, \"Hash should be 8 characters\");\n\n        // Hash should be lowercase hexadecimal\n        assert!(parts[3].chars().all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase()));\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_format",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_format\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1334,\"end\":1359},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_format:__crates_parseltongue-core_src_entities_rs:1334-1359",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_impl_block() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test ImplBlock type (should default to \"impl\")\n        let impl_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"MyStruct\",\n            &EntityType::ImplBlock {\n                trait_name: Some(\"Display\".to_string()),\n                struct_name: \"MyStruct\".to_string(),\n            },\n            timestamp\n        );\n        assert!(impl_key.contains(\"-impl-\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_impl_block",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_impl_block\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1362,\"end\":1378},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_impl_block:__crates_parseltongue-core_src_entities_rs:1362-1378",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_path_sanitization() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test forward slashes\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key1.contains(\"src_models_user_rs\"));\n        assert!(!key1.contains('/'));\n\n        // Test dots in filename\n        assert!(key1.contains(\"_rs\"));\n        assert!(!key1.contains(\".rs\"));\n\n        // Test backslashes (Windows paths)\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src\\\\models\\\\user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key2.contains(\"src_models_user_rs\"));\n        assert!(!key2.contains('\\\\'));\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_path_sanitization",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_path_sanitization\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1273,\"end\":1301},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_path_sanitization:__crates_parseltongue-core_src_entities_rs:1273-1301",
      "line_number": 0
    },
    {
      "current_code": "    fn test_generate_new_entity_key_uniqueness() {\n        use chrono::TimeZone;\n\n        // Same inputs but different timestamps should produce different keys\n        let timestamp1 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let timestamp2 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 1, 0).unwrap();\n\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp1\n        );\n\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp2\n        );\n\n        assert_ne!(key1, key2, \"Different timestamps should produce different keys\");\n\n        // Extract hash parts to verify they're different\n        let hash1 = key1.split('-').last().unwrap();\n        let hash2 = key2.split('-').last().unwrap();\n        assert_ne!(hash1, hash2, \"Hash parts should be different\");\n    }",
      "current_ind": 1,
      "entity_name": "test_generate_new_entity_key_uniqueness",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_generate_new_entity_key_uniqueness\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1304,\"end\":1331},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_generate_new_entity_key_uniqueness:__crates_parseltongue-core_src_entities_rs:1304-1331",
      "line_number": 0
    },
    {
      "current_code": "    fn test_git_detection_performance_contract() {\n        // Given: Deep path structure\n        let project_root = PathBuf::from(\"/project\");\n        let deep_path = PathBuf::from(\"/project/a/b/c/d/e/f/g/h/i/j/file.rs\");\n        \n        // When: Checking for nested git\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            is_under_git_subdirectory(&deep_path, &project_root);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<50s per check)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(50),\n                \"Git detection took {:?}, expected <50s\", avg_time_per_check);\n    }",
      "current_ind": 1,
      "entity_name": "test_git_detection_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_git_detection_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":170,\"end\":186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_git_detection_performance_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:170-186",
      "line_number": 0
    },
    {
      "current_code": "fn test_go_extraction_struct_and_function() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    let go_code = r#\"\npackage main\n\ntype User struct {\n    Name string\n    Age  int\n}\n\nfunc NewUser(name string, age int) *User {\n    return &User{Name: name, Age: age}\n}\n\nfunc (u *User) Greet() string {\n    return \"Hello, \" + u.Name\n}\n\"#;\n\n    let file_path = Path::new(\"test.go\");\n    let (entities, _dependencies) = generator.parse_source(go_code, file_path)\n        .expect(\"Should parse valid Go code without errors\");\n\n    // RED: This assertion will FAIL\n    assert!(\n        entities.len() >= 2,\n        \"FAILURE: Go extraction produced {} entities, expected >= 2 (struct + functions)\",\n        entities.len()\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_go_extraction_struct_and_function",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_go_extraction_struct_and_function\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":195,\"end\":225},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_go_extraction_struct_and_function:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:195-225",
      "line_number": 0
    },
    {
      "current_code": "    fn test_go_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let test_cases = vec![\n            (\"main.go\", \"func main() { }\", EntityClass::Code),\n            (\"main_test.go\", \"func TestMain(t *testing.T) { }\", EntityClass::Test),\n            (\"integration_test.go\", \"func ExampleUsage() { }\", EntityClass::Test),\n            (\"benchmark_test.go\", \"func BenchmarkAlgorithm(b *testing.B) { }\", EntityClass::Test),\n            (\"utils.go\", \"func helper() { }\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected,\n                      \"Go file {} should be {:?}\", file_path, expected);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_go_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_go_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":240,\"end\":259},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_go_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:240-259",
      "line_number": 0
    },
    {
      "current_code": "    fn test_go_test_detection_contract() {\n        // Given: Go test patterns\n        let test_cases = vec![\n            (\"main.go\", \"func main() { }\", false),\n            (\"main_test.go\", \"func TestMain(t *testing.T) { }\", true),\n            (\"integration_test.go\", \"func ExampleUsage() { }\", true),\n            (\"benchmark_test.go\", \"func BenchmarkAlgorithm(b *testing.B) { }\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test,\n                      \"Go file {} should be test: {}\", file_path, expected_is_test);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_go_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_go_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":248,\"end\":265},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_go_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:248-265",
      "line_number": 0
    },
    {
      "current_code": "async fn test_handles_all_operation_types() {\n    // Setup\n    let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    storage.create_schema().await.unwrap();\n\n    // CREATE: Hash-based ISGL1 key, no current_code\n    let create_entity = create_test_entity(\n        \"src_lib_rs-new_feature-fn-abc12345\",\n        None, // No current code (doesn't exist yet)\n        Some(\"fn new_feature() { /* brand new */ }\"),\n        TemporalState::create(),\n    );\n\n    // EDIT: Line-based ISGL1 key, has both current and future code\n    let edit_entity = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:100-120\",\n        Some(\"fn existing() { /* old */ }\"),\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalState::edit(),\n    );\n\n    // DELETE: Line-based ISGL1 key, no future code\n    let delete_entity = create_test_entity(\n        \"rust:fn:obsolete:src_lib_rs:200-220\",\n        Some(\"fn obsolete() { /* to be removed */ }\"),\n        None, // No future code (being deleted)\n        TemporalState::delete(),\n    );\n\n    storage.insert_entity(&create_entity).await.unwrap();\n    storage.insert_entity(&edit_entity).await.unwrap();\n    storage.insert_entity(&delete_entity).await.unwrap();\n\n    // Generate diff\n    let storage_arc = Arc::new(storage);\n    let generator = DiffGenerator::new(storage_arc);\n    let diff = generator.generate_diff().await.unwrap();\n\n    // EXPECTATION: Should have 3 changes with correct operations\n    assert_eq!(diff.metadata.total_changes, 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n\n    // Verify CREATE operation\n    let create_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Create)\n        .expect(\"Should have CREATE operation\");\n    assert!(create_change.current_code.is_none(), \"CREATE has no current_code\");\n    assert!(create_change.future_code.is_some(), \"CREATE has future_code\");\n    assert!(\n        create_change.line_range.is_none(),\n        \"CREATE (hash-based key) has no line_range\"\n    );\n\n    // Verify EDIT operation\n    let edit_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Edit)\n        .expect(\"Should have EDIT operation\");\n    assert!(edit_change.current_code.is_some(), \"EDIT has current_code\");\n    assert!(edit_change.future_code.is_some(), \"EDIT has future_code\");\n    assert!(\n        edit_change.line_range.is_some(),\n        \"EDIT (line-based key) has line_range\"\n    );\n\n    // Verify DELETE operation\n    let delete_change = diff\n        .changes\n        .iter()\n        .find(|c| c.operation == Operation::Delete)\n        .expect(\"Should have DELETE operation\");\n    assert!(delete_change.current_code.is_some(), \"DELETE has current_code\");\n    assert!(delete_change.future_code.is_none(), \"DELETE has no future_code\");\n    assert!(\n        delete_change.line_range.is_some(),\n        \"DELETE (line-based key) has line_range\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_handles_all_operation_types",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_handles_all_operation_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":243,\"end\":325},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_handles_all_operation_types:__crates_pt05-llm-cozodb-to-diff-writer_tests_integration_tests_rs:243-325",
      "line_number": 0
    },
    {
      "current_code": "fn test_import_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has an import error (module doesn't exist) but is syntactically valid\n    let import_error_code = r#\"\n        use nonexistent::Module;\n\n        fn test() {}\n    \"#;\n\n    let result = validator.validate_syntax(import_error_code, Language::Rust).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Import errors should pass syntax validation (cargo catches these)\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_import_error_passes_syntax_check",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_import_error_passes_syntax_check\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":139,\"end\":154},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_import_error_passes_syntax_check:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:139-154",
      "line_number": 0
    },
    {
      "current_code": "async fn test_insert_code_entity() {\n    // RED: Entity insertion not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    let entity = create_test_entity();\n\n    db.insert_entity(&entity).await.unwrap();\n\n    // Verify entity can be retrieved\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.isgl1_key, entity.isgl1_key);\n    assert_eq!(retrieved.current_code, entity.current_code);\n}",
      "current_ind": 1,
      "entity_name": "test_insert_code_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_insert_code_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":63,\"end\":76},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_insert_code_entity:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:63-76",
      "line_number": 0
    },
    {
      "current_code": "async fn test_insert_duplicate_edge_is_idempotent() {\n    // Test: Inserting same edge twice should succeed (upsert semantics)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Uses)\n        .build()\n        .unwrap();\n\n    // Insert twice - should succeed both times\n    db.insert_edge(&edge).await.unwrap();\n    db.insert_edge(&edge).await.unwrap();\n}",
      "current_ind": 1,
      "entity_name": "test_insert_duplicate_edge_is_idempotent",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_insert_duplicate_edge_is_idempotent\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":303,\"end\":318},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_insert_duplicate_edge_is_idempotent:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:303-318",
      "line_number": 0
    },
    {
      "current_code": "async fn test_insert_edge_without_source_location() {\n    // Test: Edge insertion works with optional source_location = None\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:struct:MyStruct:src_lib_rs:10-20\")\n        .to_key(\"rust:trait:MyTrait:src_lib_rs:5-8\")\n        .edge_type(EdgeType::Implements)\n        .build()\n        .unwrap();\n\n    db.insert_edge(&edge).await.unwrap();\n}",
      "current_ind": 1,
      "entity_name": "test_insert_edge_without_source_location",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_insert_edge_without_source_location\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":287,\"end\":300},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_insert_edge_without_source_location:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:287-300",
      "line_number": 0
    },
    {
      "current_code": "async fn test_insert_single_dependency_edge() {\n    // RED: Edge insertion not yet tested\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:main:src_main_rs:1-10\")\n        .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n        .edge_type(EdgeType::Calls)\n        .source_location(\"src/main.rs:3:15\")\n        .build()\n        .unwrap();\n\n    // Insert edge\n    db.insert_edge(&edge).await.unwrap();\n\n    // Verify insertion by querying (will implement query methods later)\n    // For now, just verify no error occurred\n}",
      "current_ind": 1,
      "entity_name": "test_insert_single_dependency_edge",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_insert_single_dependency_edge\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":266,\"end\":284},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_insert_single_dependency_edge:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:266-284",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_cross_level_field_progression() {\n    // Verify: Level 0  Level 1  Level 2 field hierarchy\n\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n\n    // Level 0: Only edges\n    let output0 = Level0Exporter.export(&db, &create_config(\n        0, false, \"ALL\", temp_dir.path().join(\"l0.json\")\n    )).await.unwrap();\n\n    let json0 = serde_json::to_string(&output0).unwrap();\n    assert!(json0.contains(\"\\\"edges\\\"\"));\n    assert!(!json0.contains(\"\\\"entities\\\"\"));\n    assert!(!json0.contains(\"\\\"interface_signature\\\"\"));\n    assert!(!json0.contains(\"\\\"return_type\\\"\"));\n\n    // Level 1: Entities + ISG (no type system)\n    let output1 = Level1Exporter.export(&db, &create_config(\n        1, false, \"ALL\", temp_dir.path().join(\"l1.json\")\n    )).await.unwrap();\n\n    let json1 = serde_json::to_string(&output1).unwrap();\n    assert!(json1.contains(\"\\\"entities\\\"\"));\n    assert!(!json1.contains(\"\\\"edges\\\"\"));\n    assert!(json1.contains(\"\\\"interface_signature\\\"\"));\n    assert!(!json1.contains(\"\\\"return_type\\\"\"), \"Level 1 should NOT have type fields\");\n\n    // Level 2: All fields\n    let output2 = Level2Exporter.export(&db, &create_config(\n        2, false, \"ALL\", temp_dir.path().join(\"l2.json\")\n    )).await.unwrap();\n\n    let json2 = serde_json::to_string(&output2).unwrap();\n    assert!(json2.contains(\"\\\"entities\\\"\"));\n    assert!(json2.contains(\"\\\"interface_signature\\\"\"));\n    assert!(json2.contains(\"\\\"return_type\\\"\"), \"Level 2 should have type fields\");\n}",
      "current_ind": 1,
      "entity_name": "test_integration_cross_level_field_progression",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_cross_level_field_progression\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":520,\"end\":557},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_cross_level_field_progression:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:520-557",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_empty_where_clause() {\n    // Empty WHERE should be caught by CLI validation\n    // This test documents expected behavior\n\n    let _db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let config = create_config(0, false, \"\", temp_dir.path().join(\"empty_where.json\"));\n\n    // CLI validation prevents empty WHERE clauses\n    // Exporters can assume non-empty WHERE from config\n    assert!(config.where_filter.is_empty());  // Document invalid state\n}",
      "current_ind": 1,
      "entity_name": "test_integration_empty_where_clause",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_empty_where_clause\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":581,\"end\":592},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_empty_where_clause:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:581-592",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_invalid_level() {\n    // Note: This would be caught by CLI validation, but test repository behavior\n    // Exporters should gracefully handle unexpected levels\n\n    let _db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n\n    // Level must be 0, 1, or 2 (validated by CLI)\n    // This test documents expected behavior\n    let config = create_config(3, false, \"ALL\", temp_dir.path().join(\"invalid.json\"));\n\n    // Note: In real implementation, this would be prevented by CLI validation\n    // Exporters assume valid config from CLI\n    assert_eq!(config.level, 3);  // Document invalid state\n}",
      "current_ind": 1,
      "entity_name": "test_integration_invalid_level",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_invalid_level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":564,\"end\":578},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_invalid_level:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:564-578",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_json_serialization_valid() {\n    // Verify all export outputs serialize to valid JSON\n\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n\n    // Level 0\n    let output0 = Level0Exporter.export(&db, &create_config(\n        0, false, \"ALL\", temp_dir.path().join(\"json0.json\")\n    )).await.unwrap();\n\n    let json0 = serde_json::to_string_pretty(&output0);\n    assert!(json0.is_ok(), \"Level 0 output should serialize to JSON\");\n\n    // Verify can deserialize back\n    let json_str = json0.unwrap();\n    let parsed: serde_json::Value = serde_json::from_str(&json_str).unwrap();\n    assert_eq!(parsed[\"export_metadata\"][\"level\"], 0);\n}",
      "current_ind": 1,
      "entity_name": "test_integration_json_serialization_valid",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_json_serialization_valid\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":599,\"end\":617},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_json_serialization_valid:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:599-617",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level0_empty_database() {\n    // Arrange\n    let db = IntegrationMockDatabase::empty();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level0_empty.json\");\n    let config = create_config(0, false, \"ALL\", output_path);\n    let exporter = Level0Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert\n    assert_eq!(output.export_metadata.total_edges, Some(0));\n    assert_eq!(output.edges.unwrap().len(), 0);\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level0_empty_database",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level0_empty_database\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":289,\"end\":306},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level0_empty_database:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:289-306",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level0_export_all_edges() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level0.json\");\n    let config = create_config(0, false, \"ALL\", output_path.clone());\n    let exporter = Level0Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok(), \"Level 0 export should succeed\");\n\n    let output = result.unwrap();\n\n    // Assert: Output structure\n    assert_eq!(output.export_metadata.level, 0);\n    assert_eq!(output.export_metadata.total_edges, Some(3));\n    assert!(output.edges.is_some());\n    assert!(output.entities.is_none(), \"Level 0 should NOT have entities\");\n\n    // Assert: Edge content\n    let edges = output.edges.unwrap();\n    assert_eq!(edges.len(), 3);\n\n    // Verify semantic ISGL1 keys\n    assert!(edges.iter().all(|e| e.from_key.contains(\":\")));\n    assert!(edges.iter().all(|e| e.to_key.contains(\":\")));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level0_export_all_edges",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level0_export_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":238,\"end\":265},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level0_export_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:238-265",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level0_filter_depends_on() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level0_filtered.json\");\n    let config = create_config(0, false, \"edge_type = 'depends_on'\", output_path);\n    let exporter = Level0Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let edges = output.edges.unwrap();\n\n    // Assert: Only \"depends_on\" edges\n    assert_eq!(edges.len(), 2, \"Should have 2 depends_on edges\");\n    assert!(edges.iter().all(|e| e.edge_type == \"depends_on\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level0_filter_depends_on",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level0_filter_depends_on\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":268,\"end\":286},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level0_filter_depends_on:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:268-286",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level1_dependency_arrays() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level1_deps.json\");\n    let config = create_config(1, false, \"ALL\", output_path);\n    let exporter = Level1Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: forward_deps and reverse_deps present\n    assert!(json.contains(\"\\\"forward_deps\\\"\"));\n    assert!(json.contains(\"\\\"reverse_deps\\\"\"));\n    assert!(json.contains(\"rust:struct:ExportConfig:src_models_rs:15\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level1_dependency_arrays",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level1_dependency_arrays\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":413,\"end\":432},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level1_dependency_arrays:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:413-432",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level1_export_all_entities_no_code() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level1_no_code.json\");\n    let config = create_config(1, false, \"ALL\", output_path);\n    let exporter = Level1Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Metadata\n    assert_eq!(output.export_metadata.level, 1);\n    assert_eq!(output.export_metadata.total_entities, Some(3));\n    assert_eq!(output.export_metadata.include_code, Some(false));\n\n    // Assert: Entities present, edges absent\n    assert!(output.entities.is_some());\n    assert!(output.edges.is_none(), \"Level 1 should NOT have edges\");\n\n    // Assert: No current_code field when include_code=false\n    let json = serde_json::to_string(&output).unwrap();\n    assert!(!json.contains(\"\\\"current_code\\\"\"), \"Signatures only mode should skip current_code\");\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level1_export_all_entities_no_code",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level1_export_all_entities_no_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":313,\"end\":339},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level1_export_all_entities_no_code:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:313-339",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level1_export_with_code() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level1_with_code.json\");\n    let config = create_config(1, true, \"ALL\", output_path);\n    let exporter = Level1Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: current_code present when include_code=true\n    assert!(json.contains(\"\\\"current_code\\\"\"), \"Full code mode should include current_code\");\n    assert!(json.contains(\"pub async fn export_level1\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level1_export_with_code",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level1_export_with_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":342,\"end\":360},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level1_export_with_code:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:342-360",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level1_filter_public_functions() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level1_public.json\");\n    let config = create_config(1, false, \"is_public = true\", output_path);\n    let exporter = Level1Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Only public entities (export_level1 function and ExportConfig struct)\n    assert_eq!(output.export_metadata.total_entities, Some(2), \"Should have 2 public entities\");\n\n    // Verify JSON contains expected public entities\n    let json = serde_json::to_string(&output).unwrap();\n    assert!(json.contains(\"export_level1\"));\n    assert!(json.contains(\"ExportConfig\"));\n    assert!(!json.contains(\"helper\"), \"Private helper function should be filtered out\");\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level1_filter_public_functions",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level1_filter_public_functions\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":363,\"end\":385},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level1_filter_public_functions:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:363-385",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level1_filter_with_future_action() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level1_future.json\");\n    let config = create_config(1, false, \"future_action != null\", output_path);\n    let exporter = Level1Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Only entities with planned changes (helper function)\n    assert_eq!(output.export_metadata.total_entities, Some(1), \"Should have 1 entity with future_action\");\n\n    // Verify JSON contains expected entity with future_action\n    let json = serde_json::to_string(&output).unwrap();\n    assert!(json.contains(\"helper\"));\n    assert!(json.contains(\"\\\"future_action\\\"\"));\n    assert!(json.contains(\"refactor\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level1_filter_with_future_action",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level1_filter_with_future_action\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":388,\"end\":410},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level1_filter_with_future_action:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:388-410",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level2_filter_async_functions() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level2_async.json\");\n    let config = create_config(2, false, \"is_async = true\", output_path);\n    let exporter = Level2Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Only async function (export_level1)\n    assert_eq!(output.export_metadata.total_entities, Some(1), \"Should have 1 async function\");\n\n    // Verify JSON contains expected async function\n    let json = serde_json::to_string(&output).unwrap();\n    assert!(json.contains(\"export_level1\"));\n    assert!(json.contains(\"\\\"is_async\\\":true\") || json.contains(\"\\\"is_async\\\": true\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level2_filter_async_functions",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level2_filter_async_functions\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":492,\"end\":513},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level2_filter_async_functions:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:492-513",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level2_includes_level1_fields() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level2_full.json\");\n    let config = create_config(2, false, \"ALL\", output_path);\n    let exporter = Level2Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All Level 1 fields still present\n    assert!(json.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json.contains(\"\\\"forward_deps\\\"\"));\n    assert!(json.contains(\"\\\"current_ind\\\"\"));\n    assert!(json.contains(\"\\\"entity_name\\\"\"));\n    assert!(json.contains(\"\\\"interface_signature\\\"\"));\n\n    // Assert: Level 2 additions\n    assert!(json.contains(\"\\\"return_type\\\"\"));\n    assert!(json.contains(\"\\\"is_async\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level2_includes_level1_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level2_includes_level1_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":464,\"end\":489},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level2_includes_level1_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:464-489",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_level2_type_system_fields() {\n    // Arrange\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n    let output_path = temp_dir.path().join(\"level2.json\");\n    let config = create_config(2, false, \"ALL\", output_path);\n    let exporter = Level2Exporter;\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: Type system fields present\n    assert!(json.contains(\"\\\"return_type\\\"\"));\n    assert!(json.contains(\"\\\"param_types\\\"\"));\n    assert!(json.contains(\"\\\"param_names\\\"\"));\n    assert!(json.contains(\"\\\"is_public\\\"\"));\n    assert!(json.contains(\"\\\"is_async\\\"\"));\n    assert!(json.contains(\"\\\"is_unsafe\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_integration_level2_type_system_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_level2_type_system_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":439,\"end\":461},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_level2_type_system_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:439-461",
      "line_number": 0
    },
    {
      "current_code": "async fn test_integration_timestamp_format() {\n    // Verify all exports include RFC3339 timestamps\n\n    let db = IntegrationMockDatabase::create_realistic();\n    let temp_dir = TempDir::new().unwrap();\n\n    let output = Level0Exporter.export(&db, &create_config(\n        0, false, \"ALL\", temp_dir.path().join(\"timestamp.json\")\n    )).await.unwrap();\n\n    let timestamp = &output.export_metadata.timestamp;\n\n    // RFC3339 format: 2024-01-15T10:30:00Z or 2024-01-15T10:30:00+00:00\n    assert!(timestamp.contains(\"T\"), \"Should have date-time separator\");\n    assert!(timestamp.contains(\"Z\") || timestamp.contains(\"+\"), \"Should have timezone\");\n\n    // Verify parseable as RFC3339\n    let parsed = chrono::DateTime::parse_from_rfc3339(timestamp);\n    assert!(parsed.is_ok(), \"Timestamp should be valid RFC3339\");\n}",
      "current_ind": 1,
      "entity_name": "test_integration_timestamp_format",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_integration_timestamp_format\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":620,\"end\":639},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_integration_timestamp_format:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:620-639",
      "line_number": 0
    },
    {
      "current_code": "fn test_invalid_function_syntax_missing_paren() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        fn broken_function( {\n            println!(\"broken\");\n        }\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Invalid syntax should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
      "current_ind": 1,
      "entity_name": "test_invalid_function_syntax_missing_paren",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_invalid_function_syntax_missing_paren\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":26,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_invalid_function_syntax_missing_paren:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:26-38",
      "line_number": 0
    },
    {
      "current_code": "    fn test_invalid_isgl1_key_error() {\n        let err = FileWriterError::invalid_isgl1_key(\"invalid-key\".to_string());\n        assert!(err.to_string().contains(\"invalid-key\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_invalid_isgl1_key_error",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_invalid_isgl1_key_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":57,\"end\":60},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_invalid_isgl1_key_error:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:57-60",
      "line_number": 0
    },
    {
      "current_code": "fn test_invalid_struct_missing_brace() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let invalid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        // Missing closing brace\n    \"#;\n\n    let result = validator.validate_syntax(invalid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(!result.is_valid, \"Missing brace should fail\");\n    assert!(!result.errors.is_empty(), \"Should have syntax errors\");\n}",
      "current_ind": 1,
      "entity_name": "test_invalid_struct_missing_brace",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_invalid_struct_missing_brace\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":59,\"end\":72},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_invalid_struct_missing_brace:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:59-72",
      "line_number": 0
    },
    {
      "current_code": "    fn test_isgl1_key_as_ref() {\n        // S77 Pattern A.2: Accept AsRef<str> in APIs\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        let s: &str = key.as_ref();\n        assert_eq!(s, \"test_key\");\n    }",
      "current_ind": 1,
      "entity_name": "test_isgl1_key_as_ref",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_isgl1_key_as_ref\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1425,\"end\":1430},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_isgl1_key_as_ref:__crates_parseltongue-core_src_entities_rs:1425-1430",
      "line_number": 0
    },
    {
      "current_code": "    fn test_isgl1_key_display() {\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        assert_eq!(format!(\"{}\", key), \"test_key\");\n    }",
      "current_ind": 1,
      "entity_name": "test_isgl1_key_display",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_isgl1_key_display\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1433,\"end\":1436},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_isgl1_key_display:__crates_parseltongue-core_src_entities_rs:1433-1436",
      "line_number": 0
    },
    {
      "current_code": "    fn test_isgl1_key_format() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let entity = ParsedEntity {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            language: Language::Rust,\n            line_range: (10, 15),\n            file_path: \"src/main.rs\".to_string(),\n            metadata: HashMap::new(),\n        };\n\n        let key = generator.generate_key(&entity).unwrap();\n        assert!(key.contains(\"rust:fn:test_function\"));\n        assert!(key.contains(\"10-15\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_isgl1_key_format",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_isgl1_key_format\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":403,\"end\":417},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_isgl1_key_format:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:403-417",
      "line_number": 0
    },
    {
      "current_code": "    fn test_isgl1_key_validates_non_empty() {\n        // RED: This validates the non-empty invariant\n        let result = Isgl1Key::new(\"\");\n        assert!(result.is_err(), \"Empty key should be rejected\");\n\n        // Valid key\n        let key = Isgl1Key::new(\"rust:fn:main:src_main_rs:1-10\").unwrap();\n        assert_eq!(key.as_str(), \"rust:fn:main:src_main_rs:1-10\");\n    }",
      "current_ind": 1,
      "entity_name": "test_isgl1_key_validates_non_empty",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_isgl1_key_validates_non_empty\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1414,\"end\":1422},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_isgl1_key_validates_non_empty:__crates_parseltongue-core_src_entities_rs:1414-1422",
      "line_number": 0
    },
    {
      "current_code": "fn test_javascript_extraction_mixed_syntax() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    let js_code = r#\"\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\nconst add = (a, b) => a + b;\n\nclass Calculator {\n    constructor(name) {\n        this.name = name;\n    }\n\n    multiply(x, y) {\n        return x * y;\n    }\n}\n\"#;\n\n    let file_path = Path::new(\"test.js\");\n    let (entities, _dependencies) = generator.parse_source(js_code, file_path)\n        .expect(\"Should parse valid JavaScript code without errors\");\n\n    // RED: This assertion will FAIL - currently returns 0 entities\n    assert!(\n        entities.len() >= 2,\n        \"FAILURE: JavaScript extraction produced {} entities, expected >= 2 (function + class). \\\n         This indicates walk_node() doesn't handle JavaScript.\",\n        entities.len()\n    );\n\n    // Verify function extraction\n    let has_greet = entities.iter().any(|e| e.name == \"greet\");\n    assert!(has_greet, \"Should extract greet function\");\n\n    // Verify class extraction\n    let has_calculator = entities.iter().any(|e| e.name == \"Calculator\");\n    assert!(has_calculator, \"Should extract Calculator class\");\n}",
      "current_ind": 1,
      "entity_name": "test_javascript_extraction_mixed_syntax",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_javascript_extraction_mixed_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":148,\"end\":188},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_javascript_extraction_mixed_syntax:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:148-188",
      "line_number": 0
    },
    {
      "current_code": "    fn test_javascript_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let test_cases = vec![\n            (\"src/app.js\", \"function runApp() { }\", EntityClass::Code),\n            (\"src/app.test.js\", \"test('app runs', () => { })\", EntityClass::Test),\n            (\"utils.spec.ts\", \"describe('utils', () => { })\", EntityClass::Test),\n            (\"__tests__/helper.js\", \"expect(true).toBe(true)\", EntityClass::Test),\n            (\"components/Button.tsx\", \"export Button = () => {}\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected,\n                      \"JS/TS file {} should be {:?}\", file_path, expected);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_javascript_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_javascript_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":263,\"end\":282},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_javascript_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:263-282",
      "line_number": 0
    },
    {
      "current_code": "    fn test_javascript_test_detection_contract() {\n        // Given: JS/TS test patterns\n        let test_cases = vec![\n            (\"src/app.js\", \"function runApp() { }\", false),\n            (\"src/app.test.js\", \"test('app runs', () => { })\", true),\n            (\"utils.spec.ts\", \"describe('utils', () => { })\", true),\n            (\"__tests__/helper.js\", \"expect(true).toBe(true)\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test,\n                      \"JS/TS file {} should be test: {}\", file_path, expected_is_test);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_javascript_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_javascript_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":269,\"end\":286},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_javascript_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:269-286",
      "line_number": 0
    },
    {
      "current_code": "    fn test_javascript_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"function hello() { console.log('world'); }\";\n        let result = validator.validate_syntax(code, Language::JavaScript).unwrap();\n        assert!(result.is_valid);\n    }",
      "current_ind": 1,
      "entity_name": "test_javascript_valid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_javascript_valid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":209,\"end\":214},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_javascript_valid_code:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:209-214",
      "line_number": 0
    },
    {
      "current_code": "    fn test_json_serialization() {\n        let mut diff = CodeDiff::new();\n\n        diff.add_change(Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn test()\".to_string(),\n        });\n\n        let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n        assert!(json.contains(\"\\\"changes\\\"\"));\n        assert!(json.contains(\"\\\"metadata\\\"\"));\n        assert!(json.contains(\"\\\"CREATE\\\"\"));\n        // Enhanced schema includes these fields\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"\\\"future_code\\\"\"));\n        assert!(json.contains(\"\\\"line_range\\\"\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_json_serialization",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_json_serialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":245,\"end\":266},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_json_serialization:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:245-266",
      "line_number": 0
    },
    {
      "current_code": "async fn test_known_limitation_macro_wrapped_calls() {\n    let source = r#\"\nfn debug_demo() {\n    println!(\"{}\", expensive_computation());\n    vec![factory(), factory()];\n}\n\nfn expensive_computation() -> i32 { 42 }\nfn factory() -> i32 { 0 }\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Macro-Wrapped Calls (Known Limitation) ===\");\n    print_dependencies(&deps);\n\n    // Document the limitation\n    let has_expensive = has_call(&deps, \"expensive_computation\");\n    let has_factory = has_call(&deps, \"factory\");\n\n    println!(\"\\nKNOWN LIMITATION: Calls inside macro token trees are not captured by tree-sitter\");\n    println!(\"  - expensive_computation() captured: {}\", has_expensive);\n    println!(\"  - factory() captured: {}\", has_factory);\n    println!(\"  - This is a tree-sitter architectural constraint, not a bug\");\n\n    // Don't assert - just document\n    if has_expensive || has_factory {\n        println!(\"  - Unexpectedly captured! Tree-sitter behavior may have changed.\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_known_limitation_macro_wrapped_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_known_limitation_macro_wrapped_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":247,\"end\":276},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_known_limitation_macro_wrapped_calls:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:247-276",
      "line_number": 0
    },
    {
      "current_code": "fn test_level0_dependency_edge_clone() {\n    // Test that DependencyEdge implements Clone (needed for conversions)\n    let edge = DependencyEdge {\n        from_key: \"test_from\".to_string(),\n        to_key: \"test_to\".to_string(),\n        edge_type: \"test_type\".to_string(),\n    };\n\n    let cloned = edge.clone();\n    assert_eq!(cloned.from_key, \"test_from\");\n    assert_eq!(cloned.to_key, \"test_to\");\n    assert_eq!(cloned.edge_type, \"test_type\");\n}",
      "current_ind": 1,
      "entity_name": "test_level0_dependency_edge_clone",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_dependency_edge_clone\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":355,\"end\":367},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_dependency_edge_clone:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:355-367",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_edge_count_accuracy() {\n    // Arrange: Test that metadata.total_edges matches actual edge count\n    let edges = vec![\n        create_test_edge(\"a\", \"b\", \"depends_on\"),\n        create_test_edge(\"b\", \"c\", \"depends_on\"),\n        create_test_edge(\"c\", \"d\", \"depends_on\"),\n        create_test_edge(\"d\", \"e\", \"depends_on\"),\n        create_test_edge(\"e\", \"f\", \"depends_on\"),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert\n    assert_eq!(output.export_metadata.total_edges, Some(5));\n    assert_eq!(output.edges.as_ref().unwrap().len(), 5);\n}",
      "current_ind": 1,
      "entity_name": "test_level0_edge_count_accuracy",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_edge_count_accuracy\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":329,\"end\":352},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_edge_count_accuracy:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:329-352",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_empty_database() {\n    // Arrange: Empty database\n    let db = MockDatabase::new();\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let output = result.unwrap();\n    assert_eq!(output.export_metadata.total_edges, Some(0));\n    assert_eq!(output.edges.unwrap().len(), 0);\n}",
      "current_ind": 1,
      "entity_name": "test_level0_empty_database",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_empty_database\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":192,\"end\":206},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_empty_database:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:192-206",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_export_all_edges() {\n    // Arrange: Create mock database with 3 edges\n    let edges = vec![\n        create_test_edge(\n            \"rust:fn:calculate_total:src_billing_rs:42\",\n            \"rust:fn:get_tax_rate:src_billing_rs:102\",\n            \"depends_on\"\n        ),\n        create_test_edge(\n            \"rust:fn:calculate_total:src_billing_rs:42\",\n            \"rust:struct:Invoice:src_models_rs:15\",\n            \"depends_on\"\n        ),\n        create_test_edge(\n            \"rust:struct:Invoice:src_models_rs:15\",\n            \"rust:trait:Serialize:external:0\",\n            \"implements\"\n        ),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n\n    // Assert\n    assert!(result.is_ok(), \"Export should succeed\");\n    let output = result.unwrap();\n\n    // Verify metadata\n    assert_eq!(output.export_metadata.level, 0);\n    assert_eq!(output.export_metadata.total_edges, Some(3));\n    assert_eq!(output.export_metadata.total_entities, None);\n    assert_eq!(output.export_metadata.include_code, None);\n    assert_eq!(output.export_metadata.where_filter, \"ALL\");\n\n    // Verify edges present, entities absent\n    assert!(output.edges.is_some());\n    assert!(output.entities.is_none());\n\n    let exported_edges = output.edges.unwrap();\n    assert_eq!(exported_edges.len(), 3);\n\n    // Verify first edge structure\n    let edge0 = &exported_edges[0];\n    assert_eq!(edge0.from_key, \"rust:fn:calculate_total:src_billing_rs:42\");\n    assert_eq!(edge0.to_key, \"rust:fn:get_tax_rate:src_billing_rs:102\");\n    assert_eq!(edge0.edge_type, \"depends_on\");\n}",
      "current_ind": 1,
      "entity_name": "test_level0_export_all_edges",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_export_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":113,\"end\":163},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_export_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:113-163",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_export_filtered_edges() {\n    // Arrange: Database with multiple edge types\n    let edges = vec![\n        create_test_edge(\"rust:fn:foo:src_lib_rs:10\", \"rust:fn:bar:src_lib_rs:20\", \"depends_on\"),\n        create_test_edge(\"rust:struct:Foo:src_lib_rs:30\", \"rust:trait:Debug:external:0\", \"implements\"),\n        create_test_edge(\"rust:fn:baz:src_lib_rs:40\", \"rust:fn:qux:src_lib_rs:50\", \"depends_on\"),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"edge_type = 'depends_on'\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let output = result.unwrap();\n    let exported_edges = output.edges.unwrap();\n\n    // Should only have 2 \"depends_on\" edges\n    assert_eq!(exported_edges.len(), 2);\n    assert!(exported_edges.iter().all(|e| e.edge_type == \"depends_on\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level0_export_filtered_edges",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_export_filtered_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":166,\"end\":189},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_export_filtered_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:166-189",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_level0_exporter_basic() {\n        // Arrange\n        let edges = vec![\n            Edge {\n                from_key: \"rust:fn:foo:src_lib_rs:10\".to_string(),\n                to_key: \"rust:fn:bar:src_lib_rs:20\".to_string(),\n                edge_type: \"depends_on\".to_string(),\n            },\n        ];\n\n        let db = MockDatabase { edges };\n        let config = ExportConfig {\n            level: 0,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level0Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 0);\n        assert_eq!(output.export_metadata.total_edges, Some(1));\n        assert!(output.edges.is_some());\n        assert!(output.entities.is_none());\n\n        let exported_edges = output.edges.unwrap();\n        assert_eq!(exported_edges.len(), 1);\n        assert_eq!(exported_edges[0].from_key, \"rust:fn:foo:src_lib_rs:10\");\n    }",
      "current_ind": 1,
      "entity_name": "test_level0_exporter_basic",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_exporter_basic\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":138,\"end\":177},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_exporter_basic:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:138-177",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level0_exporter_metadata() {\n        let exporter = Level0Exporter::new();\n        assert_eq!(exporter.level(), 0);\n        assert_eq!(exporter.estimated_tokens(), 5_000);\n    }",
      "current_ind": 1,
      "entity_name": "test_level0_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":180,\"end\":184},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:180-184",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_exporter_metadata() {\n    // Arrange\n    let exporter = Level0Exporter::new();\n\n    // Act & Assert\n    assert_eq!(exporter.level(), 0);\n    assert_eq!(exporter.estimated_tokens(), 5000);\n}",
      "current_ind": 1,
      "entity_name": "test_level0_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":243,\"end\":250},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:243-250",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_json_serialization() {\n    // Arrange\n    let edges = vec![\n        create_test_edge(\"rust:fn:foo:src_lib_rs:10\", \"rust:fn:bar:src_lib_rs:20\", \"depends_on\"),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string_pretty(&output);\n\n    // Assert: JSON should serialize successfully\n    assert!(json.is_ok(), \"Output should serialize to JSON\");\n\n    let json_str = json.unwrap();\n    assert!(json_str.contains(\"\\\"level\\\": 0\"));\n    assert!(json_str.contains(\"\\\"from_key\\\"\"));\n    assert!(json_str.contains(\"\\\"to_key\\\"\"));\n    assert!(json_str.contains(\"\\\"edge_type\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level0_json_serialization",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_json_serialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":253,\"end\":278},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_json_serialization:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:253-278",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level0_minimal() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        assert_eq!(cli.level, 0);\n        assert!(cli.include_code.is_none());\n        assert_eq!(cli.where_clause, \"ALL\");\n\n        let config = cli.validate();\n        assert!(config.is_ok());\n        let config = config.unwrap();\n        assert_eq!(config.level, 0);\n        assert_eq!(config.include_code, false);\n    }",
      "current_ind": 1,
      "entity_name": "test_level0_minimal",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_minimal\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":172,\"end\":188},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_minimal:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:172-188",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_no_code_fields() {\n    // Arrange: Verify Level 0 has NO code fields (current_code, future_code)\n    let edges = vec![\n        create_test_edge(\"rust:fn:foo:src_lib_rs:10\", \"rust:fn:bar:src_lib_rs:20\", \"depends_on\"),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: No code-related fields in JSON\n    assert!(!json.contains(\"current_code\"), \"Level 0 should NOT have current_code\");\n    assert!(!json.contains(\"future_code\"), \"Level 0 should NOT have future_code\");\n    assert!(!json.contains(\"interface_signature\"), \"Level 0 should NOT have interface_signature\");\n\n    // Only edge fields should be present\n    assert!(json.contains(\"from_key\"));\n    assert!(json.contains(\"to_key\"));\n    assert!(json.contains(\"edge_type\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level0_no_code_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_no_code_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":281,\"end\":307},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_no_code_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:281-307",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_semantic_isgl1_keys() {\n    // Arrange: Verify semantic ISGL1 keys (NOT integer indices)\n    let edges = vec![\n        create_test_edge(\n            \"rust:fn:calculate_total:src_billing_rs:42\",\n            \"rust:fn:get_tax_rate:src_billing_rs:102\",\n            \"depends_on\"\n        ),\n    ];\n\n    let db = MockDatabase::with_edges(edges);\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n\n    // Assert\n    assert!(result.is_ok());\n    let output = result.unwrap();\n    let exported_edges = output.edges.unwrap();\n\n    // Verify keys are semantic, not numeric indices\n    let edge = &exported_edges[0];\n    assert!(edge.from_key.contains(\":\"), \"ISGL1 key should be semantic (colon-separated)\");\n    assert!(edge.from_key.contains(\"rust\"), \"ISGL1 key should contain language\");\n    assert!(edge.from_key.contains(\"fn\"), \"ISGL1 key should contain entity type\");\n    assert!(edge.from_key.contains(\"calculate_total\"), \"ISGL1 key should contain entity name\");\n\n    // Verify NOT integer indices\n    assert!(!edge.from_key.chars().all(|c| c.is_numeric()), \"Keys should NOT be pure integers\");\n}",
      "current_ind": 1,
      "entity_name": "test_level0_semantic_isgl1_keys",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_semantic_isgl1_keys\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":209,\"end\":240},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_semantic_isgl1_keys:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:209-240",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level0_timestamp_format() {\n    // Arrange\n    let db = MockDatabase::new();\n    let config = create_test_config(0, \"ALL\");\n    let exporter = Level0Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Timestamp should be RFC3339 format\n    let timestamp = &output.export_metadata.timestamp;\n    assert!(timestamp.contains(\"T\"), \"Timestamp should be RFC3339 (contains T separator)\");\n    assert!(timestamp.contains(\"Z\") || timestamp.contains(\"+\"), \"Timestamp should have timezone\");\n}",
      "current_ind": 1,
      "entity_name": "test_level0_timestamp_format",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_timestamp_format\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":310,\"end\":326},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_timestamp_format:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:310-326",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level0_with_include_code_fails() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"0\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let result = cli.validate();\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"Level 0 exports edges only\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_level0_with_include_code_fails",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level0_with_include_code_fails\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":191,\"end\":203},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level0_with_include_code_fails:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:191-203",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_core_identity_fields() {\n    // Arrange\n    let entity = create_test_entity(\"rust:fn:calculate_total:src_billing_rs:42\", false);\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All core identity fields present\n    assert!(json.contains(\"\\\"entity_name\\\":\\\"test_function\\\"\") || json.contains(\"\\\"entity_name\\\": \\\"test_function\\\"\"));\n    assert!(json.contains(\"\\\"entity_type\\\":\\\"fn\\\"\") || json.contains(\"\\\"entity_type\\\": \\\"fn\\\"\"));\n    assert!(json.contains(\"\\\"file_path\\\":\\\"src/lib.rs\\\"\") || json.contains(\"\\\"file_path\\\": \\\"src/lib.rs\\\"\"));\n    assert!(json.contains(\"\\\"line_number\\\":42\") || json.contains(\"\\\"line_number\\\": 42\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_core_identity_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_core_identity_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":398,\"end\":417},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_core_identity_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:398-417",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_doc_comment_optional() {\n    // Arrange: Entity without doc_comment\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", false);\n    entity.doc_comment = None;\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: doc_comment field should be skipped (null-skipping)\n    assert!(!json.contains(\"\\\"doc_comment\\\"\"),\n            \"doc_comment should be skipped when null (serde optimization)\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_doc_comment_optional",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_doc_comment_optional\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":289,\"end\":308},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_doc_comment_optional:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:289-308",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_empty_deps_arrays_skipped() {\n    // Arrange: Entity with no dependencies\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", false);\n    entity.forward_deps = vec![];\n    entity.reverse_deps = vec![];\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: Empty arrays should be skipped (serde optimization)\n    // Note: serde skip_serializing_if = \"Vec::is_empty\" should hide these\n    let forward_deps_count = json.matches(\"\\\"forward_deps\\\"\").count();\n    let reverse_deps_count = json.matches(\"\\\"reverse_deps\\\"\").count();\n\n    assert_eq!(forward_deps_count, 0, \"Empty forward_deps should be skipped\");\n    assert_eq!(reverse_deps_count, 0, \"Empty reverse_deps should be skipped\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_empty_deps_arrays_skipped",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_empty_deps_arrays_skipped\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":367,\"end\":391},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_empty_deps_arrays_skipped:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:367-391",
      "line_number": 0
    },
    {
      "current_code": "fn test_level1_entity_struct_clone() {\n    // Test that EntityExportLevel1 implements Clone\n    let entity = EntityExportLevel1 {\n        isgl1_key: \"test\".to_string(),\n        forward_deps: vec![],\n        reverse_deps: vec![],\n        current_ind: 1,\n        future_ind: 0,\n        future_action: None,\n        future_code: None,\n        current_code: None,\n        entity_name: \"test\".to_string(),\n        entity_type: \"fn\".to_string(),\n        file_path: \"test.rs\".to_string(),\n        line_number: 10,\n        interface_signature: \"pub fn test()\".to_string(),\n        doc_comment: None,\n    };\n\n    let cloned = entity.clone();\n    assert_eq!(cloned.isgl1_key, \"test\");\n    assert_eq!(cloned.entity_name, \"test\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_entity_struct_clone",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_entity_struct_clone\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":553,\"end\":575},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_entity_struct_clone:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:553-575",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_export_all_entities() {\n    // Arrange: 3 entities with different states\n    let entities = vec![\n        create_test_entity(\"rust:fn:foo:src_lib_rs:10\", false),\n        create_test_entity(\"rust:fn:bar:src_lib_rs:20\", true),\n        create_test_entity(\"rust:fn:baz:src_lib_rs:30\", false),\n    ];\n\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n\n    // Assert\n    assert!(result.is_ok(), \"Export should succeed\");\n    let output = result.unwrap();\n\n    // Verify metadata\n    assert_eq!(output.export_metadata.level, 1);\n    assert_eq!(output.export_metadata.total_entities, Some(3));\n    assert_eq!(output.export_metadata.total_edges, None);\n    assert_eq!(output.export_metadata.include_code, Some(false));\n\n    // Verify entities present, edges absent\n    assert!(output.entities.is_some());\n    assert!(output.edges.is_none());\n}",
      "current_ind": 1,
      "entity_name": "test_level1_export_all_entities",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_export_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":137,\"end\":165},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_export_all_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:137-165",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_level1_exporter_basic() {\n        // Arrange\n        let entities = vec![create_test_entity()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 1,\n            include_code: false,  // Signatures only\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level1Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 1);\n        assert_eq!(output.export_metadata.total_entities, Some(1));\n        assert_eq!(output.export_metadata.include_code, Some(false));\n        assert!(output.entities.is_some());\n        assert!(output.edges.is_none());\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_exporter_basic",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_exporter_basic\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":267,\"end\":297},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_exporter_basic:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:267-297",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level1_exporter_metadata() {\n        let exporter = Level1Exporter::new();\n        assert_eq!(exporter.level(), 1);\n        assert_eq!(exporter.estimated_tokens(), 30_000);\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":348,\"end\":352},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:348-352",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_exporter_metadata() {\n    let exporter = Level1Exporter::new();\n\n    // Assert\n    assert_eq!(exporter.level(), 1);\n    assert_eq!(exporter.estimated_tokens(), 30_000);\n}",
      "current_ind": 1,
      "entity_name": "test_level1_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":513,\"end\":519},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:513-519",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_forward_deps_array() {\n    // Arrange\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", false);\n    entity.forward_deps = vec![\n        \"rust:fn:dep1:src_lib_rs:100\".to_string(),\n        \"rust:fn:dep2:src_lib_rs:200\".to_string(),\n        \"rust:struct:Foo:src_models_rs:50\".to_string(),\n    ];\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All dependencies present as semantic ISGL1 keys\n    assert!(json.contains(\"rust:fn:dep1:src_lib_rs:100\"));\n    assert!(json.contains(\"rust:fn:dep2:src_lib_rs:200\"));\n    assert!(json.contains(\"rust:struct:Foo:src_models_rs:50\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_forward_deps_array",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_forward_deps_array\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":315,\"end\":339},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_forward_deps_array:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:315-339",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_future_code_only_when_future_action_present() {\n    // Arrange: 2 entities - one with future_action, one without\n    let entities = vec![\n        create_test_entity(\"rust:fn:unchanged:src_lib_rs:10\", false),  // No future_action\n        create_test_entity(\"rust:fn:changed:src_lib_rs:20\", true),     // Has future_action\n    ];\n\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: future_code appears exactly once (only for changed entity)\n    let future_code_count = json.matches(\"\\\"future_code\\\"\").count();\n    assert_eq!(future_code_count, 1,\n               \"future_code should only appear for entity with future_action\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_future_code_only_when_future_action_present",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_future_code_only_when_future_action_present\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":214,\"end\":236},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_future_code_only_when_future_action_present:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:214-236",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_include_code_false() {\n    // Arrange\n    let entities = vec![create_test_entity(\"rust:fn:test:src_lib_rs:10\", false)];\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"ALL\");  // include_code = false\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: current_code should NOT be present\n    assert!(!json.contains(\"\\\"current_code\\\"\"),\n            \"current_code should be excluded when include_code=false\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_include_code_false",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_include_code_false\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":168,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_include_code_false:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:168-185",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_level1_include_code_flag() {\n        // Arrange\n        let entities = vec![create_test_entity()];\n        let db = MockDatabase { entities };\n\n        // Test with include_code = true\n        let config_with_code = ExportConfig {\n            level: 1,\n            include_code: true,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level1Exporter::new();\n        let output = exporter.export(&db, &config_with_code).await.unwrap();\n        let json = serde_json::to_string(&output).unwrap();\n\n        // Should contain current_code\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"pub fn test()\"));\n\n        // Test with include_code = false\n        let db2 = MockDatabase {\n            entities: vec![create_test_entity()],\n        };\n        let config_no_code = ExportConfig {\n            level: 1,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let output2 = exporter.export(&db2, &config_no_code).await.unwrap();\n        let json2 = serde_json::to_string(&output2).unwrap();\n\n        // Should NOT contain current_code (null-skipped)\n        assert!(!json2.contains(\"\\\"current_code\\\"\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_include_code_flag",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_include_code_flag\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":300,\"end\":345},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_include_code_flag:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:300-345",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_include_code_true() {\n    // Arrange\n    let entities = vec![create_test_entity(\"rust:fn:test:src_lib_rs:10\", false)];\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(true, \"ALL\");  // include_code = true\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: current_code should be present\n    assert!(json.contains(\"\\\"current_code\\\"\"),\n            \"current_code should be included when include_code=true\");\n    assert!(json.contains(\"pub fn original\"),\n            \"current_code content should be present\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_include_code_true",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_include_code_true\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":188,\"end\":207},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_include_code_true:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:188-207",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_interface_signature_present() {\n    // Arrange\n    let entities = vec![create_test_entity(\"rust:fn:test:src_lib_rs:10\", false)];\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: interface_signature is core Level 1 field\n    assert!(json.contains(\"\\\"interface_signature\\\"\"));\n    assert!(json.contains(\"pub fn test_function() -> Result<()>\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_interface_signature_present",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_interface_signature_present\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":269,\"end\":286},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_interface_signature_present:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:269-286",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_metadata_accuracy() {\n    // Arrange\n    let entities = vec![\n        create_test_entity(\"rust:fn:test1:src_lib_rs:10\", false),\n        create_test_entity(\"rust:fn:test2:src_lib_rs:20\", false),\n        create_test_entity(\"rust:fn:test3:src_lib_rs:30\", false),\n    ];\n\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(true, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert metadata fields\n    assert_eq!(output.export_metadata.level, 1);\n    assert_eq!(output.export_metadata.total_entities, Some(3));\n    assert_eq!(output.export_metadata.include_code, Some(true));\n    assert_eq!(output.export_metadata.where_filter, \"ALL\");\n    assert!(output.export_metadata.timestamp.contains(\"T\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_metadata_accuracy",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_metadata_accuracy\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":522,\"end\":546},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_metadata_accuracy:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:522-546",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_null_skipping_token_savings() {\n    // Arrange: Entity with many null fields\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", false);\n    entity.future_action = None;\n    entity.future_code = None;\n    entity.doc_comment = None;\n    entity.forward_deps = vec![];\n    entity.reverse_deps = vec![];\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: Null/empty fields should be skipped\n    assert!(!json.contains(\"\\\"future_action\\\"\"), \"Null future_action should be skipped\");\n    assert!(!json.contains(\"\\\"future_code\\\"\"), \"Null future_code should be skipped\");\n    assert!(!json.contains(\"\\\"doc_comment\\\"\"), \"Null doc_comment should be skipped\");\n    assert!(!json.contains(\"\\\"forward_deps\\\"\"), \"Empty forward_deps should be skipped\");\n    assert!(!json.contains(\"\\\"reverse_deps\\\"\"), \"Empty reverse_deps should be skipped\");\n\n    // Verify this reduces token count\n    assert!(json.len() < 500, \"Null-skipping should keep JSON compact\");\n}",
      "current_ind": 1,
      "entity_name": "test_level1_null_skipping_token_savings",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_null_skipping_token_savings\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":477,\"end\":506},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_null_skipping_token_savings:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:477-506",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_reverse_deps_array() {\n    // Arrange\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", false);\n    entity.reverse_deps = vec![\n        \"rust:fn:caller1:src_main_rs:10\".to_string(),\n        \"rust:fn:caller2:src_api_rs:20\".to_string(),\n    ];\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"rust:fn:caller1:src_main_rs:10\"));\n    assert!(json.contains(\"rust:fn:caller2:src_api_rs:20\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_reverse_deps_array",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_reverse_deps_array\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":342,\"end\":364},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_reverse_deps_array:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:342-364",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level1_signatures_only() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 1);\n        assert_eq!(config.include_code, false);  // 0 = signatures only\n        assert_eq!(config.where_filter, \"ALL\");\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_signatures_only",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_signatures_only\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":218,\"end\":230},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_signatures_only:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:218-230",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_temporal_state_fields() {\n    // Arrange\n    let mut entity = create_test_entity(\"rust:fn:test:src_lib_rs:10\", true);\n    entity.current_ind = 1;\n    entity.future_ind = 1;\n    entity.future_action = Some(\"Edit\".to_string());\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All temporal fields present\n    assert!(json.contains(\"\\\"current_ind\\\":1\") || json.contains(\"\\\"current_ind\\\": 1\"));\n    assert!(json.contains(\"\\\"future_ind\\\":1\") || json.contains(\"\\\"future_ind\\\": 1\"));\n    assert!(json.contains(\"\\\"future_action\\\":\\\"Edit\\\"\") || json.contains(\"\\\"future_action\\\": \\\"Edit\\\"\"));\n    assert!(json.contains(\"\\\"future_code\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_temporal_state_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_temporal_state_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":239,\"end\":262},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_temporal_state_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:239-262",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_where_clause_filter_public() {\n    // Arrange: 3 entities - 2 public, 1 private\n    let mut entity1 = create_test_entity(\"rust:fn:public1:src_lib_rs:10\", false);\n    entity1.is_public = Some(true);\n\n    let mut entity2 = create_test_entity(\"rust:fn:private:src_lib_rs:20\", false);\n    entity2.is_public = Some(false);\n\n    let mut entity3 = create_test_entity(\"rust:fn:public2:src_lib_rs:30\", false);\n    entity3.is_public = Some(true);\n\n    let db = MockDatabase::with_entities(vec![entity1, entity2, entity3]);\n    let config = create_test_config(false, \"is_public = true\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Only 2 public entities\n    assert_eq!(output.export_metadata.total_entities, Some(2));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_where_clause_filter_public",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_where_clause_filter_public\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":424,\"end\":447},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_where_clause_filter_public:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:424-447",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level1_where_clause_future_action() {\n    // Arrange: 3 entities - 1 with future_action, 2 without\n    let entities = vec![\n        create_test_entity(\"rust:fn:unchanged1:src_lib_rs:10\", false),\n        create_test_entity(\"rust:fn:changed:src_lib_rs:20\", true),\n        create_test_entity(\"rust:fn:unchanged2:src_lib_rs:30\", false),\n    ];\n\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"future_action != null\");\n    let exporter = Level1Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert: Only 1 entity with future_action\n    assert_eq!(output.export_metadata.total_entities, Some(1));\n}",
      "current_ind": 1,
      "entity_name": "test_level1_where_clause_future_action",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_where_clause_future_action\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":450,\"end\":470},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_where_clause_future_action:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:450-470",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level1_with_code() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"1\",\n            \"--where-clause\", \"future_action != null\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 1);\n        assert_eq!(config.include_code, true);  // 1 = with code\n        assert_eq!(config.where_filter, \"future_action != null\");\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_with_code",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_with_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":233,\"end\":245},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_with_code:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:233-245",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level1_without_include_code_fails() {\n        // This should fail at clap parsing level due to required_if_eq\n        let result = Cli::try_parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        assert!(result.is_err());\n    }",
      "current_ind": 1,
      "entity_name": "test_level1_without_include_code_fails",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level1_without_include_code_fails\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":206,\"end\":215},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level1_without_include_code_fails:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:206-215",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_async_function() {\n    // Arrange\n    let mut entity = create_typed_entity(\"rust:fn:async_test:src_lib_rs:10\");\n    entity.is_async = Some(true);\n    entity.interface_signature = \"pub async fn async_test() -> Result<()>\".to_string();\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"\\\"is_async\\\":true\") || json.contains(\"\\\"is_async\\\": true\"));\n    assert!(json.contains(\"async fn async_test\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_async_function",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_async_function\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":229,\"end\":249},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_async_function:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:229-249",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_empty_type_arrays_skipped() {\n    // Arrange: Entity with empty type arrays\n    let mut entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    entity.param_types = Some(vec![]);\n    entity.param_names = Some(vec![]);\n    entity.generic_constraints = Some(vec![]);\n    entity.trait_impls = Some(vec![]);\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: Empty arrays should be skipped\n    // Note: We have Some(vec![]) which may or may not be skipped depending on serde config\n    // This test verifies the behavior\n    let json_compact = json.replace(\" \", \"\").replace(\"\\n\", \"\");\n\n    // Empty arrays should either be skipped OR be []\n    if json_compact.contains(\"param_types\") {\n        assert!(json_compact.contains(\"\\\"param_types\\\":[]\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_level2_empty_type_arrays_skipped",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_empty_type_arrays_skipped\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":312,\"end\":340},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_empty_type_arrays_skipped:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:312-340",
      "line_number": 0
    },
    {
      "current_code": "fn test_level2_entity_struct_clone() {\n    // Test that EntityExportLevel2 implements Clone\n    let entity = EntityExportLevel2 {\n        isgl1_key: \"test\".to_string(),\n        forward_deps: vec![],\n        reverse_deps: vec![],\n        current_ind: 1,\n        future_ind: 0,\n        future_action: None,\n        future_code: None,\n        current_code: None,\n        entity_name: \"test\".to_string(),\n        entity_type: \"fn\".to_string(),\n        file_path: \"test.rs\".to_string(),\n        line_number: 10,\n        interface_signature: \"pub fn test()\".to_string(),\n        doc_comment: None,\n        // Level 2 fields\n        return_type: Some(\"()\".to_string()),\n        param_types: vec![],\n        param_names: vec![],\n        generic_constraints: vec![],\n        trait_impls: vec![],\n        is_public: true,\n        is_async: false,\n        is_unsafe: false,\n    };\n\n    let cloned = entity.clone();\n    assert_eq!(cloned.isgl1_key, \"test\");\n    assert_eq!(cloned.return_type, Some(\"()\".to_string()));\n    assert_eq!(cloned.is_public, true);\n}",
      "current_ind": 1,
      "entity_name": "test_level2_entity_struct_clone",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_entity_struct_clone\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":414,\"end\":446},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_entity_struct_clone:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:414-446",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_export_metadata() {\n    // Arrange\n    let entities = vec![\n        create_typed_entity(\"rust:fn:test1:src_lib_rs:10\"),\n        create_typed_entity(\"rust:fn:test2:src_lib_rs:20\"),\n    ];\n\n    let db = MockDatabase::with_entities(entities);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n\n    // Assert\n    assert_eq!(output.export_metadata.level, 2);\n    assert_eq!(output.export_metadata.total_entities, Some(2));\n    assert_eq!(output.export_metadata.include_code, Some(false));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_export_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_export_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":386,\"end\":407},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_export_metadata:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:386-407",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_level2_exporter_basic() {\n        // Arrange\n        let entities = vec![create_test_entity_with_types()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 2,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level2Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 2);\n        assert_eq!(output.export_metadata.total_entities, Some(1));\n        assert!(output.entities.is_some());\n        assert!(output.edges.is_none());\n    }",
      "current_ind": 1,
      "entity_name": "test_level2_exporter_basic",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_exporter_basic\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":242,\"end\":271},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_exporter_basic:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:242-271",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level2_exporter_metadata() {\n        let exporter = Level2Exporter::new();\n        assert_eq!(exporter.level(), 2);\n        assert_eq!(exporter.estimated_tokens(), 60_000);\n    }",
      "current_ind": 1,
      "entity_name": "test_level2_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":306,\"end\":310},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:306-310",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_exporter_metadata() {\n    let exporter = Level2Exporter::new();\n\n    // Assert\n    assert_eq!(exporter.level(), 2);\n    assert_eq!(exporter.estimated_tokens(), 60_000);\n}",
      "current_ind": 1,
      "entity_name": "test_level2_exporter_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_exporter_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":377,\"end\":383},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_exporter_metadata:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:377-383",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_filter_async_functions() {\n    // Arrange: Mix of async and sync functions\n    let mut entity1 = create_typed_entity(\"rust:fn:async_fn:src_lib_rs:10\");\n    entity1.is_async = Some(true);\n\n    let mut entity2 = create_typed_entity(\"rust:fn:sync_fn:src_lib_rs:20\");\n    entity2.is_async = Some(false);\n\n    let db = MockDatabase::with_entities(vec![entity1, entity2]);\n    let config = create_test_config(false, \"is_async = true\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    // Note: This test validates the WHERE clause format, actual filtering\n    // happens in Phase 3 implementation\n}",
      "current_ind": 1,
      "entity_name": "test_level2_filter_async_functions",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_filter_async_functions\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":453,\"end\":471},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_filter_async_functions:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:453-471",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_filter_public_functions() {\n    // Arrange\n    let mut entity1 = create_typed_entity(\"rust:fn:public_fn:src_lib_rs:10\");\n    entity1.is_public = Some(true);\n\n    let mut entity2 = create_typed_entity(\"rust:fn:private_fn:src_lib_rs:20\");\n    entity2.is_public = Some(false);\n\n    let db = MockDatabase::with_entities(vec![entity1, entity2]);\n    let config = create_test_config(false, \"is_public = true\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n}",
      "current_ind": 1,
      "entity_name": "test_level2_filter_public_functions",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_filter_public_functions\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":474,\"end\":489},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_filter_public_functions:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:474-489",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_generic_constraints() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"\\\"generic_constraints\\\"\"));\n    assert!(json.contains(\"\\\"T: Clone\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_generic_constraints",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_generic_constraints\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":163,\"end\":180},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_generic_constraints:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:163-180",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_includes_level1_fields() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All Level 1 fields still present\n    assert!(json.contains(\"\\\"isgl1_key\\\"\"));\n    assert!(json.contains(\"\\\"current_ind\\\"\"));\n    assert!(json.contains(\"\\\"future_ind\\\"\"));\n    assert!(json.contains(\"\\\"entity_name\\\"\"));\n    assert!(json.contains(\"\\\"entity_type\\\"\"));\n    assert!(json.contains(\"\\\"file_path\\\"\"));\n    assert!(json.contains(\"\\\"line_number\\\"\"));\n    assert!(json.contains(\"\\\"interface_signature\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_includes_level1_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_includes_level1_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":347,\"end\":370},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_includes_level1_fields:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:347-370",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_null_type_fields_skipped() {\n    // Arrange: Entity without type information\n    let mut entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    entity.return_type = None;\n    entity.param_types = None;\n    entity.param_names = None;\n    entity.generic_constraints = None;\n    entity.trait_impls = None;\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: Null type fields should be skipped\n    assert!(!json.contains(\"\\\"return_type\\\"\"),\n            \"Null return_type should be skipped\");\n    assert!(!json.contains(\"\\\"param_types\\\"\"),\n            \"Null param_types should be skipped\");\n    assert!(!json.contains(\"\\\"param_names\\\"\"),\n            \"Null param_names should be skipped\");\n    assert!(!json.contains(\"\\\"generic_constraints\\\"\"),\n            \"Null generic_constraints should be skipped\");\n    assert!(!json.contains(\"\\\"trait_impls\\\"\"),\n            \"Null trait_impls should be skipped\");\n}",
      "current_ind": 1,
      "entity_name": "test_level2_null_type_fields_skipped",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_null_type_fields_skipped\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":278,\"end\":309},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_null_type_fields_skipped:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:278-309",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_param_types_and_names() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: param_types and param_names are parallel arrays\n    assert!(json.contains(\"\\\"param_types\\\"\"));\n    assert!(json.contains(\"\\\"&str\\\"\"));\n    assert!(json.contains(\"\\\"i32\\\"\"));\n\n    assert!(json.contains(\"\\\"param_names\\\"\"));\n    assert!(json.contains(\"\\\"name\\\"\"));\n    assert!(json.contains(\"\\\"count\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_param_types_and_names",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_param_types_and_names\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":138,\"end\":160},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_param_types_and_names:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:138-160",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_return_type() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"\\\"return_type\\\":\\\"Result<()>\\\"\") || json.contains(\"\\\"return_type\\\": \\\"Result<()>\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_return_type",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_return_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":119,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_return_type:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:119-135",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_safety_flags() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert: All safety flags present\n    assert!(json.contains(\"\\\"is_public\\\":true\") || json.contains(\"\\\"is_public\\\": true\"));\n    assert!(json.contains(\"\\\"is_async\\\":false\") || json.contains(\"\\\"is_async\\\": false\"));\n    assert!(json.contains(\"\\\"is_unsafe\\\":false\") || json.contains(\"\\\"is_unsafe\\\": false\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_safety_flags",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_safety_flags\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":208,\"end\":226},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_safety_flags:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:208-226",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_trait_impls() {\n    // Arrange\n    let entity = create_typed_entity(\"rust:fn:test:src_lib_rs:10\");\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"\\\"trait_impls\\\"\"));\n    assert!(json.contains(\"\\\"Debug\\\"\"));\n    assert!(json.contains(\"\\\"Clone\\\"\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_trait_impls",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_trait_impls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":183,\"end\":201},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_trait_impls:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:183-201",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_level2_type_system_fields() {\n        // Arrange\n        let entities = vec![create_test_entity_with_types()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 2,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level2Exporter::new();\n\n        // Act\n        let output = exporter.export(&db, &config).await.unwrap();\n        let json = serde_json::to_string(&output).unwrap();\n\n        // Assert: Type system fields present\n        assert!(json.contains(\"\\\"return_type\\\"\"));\n        assert!(json.contains(\"Result<()>\"));\n        assert!(json.contains(\"\\\"param_types\\\"\"));\n        assert!(json.contains(\"\\\"&str\\\"\"));\n        assert!(json.contains(\"\\\"is_async\\\"\"));\n        assert!(json.contains(\"\\\"is_public\\\"\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_level2_type_system_fields",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_type_system_fields\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":274,\"end\":303},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_type_system_fields:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:274-303",
      "line_number": 0
    },
    {
      "current_code": "async fn test_level2_unsafe_function() {\n    // Arrange\n    let mut entity = create_typed_entity(\"rust:fn:unsafe_test:src_lib_rs:10\");\n    entity.is_unsafe = Some(true);\n    entity.interface_signature = \"pub unsafe fn unsafe_test()\".to_string();\n\n    let db = MockDatabase::with_entities(vec![entity]);\n    let config = create_test_config(false, \"ALL\");\n    let exporter = Level2Exporter::new();\n\n    // Act\n    let result = exporter.export(&db, &config).await;\n    assert!(result.is_ok());\n\n    let output = result.unwrap();\n    let json = serde_json::to_string(&output).unwrap();\n\n    // Assert\n    assert!(json.contains(\"\\\"is_unsafe\\\":true\") || json.contains(\"\\\"is_unsafe\\\": true\"));\n}",
      "current_ind": 1,
      "entity_name": "test_level2_unsafe_function",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_unsafe_function\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":252,\"end\":271},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_unsafe_function:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:252-271",
      "line_number": 0
    },
    {
      "current_code": "    fn test_level2_with_complex_where() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"2\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"is_public = true, entity_type = 'fn', is_async = true\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 2);\n        assert_eq!(config.include_code, false);\n        assert!(config.where_filter.contains(\"is_public = true\"));\n        assert!(config.where_filter.contains(\"entity_type = 'fn'\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_level2_with_complex_where",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_level2_with_complex_where\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":248,\"end\":261},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_level2_with_complex_where:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:248-261",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_main_with_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"**/*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        let stream_result = result.unwrap();\n        assert_eq!(stream_result.total_files, 0);\n        assert_eq!(stream_result.processed_files, 0);\n        assert_eq!(stream_result.entities_created, 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_main_with_empty_directory",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_main_with_empty_directory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/main.rs\",\"line_range\":{\"start\":157,\"end\":177},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_main_with_empty_directory:__crates_pt01-folder-to-cozodb-streamer_src_main_rs:157-177",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_main_with_valid_directory() {\n        // Create temporary directory with test files\n        let temp_dir = TempDir::new().unwrap();\n        let test_file_path = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file_path,\n            r#\"fn test_function() {\n    println!(\"Hello, world!\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Verify file was created\n        assert!(test_file_path.exists(), \"Test file should exist\");\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()], // Simplified pattern\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        // Verify entities were actually created\n        let stream_result = result.unwrap();\n        assert!(stream_result.total_files > 0, \"Should have found at least one file\");\n        assert!(stream_result.entities_created > 0, \"Should have created at least one entity\");\n    }",
      "current_ind": 1,
      "entity_name": "test_main_with_valid_directory",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_main_with_valid_directory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/main.rs\",\"line_range\":{\"start\":121,\"end\":154},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_main_with_valid_directory:__crates_pt01-folder-to-cozodb-streamer_src_main_rs:121-154",
      "line_number": 0
    },
    {
      "current_code": "fn test_malformed_code_no_panic() {\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let broken_code = \"fn main( { println!(\\\"broken\\\";\";\n\n    // Should not panic, may return Ok with partial entities or Err\n    let result = extractor.parse_source(broken_code, Path::new(\"test.rs\"), Language::Rust);\n    // Just verify no panic - result can be Ok or Err\n    let _ = result;\n}",
      "current_ind": 1,
      "entity_name": "test_malformed_code_no_panic",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_malformed_code_no_panic\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":119,\"end\":127},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_malformed_code_no_panic:__crates_parseltongue-core_tests_query_based_extraction_test_rs:119-127",
      "line_number": 0
    },
    {
      "current_code": "    fn test_missing_dependency_target_error() {\n        let error = ParseltongError::MissingDependencyTarget {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:nonexistent:src_helper_rs:5-20\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency target not found\"));\n        assert!(formatted.contains(\"rust:fn:nonexistent:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"referenced from\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_missing_dependency_target_error",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_missing_dependency_target_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":247,\"end\":258},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_missing_dependency_target_error:__crates_parseltongue-core_src_error_rs:247-258",
      "line_number": 0
    },
    {
      "current_code": "async fn test_mixed_operations_diff() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Create\n    let create = create_test_entity(\n        \"src_lib_rs-new_func-fn-xyz789\",\n        Some(\"fn new_func() {}\"),\n        TemporalAction::Create,\n    );\n\n    // Edit\n    let edit = create_test_entity(\n        \"rust:fn:existing:src_lib_rs:50-60\",\n        Some(\"fn existing() { /* updated */ }\"),\n        TemporalAction::Edit,\n    );\n\n    // Delete\n    let mut delete = create_test_entity(\n        \"rust:fn:old:src_lib_rs:70-80\",\n        None,\n        TemporalAction::Delete,\n    );\n    delete.future_code = None;\n\n    storage.insert_entity(&create).await.unwrap();\n    storage.insert_entity(&edit).await.unwrap();\n    storage.insert_entity(&delete).await.unwrap();\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    assert_eq!(diff.changes.len(), 3);\n    assert_eq!(diff.metadata.create_count, 1);\n    assert_eq!(diff.metadata.edit_count, 1);\n    assert_eq!(diff.metadata.delete_count, 1);\n}",
      "current_ind": 1,
      "entity_name": "test_mixed_operations_diff",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_mixed_operations_diff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":145,\"end\":186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_mixed_operations_diff:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:145-186",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_mock_client_returns_configured_response() {\n        let mut mock_client = MockRustAnalyzerClient::new();\n        let test_response = HoverResponse {\n            contents: \"fn test() -> i32\".to_string(),\n            raw_metadata: serde_json::json!({\n                \"type_info\": {\n                    \"resolved_type\": \"i32\"\n                }\n            }),\n        };\n\n        mock_client.add_response(\n            \"test.rs:10:5\".to_string(),\n            test_response.clone(),\n        );\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_some());\n        let response = result.unwrap();\n        assert_eq!(response.contents, \"fn test() -> i32\");\n    }",
      "current_ind": 1,
      "entity_name": "test_mock_client_returns_configured_response",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_mock_client_returns_configured_response\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":142,\"end\":166},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_mock_client_returns_configured_response:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:142-166",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_mock_client_returns_none_for_unconfigured_position() {\n        let mock_client = MockRustAnalyzerClient::new();\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 99, 99)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
      "current_ind": 1,
      "entity_name": "test_mock_client_returns_none_for_unconfigured_position",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_mock_client_returns_none_for_unconfigured_position\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":169,\"end\":178},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_mock_client_returns_none_for_unconfigured_position:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:169-178",
      "line_number": 0
    },
    {
      "current_code": "    fn test_mock_exporter_level() {\n        let exporter = MockExporter { level: 0, tokens: 5000 };\n        assert_eq!(exporter.level(), 0);\n        assert_eq!(exporter.estimated_tokens(), 5000);\n    }",
      "current_ind": 1,
      "entity_name": "test_mock_exporter_level",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_mock_exporter_level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":181,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_mock_exporter_level:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:181-185",
      "line_number": 0
    },
    {
      "current_code": "fn test_multi_language_performance_parity() {\n    use std::time::Instant;\n\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    // Generate 100 lines of Ruby code\n    let ruby_code: String = (0..100)\n        .map(|i| format!(\"  def method_{i}()\\n    puts 'test'\\n  end\\n\", i = i))\n        .collect::<Vec<_>>()\n        .join(\"\\n\");\n    let ruby_code = format!(\"class TestClass\\n{}\\nend\", ruby_code);\n\n    let start = Instant::now();\n    let (entities, _) = generator.parse_source(&ruby_code, Path::new(\"test.rb\"))\n        .expect(\"Should parse Ruby\");\n    let elapsed = start.elapsed();\n\n    // Performance contract: <150ms for 100 LOC (scales to <1500ms for 1K LOC)\n    // Note: Ruby parser + dependency queries add overhead, adjusted from 100ms\n    assert!(\n        elapsed.as_millis() < 150,\n        \"Ruby extraction too slow: {:?} for 100 LOC\",\n        elapsed\n    );\n\n    // RED: Currently entities.len() == 0, so can't verify performance\n    // GREEN: Once extraction works, verify entity count matches expectations\n    if !entities.is_empty() {\n        assert!(entities.len() >= 100, \"Should extract ~100 method entities\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_multi_language_performance_parity",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_multi_language_performance_parity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":281,\"end\":311},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_multi_language_performance_parity:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:281-311",
      "line_number": 0
    },
    {
      "current_code": "    fn test_multiple_exclusion_patterns_contract() {\n        // Given: Multiple exclusion patterns\n        let patterns = vec![\".ref\".to_string(), \"archive\".to_string(), \"tmp\".to_string()];\n        \n        // When: Checking various paths\n        let ref_path = PathBuf::from(\".ref/tool-semgrep\");\n        let archive_path = PathBuf::from(\"archive/old-project\");\n        let tmp_path = PathBuf::from(\"tmp/cache\");\n        let src_path = PathBuf::from(\"src/main.rs\");\n        \n        // Then: Correct exclusion decisions\n        assert!(should_exclude_path(&ref_path, &patterns));      // .ref excluded\n        assert!(should_exclude_path(&archive_path, &patterns));  // archive excluded\n        assert!(should_exclude_path(&tmp_path, &patterns));      // tmp excluded\n        assert!(!should_exclude_path(&src_path, &patterns));     // src included\n    }",
      "current_ind": 1,
      "entity_name": "test_multiple_exclusion_patterns_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_multiple_exclusion_patterns_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":55,\"end\":70},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_multiple_exclusion_patterns_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:55-70",
      "line_number": 0
    },
    {
      "current_code": "fn test_multiple_languages_basic_parsing() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    // Test that various languages can parse simple code\n    // Note: Kotlin is excluded - tree-sitter-kotlin v0.3 uses incompatible tree-sitter 0.20\n    let test_cases = vec![\n        (\"test.rs\", \"fn hello() {}\", \"Rust\"),\n        (\"test.py\", \"def hello():\\n    pass\", \"Python\"),\n        (\"test.js\", \"function hello() {}\", \"JavaScript\"),\n        (\"test.ts\", \"function hello() {}\", \"TypeScript\"),\n        (\"test.go\", \"func hello() {}\", \"Go\"),\n        (\"test.java\", \"class Test { void hello() {} }\", \"Java\"),\n        (\"test.cpp\", \"void hello() {}\", \"C++\"),\n        (\"test.rb\", \"def hello\\nend\", \"Ruby\"),\n        (\"test.php\", \"<?php function hello() {} ?>\", \"PHP\"),\n        (\"test.cs\", \"void Hello() {}\", \"C#\"),\n        (\"test.swift\", \"func hello() {}\", \"Swift\"),\n        (\"test.scala\", \"def hello() = {}\", \"Scala\"),\n    ];\n\n    for (filename, code, lang_name) in test_cases {\n        let path = Path::new(filename);\n        let result = generator.parse_source(code, path);\n\n        assert!(\n            result.is_ok(),\n            \"{} parser should initialize and parse basic code (got error: {:?})\",\n            lang_name,\n            result.err()\n        );\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_multiple_languages_basic_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_multiple_languages_basic_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs\",\"line_range\":{\"start\":61,\"end\":92},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_multiple_languages_basic_parsing:__crates_pt01-folder-to-cozodb-streamer_tests_tree_sitter_api_compatibility_test_rs:61-92",
      "line_number": 0
    },
    {
      "current_code": "fn test_multiple_valid_entities() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct User {\n            pub name: String,\n            pub age: u32,\n        }\n\n        impl User {\n            pub fn new(name: String, age: u32) -> Self {\n                Self { name, age }\n            }\n\n            pub fn greet(&self) -> String {\n                format!(\"Hello, I'm {}\", self.name)\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Multiple valid entities should pass\");\n    assert!(result.errors.is_empty());\n}",
      "current_ind": 1,
      "entity_name": "test_multiple_valid_entities",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_multiple_valid_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":93,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_multiple_valid_entities:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:93-116",
      "line_number": 0
    },
    {
      "current_code": "async fn test_nested_call_in_struct_construction() {\n    let source = r#\"\nstruct Config {\n    settings: HashMap<String, String>,\n}\n\nimpl Config {\n    fn new() -> Self {\n        Self {\n            settings: create_defaults(),\n        }\n    }\n}\n\nfn create_defaults() -> HashMap<String, String> {\n    HashMap::new()\n}\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Nested Call in Struct Construction ===\");\n    print_dependencies(&deps);\n\n    // Verify the call is captured\n    assert!(\n        has_call(&deps, \"create_defaults\"),\n        \"Should capture create_defaults() call in struct construction\"\n    );\n\n    // Document current attribution behavior\n    let source_entity = find_call_source(&deps, \"create_defaults\");\n    println!(\"Attribution: {:?}\", source_entity);\n    println!(\"Note: Currently attributed to impl:Config, will be method:new after enhancement\");\n}",
      "current_ind": 1,
      "entity_name": "test_nested_call_in_struct_construction",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_nested_call_in_struct_construction\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":17,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_nested_call_in_struct_construction:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:17-51",
      "line_number": 0
    },
    {
      "current_code": "    fn test_nested_git_repo_detection_contract() {\n        // Given: Create a temporary directory structure for testing\n        let temp_dir = tempfile::tempdir().unwrap();\n        let project_root = temp_dir.path();\n        \n        // Create nested structure with .git\n        let nested_dir = project_root.join(\".ref\").join(\"tool-semgrep\");\n        std::fs::create_dir_all(&nested_dir).unwrap();\n        let nested_git = nested_dir.join(\".git\");\n        std::fs::create_dir(&nested_git).unwrap();\n        \n        let test_file = nested_dir.join(\"some_file.rs\");\n        \n        // When: Checking if test_file is under git subdirectory\n        let is_nested = is_under_git_subdirectory(&test_file, project_root);\n        \n        // Then: Should detect as nested git repo\n        assert!(is_nested, \"Should detect nested git repository\");\n    }",
      "current_ind": 1,
      "entity_name": "test_nested_git_repo_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_nested_git_repo_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":128,\"end\":146},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_nested_git_repo_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:128-146",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/file.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"old content\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-file-rs-Func\",\n            Some(\"new content\".to_string()),\n            TemporalState::edit(),\n        );\n\n        writer.write_entity(&entity).await.unwrap();\n\n        // Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path().join(\"src\"))\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(!name_str.ends_with(\".bak\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".backup\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\"~\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".old\"), \"Found backup file: {}\", name_str);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_no_backup_files_created",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_no_backup_files_created\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":241,\"end\":275},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_no_backup_files_created:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:241-275",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        let _result = manager.reset(&project_path).await;\n\n        // Postcondition: Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path())\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(\n                !name_str.contains(\".backup\"),\n                \"Found backup file: {}\",\n                name_str\n            );\n            assert!(\n                !name_str.contains(\".snapshot\"),\n                \"Found snapshot file: {}\",\n                name_str\n            );\n            assert!(!name_str.contains(\".meta\"), \"Found metadata file: {}\", name_str);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_no_backup_files_created",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_no_backup_files_created\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":202,\"end\":233},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_no_backup_files_created:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:202-233",
      "line_number": 0
    },
    {
      "current_code": "    fn test_no_dependencies_when_no_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    let x = 42;\n    println!(\"{}\", x);\n}\n\nfn helper() {\n    // No calls to other local functions\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities\n        assert_eq!(entities.len(), 2);\n\n        // No dependencies to LOCAL functions (println! is external macro, ignored for MVP)\n        assert_eq!(dependencies.len(), 0, \"Expected no dependencies to local functions\");\n    }",
      "current_ind": 1,
      "entity_name": "test_no_dependencies_when_no_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_no_dependencies_when_no_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":576,\"end\":597},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_no_dependencies_when_no_calls:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:576-597",
      "line_number": 0
    },
    {
      "current_code": "    fn test_no_exclusion_patterns_default() {\n        // Test that defaults work when no -e flags specified\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"./src\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        \n        // Should have only default patterns\n        assert_eq!(config.exclude_patterns.len(), 8);\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert!(!config.exclude_patterns.contains(&\".ref\".to_string()));\n    }",
      "current_ind": 1,
      "entity_name": "test_no_exclusion_patterns_default",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_no_exclusion_patterns_default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":250,\"end\":268},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_no_exclusion_patterns_default:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:250-268",
      "line_number": 0
    },
    {
      "current_code": "    fn test_operation_counts() {\n        let mut diff = CodeDiff::new();\n\n        // Add create\n        diff.add_change(Change {\n            isgl1_key: \"create-key\".to_string(),\n            file_path: PathBuf::from(\"src/new.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn new() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn new()\".to_string(),\n        });\n\n        // Add edit\n        diff.add_change(Change {\n            isgl1_key: \"edit-key\".to_string(),\n            file_path: PathBuf::from(\"src/old.rs\"),\n            operation: Operation::Edit,\n            current_code: Some(\"fn old() {}\".to_string()),\n            future_code: Some(\"fn updated() {}\".to_string()),\n            line_range: Some(LineRange { start: 10, end: 20 }),\n            interface_signature: \"fn updated()\".to_string(),\n        });\n\n        // Add delete\n        diff.add_change(Change {\n            isgl1_key: \"delete-key\".to_string(),\n            file_path: PathBuf::from(\"src/gone.rs\"),\n            operation: Operation::Delete,\n            current_code: Some(\"fn gone() {}\".to_string()),\n            future_code: None,\n            line_range: Some(LineRange { start: 30, end: 40 }),\n            interface_signature: \"fn gone()\".to_string(),\n        });\n\n        assert_eq!(diff.metadata.total_changes, 3);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 1);\n        assert_eq!(diff.metadata.delete_count, 1);\n    }",
      "current_ind": 1,
      "entity_name": "test_operation_counts",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_operation_counts\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":202,\"end\":242},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_operation_counts:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:202-242",
      "line_number": 0
    },
    {
      "current_code": "    fn test_output_path_custom() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n            \"--output\", \"custom.json\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.output_path, PathBuf::from(\"custom.json\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_output_path_custom",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_output_path_custom\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":277,\"end\":288},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_output_path_custom:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:277-288",
      "line_number": 0
    },
    {
      "current_code": "    fn test_output_path_default() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.output_path, PathBuf::from(\"ISGLevel01.json\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_output_path_default",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_output_path_default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":264,\"end\":274},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_output_path_default:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:264-274",
      "line_number": 0
    },
    {
      "current_code": "    fn test_parse_entity_name() {\n        assert_eq!(\n            parse_entity_name_from_key(\"rust:fn:main:src_main_rs:1\"),\n            \"main\"\n        );\n    }",
      "current_ind": 1,
      "entity_name": "test_parse_entity_name",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_parse_entity_name\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":269,\"end\":274},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_parse_entity_name:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:269-274",
      "line_number": 0
    },
    {
      "current_code": "    fn test_parse_line_number() {\n        assert_eq!(\n            parse_line_number_from_key(\"rust:fn:main:src_main_rs:42\"),\n            42\n        );\n    }",
      "current_ind": 1,
      "entity_name": "test_parse_line_number",
      "entity_type": "function",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_parse_line_number\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":277,\"end\":282},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_parse_line_number:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:277-282",
      "line_number": 0
    },
    {
      "current_code": "    fn test_parser_roundtrip() {\n        fn prop_roundtrip(ast: TestAst) -> bool {\n            let printed = ast.to_string();\n            let parsed = TestParser.parse(printed.clone());\n            match parsed {\n                Ok(parsed_ast) => parsed_ast == ast,\n                Err(_) => false,\n            }\n        }\n        \n        QuickCheck::new()\n            .tests(1000)\n            .quickcheck(prop_roundtrip as fn(TestAst) -> bool);\n    }",
      "current_ind": 1,
      "entity_name": "test_parser_roundtrip",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_parser_roundtrip\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1364,\"end\":1377},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_parser_roundtrip:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1364-1377",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pattern_matching_performance_contract() {\n        // Given: 100 exclusion patterns\n        let patterns: Vec<String> = (0..100)\n            .map(|i| format!(\"pattern_{}\", i))\n            .collect();\n        \n        let test_path = PathBuf::from(\"pattern_42/some_file.rs\");\n        \n        // When: Matching pattern\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            should_exclude_path(&test_path, &patterns);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<10s per check)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(10),\n                \"Pattern matching took {:?}, expected <10s\", avg_time_per_check);\n    }",
      "current_ind": 1,
      "entity_name": "test_pattern_matching_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pattern_matching_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":74,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pattern_matching_performance_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:74-93",
      "line_number": 0
    },
    {
      "current_code": "fn test_performance_contract_rust() {\n    use std::time::Instant;\n\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let code = generate_rust_code(1000); // 1K lines\n\n    let start = Instant::now();\n    let _ = extractor.parse_source(&code, Path::new(\"test.rs\"), Language::Rust).unwrap();\n    let elapsed = start.elapsed();\n\n    // Performance contract: <20ms in release, <100ms in debug builds\n    // Note: With 12 languages, parser initialization adds overhead in debug mode\n    let threshold_ms = if cfg!(debug_assertions) { 100 } else { 20 };\n\n    assert!(\n        elapsed.as_millis() < threshold_ms,\n        \"Parsing 1K LOC took {:?}, expected <{}ms ({})\",\n        elapsed,\n        threshold_ms,\n        if cfg!(debug_assertions) { \"debug mode\" } else { \"release mode\" }\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_performance_contract_rust",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_performance_contract_rust\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":94,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_performance_contract_rust:__crates_parseltongue-core_tests_query_based_extraction_test_rs:94-115",
      "line_number": 0
    },
    {
      "current_code": "    fn test_prd_command_format() {\n        // Test ultra-minimalist CLI (S01 principle)\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"folder-to-cozoDB-streamer\",\n            \"./src\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"./parseltongue.db\",\n        ]);\n\n        assert!(matches.is_ok(), \"Ultra-minimalist command should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"./src\"));\n        assert_eq!(config.db_path, \"./parseltongue.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist)\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }",
      "current_ind": 1,
      "entity_name": "test_prd_command_format",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_prd_command_format\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":195,\"end\":216},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_prd_command_format:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:195-216",
      "line_number": 0
    },
    {
      "current_code": "    fn test_project_root_git_not_excluded_contract() {\n        // Given: Create a temporary directory structure for testing\n        let temp_dir = tempfile::tempdir().unwrap();\n        let project_root = temp_dir.path();\n        \n        // Create project root .git\n        let project_git = project_root.join(\".git\");\n        std::fs::create_dir(&project_git).unwrap();\n        \n        let test_file = project_root.join(\"src/main.rs\");\n        \n        // When: Checking project root file\n        let is_nested = is_under_git_subdirectory(&test_file, project_root);\n        \n        // Then: Should NOT be considered nested (it's the main repo)\n        assert!(!is_nested, \"Project root .git should not be excluded\");\n    }",
      "current_ind": 1,
      "entity_name": "test_project_root_git_not_excluded_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_project_root_git_not_excluded_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":150,\"end\":166},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_project_root_git_not_excluded_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:150-166",
      "line_number": 0
    },
    {
      "current_code": "fn test_protocol_query_matching() {\n    let swift_code = r#\"\nprotocol Drawable {\n    func draw()\n}\n\"#;\n\n    let mut parser = Parser::new();\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n    parser.set_language(&swift_lang).unwrap();\n\n    let tree = parser.parse(swift_code, None).unwrap();\n\n    // Test just the protocol query\n    let protocol_query = r#\"\n(protocol_declaration\n  name: (type_identifier) @name) @definition.interface\n\"#;\n\n    println!(\"\\n=== Testing Protocol Query ===\");\n    println!(\"Query:\\n{}\", protocol_query);\n\n    match Query::new(&swift_lang, protocol_query) {\n        Ok(query) => {\n            println!(\" Protocol query compiled\");\n\n            let mut cursor = QueryCursor::new();\n            let mut matches = cursor.matches(&query, tree.root_node(), swift_code.as_bytes());\n\n            let mut match_count = 0;\n            while let Some(m) = matches.next() {\n                match_count += 1;\n                println!(\"\\nMatch #{}:\", match_count);\n                for capture in m.captures {\n                    let capture_name = &query.capture_names()[capture.index as usize];\n                    let text = &swift_code[capture.node.byte_range()];\n                    println!(\"  Capture '{}': {}\", capture_name, text.trim());\n                }\n            }\n\n            if match_count == 0 {\n                println!(\" No matches found!\");\n            }\n\n            assert!(match_count > 0, \"Protocol query should match\");\n        }\n        Err(e) => {\n            panic!(\" Protocol query compilation failed: {:?}\", e);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_protocol_query_matching",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_protocol_query_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_protocol_query_matching\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_protocol_query_test.rs\",\"line_range\":{\"start\":5,\"end\":55},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_protocol_query_matching:__crates_parseltongue-core_tests_swift_protocol_query_test_rs:5-55",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt01_classifies_production_code() {\n        // Arrange: Production file patterns\n        let prod_cases = vec![\n            (\"src/lib.rs\", \"pub fn main() {}\", EntityClass::CodeImplementation),\n            (\"src/utils/mod.rs\", \"pub mod utils\", EntityClass::CodeImplementation),\n            (\"src/main.rs\", \"fn main() {}\", EntityClass::CodeImplementation),\n            (\"src/core.rs\", \"struct Core {}\", EntityClass::CodeImplementation),\n        ];\n\n        // Act & Assert: Verify classification logic\n        for (file_path, _content, expected_class) in prod_cases {\n            // Simulate PT01 classification logic\n            let is_test_file = file_path.contains(\"test\") || \n                              file_path.starts_with(\"tests/\") || \n                              file_path.starts_with(\"test/\");\n            \n            let actual_class = if is_test_file {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            };\n\n            assert_eq!(actual_class, expected_class, \n                      \"File '{}' should be classified as {:?}\", file_path, expected_class);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_pt01_classifies_production_code",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt01_classifies_production_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":201,\"end\":226},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt01_classifies_production_code:__crates_parseltongue-core_src_entity_class_specifications_rs:201-226",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt01_classifies_test_files() {\n        // This test verifies the test detector can classify test files\n        // Actual PT01 integration is tested in pt01 crate\n        \n        // Arrange: Test file patterns\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn test_main() {}\", EntityClass::CodeImplementation),\n            (\"tests/integration_test.rs\", \"fn test_integration() {}\", EntityClass::TestImplementation),\n            (\"src/utils_test.rs\", \"fn test_utils() {}\", EntityClass::TestImplementation),\n            (\"test/unit_test.rs\", \"fn test_unit() {}\", EntityClass::TestImplementation),\n        ];\n\n        // Act & Assert: Verify classification logic\n        for (file_path, _content, expected_class) in test_cases {\n            // Simulate PT01 classification logic\n            let is_test_file = file_path.contains(\"test\") || \n                              file_path.starts_with(\"tests/\") || \n                              file_path.starts_with(\"test/\");\n            \n            let actual_class = if is_test_file {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            };\n\n            assert_eq!(actual_class, expected_class, \n                      \"File '{}' should be classified as {:?}\", file_path, expected_class);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_pt01_classifies_test_files",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt01_classifies_test_files\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":169,\"end\":197},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt01_classifies_test_files:__crates_parseltongue-core_src_entity_class_specifications_rs:169-197",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt02_dual_output_generation() {\n        // Arrange: Create mixed entities\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"code2.rs\", \"fn code2()\", EntityClass::CodeImplementation),\n        ];\n\n        // Act: Separate into code and test outputs (simulating PT02 dual output)\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::CodeImplementation)\n            .collect();\n        \n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::TestImplementation)\n            .collect();\n\n        // Assert: Proper separation for dual outputs\n        assert_eq!(code_entities.len(), 2, \"Code output should have 2 entities\");\n        assert_eq!(test_entities.len(), 1, \"Tests output should have 1 entity\");\n        \n        // Verify no overlap\n        let code_keys: std::collections::HashSet<_> = code_entities.iter()\n            .map(|e| &e.isgl1_key).collect();\n        let test_keys: std::collections::HashSet<_> = test_entities.iter()\n            .map(|e| &e.isgl1_key).collect();\n        \n        assert!(code_keys.intersection(&test_keys).next().is_none(), \n               \"Code and test outputs should not overlap\");\n    }",
      "current_ind": 1,
      "entity_name": "test_pt02_dual_output_generation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt02_dual_output_generation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":308,\"end\":337},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt02_dual_output_generation:__crates_parseltongue-core_src_entity_class_specifications_rs:308-337",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt02_filters_code_entities() {\n        // Arrange: Create entities with different classifications\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"code2.rs\", \"fn code2()\", EntityClass::CodeImplementation),\n        ];\n\n        // Act: Filter for code entities (simulating PT02 query)\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::CodeImplementation)\n            .collect();\n\n        // Assert: Only code entities returned\n        assert_eq!(code_entities.len(), 2, \"Should return 2 code entities\");\n        assert!(code_entities.iter().all(|e| e.entity_class == EntityClass::CodeImplementation));\n    }",
      "current_ind": 1,
      "entity_name": "test_pt02_filters_code_entities",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt02_filters_code_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":268,\"end\":284},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt02_filters_code_entities:__crates_parseltongue-core_src_entity_class_specifications_rs:268-284",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt02_filters_test_entities() {\n        // Arrange: Create entities with different classifications\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"test2.rs\", \"fn test2()\", EntityClass::TestImplementation),\n        ];\n\n        // Act: Filter for test entities (simulating PT02 query)\n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::TestImplementation)\n            .collect();\n\n        // Assert: Only test entities returned\n        assert_eq!(test_entities.len(), 2, \"Should return 2 test entities\");\n        assert!(test_entities.iter().all(|e| e.entity_class == EntityClass::TestImplementation));\n    }",
      "current_ind": 1,
      "entity_name": "test_pt02_filters_test_entities",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt02_filters_test_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":288,\"end\":304},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt02_filters_test_entities:__crates_parseltongue-core_src_entity_class_specifications_rs:288-304",
      "line_number": 0
    },
    {
      "current_code": "async fn test_pt02_level00_with_zero_dependencies_should_succeed() {\n    // Arrange: Create temp database and test file\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"zero_deps_test.db\");\n    let test_file = create_zero_dependency_file(&temp_dir.path().to_path_buf());\n\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .expect(\"Failed to create test database\");\n\n    // Act 1: Create schema (simulating pt01 initialization)\n    storage.create_schema().await.expect(\"Failed to create CodeGraph schema\");\n\n    // Act 1b: Create DependencyEdges schema (this is what pt01 now does ALWAYS after our fix)\n    // Previously this was only called if dependencies.is_empty() == false (BUG!)\n    // After fix: Always called, ensuring pt02-level00 can query the table\n    storage.create_dependency_edges_schema().await.expect(\"Failed to create DependencyEdges schema\");\n\n    // For this test, we'll manually create an entity using proper constructor\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"standalone\".to_string(),\n        visibility: Visibility::Public,\n        file_path: test_file.clone(),\n        line_range: LineRange::new(3, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let isgl1_key = format!(\"rust:fn:standalone:{}:3-5\", test_file.file_name().unwrap().to_str().unwrap().replace('.', \"_\"));\n\n    let mut entity1 = CodeEntity::new(isgl1_key, signature).unwrap();\n    entity1.current_code = Some(\"pub fn standalone() -> i32 {\\n    42\\n}\".to_string());\n    entity1.tdd_classification.entity_class = EntityClass::CodeImplementation;\n\n    storage.insert_entity(&entity1).await.expect(\"Failed to insert entity\");\n\n    // Verify entity was indexed\n    let entities = storage.get_all_entities().await.unwrap();\n    assert_eq!(entities.len(), 1, \"Should have indexed 1 entity\");\n\n    // Act 2: Try to query DependencyEdges (simulating pt02-level00)\n    //\n    // This is what pt02-level00 does:\n    // db.run_script(\"?[from_key, to_key, edge_type] := *DependencyEdges{from_key, to_key, edge_type}\", ...)\n    //\n    // Expected: Should fail with \"Cannot find requested stored relation 'DependencyEdges'\"\n\n    let query = r#\"\n        ?[from_key, to_key, edge_type] :=\n        *DependencyEdges{from_key, to_key, edge_type}\n    \"#;\n\n    let result = storage.raw_query(query).await;\n\n    // Assert: Currently this FAILS (RED) - table doesn't exist\n    //\n    // After fix: This should SUCCEED (GREEN) - table exists, returns empty array\n    assert!(\n        result.is_ok(),\n        \"pt02-level00 should succeed even with zero dependencies (table should exist but be empty). Got error: {:?}\",\n        result.err()\n    );\n\n    if let Ok(edges_data) = result {\n        // Should return empty array, not error\n        let rows = edges_data.rows;\n        assert_eq!(\n            rows.len(), 0,\n            \"Should have zero edges for zero-dependency codebase\"\n        );\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_pt02_level00_with_zero_dependencies_should_succeed",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt02_level00_with_zero_dependencies_should_succeed\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/pt02_level00_zero_dependencies_test.rs\",\"line_range\":{\"start\":64,\"end\":143},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt02_level00_with_zero_dependencies_should_succeed:__crates_parseltongue-core_tests_pt02_level00_zero_dependencies_test_rs:64-143",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt03_cannot_change_entity_class() {\n        // Arrange: Create entity with specific classification\n        let mut entity = create_test_entity(\"test.rs\", \"fn test_fn()\", EntityClass::TestImplementation);\n        let original_class = entity.entity_class;\n\n        // Act: Attempt various PT03 operations\n        entity.apply_temporal_change(crate::entities::TemporalAction::Create, None).unwrap();\n        entity.apply_temporal_change(crate::entities::TemporalAction::Edit, Some(\"new code\".to_string())).unwrap();\n        entity.apply_temporal_change(crate::entities::TemporalAction::Delete, None).unwrap();\n\n        // Assert: EntityClass never changes through PT03 operations\n        assert_eq!(entity.entity_class, original_class, \n                  \"EntityClass should never change through PT03 operations\");\n        assert_eq!(entity.entity_class, EntityClass::TestImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_pt03_cannot_change_entity_class",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt03_cannot_change_entity_class\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":370,\"end\":384},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt03_cannot_change_entity_class:__crates_parseltongue-core_src_entity_class_specifications_rs:370-384",
      "line_number": 0
    },
    {
      "current_code": "    fn test_pt03_preserves_entity_class_during_edits() {\n        // Arrange: Create entity with specific classification\n        let mut entity = create_test_entity(\"code.rs\", \"fn original()\", EntityClass::CodeImplementation);\n        let original_class = entity.entity_class;\n\n        // Act: Simulate PT03 edit operation (update future code)\n        entity.apply_temporal_change(\n            crate::entities::TemporalAction::Edit,\n            Some(\"fn updated() { /* new implementation */ }\".to_string()),\n        ).unwrap();\n\n        // Assert: EntityClass preserved during edit\n        assert_eq!(entity.entity_class, original_class, \n                  \"EntityClass should be preserved during PT03 edits\");\n        assert_eq!(entity.entity_class, EntityClass::CodeImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_pt03_preserves_entity_class_during_edits",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_pt03_preserves_entity_class_during_edits\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":351,\"end\":366},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_pt03_preserves_entity_class_during_edits:__crates_parseltongue-core_src_entity_class_specifications_rs:351-366",
      "line_number": 0
    },
    {
      "current_code": "fn test_python_extraction_class_and_function() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    let python_code = r#\"\nclass Calculator:\n    def __init__(self, name):\n        self.name = name\n\n    def add(self, a, b):\n        return a + b\n\n    def multiply(self, x, y):\n        return x * y\n\ndef hello_world():\n    print(\"Hello from Python!\")\n\"#;\n\n    let file_path = Path::new(\"test_calculator.py\");\n    let (entities, _dependencies) = generator.parse_source(python_code, file_path)\n        .expect(\"Should parse valid Python code without errors\");\n\n    // RED: This assertion will FAIL - currently returns 0 entities\n    assert!(\n        entities.len() >= 3,\n        \"FAILURE: Python extraction produced {} entities, expected >= 3. \\\n         This indicates the TODO stub at Language::Python is not implemented.\",\n        entities.len()\n    );\n\n    // Verify class extraction\n    let class_count = entities.iter()\n        .filter(|e| e.name == \"Calculator\")\n        .count();\n    assert!(class_count > 0, \"Should extract Calculator class\");\n\n    // Verify function extraction\n    let function_names: Vec<&str> = entities.iter()\n        .map(|e| e.name.as_str())\n        .collect();\n    assert!(function_names.contains(&\"hello_world\"), \"Should extract hello_world function\");\n}",
      "current_ind": 1,
      "entity_name": "test_python_extraction_class_and_function",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_python_extraction_class_and_function\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":94,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_python_extraction_class_and_function:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:94-135",
      "line_number": 0
    },
    {
      "current_code": "async fn test_python_import_dependencies_extensible() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"app.py\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\nimport os\nfrom pathlib import Path\n\ndef setup_dirs():\n    base = Path.home()\n    return base\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.py\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // RED: Python dependencies not yet implemented\n    // GREEN: After adding Python dependency queries, should capture imports\n    let import_count = dependencies.iter()\n        .filter(|dep| dep.to_key.as_str().contains(\"os\") || dep.to_key.as_str().contains(\"Path\"))\n        .count();\n\n    assert!(\n        import_count >= 1,\n        \"Should capture Python imports as dependencies (extensibility test)\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_python_import_dependencies_extensible",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_python_import_dependencies_extensible\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":259,\"end\":305},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_python_import_dependencies_extensible:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:259-305",
      "line_number": 0
    },
    {
      "current_code": "    fn test_python_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"def hello():\\n    print('world')\";\n        let result = validator.validate_syntax(code, Language::Python).unwrap();\n        assert!(result.is_valid);\n    }",
      "current_ind": 1,
      "entity_name": "test_python_valid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_python_valid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":201,\"end\":206},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_python_valid_code:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:201-206",
      "line_number": 0
    },
    {
      "current_code": "async fn test_query_based_matches_manual_extraction_quality() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"complex.rs\");\n\n    // Real-world Rust code with multiple dependency types\n    std::fs::write(\n        &test_file,\n        r#\"\nuse std::collections::HashMap;\n\nstruct Config {\n    settings: HashMap<String, String>,\n}\n\nimpl Config {\n    fn new() -> Self {\n        Self {\n            settings: create_defaults(),\n        }\n    }\n\n    fn get(&self, key: &str) -> Option<&String> {\n        self.settings.get(key)\n    }\n}\n\nfn create_defaults() -> HashMap<String, String> {\n    HashMap::new()\n}\n\nfn main() {\n    let config = Config::new();\n    println!(\"{:?}\", config.get(\"test\"));\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // DEBUG: Print all dependencies\n    println!(\"\\n=== EXTRACTED DEPENDENCIES ({}) ===\", dependencies.len());\n    for (i, dep) in dependencies.iter().enumerate() {\n        println!(\"{}. {} -> {} ({})\",\n            i + 1,\n            dep.from_key.as_str(),\n            dep.to_key.as_str(),\n            match dep.edge_type {\n                parseltongue_core::entities::EdgeType::Calls => \"Calls\",\n                parseltongue_core::entities::EdgeType::Uses => \"Uses\",\n                parseltongue_core::entities::EdgeType::Implements => \"Implements\",\n            }\n        );\n    }\n    println!(\"=================================\\n\");\n\n    // Expected dependencies:\n    // 1. Config::new() -> create_defaults() [function call]\n    // 2. main() -> Config::new() [function call]\n    // 3. main() -> Config::get() [method call]\n    // 4. Config::get() -> HashMap::get() [external call]\n\n    assert!(\n        dependencies.len() >= 3,\n        \"Should extract multiple dependency types. Found: {} dependencies\",\n        dependencies.len()\n    );\n\n    // Verify key call graph edges exist with method-level precision\n    // After v0.9.0 fix: calls from impl methods are now attributed to the specific method,\n    // not the impl block. We check for \"method:new\" instead of \"impl:Config\".\n    let has_new_to_defaults = dependencies.iter().any(|dep| {\n        dep.from_key.as_str().contains(\"method:new\") && dep.to_key.as_str().contains(\"create_defaults\")\n    });\n\n    assert!(\n        has_new_to_defaults,\n        \"Should have edge: method:new -> create_defaults (method-level precision). Found {} dependencies total.\",\n        dependencies.len()\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_query_based_matches_manual_extraction_quality",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_based_matches_manual_extraction_quality\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":377,\"end\":474},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_based_matches_manual_extraction_quality:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:377-474",
      "line_number": 0
    },
    {
      "current_code": "fn test_query_c_functions_and_structs() {\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let code = r#\"\nint add(int a, int b) { return a + b; }\n\nstruct Node {\n    int value;\n    struct Node* next;\n};\n\ntypedef struct {\n    char* name;\n    int age;\n} Person;\n    \"#;\n\n    let (entities, _deps) = extractor.parse_source(\n        code,\n        Path::new(\"test.c\"),\n        Language::C\n    ).unwrap();\n\n    assert_eq!(entities.len(), 3, \"Should extract function + 2 structs\");\n}",
      "current_ind": 1,
      "entity_name": "test_query_c_functions_and_structs",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_c_functions_and_structs\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":67,\"end\":90},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_c_functions_and_structs:__crates_parseltongue-core_tests_query_based_extraction_test_rs:67-90",
      "line_number": 0
    },
    {
      "current_code": "async fn test_query_changed_entities() {\n    // RED: Query for changed entities not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert 3 entities: 1 unchanged, 1 edit, 1 delete\n    let unchanged = create_test_entity_with_key(\"entity1\");\n    let to_edit = create_test_entity_with_key(\"entity2\");\n    let to_delete = create_test_entity_with_key(\"entity3\");\n\n    db.insert_entity(&unchanged).await.unwrap();\n    db.insert_entity(&to_edit).await.unwrap();\n    db.insert_entity(&to_delete).await.unwrap();\n\n    // Mark changes\n    db.update_temporal_state(\"entity2\", true, Some(TemporalAction::Edit)).await.unwrap();\n    db.update_temporal_state(\"entity3\", false, Some(TemporalAction::Delete)).await.unwrap();\n\n    // Query changed entities\n    let changed = db.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 2);\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity2\"));\n    assert!(changed.iter().any(|e| e.isgl1_key == \"entity3\"));\n}",
      "current_ind": 1,
      "entity_name": "test_query_changed_entities",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_changed_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":103,\"end\":126},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_changed_entities:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:103-126",
      "line_number": 0
    },
    {
      "current_code": "fn test_query_javascript_functions_and_classes() {\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let code = r#\"\nfunction greet(name) {\n    console.log(\"Hello \" + name);\n}\n\nconst add = (a, b) => a + b;\n\nclass Calculator {\n    multiply(x, y) {\n        return x * y;\n    }\n}\n    \"#;\n\n    let (entities, _deps) = extractor.parse_source(\n        code,\n        Path::new(\"test.js\"),\n        Language::JavaScript\n    ).unwrap();\n\n    assert!(entities.len() >= 3, \"Should extract function + arrow function + class (got {})\", entities.len());\n\n    // Verify entity names\n    let names: Vec<&str> = entities.iter()\n        .map(|e| e.name.as_str())\n        .collect();\n    assert!(names.contains(&\"greet\"), \"Should find 'greet' function\");\n    assert!(names.contains(&\"Calculator\"), \"Should find 'Calculator' class\");\n}",
      "current_ind": 1,
      "entity_name": "test_query_javascript_functions_and_classes",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_javascript_functions_and_classes\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":131,\"end\":161},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_javascript_functions_and_classes:__crates_parseltongue-core_tests_query_based_extraction_test_rs:131-161",
      "line_number": 0
    },
    {
      "current_code": "fn test_query_python_classes_and_functions() {\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let code = r#\"\nclass Calculator:\n    def add(self, a, b):\n        return a + b\n\ndef hello_world():\n    print(\"Hello\")\n    \"#;\n\n    let (entities, _deps) = extractor.parse_source(\n        code,\n        Path::new(\"test.py\"),\n        Language::Python\n    ).unwrap();\n\n    assert_eq!(entities.len(), 3, \"Should extract class + 2 functions\");\n}",
      "current_ind": 1,
      "entity_name": "test_query_python_classes_and_functions",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_python_classes_and_functions\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":45,\"end\":63},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_python_classes_and_functions:__crates_parseltongue-core_tests_query_based_extraction_test_rs:45-63",
      "line_number": 0
    },
    {
      "current_code": "fn test_query_rust_functions_and_structs() {\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let code = r#\"\n        fn calculate_sum(a: i32, b: i32) -> i32 { a + b }\n        struct User { name: String, age: u32 }\n        enum Status { Active, Inactive }\n    \"#;\n\n    let (entities, _deps) = extractor.parse_source(\n        code,\n        Path::new(\"test.rs\"),\n        Language::Rust\n    ).unwrap();\n\n    assert_eq!(entities.len(), 3, \"Should extract function + struct + enum\");\n\n    // Verify entity names\n    let names: Vec<&str> = entities.iter()\n        .map(|e| e.name.as_str())\n        .collect();\n    assert!(names.contains(&\"calculate_sum\"));\n    assert!(names.contains(&\"User\"));\n    assert!(names.contains(&\"Status\"));\n}",
      "current_ind": 1,
      "entity_name": "test_query_rust_functions_and_structs",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/query_based_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_rust_functions_and_structs\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/query_based_extraction_test.rs\",\"line_range\":{\"start\":18,\"end\":41},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_rust_functions_and_structs:__crates_parseltongue-core_tests_query_based_extraction_test_rs:18-41",
      "line_number": 0
    },
    {
      "current_code": "async fn test_query_stored_entity_and_verify_in_codebase() {\n    // Create a test Rust file\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"example.rs\");\n    std::fs::write(\n        &test_file,\n        r#\"\npub fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\npub struct Calculator {\n    name: String,\n    version: u32,\n}\n\nimpl Calculator {\n    pub fn new(name: String) -> Self {\n        Self { name, version: 1 }\n    }\n}\n\"#,\n    )\n    .unwrap();\n\n    // Index the file\n    let db_dir = TempDir::new().unwrap();\n    let db_path = format!(\"rocksdb:{}\", db_dir.path().display());\n\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: db_path.clone(),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    let streamer = ToolFactory::create_streamer(config).await.unwrap();\n    let result = streamer.stream_directory().await.unwrap();\n\n    println!(\"\\n Indexing Results:\");\n    println!(\"  Files processed: {}\", result.processed_files);\n    println!(\"  Entities created: {}\", result.entities_created);\n    assert!(result.entities_created >= 3, \"Should have at least 3 entities (function, struct, impl)\");\n\n    // Drop the streamer to release the RocksDB lock before opening a new connection\n    drop(streamer);\n\n    // Now query the database to get one entity\n    let db = CozoDbStorage::new(&db_path).await.unwrap();\n\n    // Query using get_all_entities\n    let entities = db.get_all_entities().await.unwrap();\n    println!(\"\\n Total entities in database: {}\", entities.len());\n\n    // Pick first entity and verify\n    if let Some(first_entity) = entities.first() {\n        let isgl1_key = &first_entity.isgl1_key;\n        println!(\"\\n Found entity: {}\", isgl1_key);\n        println!(\"  LSP metadata present: {}\", first_entity.lsp_metadata.is_some());\n\n        if let Some(lsp_meta) = &first_entity.lsp_metadata {\n            println!(\"\\n LSP Metadata:\");\n            println!(\"  Type: {}\", lsp_meta.type_information.resolved_type);\n            println!(\"  Module path: {:?}\", lsp_meta.type_information.module_path);\n            println!(\"  Generic params: {:?}\", lsp_meta.type_information.generic_parameters);\n            println!(\"  Usage references: {}\", lsp_meta.usage_analysis.total_references);\n        }\n\n        // Verify the entity exists in the source file\n        let source_content = std::fs::read_to_string(&test_file).unwrap();\n\n        // Parse ISGL1 key to extract entity name\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() >= 3 {\n            let entity_name = parts[2];\n            println!(\"\\n Searching for entity '{}' in source...\", entity_name);\n\n            // Search for entity in source\n            assert!(\n                source_content.contains(entity_name),\n                \"Entity '{}' should exist in source file\",\n                entity_name\n            );\n            println!(\"   Verified in source code!\");\n\n            // Show context from source\n            for (i, line) in source_content.lines().enumerate() {\n                if line.contains(entity_name) {\n                    println!(\"\\n Source code context (line {}):\", i + 1);\n                    println!(\"  {}\", line.trim());\n                }\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_query_stored_entity_and_verify_in_codebase",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/verify_lsp_storage.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_query_stored_entity_and_verify_in_codebase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/verify_lsp_storage.rs\",\"line_range\":{\"start\":8,\"end\":105},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_query_stored_entity_and_verify_in_codebase:__crates_pt01-folder-to-cozodb-streamer_tests_verify_lsp_storage_rs:8-105",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_real_client_gracefully_degrades_when_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n\n        // Should not panic, should return None\n        let result = client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }",
      "current_ind": 1,
      "entity_name": "test_real_client_gracefully_degrades_when_unavailable",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_real_client_gracefully_degrades_when_unavailable\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":181,\"end\":191},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_real_client_gracefully_degrades_when_unavailable:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:181-191",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_real_client_reports_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n        assert!(!client.is_available().await);\n    }",
      "current_ind": 1,
      "entity_name": "test_real_client_reports_unavailable",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_real_client_reports_unavailable\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":194,\"end\":197},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_real_client_reports_unavailable:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:194-197",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_resolve_file_path() {\n        let writer = FileWriter::new(PathBuf::from(\"/tmp\"));\n\n        let path = writer.resolve_file_path(\"src-models-rs-User\").unwrap();\n        assert_eq!(path, PathBuf::from(\"/tmp/src/models.rs\"));\n    }",
      "current_ind": 1,
      "entity_name": "test_resolve_file_path",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_resolve_file_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":278,\"end\":283},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_resolve_file_path:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:278-283",
      "line_number": 0
    },
    {
      "current_code": "async fn test_reverse_dependencies_empty() {\n    // RED: Test entity with no reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no incoming edges\n    let deps = db.get_reverse_dependencies(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(deps.len(), 0, \"Entity with no incoming edges should return empty\");\n}",
      "current_ind": 1,
      "entity_name": "test_reverse_dependencies_empty",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_reverse_dependencies_empty\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":694,\"end\":703},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_reverse_dependencies_empty:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:694-703",
      "line_number": 0
    },
    {
      "current_code": "async fn test_reverse_dependencies_multiple() {\n    // RED: Test multiple reverse dependencies\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> D, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: D should have A, B, C as dependents\n    let deps = db.get_reverse_dependencies(\"rust:fn:D:test_rs:30-35\").await.unwrap();\n\n    assert_eq!(deps.len(), 3, \"D should have 3 dependents\");\n    assert!(deps.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_reverse_dependencies_multiple",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_reverse_dependencies_multiple\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":644,\"end\":679},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_reverse_dependencies_multiple:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:644-679",
      "line_number": 0
    },
    {
      "current_code": "async fn test_reverse_dependencies_single() {\n    // RED: Test reverse dependencies (incoming edges)\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B\n    let edge = DependencyEdge::builder()\n        .from_key(\"rust:fn:A:test_rs:1-5\")\n        .to_key(\"rust:fn:B:test_rs:10-15\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n    db.insert_edge(&edge).await.unwrap();\n\n    // Query: B's reverse dependencies should return [A]\n    let deps = db.get_reverse_dependencies(\"rust:fn:B:test_rs:10-15\").await.unwrap();\n\n    assert_eq!(deps.len(), 1, \"B should have 1 dependent\");\n    assert_eq!(deps[0], \"rust:fn:A:test_rs:1-5\");\n}",
      "current_ind": 1,
      "entity_name": "test_reverse_dependencies_single",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_reverse_dependencies_single\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":584,\"end\":603},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_reverse_dependencies_single:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:584-603",
      "line_number": 0
    },
    {
      "current_code": "fn test_ruby_extraction_rails_model() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n\n    // Real Ruby code from Campfire (app/models/room.rb)\n    let ruby_code = r#\"\nclass Room < ApplicationRecord\n  has_many :memberships, dependent: :delete_all do\n    def grant_to(users)\n      room = proxy_association.owner\n      Membership.insert_all(Array(users).collect { |user| { room_id: room.id, user_id: user.id } })\n    end\n\n    def revoke_from(users)\n      destroy_by user: users\n    end\n  end\nend\n\"#;\n\n    let file_path = Path::new(\"test_room.rb\");\n    let (entities, _dependencies) = generator.parse_source(ruby_code, file_path)\n        .expect(\"Should parse valid Ruby code without errors\");\n\n    // RED: This assertion will FAIL - currently returns 0 entities\n    assert!(\n        entities.len() > 0,\n        \"FAILURE: Ruby extraction produced 0 entities from valid code. \\\n         Expected: class + methods. \\\n         This indicates walk_node() falls through to `_ => {{}}` for Ruby.\"\n    );\n\n    // GREEN target: Should extract at least the class\n    let class_entities: Vec<_> = entities.iter()\n        .filter(|e| e.name == \"Room\")\n        .collect();\n\n    assert!(\n        !class_entities.is_empty(),\n        \"Should extract Room class from Ruby code\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_ruby_extraction_rails_model",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_ruby_extraction_rails_model\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/multi_language_extraction_test.rs\",\"line_range\":{\"start\":40,\"end\":80},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_ruby_extraction_rails_model:__crates_pt01-folder-to-cozodb-streamer_tests_multi_language_extraction_test_rs:40-80",
      "line_number": 0
    },
    {
      "current_code": "fn test_ruby_query_compilation_baseline() {\n    // Ruby works - use as baseline\n    let ruby_query = include_str!(\"../../../entity_queries/ruby.scm\");\n    let ruby_lang: Language = tree_sitter_ruby::LANGUAGE.into();\n\n    println!(\"\\n=== Ruby Query Content (Working Baseline) ===\");\n    println!(\"{}\", ruby_query);\n    println!(\"=== End Query Content ===\\n\");\n\n    match Query::new(&ruby_lang, ruby_query) {\n        Ok(query) => {\n            println!(\" Ruby query compiled successfully!\");\n            println!(\"Number of patterns: {}\", query.pattern_count());\n            println!(\"Capture names: {:?}\", query.capture_names());\n        }\n        Err(e) => {\n            panic!(\" Ruby query compilation FAILED: {:?}\", e);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_ruby_query_compilation_baseline",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_query_debug.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_ruby_query_compilation_baseline\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_query_debug.rs\",\"line_range\":{\"start\":26,\"end\":45},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_ruby_query_compilation_baseline:__crates_parseltongue-core_tests_swift_query_debug_rs:26-45",
      "line_number": 0
    },
    {
      "current_code": "fn test_rust_basic_parsing() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n    let code = \"fn hello() {}\";\n    let path = Path::new(\"test.rs\");\n\n    // This will fail if API is broken\n    let result = generator.parse_source(code, path);\n\n    assert!(result.is_ok(), \"Should parse valid Rust code\");\n\n    let (entities, _) = result.unwrap();\n    assert_eq!(entities.len(), 1, \"Should extract one function\");\n    assert_eq!(entities[0].name, \"hello\");\n}",
      "current_ind": 1,
      "entity_name": "test_rust_basic_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_basic_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs\",\"line_range\":{\"start\":25,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_basic_parsing:__crates_pt01-folder-to-cozodb-streamer_tests_tree_sitter_api_compatibility_test_rs:25-38",
      "line_number": 0
    },
    {
      "current_code": "fn test_rust_invalid_syntax_detection() {\n    let generator = Isgl1KeyGeneratorImpl::new();\n    let code = \"fn hello( {\"; // Missing closing paren\n    let path = Path::new(\"test.rs\");\n\n    let result = generator.parse_source(code, path);\n\n    // Parser should still succeed but tree should have errors\n    assert!(result.is_ok(), \"Parser should not crash on invalid syntax\");\n}",
      "current_ind": 1,
      "entity_name": "test_rust_invalid_syntax_detection",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_invalid_syntax_detection\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs\",\"line_range\":{\"start\":45,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_invalid_syntax_detection:__crates_pt01-folder-to-cozodb-streamer_tests_tree_sitter_api_compatibility_test_rs:45-54",
      "line_number": 0
    },
    {
      "current_code": "fn test_rust_parser_initialization() {\n    // This will panic if .into() is missing or parser initialization fails\n    let _generator = Isgl1KeyGeneratorImpl::new();\n    // If we get here, Rust parser initialized successfully\n}",
      "current_ind": 1,
      "entity_name": "test_rust_parser_initialization",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_parser_initialization\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tree_sitter_api_compatibility_test.rs\",\"line_range\":{\"start\":14,\"end\":18},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_parser_initialization:__crates_pt01-folder-to-cozodb-streamer_tests_tree_sitter_api_compatibility_test_rs:14-18",
      "line_number": 0
    },
    {
      "current_code": "    fn test_rust_parsing() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn test_function() {\n    println!(\"Hello, world!\");\n}\n\nstruct TestStruct {\n    field: i32,\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        assert!(!entities.is_empty());\n        assert_eq!(entities.len(), 2); // One function, one struct\n\n        let function = &entities[0];\n        assert_eq!(function.entity_type, EntityType::Function);\n        assert_eq!(function.name, \"test_function\");\n\n        // For now, dependencies should be empty (will implement extraction next)\n        assert_eq!(dependencies.len(), 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_rust_parsing",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_parsing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":420,\"end\":444},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_parsing:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:420-444",
      "line_number": 0
    },
    {
      "current_code": "    fn test_rust_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        // Test cases: (file_path, content, expected_result)\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn normal_function() { }\", EntityClass::Code),\n            (\"tests/integration_test.rs\", \"#[test] fn test_integration() { }\", EntityClass::Test),\n            (\"src/module_test.rs\", \"#[tokio::test] async fn test_async() { }\", EntityClass::Test),\n            (\"src/benches/bench.rs\", \"#[test] fn test_unit() { }\", EntityClass::Test),\n            (\"src/main.rs\", \"fn main() { println!(\\\"hello\\\"); }\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected, \n                      \"Rust file {} with content should be {:?}\", file_path, expected);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_rust_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":216,\"end\":236},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:216-236",
      "line_number": 0
    },
    {
      "current_code": "    fn test_rust_test_detection_contract() {\n        // Given: Rust test patterns\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn normal_function() { }\", false),\n            (\"tests/integration_test.rs\", \"#[test] fn test_integration() { }\", true),\n            (\"src/module_test.rs\", \"#[tokio::test] async fn test_async() { }\", true),\n            (\"src/benches/bench.rs\", \"#[test] fn test_unit() { }\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test, \n                      \"File {} with content should be test: {}\", file_path, expected_is_test);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_rust_test_detection_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_rust_test_detection_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":227,\"end\":244},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_rust_test_detection_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:227-244",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_schema_recreation_after_deletion() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Insert test entity\n        storage.insert_entity(&create_test_entity(\"before\")).await.unwrap();\n\n        // Reset\n        let manager = StateResetManager::new(storage);\n        manager.delete_table().await.unwrap();\n        manager.recreate_schema().await.unwrap();\n\n        // Postcondition: Can insert new entity (schema is valid)\n        let result = manager.storage.insert_entity(&create_test_entity(\"after\")).await;\n        assert!(\n            result.is_ok(),\n            \"Should be able to insert after schema recreation\"\n        );\n\n        // Verify only new entity exists\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 1, \"Should have exactly 1 entity\");\n        assert_eq!(\n            entities[0].isgl1_key, \"after\",\n            \"Should be the new entity, not old one\"\n        );\n    }",
      "current_ind": 1,
      "entity_name": "test_schema_recreation_after_deletion",
      "entity_type": "function",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_schema_recreation_after_deletion\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":244,\"end\":270},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_schema_recreation_after_deletion:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:244-270",
      "line_number": 0
    },
    {
      "current_code": "async fn test_self_method_calls() {\n    let source = r#\"\nstruct Calculator {\n    value: i32,\n}\n\nimpl Calculator {\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn default() -> Self {\n        Self { value: 0 }\n    }\n\n    fn compute(&self) -> i32 {\n        self.helper()\n    }\n\n    fn helper(&self) -> i32 {\n        self.value\n    }\n}\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Self and Method Calls ===\");\n    print_dependencies(&deps);\n\n    // Should capture Self::default() and self.helper()\n    assert!(has_call(&deps, \"default\"), \"Should capture Self::default()\");\n    assert!(has_call(&deps, \"helper\"), \"Should capture self.helper()\");\n}",
      "current_ind": 1,
      "entity_name": "test_self_method_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_self_method_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":283,\"end\":316},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_self_method_calls:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:283-316",
      "line_number": 0
    },
    {
      "current_code": "    fn test_simple_interface_mode() {\n        let config = SimpleUpdateConfig {\n            entity_key: \"rust:fn:test:lib_rs:1-5\".to_string(),\n            action: EntityAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Simple(config.clone());\n\n        match mode {\n            InterfaceMode::Simple(c) => {\n                assert_eq!(c.entity_key, \"rust:fn:test:lib_rs:1-5\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Simple mode\"),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "test_simple_interface_mode",
      "entity_type": "function",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_simple_interface_mode\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/main.rs\",\"line_range\":{\"start\":104,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_simple_interface_mode:__crates_pt03-llm-to-cozodb-writer_src_main_rs:104-121",
      "line_number": 0
    },
    {
      "current_code": "    fn test_simple_invalid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main( {\"; // Missing closing paren\n        let result = validator.validate_syntax(code, Language::Rust).unwrap();\n        assert!(!result.is_valid);\n        assert!(!result.errors.is_empty());\n    }",
      "current_ind": 1,
      "entity_name": "test_simple_invalid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_simple_invalid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":192,\"end\":198},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_simple_invalid_code:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:192-198",
      "line_number": 0
    },
    {
      "current_code": "    fn test_simple_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main() {}\";\n        let result = validator.validate_syntax(code, Language::Rust).unwrap();\n        assert!(result.is_valid);\n    }",
      "current_ind": 1,
      "entity_name": "test_simple_valid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_simple_valid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":184,\"end\":189},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_simple_valid_code:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:184-189",
      "line_number": 0
    },
    {
      "current_code": "async fn test_single_edge_insert_performance_contract() {\n    // Performance Contract: Single insert <5ms (D10 specification)\n    use std::time::Instant;\n\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    let edge = DependencyEdge::builder()\n        .from_key(\"A\")\n        .to_key(\"B\")\n        .edge_type(EdgeType::Calls)\n        .build()\n        .unwrap();\n\n    // Warm up\n    db.insert_edge(&edge).await.unwrap();\n\n    // Measure\n    let start = Instant::now();\n    db.insert_edge(&edge).await.unwrap();\n    let elapsed = start.elapsed();\n\n    assert!(\n        elapsed.as_millis() < 5,\n        \"Single edge insert took {:?}, expected <5ms\",\n        elapsed\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_single_edge_insert_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_single_edge_insert_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":361,\"end\":388},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_single_edge_insert_performance_contract:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:361-388",
      "line_number": 0
    },
    {
      "current_code": "    fn test_single_exclusion_pattern_contract() {\n        // Given: Exclusion pattern \".ref\"\n        let patterns = vec![\".ref\".to_string()];\n        \n        // When: Checking path \".ref/tool-semgrep\"\n        let path = PathBuf::from(\".ref/tool-semgrep\");\n        \n        // Then: Should be excluded\n        assert!(should_exclude_path(&path, &patterns));\n        \n        // And: Normal source code should not be excluded\n        let src_path = PathBuf::from(\"src/main.rs\");\n        assert!(!should_exclude_path(&src_path, &patterns));\n    }",
      "current_ind": 1,
      "entity_name": "test_single_exclusion_pattern_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_single_exclusion_pattern_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":38,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_single_exclusion_pattern_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:38-51",
      "line_number": 0
    },
    {
      "current_code": "async fn test_skip_unchanged_entities() {\n    let storage = CozoDbStorage::new(\"mem\").await.expect(\"Failed to create storage\");\n    storage.create_schema().await.expect(\"Failed to create schema\");\n\n    // Insert unchanged entity (no FutureAction)\n    let mut entity = create_test_entity(\n        \"rust:fn:unchanged:src_lib_rs:10-20\",\n        Some(\"fn unchanged() {}\"),\n        TemporalAction::Create, // Will be overridden\n    );\n    entity.temporal_state = TemporalState::unchanged();\n\n    storage\n        .insert_entity(&entity)\n        .await\n        .expect(\"Failed to insert entity\");\n\n    // Generate diff\n    let generator = DiffGenerator::new(Arc::new(storage));\n    let diff = generator\n        .generate_diff()\n        .await\n        .expect(\"Failed to generate diff\");\n\n    // Should be empty - unchanged entities should be skipped\n    assert_eq!(diff.changes.len(), 0);\n    assert_eq!(diff.metadata.total_changes, 0);\n}",
      "current_ind": 1,
      "entity_name": "test_skip_unchanged_entities",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_skip_unchanged_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/tests/diff_generator_tests.rs\",\"line_range\":{\"start\":114,\"end\":141},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_skip_unchanged_entities:__crates_pt05-llm-cozodb-to-diff-writer_tests_diff_generator_tests_rs:114-141",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_streamer_enriches_entities_with_lsp_metadata() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nstruct Calculator {\n    name: String,\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client with hover responses\n        let mut mock_lsp = MockRustAnalyzerClient::new();\n\n        // Add hover response for function (line 1)\n        mock_lsp.add_response(\n            format!(\"{}:0:0\", test_file.display()),\n            HoverResponse {\n                contents: \"fn calculate_sum(a: i32, b: i32) -> i32\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"function\",\n                    \"signature\": \"fn(i32, i32) -> i32\"\n                }),\n            },\n        );\n\n        // Add hover response for struct (line 5)\n        mock_lsp.add_response(\n            format!(\"{}:4:0\", test_file.display()),\n            HoverResponse {\n                contents: \"struct Calculator\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"struct\",\n                    \"fields\": [\"name: String\"]\n                }),\n            },\n        );\n\n        // Setup: Create streamer with mock LSP client\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n            std::sync::Arc::new(crate::test_detector::DefaultTestDetector::new()),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entities were created\n        assert_eq!(result.entities_created, 2, \"Should create 2 entities (function + struct)\");\n        assert!(result.success, \"Streaming should succeed\");\n\n        // Verify: LSP metadata was stored (we can't easily query DB in this test,\n        // but the fact that no errors occurred means LSP integration works)\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
      "current_ind": 1,
      "entity_name": "test_streamer_enriches_entities_with_lsp_metadata",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_streamer_enriches_entities_with_lsp_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs\",\"line_range\":{\"start\":12,\"end\":87},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_streamer_enriches_entities_with_lsp_metadata:__crates_pt01-folder-to-cozodb-streamer_src_streamer_lsp_tests_rs:12-87",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_streamer_gracefully_degrades_without_lsp() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn test_fn() {\n    println!(\"test\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client that returns None (simulating unavailable LSP)\n        let mock_lsp = MockRustAnalyzerClient::new(); // No responses configured\n\n        // Setup: Create streamer\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n            std::sync::Arc::new(crate::test_detector::DefaultTestDetector::new()),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entity still created despite LSP unavailable (graceful degradation)\n        assert_eq!(result.entities_created, 1, \"Should still create entity without LSP\");\n        assert!(result.success, \"Streaming should succeed without LSP\");\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }",
      "current_ind": 1,
      "entity_name": "test_streamer_gracefully_degrades_without_lsp",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_streamer_gracefully_degrades_without_lsp\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs\",\"line_range\":{\"start\":90,\"end\":134},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_streamer_gracefully_degrades_without_lsp:__crates_pt01-folder-to-cozodb-streamer_src_streamer_lsp_tests_rs:90-134",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_entity_extraction_integration() {\n    let swift_code = r#\"\n// Test Swift file for entity extraction\nimport Foundation\n\n// Function\nfunc calculateSum(a: Int, b: Int) -> Int {\n    return a + b\n}\n\n// Class\nclass UserManager {\n    var users: [String] = []\n\n    func addUser(name: String) {\n        users.append(name)\n    }\n}\n\n// Struct\nstruct Point {\n    var x: Double\n    var y: Double\n\n    func distance(to other: Point) -> Double {\n        let dx = x - other.x\n        let dy = y - other.y\n        return sqrt(dx * dx + dy * dy)\n    }\n}\n\n// Enum\nenum Direction {\n    case north\n    case south\n    case east\n    case west\n}\n\n// Protocol\nprotocol Drawable {\n    func draw()\n}\n\"#;\n\n    let mut extractor = QueryBasedExtractor::new()\n        .expect(\"Failed to initialize QueryBasedExtractor\");\n\n    let (entities, _deps) = extractor\n        .parse_source(swift_code, Path::new(\"test.swift\"), Language::Swift)\n        .expect(\"Failed to parse Swift code\");\n\n    println!(\"\\n=== Extracted Swift Entities ===\");\n    for entity in &entities {\n        println!(\n            \"{:?}: {} (lines {}-{})\",\n            entity.entity_type, entity.name, entity.line_range.0, entity.line_range.1\n        );\n    }\n\n    // Verify expected entities\n    assert!(\n        entities.iter().any(|e| e.name == \"calculateSum\"),\n        \"Should extract function 'calculateSum'\"\n    );\n    assert!(\n        entities.iter().any(|e| e.name == \"UserManager\"),\n        \"Should extract class 'UserManager'\"\n    );\n    assert!(\n        entities.iter().any(|e| e.name == \"Point\"),\n        \"Should extract struct 'Point'\"\n    );\n    assert!(\n        entities.iter().any(|e| e.name == \"Direction\"),\n        \"Should extract enum 'Direction'\"\n    );\n    assert!(\n        entities.iter().any(|e| e.name == \"Drawable\"),\n        \"Should extract protocol 'Drawable'\"\n    );\n\n    // Verify methods inside types are also extracted\n    assert!(\n        entities.iter().any(|e| e.name == \"addUser\"),\n        \"Should extract method 'addUser'\"\n    );\n    assert!(\n        entities.iter().any(|e| e.name == \"distance\"),\n        \"Should extract method 'distance'\"\n    );\n\n    println!(\"\\n Swift integration test passed! Extracted {} entities\", entities.len());\n}",
      "current_ind": 1,
      "entity_name": "test_swift_entity_extraction_integration",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_integration_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_entity_extraction_integration\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_integration_test.rs\",\"line_range\":{\"start\":7,\"end\":100},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_entity_extraction_integration:__crates_parseltongue-core_tests_swift_integration_test_rs:7-100",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_extracts_all_entity_types() {\n    let swift_code = r#\"\n// Functions\nfunc globalFunction() {\n    print(\"Hello\")\n}\n\n// Class\nclass MyClass {\n    func classMethod() {}\n}\n\n// Struct\nstruct MyStruct {\n    func structMethod() {}\n}\n\n// Enum\nenum MyEnum {\n    case value\n}\n\n// Protocol\nprotocol MyProtocol {\n    func protocolMethod()\n}\n\"#;\n\n    let mut extractor = QueryBasedExtractor::new()\n        .expect(\"Failed to initialize QueryBasedExtractor\");\n\n    let (entities, _) = extractor\n        .parse_source(swift_code, Path::new(\"test.swift\"), Language::Swift)\n        .expect(\"Failed to parse Swift code\");\n\n    println!(\"\\n=== Extracted Entities ===\");\n    for entity in &entities {\n        println!(\n            \"{:?}: {} (line {})\",\n            entity.entity_type, entity.name, entity.line_range.0\n        );\n    }\n\n    // Validate function extraction\n    assert!(\n        entities.iter().any(|e| e.name == \"globalFunction\"),\n        \"Should extract global function\"\n    );\n\n    // Validate class extraction\n    assert!(\n        entities.iter().any(|e| e.name == \"MyClass\"),\n        \"Should extract class (via class_declaration node)\"\n    );\n\n    // Validate struct extraction\n    // NOTE: Swift uses class_declaration for structs, so tagged as Class\n    assert!(\n        entities.iter().any(|e| e.name == \"MyStruct\"),\n        \"Should extract struct (via class_declaration node)\"\n    );\n\n    // Validate enum extraction\n    // NOTE: Swift uses class_declaration for enums, so tagged as Class\n    assert!(\n        entities.iter().any(|e| e.name == \"MyEnum\"),\n        \"Should extract enum (via class_declaration node)\"\n    );\n\n    // Validate protocol extraction\n    assert!(\n        entities.iter().any(|e| e.name == \"MyProtocol\"),\n        \"Should extract protocol (via protocol_declaration node)\"\n    );\n\n    // Validate methods are extracted\n    assert!(\n        entities.iter().any(|e| e.name == \"classMethod\"),\n        \"Should extract class methods\"\n    );\n\n    println!(\"\\n All Swift entity types extracted successfully\");\n    println!(\"   Total entities: {}\", entities.len());\n}",
      "current_ind": 1,
      "entity_name": "test_swift_extracts_all_entity_types",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_fix_validation.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_extracts_all_entity_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_fix_validation.rs\",\"line_range\":{\"start\":32,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_extracts_all_entity_types:__crates_parseltongue-core_tests_swift_fix_validation_rs:32-115",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_protocol_uses_interface_entity_type() {\n    let swift_code = r#\"\nprotocol Drawable {\n    func draw()\n}\n\"#;\n\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let (entities, _) = extractor\n        .parse_source(swift_code, Path::new(\"test.swift\"), Language::Swift)\n        .unwrap();\n\n    let protocol_entity = entities\n        .iter()\n        .find(|e| e.name == \"Drawable\")\n        .expect(\"Should extract protocol\");\n\n    assert_eq!(\n        protocol_entity.entity_type,\n        parseltongue_core::query_extractor::EntityType::Interface,\n        \"Protocols should be tagged as Interface type (not Trait)\"\n    );\n\n    println!(\" Protocol correctly tagged as Interface entity type\");\n}",
      "current_ind": 1,
      "entity_name": "test_swift_protocol_uses_interface_entity_type",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_fix_validation.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_protocol_uses_interface_entity_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_fix_validation.rs\",\"line_range\":{\"start\":118,\"end\":142},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_protocol_uses_interface_entity_type:__crates_parseltongue-core_tests_swift_fix_validation_rs:118-142",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_query_compilation() {\n    let swift_query = include_str!(\"../../../entity_queries/swift.scm\");\n    let swift_lang: Language = tree_sitter_swift::LANGUAGE.into();\n\n    println!(\"\\n=== Swift Query Content ===\");\n    println!(\"{}\", swift_query);\n    println!(\"=== End Query Content ===\\n\");\n\n    match Query::new(&swift_lang, swift_query) {\n        Ok(query) => {\n            println!(\" Swift query compiled successfully!\");\n            println!(\"Number of patterns: {}\", query.pattern_count());\n            println!(\"Capture names: {:?}\", query.capture_names());\n        }\n        Err(e) => {\n            panic!(\" Swift query compilation FAILED: {:?}\", e);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_swift_query_compilation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_query_debug.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_query_compilation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_query_debug.rs\",\"line_range\":{\"start\":5,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_query_compilation:__crates_parseltongue-core_tests_swift_query_debug_rs:5-23",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_query_compiles_without_error() {\n    // This was failing with: \"Failed to create query\" error\n    // Specifically at row: 12 (struct_declaration line)\n    let result = QueryBasedExtractor::new();\n\n    assert!(\n        result.is_ok(),\n        \"QueryBasedExtractor should initialize successfully. \\\n         If this fails with 'Failed to create query', check entity_queries/swift.scm \\\n         for invalid node types.\"\n    );\n\n    println!(\" Swift query compiled successfully (no 'Failed to create query' error)\");\n}",
      "current_ind": 1,
      "entity_name": "test_swift_query_compiles_without_error",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_fix_validation.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_query_compiles_without_error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_fix_validation.rs\",\"line_range\":{\"start\":16,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_query_compiles_without_error:__crates_parseltongue-core_tests_swift_fix_validation_rs:16-29",
      "line_number": 0
    },
    {
      "current_code": "fn test_swift_real_world_code_extraction() {\n    // Real-world Swift code with multiple entity types\n    let swift_code = r#\"\nimport Foundation\n\n// MARK: - Data Models\n\nstruct User {\n    let id: UUID\n    let name: String\n    let email: String\n}\n\nenum UserRole {\n    case admin\n    case moderator\n    case user\n}\n\n// MARK: - Protocols\n\nprotocol UserRepository {\n    func fetch(id: UUID) async throws -> User\n    func save(_ user: User) async throws\n}\n\n// MARK: - Implementations\n\nclass InMemoryUserRepository: UserRepository {\n    private var users: [UUID: User] = [:]\n\n    func fetch(id: UUID) async throws -> User {\n        guard let user = users[id] else {\n            throw RepositoryError.notFound\n        }\n        return user\n    }\n\n    func save(_ user: User) async throws {\n        users[user.id] = user\n    }\n}\n\n// MARK: - Utility Functions\n\nfunc validateEmail(_ email: String) -> Bool {\n    let regex = try! NSRegularExpression(pattern: \"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}$\")\n    return regex.firstMatch(in: email, range: NSRange(email.startIndex..., in: email)) != nil\n}\n\nfunc generateUserKey(for user: User) -> String {\n    return \"user:\\(user.id.uuidString)\"\n}\n\"#;\n\n    let mut extractor = QueryBasedExtractor::new().unwrap();\n    let (entities, _) = extractor\n        .parse_source(swift_code, Path::new(\"UserRepository.swift\"), Language::Swift)\n        .unwrap();\n\n    println!(\"\\n=== Real-world Swift Code Extraction ===\");\n    for entity in &entities {\n        println!(\n            \"{:?}: {} (lines {}-{})\",\n            entity.entity_type, entity.name, entity.line_range.0, entity.line_range.1\n        );\n    }\n\n    // Validate expected entities\n    assert!(entities.iter().any(|e| e.name == \"User\"), \"Should extract User struct\");\n    assert!(entities.iter().any(|e| e.name == \"UserRole\"), \"Should extract UserRole enum\");\n    assert!(entities.iter().any(|e| e.name == \"UserRepository\"), \"Should extract UserRepository protocol\");\n    assert!(entities.iter().any(|e| e.name == \"InMemoryUserRepository\"), \"Should extract InMemoryUserRepository class\");\n    assert!(entities.iter().any(|e| e.name == \"fetch\"), \"Should extract fetch method\");\n    assert!(entities.iter().any(|e| e.name == \"save\"), \"Should extract save method\");\n    assert!(entities.iter().any(|e| e.name == \"validateEmail\"), \"Should extract validateEmail function\");\n    assert!(entities.iter().any(|e| e.name == \"generateUserKey\"), \"Should extract generateUserKey function\");\n\n    let entity_count = entities.len();\n    assert!(\n        entity_count >= 8,\n        \"Should extract at least 8 entities, got {}\",\n        entity_count\n    );\n\n    println!(\"\\n Real-world Swift code extraction successful\");\n    println!(\"   Extracted {} entities from production-like code\", entity_count);\n}",
      "current_ind": 1,
      "entity_name": "test_swift_real_world_code_extraction",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/swift_fix_validation.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_swift_real_world_code_extraction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/swift_fix_validation.rs\",\"line_range\":{\"start\":145,\"end\":232},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_swift_real_world_code_extraction:__crates_parseltongue-core_tests_swift_fix_validation_rs:145-232",
      "line_number": 0
    },
    {
      "current_code": "    fn test_tdd_classification_has_entity_class_field() {\n        // Test that TddClassification has entity_class field\n        let tdd = TddClassification::default();\n\n        // Default should be CodeImplementation\n        assert_eq!(tdd.entity_class, EntityClass::CodeImplementation);\n    }",
      "current_ind": 1,
      "entity_name": "test_tdd_classification_has_entity_class_field",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tdd_classification_has_entity_class_field\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1391,\"end\":1397},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tdd_classification_has_entity_class_field:__crates_parseltongue-core_src_entities_rs:1391-1397",
      "line_number": 0
    },
    {
      "current_code": "async fn test_temporal_state_transitions() -> Result<()> {\n    let mut storage = CozoDbStorage::new(\"mem\").await?;\n    storage.create_schema().await?;\n\n    // Create test entity in (1,1) state - unchanged\n    let entity = create_simple_test_entity(\"test-unchanged\");\n    storage.insert_entity(&entity).await?;\n\n    let retrieved = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(retrieved.temporal_state.current_ind, true);\n    assert_eq!(retrieved.temporal_state.future_ind, true);\n    assert_eq!(retrieved.temporal_state.future_action, None);\n\n    // Transition to (1,1) with Edit - modified\n    let mut modified = retrieved.clone();\n    modified.future_code = Some(\"new code\".to_string());\n    modified.temporal_state.future_action = Some(TemporalAction::Edit);\n    storage.update_entity(modified).await?;\n\n    let after_edit = storage.get_entity(&entity.isgl1_key).await?;\n    assert_eq!(after_edit.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(after_edit.future_code, Some(\"new code\".to_string()));\n\n    println!(\" Temporal state transitions validated\");\n    Ok(())\n}",
      "current_ind": 1,
      "entity_name": "test_temporal_state_transitions",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_temporal_state_transitions\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":311,\"end\":336},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_temporal_state_transitions:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:311-336",
      "line_number": 0
    },
    {
      "current_code": "async fn test_temporal_state_update() {\n    // RED: Temporal update not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity with unchanged state\n    let entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Update temporal state: (1,1)  (1,0) for delete\n    db.update_temporal_state(\n        \"test-file-rs-TestStruct\",\n        false, // future_ind\n        Some(TemporalAction::Delete),\n    ).await.unwrap();\n\n    // Verify update\n    let updated = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(updated.temporal_state.current_ind, true);\n    assert_eq!(updated.temporal_state.future_ind, false);\n    assert_eq!(updated.temporal_state.future_action, Some(TemporalAction::Delete));\n}",
      "current_ind": 1,
      "entity_name": "test_temporal_state_update",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_temporal_state_update\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":79,\"end\":100},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_temporal_state_update:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:79-100",
      "line_number": 0
    },
    {
      "current_code": "    fn test_test_detection_performance_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        // Large file content to test performance\n        let content = \"fn regular_function() { }\\n\".repeat(1000);\n        let test_path = Path::new(\"src/lib.rs\");\n        \n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            detector.detect_test_from_path_and_name(test_path, &content);\n        }\n        let elapsed = start.elapsed();\n        \n        // Performance contract: <20s per detection\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(20),\n                \"Test detection took {:?}, expected <20s\", avg_time_per_check);\n    }",
      "current_ind": 1,
      "entity_name": "test_test_detection_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_test_detection_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":286,\"end\":303},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_test_detection_performance_contract:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:286-303",
      "line_number": 0
    },
    {
      "current_code": "    fn test_test_detection_performance_contract() {\n        // Given: Large file content\n        let content = \"fn regular_function() { }\\n\".repeat(1000);\n        let test_path = PathBuf::from(\"src/lib.rs\");\n        \n        // When: Detecting test status\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            detect_test_from_content(&test_path, &content);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<50s per detection - adjusted for reality)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(50),\n                \"Test detection took {:?}, expected <50s\", avg_time_per_check);\n    }",
      "current_ind": 1,
      "entity_name": "test_test_detection_performance_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_test_detection_performance_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":290,\"end\":306},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_test_detection_performance_contract:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:290-306",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool1_tool2_integration() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Step 1: Tool 1 indexes 3 entities\n    let entity1 = create_test_entity(\"function_to_edit\", \"src/main.rs\", (10, 20));\n    let entity2 = create_test_entity(\"function_to_delete\", \"src/main.rs\", (30, 40));\n    let entity3 = create_test_entity(\"function_unchanged\", \"src/main.rs\", (50, 60));\n\n    let key1 = entity1.isgl1_key.clone();\n    let key2 = entity2.isgl1_key.clone();\n    let key3 = entity3.isgl1_key.clone();\n\n    storage.insert_entity(&entity1).await.unwrap();\n    storage.insert_entity(&entity2).await.unwrap();\n    storage.insert_entity(&entity3).await.unwrap();\n\n    // Verify all start with initial state (1,0,None)\n    for key in &[&key1, &key2, &key3] {\n        let e = storage.get_entity(key).await.unwrap();\n        assert_eq!(e.temporal_state.current_ind, true);\n        assert_eq!(e.temporal_state.future_ind, false);\n        assert_eq!(e.temporal_state.future_action, None);\n    }\n\n    // Step 2: Tool 2 edits entity1\n    storage\n        .update_temporal_state(&key1, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Step 3: Tool 2 deletes entity2\n    storage\n        .update_temporal_state(&key2, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Step 4: Tool 2 creates new entity\n    let new_key = CodeEntity::generate_new_entity_key(\n        \"src/new.rs\",\n        \"newly_created\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"newly_created\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new.rs\"),\n        line_range: LineRange::new(1, 5).unwrap(),\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(new_key.clone(), signature).unwrap();\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn newly_created() {}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Step 5: Verify final states\n    let e1 = storage.get_entity(&key1).await.unwrap();\n    assert_eq!(e1.temporal_state.current_ind, true, \"Entity1 should exist in current\");\n    assert_eq!(e1.temporal_state.future_ind, true, \"Entity1 should exist in future\");\n    assert_eq!(e1.temporal_state.future_action, Some(TemporalAction::Edit), \"Entity1 should be marked for Edit\");\n\n    let e2 = storage.get_entity(&key2).await.unwrap();\n    assert_eq!(e2.temporal_state.current_ind, true, \"Entity2 should exist in current\");\n    assert_eq!(e2.temporal_state.future_ind, false, \"Entity2 should NOT exist in future\");\n    assert_eq!(e2.temporal_state.future_action, Some(TemporalAction::Delete), \"Entity2 should be marked for Delete\");\n\n    let e3 = storage.get_entity(&key3).await.unwrap();\n    assert_eq!(e3.temporal_state.current_ind, true);\n    assert_eq!(e3.temporal_state.future_ind, false);\n    assert_eq!(e3.temporal_state.future_action, None, \"Entity3 should remain unchanged\");\n\n    let e4 = storage.get_entity(&new_key).await.unwrap();\n    assert_eq!(e4.temporal_state.current_ind, false, \"New entity should NOT exist in current\");\n    assert_eq!(e4.temporal_state.future_ind, true, \"New entity should exist in future\");\n    assert_eq!(e4.temporal_state.future_action, Some(TemporalAction::Create), \"New entity should be marked for Create\");\n\n    // Verify get_changed_entities returns 3 entities (Edit, Delete, Create)\n    let changed = storage.get_changed_entities().await.unwrap();\n    assert_eq!(changed.len(), 3, \"Should have 3 entities with pending changes\");\n}",
      "current_ind": 1,
      "entity_name": "test_tool1_tool2_integration",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool1_tool2_integration\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":221,\"end\":321},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool1_tool2_integration:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:221-321",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool2_create_operation_with_hash_key() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Execute: Tool 2 Create operation with hash-based key\n    let hash_key = CodeEntity::generate_new_entity_key(\n        \"src/new_feature.rs\",\n        \"new_awesome_function\",\n        &EntityType::Function,\n        chrono::Utc::now(),\n    );\n\n    let signature = InterfaceSignature {\n        entity_type: EntityType::Function,\n        name: \"new_awesome_function\".to_string(),\n        visibility: Visibility::Public,\n        file_path: PathBuf::from(\"src/new_feature.rs\"),\n        line_range: LineRange::new(1, 10).unwrap(), // Temporary lines\n        module_path: vec![],\n        documentation: None,\n        language_specific: LanguageSpecificSignature::Rust(RustSignature {\n            generics: vec![],\n            lifetimes: vec![],\n            where_clauses: vec![],\n            attributes: vec![],\n            trait_impl: None,\n        }),\n    };\n\n    let mut new_entity = CodeEntity::new(hash_key.clone(), signature).unwrap();\n\n    // Set Create state manually (simulating Tool 2 logic)\n    new_entity.temporal_state.current_ind = false;\n    new_entity.temporal_state.future_ind = true;\n    new_entity.temporal_state.future_action = Some(TemporalAction::Create);\n    new_entity.future_code = Some(\"fn new_awesome_function() {\\n    // LLM-generated code\\n}\".to_string());\n\n    storage.insert_entity(&new_entity).await.unwrap();\n\n    // Verify: Create state (0,1,Create)\n    let created = storage.get_entity(&hash_key).await.unwrap();\n    assert_eq!(created.temporal_state.current_ind, false, \"Should NOT exist in current\");\n    assert_eq!(created.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        created.temporal_state.future_action,\n        Some(TemporalAction::Create),\n        \"Should be marked for Create\"\n    );\n    assert!(created.future_code.is_some(), \"Should have future_code\");\n\n    // Verify hash key format\n    assert!(hash_key.contains(\"src_new_feature_rs\"), \"Should have sanitized filepath\");\n    assert!(hash_key.contains(\"new_awesome_function\"), \"Should have entity name\");\n    assert!(hash_key.contains(\"-fn-\"), \"Should have entity type\");\n    assert!(hash_key.matches('-').count() >= 3, \"Should have at least 3 dashes (path-name-type-hash)\");\n}",
      "current_ind": 1,
      "entity_name": "test_tool2_create_operation_with_hash_key",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool2_create_operation_with_hash_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":149,\"end\":210},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool2_create_operation_with_hash_key:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:149-210",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool2_delete_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1\n    let entity = create_test_entity(\"deprecated_function\", \"src/old.rs\", (20, 25));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Execute: Tool 2 Delete operation\n    storage\n        .update_temporal_state(&key, false, Some(TemporalAction::Delete))\n        .await\n        .unwrap();\n\n    // Verify: Delete state (1,0,Delete)\n    let deleted = storage.get_entity(&key).await.unwrap();\n    assert_eq!(deleted.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(deleted.temporal_state.future_ind, false, \"Should NOT exist in future\");\n    assert_eq!(\n        deleted.temporal_state.future_action,\n        Some(TemporalAction::Delete),\n        \"Should be marked for Delete\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_tool2_delete_operation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool2_delete_operation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":108,\"end\":138},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool2_delete_operation:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:108-138",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool2_edit_operation() {\n    let temp_dir = TempDir::new().unwrap();\n    let db_path = temp_dir.path().join(\"test.db\");\n    let mut storage = CozoDbStorage::new(&format!(\"rocksdb:{}\", db_path.display()))\n        .await\n        .unwrap();\n\n    // Create schema\n    storage.create_schema().await.unwrap();\n\n    // Setup: Insert entity via Tool 1 (initial state: 1,0,None)\n    let entity = create_test_entity(\"calculate_sum\", \"src/lib.rs\", (10, 15));\n    let key = entity.isgl1_key.clone();\n    storage.insert_entity(&entity).await.unwrap();\n\n    // Verify initial state from Tool 1\n    let initial = storage.get_entity(&key).await.unwrap();\n    assert_eq!(initial.temporal_state.current_ind, true, \"Should exist in current\");\n    assert_eq!(initial.temporal_state.future_ind, false, \"Future unknown initially\");\n    assert_eq!(initial.temporal_state.future_action, None);\n\n    // Execute: Tool 2 Edit operation\n    storage\n        .update_temporal_state(&key, true, Some(TemporalAction::Edit))\n        .await\n        .unwrap();\n\n    // Set future_code (simulating LLM generation)\n    let mut updated = storage.get_entity(&key).await.unwrap();\n    updated.future_code = Some(format!(\"fn calculate_sum() {{\\n    // LLM-improved code\\n}}\"));\n    storage.update_entity(updated).await.unwrap();\n\n    // Verify: Edit state (1,1,Edit)\n    let edited = storage.get_entity(&key).await.unwrap();\n    assert_eq!(edited.temporal_state.current_ind, true, \"Should still exist in current\");\n    assert_eq!(edited.temporal_state.future_ind, true, \"Should exist in future\");\n    assert_eq!(\n        edited.temporal_state.future_action,\n        Some(TemporalAction::Edit),\n        \"Should be marked for Edit\"\n    );\n    assert!(edited.future_code.is_some(), \"Should have future_code\");\n    assert_ne!(edited.future_code, edited.current_code, \"Future should differ from current\");\n}",
      "current_ind": 1,
      "entity_name": "test_tool2_edit_operation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool2_temporal_operations.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool2_edit_operation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool2_temporal_operations.rs\",\"line_range\":{\"start\":55,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool2_edit_operation:__crates_parseltongue-core_tests_tool2_temporal_operations_rs:55-98",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool3_filters_by_current_ind() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let all_entities = storage.get_all_entities().await.unwrap();\n\n    println!(\"\\n=== TEMPORAL STATE FILTERING TEST ===\");\n    println!(\"Total entities in database: {}\", all_entities.len());\n\n    // Count by temporal state\n    let current_only = all_entities\n        .iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .count();\n\n    let future_only = all_entities\n        .iter()\n        .filter(|e| !e.temporal_state.current_ind && e.temporal_state.future_ind)\n        .count();\n\n    println!(\"current_ind=1: {}\", current_only);\n    println!(\"future_only (current_ind=0, future_ind=1): {}\", future_only);\n\n    // After Tool 1 indexing, all entities should be current_ind=1, future_ind=0\n    // (Tool 2 hasn't created any future-only entities yet)\n    assert_eq!(\n        current_only,\n        all_entities.len(),\n        \"All entities from Tool 1 should have current_ind=1\"\n    );\n\n    // Tool 3 context should include ALL these entities\n    let context_entities: Vec<_> = all_entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    assert_eq!(\n        context_entities.len(),\n        current_only,\n        \"Tool 3 should include all current_ind=1 entities\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_tool3_filters_by_current_ind",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool3_filters_by_current_ind\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool3_prd_compliance.rs\",\"line_range\":{\"start\":254,\"end\":296},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool3_filters_by_current_ind:__crates_parseltongue-core_tests_tool3_prd_compliance_rs:254-296",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool3_includes_tdd_classification() {\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path).await.unwrap();\n\n    let entities = storage.get_all_entities().await.unwrap();\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    // Count TDD classifications\n    let test_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::TestImplementation\n            )\n        })\n        .count();\n\n    let code_count = current_entities\n        .iter()\n        .filter(|e| {\n            matches!(\n                e.tdd_classification.entity_class,\n                EntityClass::CodeImplementation\n            )\n        })\n        .count();\n\n    println!(\"\\n=== TDD CLASSIFICATION IN TOOL 3 CONTEXT ===\");\n    println!(\"Test entities: {}\", test_count);\n    println!(\"Code entities: {}\", code_count);\n    println!(\"Total: {}\", current_entities.len());\n\n    // Verify: Should have test entities (Tool 1 fix validation)\n    assert!(\n        test_count > 100,\n        \"Should have >100 test entities, got {}\",\n        test_count\n    );\n    assert!(\n        code_count > 300,\n        \"Should have >300 code entities, got {}\",\n        code_count\n    );\n\n    // Create sample context entity to verify serialization\n    let sample_entity = &current_entities[0];\n    let context_entity = ContextEntity {\n        isgl1_key: sample_entity.isgl1_key.clone(),\n        interface_signature: serde_json::to_value(&sample_entity.interface_signature).unwrap(),\n        entity_class: format!(\"{:?}\", sample_entity.tdd_classification.entity_class),\n        lsp_metadata: sample_entity.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n        // temporal_state excluded per PRD\n        // Full tdd_classification excluded - only entity_class needed\n    };\n\n    let json = serde_json::to_string_pretty(&context_entity).unwrap();\n    println!(\"\\nSample entity JSON:\\n{}\", json);\n\n    // Verify entity_class is serialized (simplified TDD classification)\n    assert!(json.contains(\"entity_class\"));\n}",
      "current_ind": 1,
      "entity_name": "test_tool3_includes_tdd_classification",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool3_includes_tdd_classification\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool3_prd_compliance.rs\",\"line_range\":{\"start\":183,\"end\":247},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool3_includes_tdd_classification:__crates_parseltongue-core_tests_tool3_prd_compliance_rs:183-247",
      "line_number": 0
    },
    {
      "current_code": "async fn test_tool3_pure_data_extraction_no_llm() {\n    // Setup: Connect to real parseltongue database from Tool 1\n    let db_path = \"rocksdb:/tmp/parseltongue-rigorous-test.db\";\n    let storage = CozoDbStorage::new(db_path)\n        .await\n        .expect(\"Failed to connect to parseltongue database\");\n\n    // Execute: Pure data extraction (no LLM)\n    let entities = storage\n        .get_all_entities()\n        .await\n        .expect(\"Failed to query entities\");\n\n    println!(\"\\n=== TOOL 3 PRD COMPLIANCE TEST ===\\n\");\n    println!(\"Total entities in database: {}\", entities.len());\n\n    // Filter: Only current_ind=1 per PRD (line 122)\n    let current_entities: Vec<_> = entities\n        .into_iter()\n        .filter(|e| e.temporal_state.current_ind)\n        .collect();\n\n    println!(\"Entities with current_ind=1: {}\", current_entities.len());\n\n    // Verify: Should have 542 entities from Tool 1 indexing\n    assert!(\n        current_entities.len() > 500,\n        \"Expected >500 current entities from parseltongue codebase, got {}\",\n        current_entities.len()\n    );\n\n    // Transform: Strip code fields per PRD (line 123-128)\n    // Include ONLY: ISGL1 + interface_signature + TDD_Classification (simplified) + lsp_meta_data\n    let context_entities: Vec<ContextEntity> = current_entities\n        .iter()\n        .map(|e| ContextEntity {\n            isgl1_key: e.isgl1_key.clone(),\n            interface_signature: serde_json::to_value(&e.interface_signature).unwrap(),\n            entity_class: format!(\"{:?}\", e.tdd_classification.entity_class), // Test vs CodeImplementation\n            lsp_metadata: e.lsp_metadata.as_ref().map(|m| serde_json::to_value(m).unwrap()),\n            // temporal_state excluded - not in PRD (P01:128)\n            // Full tdd_classification excluded - only entity_class needed (ultra-minimalist)\n        })\n        .collect();\n\n    // Estimate tokens (rough approximation: 1 token  4 characters)\n    let json_output = serde_json::to_string_pretty(&context_entities).unwrap();\n    let estimated_tokens = json_output.len() / 4;\n\n    println!(\"JSON output size: {} bytes\", json_output.len());\n    println!(\"Estimated tokens: {} tokens\", estimated_tokens);\n\n    // Verify: No current_code or future_code as TOP-LEVEL entity fields (before moving context_entities)\n    // Note: Interface signatures may contain function names \"current_code\"/\"future_code\" (which is fine)\n    // We need to check the entity structure doesn't have these as code content fields\n    let sample_json = serde_json::to_value(&context_entities[0]).unwrap();\n    let entity_keys: Vec<String> = sample_json.as_object()\n        .unwrap()\n        .keys()\n        .map(|k| k.to_string())\n        .collect();\n\n    assert!(\n        !entity_keys.contains(&\"current_code\".to_string()),\n        \"Entity MUST NOT have current_code field (PRD violation at P01:123-126)\"\n    );\n    assert!(\n        !entity_keys.contains(&\"future_code\".to_string()),\n        \"Entity MUST NOT have future_code field (PRD violation at P01:123-126)\"\n    );\n\n    // Create CodeGraphContext per PRD specification\n    let context = CodeGraphContext {\n        entities: context_entities,\n        entity_count: current_entities.len(),\n        token_count: estimated_tokens,\n        generated_at: chrono::Utc::now().to_rfc3339(),\n    };\n\n    // Write output for analysis\n    let output_path = PathBuf::from(\"/tmp/CodeGraphContext.json\");\n    let context_json = serde_json::to_string_pretty(&context).unwrap();\n    std::fs::write(&output_path, &context_json).expect(\"Failed to write output\");\n    println!(\"Output written to: {} for analysis\", output_path.display());\n\n    // Verify: Contains required fields per PRD (P01:128)\n    assert!(\n        json_output.contains(\"\\\"isgl1_key\\\"\"),\n        \"Output must contain isgl1_key\"\n    );\n    assert!(\n        json_output.contains(\"\\\"interface_signature\\\"\"),\n        \"Output must contain interface_signature\"\n    );\n    assert!(\n        json_output.contains(\"\\\"entity_class\\\"\"),\n        \"Output must contain entity_class (simplified TDD_Classification)\"\n    );\n\n    // Verify: Token limit per PRD (line 115: <100k tokens)\n    assert!(\n        estimated_tokens < 100_000,\n        \"Context exceeds 100k token limit: {} tokens (PRD violation at P01:115)\",\n        estimated_tokens\n    );\n\n    println!(\"\\n Tool 3 PRD Compliance Validated:\");\n    println!(\"   - Pure data extraction (no LLM required)\");\n    println!(\"   - Only current_ind=1 entities included\");\n    println!(\"   - current_code/future_code excluded\");\n    println!(\"   - Token count: {} < 100k limit\", estimated_tokens);\n    println!(\"   - Output written to: {}\", output_path.display());\n}",
      "current_ind": 1,
      "entity_name": "test_tool3_pure_data_extraction_no_llm",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_tool3_pure_data_extraction_no_llm\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool3_prd_compliance.rs\",\"line_range\":{\"start\":64,\"end\":176},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_tool3_pure_data_extraction_no_llm:__crates_parseltongue-core_tests_tool3_prd_compliance_rs:64-176",
      "line_number": 0
    },
    {
      "current_code": "async fn test_trait_impl_dependencies_extracted_via_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"traits.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\ntrait Validator {\n    fn validate(&self) -> bool;\n}\n\nstruct EmailValidator {\n    pattern: String,\n}\n\nimpl Validator for EmailValidator {\n    fn validate(&self) -> bool {\n        true\n    }\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // Should have trait, struct, and impl block entities\n    assert!(entities.len() >= 3, \"Should extract trait, struct, and impl\");\n\n    // RED: Current implementation doesn't capture trait implementations\n    // GREEN: After adding impl queries, should have Implements edge\n    let impl_deps: Vec<_> = dependencies.iter()\n        .filter(|dep| {\n            dep.from_key.as_str().contains(\"EmailValidator\") && dep.to_key.as_str().contains(\"Validator\")\n        })\n        .collect();\n\n    assert!(\n        impl_deps.len() >= 1,\n        \"Should have Implements edge: EmailValidator -> Validator\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_trait_impl_dependencies_extracted_via_queries",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_trait_impl_dependencies_extracted_via_queries\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":188,\"end\":247},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_trait_impl_dependencies_extracted_via_queries:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:188-247",
      "line_number": 0
    },
    {
      "current_code": "async fn test_trait_method_calls() {\n    let source = r#\"\nfn stringify(value: i32) -> String {\n    let s = value.to_string();\n    let c = s.clone();\n    c\n}\n\"#;\n\n    let deps = extract_dependencies(source).await;\n\n    println!(\"\\n=== Trait Method Calls ===\");\n    print_dependencies(&deps);\n\n    // Should capture method calls syntactically\n    assert!(has_call(&deps, \"to_string\"), \"Should capture to_string() call\");\n    assert!(has_call(&deps, \"clone\"), \"Should capture clone() call\");\n\n    println!(\"Note: Trait resolution (which trait provides the method) requires semantic analysis\");\n}",
      "current_ind": 1,
      "entity_name": "test_trait_method_calls",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_trait_method_calls\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/complex_rust_patterns_test.rs\",\"line_range\":{\"start\":323,\"end\":342},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_trait_method_calls:__crates_pt01-folder-to-cozodb-streamer_tests_complex_rust_patterns_test_rs:323-342",
      "line_number": 0
    },
    {
      "current_code": "async fn test_transitive_closure_branching() {\n    // RED: Transitive closure with diamond pattern\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create diamond: A -> B, A -> C, B -> D, C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D] (D counted once despite two paths)\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_transitive_closure_branching",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_transitive_closure_branching\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":746,\"end\":787},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_transitive_closure_branching:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:746-787",
      "line_number": 0
    },
    {
      "current_code": "async fn test_transitive_closure_chain() {\n    // RED: Transitive closure for simple chain\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create: A -> B -> C -> D\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:D:test_rs:30-35\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: All reachable from A should be [B, C, D]\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, D from A\");\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_transitive_closure_chain",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_transitive_closure_chain\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":708,\"end\":743},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_transitive_closure_chain:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:708-743",
      "line_number": 0
    },
    {
      "current_code": "async fn test_transitive_closure_cycle() {\n    // RED: Transitive closure must handle cycles correctly\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Create cycle: A -> B -> C -> A (should not infinite loop)\n    let edges = vec![\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:A:test_rs:1-5\")\n            .to_key(\"rust:fn:B:test_rs:10-15\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:B:test_rs:10-15\")\n            .to_key(\"rust:fn:C:test_rs:20-25\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n        DependencyEdge::builder()\n            .from_key(\"rust:fn:C:test_rs:20-25\")\n            .to_key(\"rust:fn:A:test_rs:1-5\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap(),\n    ];\n    db.insert_edges_batch(&edges).await.unwrap();\n\n    // Query: Should return B, C, A (the cycle) without hanging\n    let reachable = db.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n\n    // In a cycle, all nodes are reachable from any node (including starting node via cycle)\n    assert_eq!(reachable.len(), 3, \"Should reach B, C, and A (cycle)\");\n    assert!(reachable.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_transitive_closure_cycle",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_transitive_closure_cycle\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":790,\"end\":826},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_transitive_closure_cycle:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:790-826",
      "line_number": 0
    },
    {
      "current_code": "async fn test_transitive_closure_empty() {\n    // RED: Entity with no outgoing edges\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Query entity with no dependencies\n    let reachable = db.get_transitive_closure(\"rust:fn:X:test_rs:1-5\").await.unwrap();\n\n    assert_eq!(reachable.len(), 0, \"No outgoing edges means empty closure\");\n}",
      "current_ind": 1,
      "entity_name": "test_transitive_closure_empty",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_transitive_closure_empty\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":829,\"end\":838},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_transitive_closure_empty:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:829-838",
      "line_number": 0
    },
    {
      "current_code": "async fn test_transitive_closure_performance_1k_nodes() {\n    // RED: Validate transitive closure performance on medium graph\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_dependency_edges_schema().await.unwrap();\n\n    // Generate 1k node graph (smaller for unbounded query)\n    println!(\"Generating 1k node test graph...\");\n    let nodes = generate_large_graph(&db, 1_000, 3).await;\n\n    // Warm up\n    let _ = db.get_transitive_closure(&nodes[0]).await.unwrap();\n\n    // Performance test: Unbounded transitive closure\n    println!(\"Running transitive closure query (unbounded on 1k nodes)...\");\n    let start = Instant::now();\n    let result = db.get_transitive_closure(&nodes[0]).await.unwrap();\n    let elapsed = start.elapsed();\n\n    println!(\n        \"Transitive closure returned {} nodes in {:?}\",\n        result.len(),\n        elapsed\n    );\n\n    // Performance expectation: <100ms for 1k nodes unbounded\n    assert!(\n        elapsed < Duration::from_millis(100),\n        \"Transitive closure took {:?}, expected <100ms for 1k nodes\",\n        elapsed\n    );\n\n    // Verify correctness\n    assert!(\n        result.len() > 0,\n        \"Should find reachable nodes in connected graph\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_transitive_closure_performance_1k_nodes",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_transitive_closure_performance_1k_nodes\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":942,\"end\":978},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_transitive_closure_performance_1k_nodes:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:942-978",
      "line_number": 0
    },
    {
      "current_code": "fn test_type_error_passes_syntax_check() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    // This has a type error (returns i32, not String) but is syntactically valid\n    let type_error_code = r#\"\n        fn broken() -> String {\n            42  // Type error, but syntax is valid\n        }\n    \"#;\n\n    let result = validator.validate_syntax(type_error_code, Language::Rust).expect(\"Validation failed\");\n    assert!(\n        result.is_valid,\n        \"Type errors should pass syntax validation (cargo catches these)\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_type_error_passes_syntax_check",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_type_error_passes_syntax_check\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":120,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_type_error_passes_syntax_check:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:120-135",
      "line_number": 0
    },
    {
      "current_code": "    fn test_unknown_file_extensions_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let result = detector.detect_test_from_path_and_name(\n            Path::new(\"unknown.xyz\"), \n            \"some content\"\n        );\n        \n        // Unknown extensions should be treated as non-test files\n        assert_eq!(result, EntityClass::Code);\n    }",
      "current_ind": 1,
      "entity_name": "test_unknown_file_extensions_contract",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_unknown_file_extensions_contract\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":307,\"end\":317},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_unknown_file_extensions_contract:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:307-317",
      "line_number": 0
    },
    {
      "current_code": "async fn test_update_entity() {\n    // RED: Update operation not implemented\n    let db = CozoDbStorage::new(\"mem\").await.unwrap();\n    db.create_schema().await.unwrap();\n\n    // Insert entity\n    let mut entity = create_test_entity();\n    db.insert_entity(&entity).await.unwrap();\n\n    // Modify entity\n    entity.apply_temporal_change(\n        TemporalAction::Edit,\n        Some(\"struct TestStruct { field: i32 }\".to_string())\n    ).unwrap();\n\n    // Update in database\n    db.update_entity_internal(&entity).await.unwrap();\n\n    // Verify update\n    let retrieved = db.get_entity(\"test-file-rs-TestStruct\").await.unwrap();\n    assert_eq!(retrieved.temporal_state.future_action, Some(TemporalAction::Edit));\n    assert_eq!(retrieved.future_code, Some(\"struct TestStruct { field: i32 }\".to_string()));\n}",
      "current_ind": 1,
      "entity_name": "test_update_entity",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_update_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/cozo_storage_integration_tests.rs\",\"line_range\":{\"start\":129,\"end\":151},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_update_entity:__crates_parseltongue-core_tests_cozo_storage_integration_tests_rs:129-151",
      "line_number": 0
    },
    {
      "current_code": "async fn test_use_declarations_extracted_via_queries() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"imports.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\nfn create_config() -> HashMap<String, PathBuf> {\n    HashMap::new()\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    }\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let dependencies = storage.get_all_dependencies().await.unwrap();\n\n    // RED: Current implementation doesn't capture use declarations\n    // GREEN: After adding dependency queries, should have Import edges\n    let import_deps: Vec<_> = dependencies.iter()\n        .filter(|dep| dep.to_key.as_str().contains(\"HashMap\") || dep.to_key.as_str().contains(\"PathBuf\"))\n        .collect();\n\n    assert!(\n        import_deps.len() >= 1,\n        \"Should capture use declarations as Import dependencies. Found: {}\",\n        import_deps.len()\n    );\n}",
      "current_ind": 1,
      "entity_name": "test_use_declarations_extracted_via_queries",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_use_declarations_extracted_via_queries\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_dependency_extraction_test.rs\",\"line_range\":{\"start\":129,\"end\":176},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_use_declarations_extracted_via_queries:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_dependency_extraction_test_rs:129-176",
      "line_number": 0
    },
    {
      "current_code": "fn test_valid_function_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        fn calculate_sum(a: i32, b: i32) -> i32 {\n            a + b\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid function should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
      "current_ind": 1,
      "entity_name": "test_valid_function_syntax",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_valid_function_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":10,\"end\":22},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_valid_function_syntax:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:10-22",
      "line_number": 0
    },
    {
      "current_code": "fn test_valid_impl_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        impl MyStruct {\n            pub fn new() -> Self {\n                Self {}\n            }\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid impl should pass syntax check\");\n}",
      "current_ind": 1,
      "entity_name": "test_valid_impl_syntax",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_valid_impl_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":76,\"end\":89},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_valid_impl_syntax:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:76-89",
      "line_number": 0
    },
    {
      "current_code": "fn test_valid_struct_syntax() {\n    let mut validator = SimpleSyntaxValidator::new().expect(\"Failed to create validator\");\n\n    let valid_code = r#\"\n        pub struct Config {\n            pub timeout: u64,\n            pub retries: usize,\n        }\n    \"#;\n\n    let result = validator.validate_syntax(valid_code, Language::Rust).expect(\"Validation failed\");\n    assert!(result.is_valid, \"Valid struct should pass syntax check\");\n    assert!(result.errors.is_empty(), \"Should have no errors\");\n}",
      "current_ind": 1,
      "entity_name": "test_valid_struct_syntax",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_valid_struct_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/tests/simple_syntax_validation_tests.rs\",\"line_range\":{\"start\":42,\"end\":55},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_valid_struct_syntax:__crates_pt04-syntax-preflight-validator_tests_simple_syntax_validation_tests_rs:42-55",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_validate_all_stops_on_first_failure() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn broken_function( {\n                // Syntax error - should stop early\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(!report.overall_valid);\n        // Should only have syntax validation result (fail-fast)\n        assert_eq!(report.individual_results.len(), 1);\n    }",
      "current_ind": 1,
      "entity_name": "test_validate_all_stops_on_first_failure",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validate_all_stops_on_first_failure\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":184,\"end\":198},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validate_all_stops_on_first_failure:__crates_pt04-syntax-preflight-validator_src_validator_rs:184-198",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_validate_all_success() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn add(a: i32, b: i32) -> i32 {\n                a + b\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(report.overall_valid);\n        // Should have all 5 validation results\n        assert_eq!(report.individual_results.len(), 5);\n    }",
      "current_ind": 1,
      "entity_name": "test_validate_all_success",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validate_all_success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":201,\"end\":215},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validate_all_success:__crates_pt04-syntax-preflight-validator_src_validator_rs:201-215",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_validate_syntax_invalid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main( {\n                // Missing closing parenthesis\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(!output.is_valid);\n        assert!(output.errors.len() > 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_validate_syntax_invalid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validate_syntax_invalid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":168,\"end\":181},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validate_syntax_invalid_code:__crates_pt04-syntax-preflight-validator_src_validator_rs:168-181",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_validate_syntax_valid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main() {\n                println!(\"Hello, world!\");\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(output.is_valid);\n        assert_eq!(output.validation_type, ValidationType::Syntax);\n        assert_eq!(output.errors.len(), 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_validate_syntax_valid_code",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validate_syntax_valid_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":151,\"end\":165},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validate_syntax_valid_code:__crates_pt04-syntax-preflight-validator_src_validator_rs:151-165",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validation_output_success() {\n        let output = ValidationOutput::success(ValidationType::Syntax);\n        assert!(output.is_valid);\n        assert_eq!(output.errors.len(), 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_output_success",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_output_success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":174,\"end\":178},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_output_success:__crates_pt04-syntax-preflight-validator_src_types_rs:174-178",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validation_report_aggregates_errors() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        let error1 = crate::errors::ValidationError::Parse(\"error 1\".to_string());\n        let error2 = crate::errors::ValidationError::Parse(\"error 2\".to_string());\n\n        report.add_result(ValidationOutput::failure(ValidationType::Syntax, error1));\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error2));\n\n        let all_errors = report.all_errors();\n        assert_eq!(all_errors.len(), 2);\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_report_aggregates_errors",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_report_aggregates_errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":195,\"end\":206},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_report_aggregates_errors:__crates_pt04-syntax-preflight-validator_src_types_rs:195-206",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validation_report_overall_status() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        // Add successful result\n        report.add_result(ValidationOutput::success(ValidationType::Syntax));\n        assert!(report.overall_valid);\n\n        // Add failed result\n        let error = crate::errors::ValidationError::Parse(\"test error\".to_string());\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error));\n        assert!(!report.overall_valid);\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_report_overall_status",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_report_overall_status\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":181,\"end\":192},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_report_overall_status:__crates_pt04-syntax-preflight-validator_src_types_rs:181-192",
      "line_number": 0
    },
    {
      "current_code": "    async fn test_validation_report_tracks_timing() {\n        let validator = DefaultRustValidator::new();\n        let code = \"fn main() {}\";\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n\n        // Timing should be tracked (even if zero for now)\n        assert!(report.total_execution_time_ms >= 0);\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_report_tracks_timing",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_report_tracks_timing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":218,\"end\":228},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_report_tracks_timing:__crates_pt04-syntax-preflight-validator_src_validator_rs:218-228",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validation_type_all() {\n        let types = ValidationType::all();\n        assert_eq!(types.len(), 5);\n        assert_eq!(types[0], ValidationType::Syntax);\n        assert_eq!(types[4], ValidationType::Test);\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_type_all",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_type_all\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":159,\"end\":164},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_type_all:__crates_pt04-syntax-preflight-validator_src_types_rs:159-164",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validation_type_up_to() {\n        let up_to_compilation = ValidationType::Compilation.up_to();\n        assert_eq!(up_to_compilation.len(), 4);\n        assert!(!up_to_compilation.contains(&ValidationType::Test));\n    }",
      "current_ind": 1,
      "entity_name": "test_validation_type_up_to",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validation_type_up_to\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":167,\"end\":171},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validation_type_up_to:__crates_pt04-syntax-preflight-validator_src_types_rs:167-171",
      "line_number": 0
    },
    {
      "current_code": "    fn test_validator_creation() {\n        let validator = SimpleSyntaxValidator::new();\n        assert!(validator.is_ok(), \"Should create validator successfully\");\n    }",
      "current_ind": 1,
      "entity_name": "test_validator_creation",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_validator_creation\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":178,\"end\":181},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_validator_creation:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:178-181",
      "line_number": 0
    },
    {
      "current_code": "    fn test_write_result_success() {\n        let result = WriteResult::success(\n            PathBuf::from(\"test.rs\"),\n            WriteOperation::Create,\n        );\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n    }",
      "current_ind": 1,
      "entity_name": "test_write_result_success",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_write_result_success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":113,\"end\":120},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_write_result_success:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:113-120",
      "line_number": 0
    },
    {
      "current_code": "    fn test_write_summary() {\n        let mut summary = WriteSummary::new();\n\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file1.rs\"),\n            WriteOperation::Create,\n        ));\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file2.rs\"),\n            WriteOperation::Edit,\n        ));\n\n        assert_eq!(summary.created, 1);\n        assert_eq!(summary.edited, 1);\n        assert_eq!(summary.total, 2);\n    }",
      "current_ind": 1,
      "entity_name": "test_write_summary",
      "entity_type": "function",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"test_write_summary\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":123,\"end\":138},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:test_write_summary:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:123-138",
      "line_number": 0
    },
    {
      "current_code": "        fn then<U, P>(self, other: P) -> Then<Self, P>\n        where\n            P: ParserCombinator<'a, U>,\n        {\n            Then { first: self, second: other }\n        }",
      "current_ind": 1,
      "entity_name": "then",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"then\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1157,\"end\":1162},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:then:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1157-1162",
      "line_number": 0
    },
    {
      "current_code": "async fn tokio_test_function_classified_correctly() {\n    let temp_dir = TempDir::new().unwrap();\n    let test_file = temp_dir.path().join(\"async_test.rs\");\n\n    std::fs::write(\n        &test_file,\n        r#\"\n#[tokio::test]\nasync fn test_async_function() {\n    assert_eq!(1 + 1, 2);\n}\n\"#,\n    )\n    .unwrap();\n\n    let db_path = temp_dir.path().join(\"test.db\");\n    let config = StreamerConfig {\n        root_dir: temp_dir.path().to_path_buf(),\n        db_path: format!(\"rocksdb:{}\", db_path.display()),\n        max_file_size: 1024 * 1024,\n        include_patterns: vec![\"*.rs\".to_string()],\n        exclude_patterns: vec![],\n        parsing_library: \"tree-sitter\".to_string(),\n        chunking: \"ISGL1\".to_string(),\n    };\n\n    {\n        let streamer = ToolFactory::create_streamer(config.clone()).await.unwrap();\n        let _result = streamer.stream_directory().await.unwrap();\n    } // Drop streamer to release database lock\n\n    let storage = CozoDbStorage::new(&config.db_path).await.unwrap();\n    let entities = storage.get_all_entities().await.unwrap();\n\n    assert_eq!(entities.len(), 1);\n    let test_entity = &entities[0];\n\n    // RED: Will fail with current implementation\n    assert_eq!(\n        test_entity.tdd_classification.entity_class,\n        EntityClass::TestImplementation,\n        \"#[tokio::test] function should be classified as TEST_IMPLEMENTATION\"\n    );\n}",
      "current_ind": 1,
      "entity_name": "tokio_test_function_classified_correctly",
      "entity_type": "function",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"tokio_test_function_classified_correctly\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/tests/tdd_classification_test.rs\",\"line_range\":{\"start\":102,\"end\":145},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:tokio_test_function_classified_correctly:__crates_pt01-folder-to-cozodb-streamer_tests_tdd_classification_test_rs:102-145",
      "line_number": 0
    },
    {
      "current_code": "    fn tool_metadata_creation() {\n        let metadata = ToolMetadata {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"A test tool\".to_string(),\n            supported_inputs: vec![\"test\".to_string()],\n            capabilities: ToolCapabilities {\n                async_execution: true,\n                parallel_processing: false,\n                incremental_processing: true,\n                requires_network: false,\n                max_input_size: Some(1024),\n            },\n        };\n\n        assert_eq!(metadata.id, \"test-tool\");\n        assert!(metadata.capabilities.async_execution);\n        assert!(!metadata.capabilities.parallel_processing);\n    }",
      "current_ind": 1,
      "entity_name": "tool_metadata_creation",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"tool_metadata_creation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":620,\"end\":639},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:tool_metadata_creation:__crates_parseltongue-core_src_interfaces_rs:620-639",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_all(&self, code: &str) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        // Run validations in order, stop on first failure\n        for validation_type in ValidationType::all() {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            // Stop on first failure (fail-fast for efficiency)\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
      "current_ind": 1,
      "entity_name": "validate_all",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validate_all\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":25,\"end\":48},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validate_all:__crates_pt04-syntax-preflight-validator_src_validator_rs:25-48",
      "line_number": 0
    },
    {
      "current_code": "fn validate_rust_syntax(code: &str) -> Result<ValidationResult> {\n    // Use syn crate for syntax validation\n    match syn::parse_file(code) {\n        Ok(_) => Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        }),\n        Err(e) => Ok(ValidationResult {\n            is_valid: false,\n            errors: vec![format!(\"Syntax error: {}\", e)],\n        }),\n    }\n}",
      "current_ind": 1,
      "entity_name": "validate_rust_syntax",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validate_rust_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":291,\"end\":303},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validate_rust_syntax:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:291-303",
      "line_number": 0
    },
    {
      "current_code": "fn validate_rust_syntax(code: &str) -> Result<bool> {\n    match syn::parse_file(code) {\n        Ok(_) => Ok(true),\n        Err(_) => Ok(false),\n    }\n}",
      "current_ind": 1,
      "entity_name": "validate_rust_syntax",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validate_rust_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":341,\"end\":346},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validate_rust_syntax:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:341-346",
      "line_number": 0
    },
    {
      "current_code": "fn validate_semantics(code: &str) -> Result<bool> {\n    // Check that the fix actually addresses the bug\n    let has_addition = code.contains(\"a + b\");\n    let no_subtraction_in_add = !code.contains(\"fn add\")\n        || !code[code.find(\"fn add\").unwrap()..].contains(\"a - b\");\n\n    Ok(has_addition && no_subtraction_in_add)\n}",
      "current_ind": 1,
      "entity_name": "validate_semantics",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validate_semantics\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/orchestrator_workflow_test.rs\",\"line_range\":{\"start\":349,\"end\":356},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validate_semantics:__crates_parseltongue-e2e-tests_tests_orchestrator_workflow_test_rs:349-356",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_specific(&self, code: &str, types: Vec<ValidationType>) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        for validation_type in types {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }",
      "current_ind": 1,
      "entity_name": "validate_specific",
      "entity_type": "function",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validate_specific\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":51,\"end\":72},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validate_specific:__crates_pt04-syntax-preflight-validator_src_validator_rs:51-72",
      "line_number": 0
    },
    {
      "current_code": "    fn validation_rules() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Test with invalid entity (missing code when current_ind=true)\n        let mut invalid_entity = CodeEntity::new(\n            \"invalid.rs-invalid\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"invalid\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"invalid.rs\"),\n                line_range: LineRange::new(1, 1).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            crate::entities::EntityClass::CodeImplementation,\n        ).unwrap();\n\n        invalid_entity.temporal_state.current_ind = true;\n        // current_code is None, which should cause validation to fail\n\n        let result = manager.add_entity(invalid_entity);\n        assert!(result.is_err());\n    }",
      "current_ind": 1,
      "entity_name": "validation_rules",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"validation_rules\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":688,\"end\":719},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:validation_rules:__crates_parseltongue-core_src_temporal_rs:688-719",
      "line_number": 0
    },
    {
      "current_code": "async fn verify_tool1_parseltongue_indexing() {\n    let storage = CozoDbStorage::new(\"rocksdb:/tmp/parseltongue-rigorous-test.db\")\n        .await\n        .expect(\"Failed to connect to test database\");\n\n    // Get all entities\n    let entities = storage.get_all_entities().await.expect(\"Failed to get entities\");\n\n    println!(\"\\n=== TOOL 1 DATA VERIFICATION ===\\n\");\n    println!(\"Total Entities: {}\", entities.len());\n    assert!(entities.len() > 500, \"Expected >500 entities from parseltongue codebase, got {}\", entities.len());\n\n    // Sample ISGL1 keys\n    println!(\"\\n--- Sample ISGL1 Keys (Line-Based Format Check) ---\");\n    for (i, entity) in entities.iter().take(10).enumerate() {\n        println!(\"{}. {}\", i+1, entity.isgl1_key);\n        println!(\"   Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"   Name: {}\", entity.interface_signature.name);\n        println!(\"   File: {}\", entity.interface_signature.file_path.display());\n        println!(\"   Lines: {}-{}\",\n            entity.interface_signature.line_range.start,\n            entity.interface_signature.line_range.end\n        );\n    }\n\n    // TDD Classification breakdown\n    println!(\"\\n--- TDD Classification Breakdown ---\");\n    let mut test_count = 0;\n    let mut code_count = 0;\n\n    for entity in &entities {\n        match entity.tdd_classification.entity_class {\n            parseltongue_core::entities::EntityClass::TestImplementation => test_count += 1,\n            parseltongue_core::entities::EntityClass::CodeImplementation => code_count += 1,\n            _ => {}\n        }\n    }\n\n    println!(\"TEST_IMPLEMENTATION: {}\", test_count);\n    println!(\"CODE_IMPLEMENTATION: {}\", code_count);\n    println!(\"Classification Rate: {:.1}%\", (test_count + code_count) as f64 / entities.len() as f64 * 100.0);\n\n    assert!(test_count > 0, \"Should have some test entities\");\n    assert!(code_count > 0, \"Should have some code entities\");\n\n    // Temporal state verification (should all be initial state after Tool 1)\n    println!(\"\\n--- Temporal State (should all be current_ind=1, future_ind=0) ---\");\n    let mut correct_state = 0;\n    for entity in &entities {\n        if entity.temporal_state.current_ind\n            && !entity.temporal_state.future_ind\n            && entity.temporal_state.future_action.is_none()\n        {\n            correct_state += 1;\n        }\n    }\n    println!(\"Correct Initial State: {}/{} ({:.1}%)\",\n        correct_state, entities.len(),\n        correct_state as f64 / entities.len() as f64 * 100.0\n    );\n\n    assert_eq!(correct_state, entities.len(),\n        \"All entities should have initial temporal state (1,0,None), but {}/{} were correct\",\n        correct_state, entities.len()\n    );\n\n    // Key format validation\n    println!(\"\\n--- ISGL1 Key Format Validation ---\");\n    let mut line_based_count = 0;\n    let mut potential_hash_based = 0;\n\n    for entity in &entities {\n        let key = &entity.isgl1_key;\n        // Line-based format check (very basic heuristic)\n        if key.contains(':') && key.contains('-') {\n            // Count colons - line-based should have multiple\n            let colon_count = key.matches(':').count();\n            if colon_count >= 2 {\n                line_based_count += 1;\n            } else {\n                potential_hash_based += 1;\n            }\n        }\n    }\n\n    println!(\"Likely line-based keys: {} ({:.1}%)\",\n        line_based_count,\n        line_based_count as f64 / entities.len() as f64 * 100.0\n    );\n\n    if potential_hash_based > 0 {\n        println!(\"Potential hash-based keys: {} ({:.1}%)\",\n            potential_hash_based,\n            potential_hash_based as f64 / entities.len() as f64 * 100.0\n        );\n    }\n\n    // Tool 1 should only create line-based keys (hash-based is for Tool 2 Create operations)\n    println!(\"\\nExpected: 100% line-based keys (Tool 1 indexes existing code only)\");\n\n    // Sample entity detail inspection\n    println!(\"\\n--- Detailed Entity Inspection ---\");\n    if let Some(entity) = entities.first() {\n        println!(\"First Entity:\");\n        println!(\"  ISGL1: {}\", entity.isgl1_key);\n        println!(\"  Name: {}\", entity.interface_signature.name);\n        println!(\"  Type: {:?}\", entity.interface_signature.entity_type);\n        println!(\"  Visibility: {:?}\", entity.interface_signature.visibility);\n        println!(\"  File: {}\", entity.interface_signature.file_path.display());\n        println!(\"  Lines: {:?}\", entity.interface_signature.line_range);\n        println!(\"  TDD Class: {:?}\", entity.tdd_classification.entity_class);\n        println!(\"  Temporal: (current={}, future={}, action={:?})\",\n            entity.temporal_state.current_ind,\n            entity.temporal_state.future_ind,\n            entity.temporal_state.future_action\n        );\n        println!(\"  Has Current Code: {}\", entity.current_code.is_some());\n        println!(\"  Has Future Code: {}\", entity.future_code.is_some());\n    }\n\n    // Find test entities\n    println!(\"\\n--- Sample Test Entities ---\");\n    let test_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::TestImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in test_entities.iter().enumerate() {\n        println!(\"{}. {} [{}]\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    // Find code entities\n    println!(\"\\n--- Sample Code Entities ---\");\n    let code_entities: Vec<_> = entities.iter()\n        .filter(|e| matches!(e.tdd_classification.entity_class,\n            parseltongue_core::entities::EntityClass::CodeImplementation))\n        .take(5)\n        .collect();\n\n    for (i, entity) in code_entities.iter().enumerate() {\n        println!(\"{}. {} [{:?}] in {}\",\n            i+1,\n            entity.interface_signature.name,\n            entity.interface_signature.entity_type,\n            entity.interface_signature.file_path.display()\n        );\n    }\n\n    println!(\"\\n Tool 1 verification complete!\\n\");\n}",
      "current_ind": 1,
      "entity_name": "verify_tool1_parseltongue_indexing",
      "entity_type": "function",
      "file_path": "./crates/parseltongue-core/tests/tool1_verification.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"verify_tool1_parseltongue_indexing\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool1_verification.rs\",\"line_range\":{\"start\":10,\"end\":164},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:verify_tool1_parseltongue_indexing:__crates_parseltongue-core_tests_tool1_verification_rs:10-164",
      "line_number": 0
    },
    {
      "current_code": "    fn visit_children(&mut self, node: &dyn Ast) -> Vec<Self::Output> {\n        node.children().iter().map(|child| child.accept(self)).collect()\n    }",
      "current_ind": 1,
      "entity_name": "visit_children",
      "entity_type": "function",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Function\",\"name\":\"visit_children\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":27,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:fn:visit_children:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:27-29",
      "line_number": 0
    },
    {
      "current_code": "    impl Parser for CParser {\n        type Input = String;\n        type Output = CAst;\n        type Error = CParseError;\n        type Config = CParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Implementation following Option 1, 2, or 3 from design doc\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "CParser",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":329,\"end\":344},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:329-344",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all edges.\"\n            ));\n        }\n\n        // Build config\n        let base_output = self.output.clone().unwrap_or_else(|| {\n            PathBuf::from(\"ISGLevel00.json\")\n        });\n        \n        // v0.9.0: Create dual outputs for code vs tests separation\n        let (code_output, tests_output) = if base_output.file_stem() == Some(std::ffi::OsStr::new(\"ISGLevel00\")) {\n            // Default case: create level00-code.json and level00-tests.json\n            (\n                PathBuf::from(\"level00-code.json\"),\n                PathBuf::from(\"level00-tests.json\"),\n            )\n        } else {\n            // Custom case: append -code and -tests to user provided base name\n            let stem = base_output.file_stem().unwrap_or_default();\n            let extension = base_output.extension().and_then(|s| s.to_str()).unwrap_or(\"json\");\n            \n            let code_path = base_output.with_file_name(format!(\"{}-code.{}\", stem.to_string_lossy(), extension));\n            let tests_path = base_output.with_file_name(format!(\"{}-tests.{}\", stem.to_string_lossy(), extension));\n            \n            (code_path, tests_path)\n        };\n\n        Ok(ExportConfig {\n            level: 0,\n            include_code: false,  // N/A for Level 0\n            where_filter: self.where_clause.clone(),\n            output_path: base_output,\n            // v0.9.0: Dual outputs for code/test separation\n            code_output_path: Some(code_output),\n            tests_output_path: Some(tests_output),\n            db_path: self.db.clone(),\n        })\n    }\n\n    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L0] {}\", message);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs\",\"line_range\":{\"start\":64,\"end\":113},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level00_rs:64-113",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all entities.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: 1,\n            include_code: self.include_code == 1,\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(\"ISGLevel01.json\")\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for level01)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }\n\n    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L1] {}\", message);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs\",\"line_range\":{\"start\":76,\"end\":105},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level01_rs:76-105",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all entities.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: 2,\n            include_code: self.include_code == 1,\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(\"ISGLevel02.json\")\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for level02)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }\n\n    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L2] {}\", message);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs\",\"line_range\":{\"start\":81,\"end\":110},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level02_rs:81-110",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    /// Validate CLI arguments and create ExportConfig\n    ///\n    /// # Validation Rules\n    ///\n    /// 1. Level 0: Must NOT have --include-code (edges only)\n    /// 2. Level 1-2: Must HAVE --include-code (entities need code flag)\n    /// 3. WHERE clause: Must be non-empty string\n    ///\n    /// # Returns\n    ///\n    /// `ExportConfig` ready for export operations\n    ///\n    /// # Errors\n    ///\n    /// - Level 0 with --include-code: \"Level 0 exports edges only, --include-code not applicable\"\n    /// - Level 1-2 without --include-code: \"Level N requires --include-code [0|1]\"\n    /// - Empty WHERE clause: \"WHERE clause cannot be empty\"\n    pub fn validate(&self) -> Result<ExportConfig> {\n        // Validate Level 0: Should NOT have include_code\n        if self.level == 0 && self.include_code.is_some() {\n            return Err(anyhow!(\n                \"Level 0 exports edges only (from_key, to_key, edge_type). \\\n                 --include-code flag not applicable. \\\n                 Remove --include-code for Level 0.\"\n            ));\n        }\n\n        // Validate Level 1-2: Must HAVE include_code\n        if self.level > 0 && self.include_code.is_none() {\n            return Err(anyhow!(\n                \"Level {} exports entities which may include code. \\\n                 --include-code [0|1] is MANDATORY. \\\n                 Use 0 for signatures only (cheap), 1 for full code (expensive).\",\n                self.level\n            ));\n        }\n\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow!(\n                \"WHERE clause cannot be empty. \\\n                 Use --where \\\"ALL\\\" to export all entities/edges.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: self.level,\n            include_code: self.include_code.map(|v| v == 1).unwrap_or(false),\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(format!(\"ISGLevel{:02}.json\", self.level))\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for general CLI)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }\n\n    /// Print verbose output if enabled\n    pub fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02] {}\", message);\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":98,\"end\":165},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:98-165",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    /// Parse command-line arguments\n    pub fn parse_args() -> Self {\n        Self::parse()\n    }\n\n    /// Validate that required arguments are present\n    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.code_snippet.is_none() && self.file.is_none() {\n            anyhow::bail!(\"Either --code-snippet or --file must be provided\");\n        }\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":53,\"end\":66},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt04-syntax-preflight-validator_src_cli_rs:53-66",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    /// Parse command-line arguments\n    pub fn parse_args() -> Self {\n        Self::parse()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs\",\"line_range\":{\"start\":25,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:25-30",
      "line_number": 0
    },
    {
      "current_code": "impl Cli {\n    /// Parse command-line arguments\n    pub fn parse_args() -> Self {\n        Self::parse()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "impl",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/cli.rs\",\"line_range\":{\"start\":25,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Cli:__crates_pt06-cozodb-make-future-code-current_src_cli_rs:25-30",
      "line_number": 0
    },
    {
      "current_code": "impl CliConfig {\n    /// Build CLI application\n    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-01\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 01: folder-to-cozoDB-streamer\")\n            .long_about(\n                \"Ultra-minimalist streaming tool that reads code files from a directory,\\n\\\n                generates ISGL1 keys using tree-sitter, and stores them in CozoDB.\\n\\\n                \\n\\\n                Following TDD-first principles with executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"directory\")\n                    .help(\"Directory to index\")\n                    .required(true)\n                    .index(1),\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database connection string (use 'mem' for in-memory)\")\n                    .default_value(\"mem\"),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n            .arg(\n                Arg::new(\"exclude\")\n                    .short('e')\n                    .long(\"exclude\")\n                    .value_name(\"PATTERN\")\n                    .help(\"Exclude pattern (can be specified multiple times)\")\n                    .action(ArgAction::Append)\n                    .long_help(\"Exclude files/directories matching pattern.\nExamples: -e '.ref' -e 'archive' -e 'tmp/**'\nPatterns are simple substring matches (not regex).\"),\n            )\n    }\n\n    /// Parse CLI arguments into StreamerConfig\n    ///\n    /// Uses hardcoded defaults for internal fields (matching unified binary behavior):\n    /// - max_file_size: 100MB (ultra-minimalist: let tree-sitter decide what to parse)\n    /// - include_patterns: ALL files (tree-sitter handles unsupported files gracefully)\n    /// - exclude_patterns: Common build/dependency dirs + user patterns\n    /// - parsing_library: \"tree-sitter\"\n    /// - chunking: \"ISGL1\"\n    pub fn parse_config(matches: &clap::ArgMatches) -> StreamerConfig {\n        // Start with default exclusion patterns\n        let mut exclude_patterns = vec![\n            \"target\".to_string(),      // Rust build\n            \"node_modules\".to_string(), // Node.js dependencies\n            \".git\".to_string(),        // Git metadata\n            \"build\".to_string(),       // Generic build dir\n            \"dist\".to_string(),        // Distribution files\n            \"__pycache__\".to_string(), // Python cache\n            \".venv\".to_string(),       // Python virtual env\n            \"venv\".to_string(),        // Python virtual env\n        ];\n        \n        // Add user-specified exclusion patterns (if any)\n        if let Some(user_excludes) = matches.get_many::<String>(\"exclude\") {\n            for pattern in user_excludes {\n                exclude_patterns.push(pattern.clone());\n            }\n        }\n        \n        StreamerConfig {\n            root_dir: PathBuf::from(matches.get_one::<String>(\"directory\").unwrap()),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            // Hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n            max_file_size: 100 * 1024 * 1024,  // 100MB - let tree-sitter decide\n            include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n            exclude_patterns,\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        }\n    }\n\n    /// Print usage information\n    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }\n\n    /// Print version information\n    pub fn print_version() {\n        println!(\"parseltongue-01 version 0.7.1\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "CliConfig",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CliConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":30,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CliConfig:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:30-135",
      "line_number": 0
    },
    {
      "current_code": "impl CliConfig {\n    /// Build CLI application with Progressive Disclosure pattern\n    ///\n    /// Two interfaces:\n    /// 1. Simple (80% use cases): --entity --action --future-code\n    /// 2. Advanced (20% power users): --query\n    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-02\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 02: LLM-to-cozoDB-writer\")\n            .long_about(\n                \"Ultra-minimalist temporal state writer for CozoDB.\\n\\\n                \\n\\\n                Two interfaces:\\n\\\n                \\n\\\n                1. Simple Interface (80% use cases):\\n  \\\n                llm-to-cozodb-writer --entity <KEY> --action <create|edit|delete> --future-code <CODE>\\n\\\n                \\n\\\n                2. Advanced Interface (20% power users):\\n  \\\n                llm-to-cozodb-writer --query \\\"?[...] := [[...]] :put CodeGraph {...}\\\"\\n\\\n                \",\n            )\n            // Simple interface arguments\n            .arg(\n                Arg::new(\"entity\")\n                    .long(\"entity\")\n                    .value_name(\"ISGL1_KEY\")\n                    .help(\"ISGL1 entity key to modify\")\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"action\")\n                    .long(\"action\")\n                    .value_name(\"ACTION\")\n                    .help(\"Action to perform: create, edit, or delete\")\n                    .value_parser([\"create\", \"edit\", \"delete\"])\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"future-code\")\n                    .long(\"future-code\")\n                    .value_name(\"CODE\")\n                    .help(\"Future code content (required for create/edit)\")\n                    .conflicts_with(\"query\"),\n            )\n            // Advanced interface arguments\n            .arg(\n                Arg::new(\"query\")\n                    .long(\"query\")\n                    .value_name(\"DATALOG\")\n                    .help(\"Raw Datalog query to execute\")\n                    .conflicts_with(\"entity\"),\n            )\n            // Common argument\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            // Mutual exclusion groups\n            .group(\n                ArgGroup::new(\"interface\")\n                    .args([\"query\", \"entity\"])\n                    .required(true),\n            )\n    }\n\n    /// Parse CLI arguments into LlmWriterConfig (S01 ultra-minimalist)\n    ///\n    /// Deprecated: Use parse_interface_mode() instead\n    pub fn parse_config(matches: &clap::ArgMatches) -> LlmWriterConfig {\n        LlmWriterConfig {\n            query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n        }\n    }\n\n    /// Parse CLI arguments into InterfaceMode (Progressive Disclosure pattern)\n    ///\n    /// Determines whether user is using Simple or Advanced interface\n    pub fn parse_interface_mode(matches: &clap::ArgMatches) -> InterfaceMode {\n        let db_path = matches\n            .get_one::<String>(\"database\")\n            .unwrap()\n            .clone();\n\n        // Check which interface mode\n        if let Some(entity_key) = matches.get_one::<String>(\"entity\") {\n            // Simple Interface\n            let action_str = matches.get_one::<String>(\"action\").unwrap();\n            let action = match action_str.as_str() {\n                \"create\" => EntityAction::Create,\n                \"edit\" => EntityAction::Edit,\n                \"delete\" => EntityAction::Delete,\n                _ => unreachable!(\"clap validates this\"),\n            };\n\n            let future_code = matches.get_one::<String>(\"future-code\").cloned();\n\n            InterfaceMode::Simple(SimpleUpdateConfig {\n                entity_key: entity_key.clone(),\n                action,\n                future_code,\n                db_path,\n            })\n        } else {\n            // Advanced Interface\n            let query = matches.get_one::<String>(\"query\").unwrap().clone();\n            InterfaceMode::Advanced(AdvancedQueryConfig { query, db_path })\n        }\n    }\n\n    /// Print usage information\n    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }\n\n    /// Print version information\n    pub fn print_version() {\n        println!(\"parseltongue-02 version 0.7.1\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "CliConfig",
      "entity_type": "impl",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CliConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":54,\"end\":180},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CliConfig:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:54-180",
      "line_number": 0
    },
    {
      "current_code": "impl CodeDiff {\n    /// Create a new empty CodeDiff\n    pub fn new() -> Self {\n        Self {\n            changes: Vec::new(),\n            metadata: DiffMetadata {\n                total_changes: 0,\n                create_count: 0,\n                edit_count: 0,\n                delete_count: 0,\n                generated_at: chrono::Utc::now().to_rfc3339(),\n            },\n        }\n    }\n\n    /// Add a change to the diff\n    pub fn add_change(&mut self, change: Change) {\n        match change.operation {\n            Operation::Create => self.metadata.create_count += 1,\n            Operation::Edit => self.metadata.edit_count += 1,\n            Operation::Delete => self.metadata.delete_count += 1,\n        }\n        self.metadata.total_changes += 1;\n        self.changes.push(change);\n    }\n\n    /// Convert to pretty-printed JSON\n    pub fn to_json_pretty(&self) -> serde_json::Result<String> {\n        serde_json::to_string_pretty(self)\n    }\n}",
      "current_ind": 1,
      "entity_name": "CodeDiff",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CodeDiff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":129,\"end\":159},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CodeDiff:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:129-159",
      "line_number": 0
    },
    {
      "current_code": "impl Default for CodeDiff {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "CodeDiff",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CodeDiff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":161,\"end\":165},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CodeDiff:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:161-165",
      "line_number": 0
    },
    {
      "current_code": "impl CodeEntity {\n    /// Create new entity (for Tool 1 indexing)\n    ///\n    /// v0.9.0: Requires EntityClass for mandatory classification\n    /// Initializes with TemporalState::initial() per PRD:\n    /// - current_ind: true (exists in current codebase)\n    /// - future_ind: false (future state unknown until Tool 2)\n    /// - Future_Action: None\n    pub fn new(\n        isgl1_key: String,\n        interface_signature: InterfaceSignature,\n        entity_class: EntityClass,\n    ) -> Result<Self> {\n        let entity = Self {\n            temporal_state: TemporalState::initial(),  // Tool 1 initial state: (1,0,None)\n            interface_signature,\n            current_code: None,\n            future_code: None,\n            tdd_classification: TddClassification::default(),\n            lsp_metadata: None,\n            metadata: EntityMetadata::new()?,\n            isgl1_key,\n            entity_class, // v0.9.0: mandatory classification\n        };\n\n        Ok(entity)\n    }\n\n    /// Apply temporal change\n    pub fn apply_temporal_change(\n        &mut self,\n        action: TemporalAction,\n        future_code: Option<String>,\n    ) -> Result<()> {\n        match action {\n            TemporalAction::Create => {\n                self.temporal_state = TemporalState::create();\n                self.future_code = future_code;\n            }\n            TemporalAction::Edit => {\n                self.temporal_state = TemporalState::edit();\n                self.future_code = future_code;\n            }\n            TemporalAction::Delete => {\n                self.temporal_state = TemporalState::delete();\n                self.future_code = None;\n            }\n        }\n\n        self.temporal_state.validate()?;\n        Ok(())\n    }\n\n    /// Check if entity is modified\n    pub fn is_modified(&self) -> bool {\n        self.temporal_state.is_changed()\n    }\n\n    /// Get effective code (current or future based on state)\n    pub fn effective_code(&self) -> Option<&String> {\n        if self.temporal_state.future_action.is_some() {\n            self.future_code.as_ref()\n        } else {\n            self.current_code.as_ref()\n        }\n    }\n\n    /// Validate entity consistency\n    pub fn validate(&self) -> Result<()> {\n        // Validate ISGL1 key format\n        self.validate_isgl1_key()?;\n\n        // Validate temporal state\n        self.temporal_state.validate()?;\n\n        // Validate line range\n        LineRange::new(self.interface_signature.line_range.start, self.interface_signature.line_range.end)\n            .map_err(|e| ParseltongError::ValidationError {\n                field: \"line_range\".to_string(),\n                expected: \"valid line range\".to_string(),\n                actual: e.to_string(),\n            })?;\n\n        // Validate code consistency\n        self.validate_code_consistency()?;\n\n        Ok(())\n    }\n\n    fn validate_isgl1_key(&self) -> Result<()> {\n        if self.isgl1_key.is_empty() {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            });\n        }\n\n        if !self.isgl1_key.contains('-') {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key must contain hyphens\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    fn validate_code_consistency(&self) -> Result<()> {\n        // If entity exists in current state, it should have current code\n        if self.temporal_state.current_ind && self.current_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"current_code\".to_string(),\n                expected: \"present when current_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        // If entity will exist in future state, it should have future code\n        if self.temporal_state.future_ind && self.future_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"future_code\".to_string(),\n                expected: \"present when future_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Generate hash-based ISGL1 key for new entities\n    ///\n    /// Creates stable identity keys for entities that don't exist yet in the codebase.\n    /// Uses SHA-256 hash to ensure uniqueness and collision avoidance.\n    ///\n    /// # Arguments\n    ///\n    /// * `file_path` - Path to the file where entity will be created\n    /// * `entity_name` - Name of the entity (function, struct, etc.)\n    /// * `entity_type` - Type of entity (Function, Struct, Enum, etc.)\n    /// * `timestamp` - Creation timestamp for uniqueness\n    ///\n    /// # Returns\n    ///\n    /// ISGL1 key in format: `{sanitized_filepath}-{entity_name}-{type_abbrev}-{hash8}`\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use parseltongue_core::entities::{CodeEntity, EntityType};\n    /// use chrono::Utc;\n    ///\n    /// let key = CodeEntity::generate_new_entity_key(\n    ///     \"src/lib.rs\",\n    ///     \"new_feature\",\n    ///     &EntityType::Function,\n    ///     Utc::now()\n    /// );\n    /// // Returns: \"src_lib_rs-new_feature-fn-abc12345\"\n    /// ```\n    pub fn generate_new_entity_key(\n        file_path: &str,\n        entity_name: &str,\n        entity_type: &EntityType,\n        timestamp: chrono::DateTime<chrono::Utc>,\n    ) -> String {\n        use sha2::{Sha256, Digest};\n\n        // Sanitize file path: replace /, \\, and . with _\n        let sanitized_path = file_path\n            .replace(['/', '\\\\', '.'], \"_\");\n\n        // Get type abbreviation\n        let type_abbrev = match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Module => \"mod\",\n            EntityType::ImplBlock { .. } => \"impl\",\n            EntityType::Macro => \"macro\",\n            EntityType::ProcMacro => \"proc_macro\",\n            EntityType::TestFunction => \"test\",\n            EntityType::Class => \"class\",\n            EntityType::Variable => \"var\",\n            EntityType::Constant => \"const\",\n        };\n\n        // Create hash input: filepath + name + type + timestamp\n        let mut hasher = Sha256::new();\n        hasher.update(file_path.as_bytes());\n        hasher.update(entity_name.as_bytes());\n        hasher.update(format!(\"{:?}\", entity_type).as_bytes());\n        hasher.update(timestamp.to_rfc3339().as_bytes());\n\n        // Get hash result and take first 8 characters\n        let hash_bytes = hasher.finalize();\n        let hash_str = format!(\"{:x}\", hash_bytes);\n        let short_hash = &hash_str[0..8];\n\n        // Format: sanitized_path-entity_name-type_abbrev-hash8\n        format!(\"{}-{}-{}-{}\", sanitized_path, entity_name, type_abbrev, short_hash)\n    }\n}",
      "current_ind": 1,
      "entity_name": "CodeEntity",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CodeEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":609,\"end\":813},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CodeEntity:__crates_parseltongue-core_src_entities_rs:609-813",
      "line_number": 0
    },
    {
      "current_code": "impl ConflictResolver {\n    /// Create new conflict resolver\n    pub fn new(strategy: ConflictResolutionStrategy) -> Self {\n        Self { strategy }\n    }\n\n    /// Detect conflicts between changes\n    pub fn detect_conflicts(&self, changes: &[TemporalChange]) -> Vec<Conflict> {\n        let mut conflicts = Vec::new();\n\n        // Check for multiple changes to same entity\n        let mut entity_changes: HashMap<String, Vec<&TemporalChange>> = HashMap::new();\n        for change in changes {\n            entity_changes\n                .entry(change.isgl1_key.clone())\n                .or_default()\n                .push(change);\n        }\n\n        for (entity, entity_changes) in entity_changes {\n            if entity_changes.len() > 1 {\n                conflicts.push(Conflict::MultipleChanges {\n                    entity,\n                    changes: entity_changes.iter().map(|c| (*c).clone()).collect(),\n                });\n            }\n        }\n\n        conflicts\n    }\n\n    /// Resolve conflicts using configured strategy\n    pub fn resolve_conflicts(&self, changes: Vec<TemporalChange>) -> Result<Vec<TemporalChange>> {\n        let conflicts = self.detect_conflicts(&changes);\n\n        if conflicts.is_empty() {\n            return Ok(changes);\n        }\n\n        match self.strategy {\n            ConflictResolutionStrategy::FailFast => {\n                Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Conflicts detected: {:?}\",\n                        conflicts\n                    ),\n                })\n            }\n            ConflictResolutionStrategy::UseLatest => {\n                self.resolve_with_latest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::UseEarliest => {\n                self.resolve_with_earliest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::AttemptMerge => {\n                self.attempt_merge(changes, conflicts)\n            }\n        }\n    }\n\n    fn resolve_with_latest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the last change\n                for i in 0..conflicting_changes.len() - 1 {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }\n\n    fn resolve_with_earliest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the first change\n                for i in 1..conflicting_changes.len() {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }\n\n    fn attempt_merge(&self, _changes: Vec<TemporalChange>, _conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        // Simplified merge implementation\n        // In a real implementation, this would be more sophisticated\n        Err(ParseltongError::TemporalError {\n            details: \"Merge conflict resolution not yet implemented\".to_string(),\n        })\n    }\n}",
      "current_ind": 1,
      "entity_name": "ConflictResolver",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ConflictResolver\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":468,\"end\":569},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ConflictResolver:__crates_parseltongue-core_src_temporal_rs:468-569",
      "line_number": 0
    },
    {
      "current_code": "impl Default for ConsistentStateRule {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "ConsistentStateRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ConsistentStateRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":312,\"end\":316},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ConsistentStateRule:__crates_parseltongue-core_src_temporal_rs:312-316",
      "line_number": 0
    },
    {
      "current_code": "impl ConsistentStateRule {\n    pub fn new() -> Self {\n        Self { _private: () }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ConsistentStateRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ConsistentStateRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":318,\"end\":322},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ConsistentStateRule:__crates_parseltongue-core_src_temporal_rs:318-322",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalValidationRule for ConsistentStateRule {\n    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            // Validate temporal state consistency\n            entity.validate()?;\n\n            // Ensure code consistency\n            if entity.temporal_state.current_ind && entity.current_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has current_ind=true but no current_code\",\n                        key\n                    ),\n                });\n            }\n\n            if entity.temporal_state.future_ind && entity.future_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has future_ind=true but no future_code\",\n                        key\n                    ),\n                });\n            }\n        }\n\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "ConsistentStateRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ConsistentStateRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":324,\"end\":352},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ConsistentStateRule:__crates_parseltongue-core_src_temporal_rs:324-352",
      "line_number": 0
    },
    {
      "current_code": "impl CozoDbAdapter {\n    /// Create new adapter from CozoDbStorage\n    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }\n\n    /// Create adapter by connecting to database\n    pub async fn connect(db_path: &str) -> Result<Self> {\n        let storage = CozoDbStorage::new(db_path)\n            .await\n            .map_err(|e| anyhow!(\"Failed to connect to CozoDB: {}\", e))?;\n        Ok(Self::new(storage))\n    }\n}",
      "current_ind": 1,
      "entity_name": "CozoDbAdapter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CozoDbAdapter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":26,\"end\":39},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CozoDbAdapter:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:26-39",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for CozoDbAdapter {\n    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        // Query all entities from CodeGraph\n        let query = r#\"\n            ?[ISGL1_key, interface_signature, entity_type, file_path,\n              Current_Code, Future_Code, current_ind, future_ind, Future_Action, entity_class] :=\n            *CodeGraph{\n                ISGL1_key,\n                interface_signature,\n                entity_type,\n                file_path,\n                Current_Code,\n                Future_Code,\n                current_ind,\n                future_ind,\n                Future_Action,\n                entity_class\n            }\n        \"#;\n\n        let result = self.storage.raw_query(query).await\n            .map_err(|e| anyhow!(\"Failed to query entities: {}\", e))?;\n\n        // Parse result into Entity structs\n        let entities = parse_entities_from_query_result(&result)?;\n        Ok(entities)\n    }\n\n    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            return self.get_all_entities().await;\n        }\n\n        // Build Datalog query with WHERE clause\n        let query = format!(\n            r#\"\n            ?[ISGL1_key, interface_signature, entity_type, file_path,\n              Current_Code, Future_Code, current_ind, future_ind, Future_Action, entity_class] :=\n            *CodeGraph{{\n                ISGL1_key,\n                interface_signature,\n                entity_type,\n                file_path,\n                Current_Code,\n                Future_Code,\n                current_ind,\n                future_ind,\n                Future_Action,\n                entity_class\n            }},\n            {}\n            \"#,\n            where_clause\n        );\n\n        let result = self.storage.raw_query(&query).await\n            .map_err(|e| anyhow!(\"Failed to query entities with WHERE clause: {}\", e))?;\n\n        let entities = parse_entities_from_query_result(&result)?;\n        Ok(entities)\n    }\n\n    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        // Query all dependency edges\n        let query = r#\"\n            ?[from_key, to_key, edge_type] :=\n            *DependencyEdges{from_key, to_key, edge_type}\n        \"#;\n\n        let result = self.storage.raw_query(query).await\n            .map_err(|e| anyhow!(\"Failed to query edges: {}\", e))?;\n\n        let edges = parse_edges_from_query_result(&result)?;\n        Ok(edges)\n    }\n\n    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        if where_clause == \"ALL\" {\n            return self.get_all_edges().await;\n        }\n\n        // Build Datalog query with WHERE clause\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type] :=\n            *DependencyEdges{{from_key, to_key, edge_type}},\n            {}\n            \"#,\n            where_clause\n        );\n\n        let result = self.storage.raw_query(&query).await\n            .map_err(|e| anyhow!(\"Failed to query edges with WHERE clause: {}\", e))?;\n\n        let edges = parse_edges_from_query_result(&result)?;\n        Ok(edges)\n    }\n}",
      "current_ind": 1,
      "entity_name": "CozoDbAdapter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CozoDbAdapter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":42,\"end\":139},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CozoDbAdapter:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:42-139",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for CozoDbStorage {\n    async fn store_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.insert_entity(&entity).await\n    }\n\n    async fn get_entity(&self, isgl1_key: &str) -> Result<Option<CodeEntity>> {\n        match self.get_entity(isgl1_key).await {\n            Ok(entity) => Ok(Some(entity)),\n            Err(ParseltongError::EntityNotFound { .. }) => Ok(None),\n            Err(e) => Err(e),\n        }\n    }\n\n    async fn update_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.update_entity_internal(&entity).await\n    }\n\n    async fn delete_entity(&mut self, isgl1_key: &str) -> Result<()> {\n        self.delete_entity(isgl1_key).await\n    }\n\n    async fn query_entities(&self, _query: &TemporalQuery) -> Result<Vec<CodeEntity>> {\n        // Simplified implementation for MVP\n        // Full query support to be added later\n        Ok(Vec::new())\n    }\n\n    async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        self.get_changed_entities().await\n    }\n\n    async fn reset_temporal_state(&mut self) -> Result<()> {\n        // Get all changed entities\n        let changed = self.get_changed_entities().await?;\n\n        for entity in changed {\n            let mut updated_entity = entity.clone();\n\n            // Apply temporal changes to current state\n            match updated_entity.temporal_state.future_action {\n                Some(TemporalAction::Create) => {\n                    // New entity becomes current\n                    updated_entity.temporal_state.current_ind = true;\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Edit) => {\n                    // Apply edit\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Delete) => {\n                    // Delete entity\n                    self.delete_entity(&entity.isgl1_key).await?;\n                    continue;\n                }\n                None => {}\n            }\n\n            // Reset temporal indicators\n            updated_entity.temporal_state.future_ind = updated_entity.temporal_state.current_ind;\n            updated_entity.temporal_state.future_action = None;\n            updated_entity.future_code = None;\n\n            self.update_entity_internal(&updated_entity).await?;\n        }\n\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "CozoDbStorage",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CozoDbStorage\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1270,\"end\":1337},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CozoDbStorage:__crates_parseltongue-core_src_storage_cozo_client_rs:1270-1337",
      "line_number": 0
    },
    {
      "current_code": "impl CozoDbStorage {\n    /// Create new CozoDB storage instance\n    ///\n    /// # Arguments\n    /// * `engine_spec` - Storage engine specification:\n    ///   - \"mem\" for in-memory\n    ///   - \"rocksdb:path/to/db\" for RocksDB persistent storage (recommended)\n    ///   - \"sqlite:path/to/db.sqlite\" for SQLite storage\n    ///\n    /// # Examples\n    /// ```ignore\n    /// let db = CozoDbStorage::new(\"mem\").await?;\n    /// let db = CozoDbStorage::new(\"rocksdb:./parseltongue.db\").await?;\n    /// let db = CozoDbStorage::new(\"sqlite:./parseltongue.sqlite\").await?;\n    /// ```\n    pub async fn new(engine_spec: &str) -> Result<Self> {\n        // Parse engine specification: \"engine:path\" or just \"engine\" (for mem)\n        let (engine, path) = if engine_spec.contains(':') {\n            let parts: Vec<&str> = engine_spec.splitn(2, ':').collect();\n            (parts[0], parts[1])\n        } else {\n            (engine_spec, \"\")\n        };\n\n        let db = DbInstance::new(engine, path, Default::default())\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"connection\".to_string(),\n                details: format!(\"Failed to create CozoDB instance with engine '{}' and path '{}': {}\", engine, path, e),\n            })?;\n\n        Ok(Self { db })\n    }\n\n    /// Check if database connection is alive\n    pub async fn is_connected(&self) -> bool {\n        // Test query to verify connection - use ::relations which always works\n        self.db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .is_ok()\n    }\n\n    /// Create CodeGraph schema\n    ///\n    /// Implements schema from 01-cozodb-schema.md specification\n    /// v0.9.0 Enhancement: Added entity_class column for test/code separation\n    pub async fn create_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create CodeGraph {\n                ISGL1_key: String =>\n                Current_Code: String?,\n                Future_Code: String?,\n                interface_signature: String,\n                TDD_Classification: String,\n                lsp_meta_data: String?,\n                current_ind: Bool,\n                future_ind: Bool,\n                Future_Action: String?,\n                file_path: String,\n                language: String,\n                last_modified: String,\n                entity_type: String,\n                entity_class: String\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"schema_creation\".to_string(),\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Create DependencyEdges schema for code dependency graph\n    ///\n    /// Implements dependency tracking with composite key (from_key, to_key, edge_type).\n    /// Indices automatically created on key fields for O(log n) query performance.\n    ///\n    /// # Schema\n    /// - **Keys**: from_key, to_key, edge_type (composite key for uniqueness)\n    /// - **Fields**: source_location (optional line/column info)\n    ///\n    /// # Performance Contracts\n    /// - Single insert: <5ms (D10 specification)\n    /// - Batch insert (100 edges): <50ms (D10 specification)\n    ///\n    /// # Example\n    /// ```ignore\n    /// let storage = CozoDbStorage::new(\"mem\").await?;\n    /// storage.create_dependency_edges_schema().await?;\n    /// // Now ready to insert edges\n    /// ```\n    pub async fn create_dependency_edges_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create DependencyEdges {\n                from_key: String,\n                to_key: String,\n                edge_type: String\n                =>\n                source_location: String?\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"create_dependency_edges_schema\".to_string(),\n                reason: format!(\"Failed to create DependencyEdges schema: {}\", e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Insert a single dependency edge\n    ///\n    /// # Performance Contract\n    /// - Single insert: <5ms (D10 specification)\n    ///\n    /// # Example\n    /// ```ignore\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// let edge = DependencyEdge::builder()\n    ///     .from_key(\"rust:fn:main:src_main_rs:1-10\")\n    ///     .to_key(\"rust:fn:helper:src_helper_rs:5-20\")\n    ///     .edge_type(EdgeType::Calls)\n    ///     .build()?;\n    ///\n    /// storage.insert_edge(&edge).await?;\n    /// ```\n    pub async fn insert_edge(&self, edge: &DependencyEdge) -> Result<()> {\n        let query = r#\"\n            ?[from_key, to_key, edge_type, source_location] <-\n            [[$from_key, $to_key, $edge_type, $source_location]]\n\n            :put DependencyEdges {\n                from_key, to_key, edge_type =>\n                source_location\n            }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"from_key\".to_string(), DataValue::Str(edge.from_key.as_ref().into()));\n        params.insert(\"to_key\".to_string(), DataValue::Str(edge.to_key.as_ref().into()));\n        params.insert(\"edge_type\".to_string(), DataValue::Str(edge.edge_type.as_str().into()));\n        params.insert(\n            \"source_location\".to_string(),\n            edge.source_location\n                .as_ref()\n                .map(|s| DataValue::Str(s.as_str().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edge\".to_string(),\n                reason: format!(\"Failed to insert dependency edge: {}\", e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Insert multiple dependency edges in a batch\n    ///\n    /// # Performance Contract\n    /// - Batch insert (100 edges): <50ms (D10 specification)\n    ///\n    /// # Example\n    /// ```ignore\n    /// let edges = vec![\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"A\").to_key(\"B\").edge_type(EdgeType::Calls).build()?,\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"B\").to_key(\"C\").edge_type(EdgeType::Uses).build()?,\n    /// ];\n    /// storage.insert_edges_batch(&edges).await?;\n    /// ```\n    pub async fn insert_edges_batch(&self, edges: &[DependencyEdge]) -> Result<()> {\n        if edges.is_empty() {\n            return Ok(());\n        }\n\n        // Build query with inline data for batch insert\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type, source_location] <- [{}]\n\n            :put DependencyEdges {{\n                from_key, to_key, edge_type =>\n                source_location\n            }}\n            \"#,\n            edges\n                .iter()\n                .map(|edge| {\n                    let source_loc = edge\n                        .source_location\n                        .as_ref()\n                        .map(|s| format!(\"'{}'\", s.replace('\\'', \"\\\\'\")))\n                        .unwrap_or_else(|| \"null\".to_string());\n\n                    format!(\n                        \"['{}', '{}', '{}', {}]\",\n                        edge.from_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.to_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.edge_type.as_str(),\n                        source_loc\n                    )\n                })\n                .collect::<Vec<_>>()\n                .join(\", \")\n        );\n\n        self.db\n            .run_script(&query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edges_batch\".to_string(),\n                reason: format!(\"Failed to batch insert {} edges: {}\", edges.len(), e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Calculate blast radius: Find all entities within N hops of a changed entity.\n    ///\n    /// Uses CozoDB recursive Datalog queries to perform bounded BFS graph traversal,\n    /// returning all reachable entities with their minimum distance from the source.\n    ///\n    /// # Performance Contract\n    /// - 5 hops on 10k node graph: <50ms (D10 PRD requirement)\n    /// - Bounded traversal prevents runaway queries on cyclic graphs\n    ///\n    /// # Arguments\n    /// * `changed_key` - ISGL1 key of the entity that changed (source node)\n    /// * `max_hops` - Maximum number of hops to traverse (1-based distance limit)\n    ///\n    /// # Returns\n    /// Vector of (ISGL1_key, distance) tuples sorted by distance.\n    /// Returns empty vector if `max_hops == 0`.\n    ///\n    /// # Algorithm\n    /// 1. **Base case**: Direct dependents at distance 1\n    /// 2. **Recursive case**: Follow edges incrementing distance up to `max_hops`\n    /// 3. **Aggregation**: Min distance per node (handles diamond/multi-path dependencies)\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::storage::CozoDbStorage;\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// # tokio_test::block_on(async {\n    /// let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    /// storage.create_dependency_edges_schema().await.unwrap();\n    ///\n    /// // Given: A -> B -> C -> D\n    /// let ab = DependencyEdge::builder()\n    ///     .from_key(\"rust:fn:a:test_rs:1-5\")\n    ///     .to_key(\"rust:fn:b:test_rs:6-10\")\n    ///     .edge_type(EdgeType::Calls)\n    ///     .build().unwrap();\n    /// let bc = DependencyEdge::builder()\n    ///     .from_key(\"rust:fn:b:test_rs:6-10\")\n    ///     .to_key(\"rust:fn:c:test_rs:11-15\")\n    ///     .edge_type(EdgeType::Calls)\n    ///     .build().unwrap();\n    /// storage.insert_edge(&ab).await.unwrap();\n    /// storage.insert_edge(&bc).await.unwrap();\n    ///\n    /// // Query: blast_radius(\"A\", 2) returns B and C\n    /// let affected = storage.calculate_blast_radius(\n    ///     \"rust:fn:a:test_rs:1-5\",\n    ///     2\n    /// ).await.unwrap();\n    ///\n    /// assert_eq!(affected.len(), 2);\n    /// assert_eq!(affected[0].0, \"rust:fn:b:test_rs:6-10\");\n    /// assert_eq!(affected[0].1, 1);\n    /// assert_eq!(affected[1].0, \"rust:fn:c:test_rs:11-15\");\n    /// assert_eq!(affected[1].1, 2);\n    /// # });\n    /// ```\n    pub async fn calculate_blast_radius(\n        &self,\n        changed_key: &str,\n        max_hops: usize,\n    ) -> Result<Vec<(String, usize)>> {\n        // Validation\n        if max_hops == 0 {\n            return Ok(Vec::new());\n        }\n\n        // CozoDB recursive query for bounded BFS\n        // Strategy: Iteratively hop through edges, tracking minimum distance\n        let query = r#\"\n            # Recursive blast radius query\n            # Find all nodes reachable from start_node within max_hops\n\n            # Base case: Starting node at distance 0\n            reachable[to_key, distance] := *DependencyEdges{from_key, to_key},\n                                            from_key == $start_key,\n                                            distance = 1\n\n            # Recursive case: Follow edges, incrementing distance\n            reachable[to_key, new_distance] := reachable[from, dist],\n                                                *DependencyEdges{from_key: from, to_key},\n                                                dist < $max_hops,\n                                                new_distance = dist + 1\n\n            # Aggregate to get minimum distance for each node\n            ?[node, min_dist] := reachable[node, dist],\n                                 min_dist = min(dist)\n\n            :order min_dist\n            \"#.to_string();\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(changed_key.into()));\n        params.insert(\"max_hops\".to_string(), DataValue::from(max_hops as i64));\n\n        let result = self\n            .db\n            .run_script(&query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"calculate_blast_radius\".to_string(),\n                reason: format!(\"Failed to execute blast radius query: {}\", e),\n            })?;\n\n        // Parse results into (key, distance) tuples\n        let mut affected = Vec::new();\n        for row in result.rows {\n            if row.len() >= 2 {\n                if let (Some(DataValue::Str(node)), Some(distance_val)) =\n                    (row.first(), row.get(1))\n                {\n                    // Distance is stored as Num enum (Int or Float)\n                    let distance = match distance_val {\n                        DataValue::Num(n) => match n {\n                            cozo::Num::Int(i) => *i as usize,\n                            cozo::Num::Float(f) => *f as usize,\n                        },\n                        _ => continue,\n                    };\n                    affected.push((node.to_string(), distance));\n                }\n            }\n        }\n\n        Ok(affected)\n    }\n\n    /// Get forward dependencies: entities that this entity directly depends on (outgoing edges).\n    ///\n    /// Returns all entities reachable in exactly 1 hop following outgoing edges from this entity.\n    /// This is a simple 1-hop query useful for understanding what a function/module directly uses.\n    ///\n    /// # Arguments\n    /// * `isgl1_key` - ISGL1 key of the entity to query\n    ///\n    /// # Returns\n    /// Vector of ISGL1 keys that this entity depends on. Returns empty vector if no dependencies exist.\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::storage::CozoDbStorage;\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// # tokio_test::block_on(async {\n    /// let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    /// storage.create_dependency_edges_schema().await.unwrap();\n    ///\n    /// // Create: A calls B and C\n    /// let edges = vec![\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:A:test_rs:1-5\")\n    ///         .to_key(\"rust:fn:B:test_rs:10-15\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:A:test_rs:1-5\")\n    ///         .to_key(\"rust:fn:C:test_rs:20-25\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    /// ];\n    /// storage.insert_edges_batch(&edges).await.unwrap();\n    ///\n    /// // Query: What does A depend on?\n    /// let deps = storage.get_forward_dependencies(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n    /// assert_eq!(deps.len(), 2); // A depends on B and C\n    /// assert!(deps.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    /// assert!(deps.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    /// # });\n    /// ```\n    ///\n    /// # See Also\n    /// - [`get_reverse_dependencies`] for finding what depends on this entity\n    /// - [`calculate_blast_radius`] for multi-hop impact analysis\n    pub async fn get_forward_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[to_key] := *DependencyEdges{from_key, to_key}, from_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_forward_dependencies\".to_string(),\n                reason: format!(\"Failed to query forward dependencies: {}\", e),\n            })?;\n\n        // Extract to_key values from results\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependencies.push(key.to_string());\n            }\n        }\n\n        Ok(dependencies)\n    }\n\n    /// Get reverse dependencies: entities that directly depend on this entity (incoming edges).\n    ///\n    /// Returns all entities that have outgoing edges pointing to this entity.\n    /// This is a simple 1-hop query useful for finding \"who calls this function\".\n    ///\n    /// # Arguments\n    /// * `isgl1_key` - ISGL1 key of the entity to query\n    ///\n    /// # Returns\n    /// Vector of ISGL1 keys that depend on this entity. Returns empty vector if no dependents exist.\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::storage::CozoDbStorage;\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// # tokio_test::block_on(async {\n    /// let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    /// storage.create_dependency_edges_schema().await.unwrap();\n    ///\n    /// // Create: A and B both call C\n    /// let edges = vec![\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:A:test_rs:1-5\")\n    ///         .to_key(\"rust:fn:C:test_rs:20-25\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:B:test_rs:10-15\")\n    ///         .to_key(\"rust:fn:C:test_rs:20-25\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    /// ];\n    /// storage.insert_edges_batch(&edges).await.unwrap();\n    ///\n    /// // Query: Who depends on C?\n    /// let dependents = storage.get_reverse_dependencies(\"rust:fn:C:test_rs:20-25\").await.unwrap();\n    /// assert_eq!(dependents.len(), 2); // A and B both call C\n    /// assert!(dependents.contains(&\"rust:fn:A:test_rs:1-5\".to_string()));\n    /// assert!(dependents.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    /// # });\n    /// ```\n    ///\n    /// # See Also\n    /// - [`get_forward_dependencies`] for finding what this entity depends on\n    /// - [`calculate_blast_radius`] for multi-hop impact analysis\n    pub async fn get_reverse_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[from_key] := *DependencyEdges{from_key, to_key}, to_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_reverse_dependencies\".to_string(),\n                reason: format!(\"Failed to query reverse dependencies: {}\", e),\n            })?;\n\n        // Extract from_key values from results\n        let mut dependents = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependents.push(key.to_string());\n            }\n        }\n\n        Ok(dependents)\n    }\n\n    /// Get all dependency edges from the database.\n    ///\n    /// Returns all dependency edges stored in the DependencyEdges table.\n    /// This is useful for test validation and full graph analysis.\n    ///\n    /// # Returns\n    /// Vector of all DependencyEdge records. Returns empty vector if no edges exist.\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::storage::CozoDbStorage;\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// # tokio_test::block_on(async {\n    /// let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    /// storage.create_dependency_edges_schema().await.unwrap();\n    ///\n    /// // Insert edges\n    /// let edges = vec![\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:A:test_rs:1-5\")\n    ///         .to_key(\"rust:fn:B:test_rs:10-15\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    /// ];\n    /// storage.insert_edges_batch(&edges).await.unwrap();\n    ///\n    /// // Query all edges\n    /// let all_deps = storage.get_all_dependencies().await.unwrap();\n    /// assert_eq!(all_deps.len(), 1);\n    /// # });\n    /// ```\n    pub async fn get_all_dependencies(&self) -> Result<Vec<DependencyEdge>> {\n        let query = \"?[from_key, to_key, edge_type, source_location] := *DependencyEdges{from_key, to_key, edge_type, source_location}\";\n\n        let result = self\n            .db\n            .run_script(query, BTreeMap::new(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_all_dependencies\".to_string(),\n                reason: format!(\"Failed to query all dependencies: {}\", e),\n            })?;\n\n        // Parse results into DependencyEdge structs\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if row.len() >= 3 {\n                if let (Some(DataValue::Str(from_key)), Some(DataValue::Str(to_key)), Some(DataValue::Str(edge_type_str))) =\n                    (row.get(0), row.get(1), row.get(2))\n                {\n                    let edge_type = match edge_type_str.as_str() {\n                        \"Calls\" => EdgeType::Calls,\n                        \"Uses\" => EdgeType::Uses,\n                        \"Implements\" => EdgeType::Implements,\n                        _ => continue, // Skip unknown edge types\n                    };\n\n                    let source_location = row.get(3).and_then(|v| {\n                        if let DataValue::Str(loc) = v {\n                            Some(loc.to_string())\n                        } else {\n                            None\n                        }\n                    });\n\n                    let edge = DependencyEdge::builder()\n                        .from_key(from_key.to_string())\n                        .to_key(to_key.to_string())\n                        .edge_type(edge_type)\n                        .source_location(source_location.unwrap_or_default())\n                        .build()\n                        .map_err(|e| ParseltongError::DependencyError {\n                            operation: \"get_all_dependencies\".to_string(),\n                            reason: format!(\"Failed to build DependencyEdge: {}\", e),\n                        })?;\n\n                    dependencies.push(edge);\n                }\n            }\n        }\n\n        Ok(dependencies)\n    }\n\n    /// Get transitive closure: all entities reachable from this entity (unbounded).\n    ///\n    /// Returns ALL entities reachable by recursively following dependency edges,\n    /// without any hop limit. Uses CozoDB's recursive Datalog for efficient graph traversal.\n    /// Automatically handles cycles without infinite loops.\n    ///\n    /// # Use Cases\n    /// - Full impact analysis: \"If I change this function, what ALL code might be affected?\"\n    /// - Dependency tree extraction for LLM context\n    /// - Reachability analysis for refactoring safety\n    ///\n    /// # Arguments\n    /// * `isgl1_key` - ISGL1 key of the starting entity\n    ///\n    /// # Returns\n    /// Vector of all reachable ISGL1 keys. May include the starting node if it's part of a cycle.\n    /// Returns empty vector if no outgoing edges exist.\n    ///\n    /// # Example\n    /// ```\n    /// use parseltongue_core::storage::CozoDbStorage;\n    /// use parseltongue_core::entities::{DependencyEdge, EdgeType};\n    ///\n    /// # tokio_test::block_on(async {\n    /// let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n    /// storage.create_dependency_edges_schema().await.unwrap();\n    ///\n    /// // Create chain: A -> B -> C -> D\n    /// let edges = vec![\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:A:test_rs:1-5\")\n    ///         .to_key(\"rust:fn:B:test_rs:10-15\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:B:test_rs:10-15\")\n    ///         .to_key(\"rust:fn:C:test_rs:20-25\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    ///     DependencyEdge::builder()\n    ///         .from_key(\"rust:fn:C:test_rs:20-25\")\n    ///         .to_key(\"rust:fn:D:test_rs:30-35\")\n    ///         .edge_type(EdgeType::Calls)\n    ///         .build().unwrap(),\n    /// ];\n    /// storage.insert_edges_batch(&edges).await.unwrap();\n    ///\n    /// // Query: What's ALL code reachable from A?\n    /// let reachable = storage.get_transitive_closure(\"rust:fn:A:test_rs:1-5\").await.unwrap();\n    ///\n    /// // Returns B, C, D (all transitively reachable nodes)\n    /// assert_eq!(reachable.len(), 3);\n    /// assert!(reachable.contains(&\"rust:fn:B:test_rs:10-15\".to_string()));\n    /// assert!(reachable.contains(&\"rust:fn:C:test_rs:20-25\".to_string()));\n    /// assert!(reachable.contains(&\"rust:fn:D:test_rs:30-35\".to_string()));\n    /// # });\n    /// ```\n    ///\n    /// # Algorithm\n    /// Uses CozoDB recursive rules for unbounded graph traversal:\n    /// 1. **Base case**: Direct outgoing edges from start node\n    /// 2. **Recursive case**: Transitively follow all edges\n    /// 3. **Termination**: CozoDB's fixed-point semantics guarantee termination (even with cycles)\n    ///\n    /// # Performance Notes\n    /// - Result size grows with graph connectivity\n    /// - For large graphs, consider [`calculate_blast_radius`] with hop limits\n    /// - Cycle handling is automatic and efficient (no explicit visited set needed)\n    ///\n    /// # See Also\n    /// - [`calculate_blast_radius`] for bounded multi-hop queries with distance tracking\n    /// - [`get_forward_dependencies`] for simple 1-hop queries\n    pub async fn get_transitive_closure(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        // CozoDB recursive query for unbounded reachability\n        let query = r#\"\n            # Transitive closure: Find all nodes reachable from start node\n\n            # Base case: Direct edges from start node\n            reachable[to_key] := *DependencyEdges{from_key, to_key},\n                                 from_key == $start_key\n\n            # Recursive case: Follow edges transitively (CozoDB handles cycle termination)\n            reachable[to_key] := reachable[from],\n                                 *DependencyEdges{from_key: from, to_key}\n\n            # Return all unique reachable nodes\n            ?[node] := reachable[node]\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_transitive_closure\".to_string(),\n                reason: format!(\"Failed to compute transitive closure: {}\", e),\n            })?;\n\n        // Extract all reachable keys\n        let mut reachable = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                reachable.push(key.to_string());\n            }\n        }\n\n        Ok(reachable)\n    }\n\n    /// Execute raw Datalog query (S01 ultra-minimalist - direct CozoDB access)\n    ///\n    /// For Tool 2 --query interface. Executes user-provided Datalog directly.\n    /// NO query validation, NO safety checks - trust the user (S01 principle).\n    pub async fn execute_query(&self, query: &str) -> Result<()> {\n        self.db\n            .run_script(query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"execute_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(())\n    }\n\n    /// Execute raw Datalog query and return results\n    ///\n    /// # Arguments\n    /// * `query` - Datalog query string\n    ///\n    /// # Returns\n    /// Query results as NamedRows (headers + rows)\n    ///\n    /// # Example\n    /// ```ignore\n    /// let result = storage.raw_query(\"?[key, value] := *CodeGraph{key, value}\").await?;\n    /// for row in result.rows {\n    ///     println!(\"{:?}\", row);\n    /// }\n    /// ```\n    pub async fn raw_query(&self, query: &str) -> Result<cozo::NamedRows> {\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"raw_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(result)\n    }\n\n    /// List all relations in the database\n    pub async fn list_relations(&self) -> Result<Vec<String>> {\n        let result = self\n            .db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"list_relations\".to_string(),\n                details: format!(\"Failed to list relations: {}\", e),\n            })?;\n\n        let mut relations = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(name)) = row.first() {\n                relations.push(name.to_string());\n            }\n        }\n\n        Ok(relations)\n    }\n\n    /// Insert entity into database\n    pub async fn insert_entity(&self, entity: &CodeEntity) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] <-\n            [[$ISGL1_key, $Current_Code, $Future_Code, $interface_signature, $TDD_Classification,\n              $lsp_meta_data, $current_ind, $future_ind, $Future_Action, $file_path, $language,\n              $last_modified, $entity_type, $entity_class]]\n\n            :put CodeGraph {\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            }\n        \"#;\n\n        let params = self.entity_to_params(entity)?;\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"insert_entity\".to_string(),\n                details: format!(\"Failed to insert entity: {}\", e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Get entity by ISGL1 key\n    pub async fn get_entity(&self, isgl1_key: &str) -> Result<CodeEntity> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            },\n            ISGL1_key == $key\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self.db.run_script(query, params, ScriptMutability::Immutable).map_err(|e| {\n            ParseltongError::DatabaseError {\n                operation: \"get_entity\".to_string(),\n                details: format!(\"Failed to get entity: {}\", e),\n            }\n        })?;\n\n        if result.rows.is_empty() {\n            return Err(ParseltongError::EntityNotFound {\n                isgl1_key: isgl1_key.to_string(),\n            });\n        }\n\n        self.row_to_entity(&result.rows[0])\n    }\n\n    /// Update entity in database (internal method)\n    pub async fn update_entity_internal(&self, entity: &CodeEntity) -> Result<()> {\n        // Update is same as insert with :put which replaces existing\n        self.insert_entity(entity).await\n    }\n\n    /// Delete entity from database\n    pub async fn delete_entity(&self, isgl1_key: &str) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key] <- [[$key]]\n            :rm CodeGraph { ISGL1_key }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"delete_entity\".to_string(),\n                details: format!(\"Failed to delete entity: {}\", e),\n            })?;\n\n        Ok(())\n    }\n\n    /// Update temporal state of entity\n    pub async fn update_temporal_state(\n        &self,\n        isgl1_key: &str,\n        future_ind: bool,\n        future_action: Option<TemporalAction>,\n    ) -> Result<()> {\n        // Get current entity\n        let mut entity = self.get_entity(isgl1_key).await?;\n\n        // Update temporal state\n        entity.temporal_state.future_ind = future_ind;\n        entity.temporal_state.future_action = future_action.clone();\n\n        // Validate temporal state\n        entity.temporal_state.validate()?;\n\n        // Update in database\n        self.update_entity_internal(&entity).await\n    }\n\n    /// Get entities with pending changes\n    pub async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            },\n            Future_Action != null\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_changed_entities\".to_string(),\n                details: format!(\"Failed to query changed entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }\n\n    /// Get all entities from database\n    ///\n    /// Returns all entities in the CodeGraph table, regardless of temporal state.\n    /// Useful for testing and diagnostic purposes.\n    pub async fn get_all_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            }\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_all_entities\".to_string(),\n                details: format!(\"Failed to query all entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }\n\n    // Helper methods for data conversion\n\n    /// Convert CodeEntity to CozoDB parameters\n    fn entity_to_params(&self, entity: &CodeEntity) -> Result<BTreeMap<String, DataValue>> {\n        let mut params = BTreeMap::new();\n\n        params.insert(\n            \"ISGL1_key\".to_string(),\n            DataValue::Str(entity.isgl1_key.clone().into()),\n        );\n\n        params.insert(\n            \"Current_Code\".to_string(),\n            entity\n                .current_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"Future_Code\".to_string(),\n            entity\n                .future_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        // Serialize complex types as JSON\n        let signature_json = serde_json::to_string(&entity.interface_signature)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize interface_signature: {}\", e),\n            })?;\n        params.insert(\n            \"interface_signature\".to_string(),\n            DataValue::Str(signature_json.into()),\n        );\n\n        let tdd_json = serde_json::to_string(&entity.tdd_classification)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize TDD_Classification: {}\", e),\n            })?;\n        params.insert(\n            \"TDD_Classification\".to_string(),\n            DataValue::Str(tdd_json.into()),\n        );\n\n        params.insert(\n            \"lsp_meta_data\".to_string(),\n            if let Some(ref lsp) = entity.lsp_metadata {\n                let lsp_json = serde_json::to_string(lsp)\n                    .map_err(|e| ParseltongError::SerializationError {\n                        details: format!(\"Failed to serialize lsp_meta_data: {}\", e),\n                    })?;\n                DataValue::Str(lsp_json.into())\n            } else {\n                DataValue::Null\n            },\n        );\n\n        params.insert(\n            \"current_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.current_ind),\n        );\n\n        params.insert(\n            \"future_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.future_ind),\n        );\n\n        params.insert(\n            \"Future_Action\".to_string(),\n            entity\n                .temporal_state\n                .future_action\n                .as_ref()\n                .map(|action| {\n                    DataValue::Str(\n                        match action {\n                            TemporalAction::Create => \"Create\",\n                            TemporalAction::Edit => \"Edit\",\n                            TemporalAction::Delete => \"Delete\",\n                        }\n                        .into(),\n                    )\n                })\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"file_path\".to_string(),\n            DataValue::Str(\n                entity\n                    .interface_signature\n                    .file_path\n                    .to_string_lossy()\n                    .to_string()\n                    .into(),\n            ),\n        );\n\n        params.insert(\n            \"language\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.language_specific {\n                    LanguageSpecificSignature::Rust(_) => \"rust\",\n                    LanguageSpecificSignature::JavaScript(_) => \"javascript\",\n                    LanguageSpecificSignature::TypeScript(_) => \"typescript\",\n                    LanguageSpecificSignature::Python(_) => \"python\",\n                    LanguageSpecificSignature::Java(_) => \"java\",\n                }\n                .into(),\n            ),\n        );\n\n        params.insert(\n            \"last_modified\".to_string(),\n            DataValue::Str(entity.metadata.modified_at.to_rfc3339().into()),\n        );\n\n        params.insert(\n            \"entity_type\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.entity_type {\n                    EntityType::Function => \"function\",\n                    EntityType::Method => \"method\",\n                    EntityType::Struct => \"struct\",\n                    EntityType::Enum => \"enum\",\n                    EntityType::Trait => \"trait\",\n                    EntityType::Interface => \"interface\",\n                    EntityType::Module => \"module\",\n                    EntityType::ImplBlock { .. } => \"impl\",\n                    EntityType::Macro => \"macro\",\n                    EntityType::ProcMacro => \"proc_macro\",\n                    EntityType::TestFunction => \"test\",\n                    EntityType::Class => \"class\",\n                    EntityType::Variable => \"variable\",\n                    EntityType::Constant => \"constant\",\n                }\n                .into(),\n            ),\n        );\n\n        // v0.9.0: Add entity_class parameter\n        params.insert(\n            \"entity_class\".to_string(),\n            DataValue::Str(\"CODE\".into()), // Default to CODE, will be updated by test detection\n        );\n\n        Ok(params)\n    }\n\n    /// Convert CozoDB row to CodeEntity\n    fn row_to_entity(&self, row: &[DataValue]) -> Result<CodeEntity> {\n        if row.len() < 14 {\n            return Err(ParseltongError::DatabaseError {\n                operation: \"row_to_entity\".to_string(),\n                details: format!(\"Invalid row length: expected 14, got {}\", row.len()),\n            });\n        }\n\n        // Extract ISGL1 key\n        let isgl1_key = match &row[0] {\n            DataValue::Str(s) => s.to_string(),\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"ISGL1_key is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Extract current_code\n        let current_code = match &row[1] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Current_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract future_code\n        let future_code = match &row[2] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize interface_signature\n        let interface_signature: InterfaceSignature = match &row[3] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize interface_signature: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"interface_signature is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize TDD_Classification\n        let tdd_classification: TddClassification = match &row[4] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize TDD_Classification: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"TDD_Classification is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize lsp_meta_data\n        let lsp_metadata: Option<LspMetadata> = match &row[5] {\n            DataValue::Str(s) => Some(serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize lsp_meta_data: {}\", e),\n                }\n            })?),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"lsp_meta_data has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract temporal state\n        let current_ind = match &row[6] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"current_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_ind = match &row[7] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"future_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_action = match &row[8] {\n            DataValue::Str(s) => Some(match s.as_ref() {\n                \"Create\" => TemporalAction::Create,\n                \"Edit\" => TemporalAction::Edit,\n                \"Delete\" => TemporalAction::Delete,\n                _ => {\n                    return Err(ParseltongError::DatabaseError {\n                        operation: \"row_to_entity\".to_string(),\n                        details: format!(\"Invalid Future_Action value: {}\", s),\n                    })\n                }\n            }),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Action has invalid type\".to_string(),\n                })\n            }\n        };\n\n        let temporal_state = TemporalState {\n            current_ind,\n            future_ind,\n            future_action,\n        };\n\n        // Extract entity_class (v0.9.0) - currently ignored in CodeEntity\n        let _entity_class = match &row[13] {\n            DataValue::Str(s) => s.to_string(),\n            _ => \"CODE\".to_string(), // Default fallback\n        };\n\n        // Build CodeEntity\n        let mut entity = CodeEntity::new(\n            isgl1_key, \n            interface_signature,\n            // v0.9.0: Extract entity_class from database row\n            match &row[13] {\n                cozo::DataValue::Str(s) => {\n                    if s == \"TEST\" {\n                        crate::entities::EntityClass::TestImplementation\n                    } else {\n                        crate::entities::EntityClass::CodeImplementation\n                    }\n                },\n                _ => crate::entities::EntityClass::CodeImplementation, // Default fallback\n            }\n        )?;\n        entity.current_code = current_code;\n        entity.future_code = future_code;\n        entity.temporal_state = temporal_state;\n        entity.tdd_classification = tdd_classification;\n        entity.lsp_metadata = lsp_metadata;\n\n        Ok(entity)\n    }\n}",
      "current_ind": 1,
      "entity_name": "CozoDbStorage",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CozoDbStorage\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":23,\"end\":1266},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CozoDbStorage:__crates_parseltongue-core_src_storage_cozo_client_rs:23-1266",
      "line_number": 0
    },
    {
      "current_code": "    impl Parser for CppParser {\n        type Input = String;\n        type Output = CppAst;\n        type Error = CppParseError;\n        type Config = CppParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "CppParser",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"CppParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":581,\"end\":595},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:CppParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:581-595",
      "line_number": 0
    },
    {
      "current_code": "impl DefaultRustValidator {\n    pub fn new() -> Self {\n        Self\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultRustValidator",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultRustValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":78,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultRustValidator:__crates_pt04-syntax-preflight-validator_src_validator_rs:78-82",
      "line_number": 0
    },
    {
      "current_code": "impl Default for DefaultRustValidator {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultRustValidator",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultRustValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":84,\"end\":88},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultRustValidator:__crates_pt04-syntax-preflight-validator_src_validator_rs:84-88",
      "line_number": 0
    },
    {
      "current_code": "impl CodeValidator for DefaultRustValidator {\n    async fn validate_syntax(&self, code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Minimal implementation using syn\n        let start = std::time::Instant::now();\n\n        let result = syn::parse_file(code);\n\n        let execution_time_ms = start.elapsed().as_millis() as u64;\n\n        match result {\n            Ok(_) => Ok(ValidationOutput {\n                is_valid: true,\n                validation_type: ValidationType::Syntax,\n                errors: Vec::new(),\n                warnings: Vec::new(),\n                execution_time_ms,\n                memory_usage_bytes: 0, // Simplified for GREEN phase\n            }),\n            Err(e) => {\n                let error_msg = format!(\"Syntax error: {}\", e);\n                Ok(ValidationOutput {\n                    is_valid: false,\n                    validation_type: ValidationType::Syntax,\n                    errors: vec![error_msg],\n                    warnings: Vec::new(),\n                    execution_time_ms,\n                    memory_usage_bytes: 0,\n                })\n            }\n        }\n    }\n\n    async fn validate_types(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Type))\n    }\n\n    async fn validate_borrow_checker(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::BorrowChecker))\n    }\n\n    async fn validate_compilation(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Compilation))\n    }\n\n    async fn validate_tests(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Test))\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultRustValidator",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultRustValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":91,\"end\":142},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultRustValidator:__crates_pt04-syntax-preflight-validator_src_validator_rs:91-142",
      "line_number": 0
    },
    {
      "current_code": "impl DefaultTestDetector {\n    pub fn new() -> Self {\n        Self\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultTestDetector",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultTestDetector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":28,\"end\":32},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultTestDetector:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:28-32",
      "line_number": 0
    },
    {
      "current_code": "impl TestDetector for DefaultTestDetector {\n    fn detect_test_from_path_and_name(&self, file_path: &Path, content: &str) -> EntityClass {\n        // REQ-V090-003.0: Language-specific test detection\n        \n        let path_str = file_path.to_string_lossy();\n        \n        // Rust test detection\n        if path_str.ends_with(\".rs\") {\n            return self.detect_rust_test(file_path, content);\n        }\n        \n        // Go test detection\n        if path_str.ends_with(\".go\") {\n            return self.detect_go_test(file_path, content);\n        }\n        \n        // JavaScript/TypeScript test detection\n        if path_str.ends_with(\".js\") || path_str.ends_with(\".ts\") || \n           path_str.ends_with(\".jsx\") || path_str.ends_with(\".tsx\") {\n            return self.detect_javascript_test(file_path, content);\n        }\n        \n        // Python test detection\n        if path_str.ends_with(\".py\") {\n            return self.detect_python_test(file_path, content);\n        }\n        \n        // Java test detection\n        if path_str.ends_with(\".java\") {\n            return self.detect_java_test(file_path, content);\n        }\n        \n        // Unknown file extensions are treated as non-test files\n        EntityClass::Code\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultTestDetector",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultTestDetector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":34,\"end\":69},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultTestDetector:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:34-69",
      "line_number": 0
    },
    {
      "current_code": "impl DefaultTestDetector {\n    /// REQ-V090-003.1: Rust test detection\n    /// \n    /// Detects tests via:\n    /// - `#[test]`, `#[tokio::test]`, `#[cfg(test)]` attributes\n    /// - `tests/` directory\n    /// - `_test.rs` filename pattern\n    fn detect_rust_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check directory pattern: tests/ directory\n        if path_str.contains(\"tests/\") {\n            return EntityClass::Test;\n        }\n        \n        // Check filename pattern: _test.rs\n        if path_str.ends_with(\"_test.rs\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test attributes\n        if content.contains(\"#[test]\") || \n           content.contains(\"#[tokio::test]\") || \n           content.contains(\"#[cfg(test)]\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }\n    \n    /// REQ-V090-003.2: Go test detection\n    /// \n    /// Detects tests via:\n    /// - `*_test.go` files\n    /// - Functions starting with `Test`, `Example`, `Benchmark`\n    fn detect_go_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename pattern: *_test.go\n        if path_str.ends_with(\"_test.go\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test functions\n        if content.contains(\"func Test\") || \n           content.contains(\"func Example\") || \n           content.contains(\"func Benchmark\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }\n    \n    /// REQ-V090-003.3: JavaScript/TypeScript test detection\n    /// \n    /// Detects tests via:\n    /// - `*.test.js`, `*.spec.ts`, `*.test.tsx`, `*.spec.jsx` files\n    /// - `__tests__/` directory\n    /// - Common test patterns in content\n    fn detect_javascript_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\".test.js\") || \n           path_str.ends_with(\".test.ts\") || \n           path_str.ends_with(\".test.tsx\") || \n           path_str.ends_with(\".spec.js\") || \n           path_str.ends_with(\".spec.ts\") || \n           path_str.ends_with(\".spec.jsx\") {\n            return EntityClass::Test;\n        }\n        \n        // Check directory pattern: __tests__/\n        if path_str.contains(\"__tests__/\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test patterns\n        if content.contains(\"test(\") || \n           content.contains(\"it(\") || \n           content.contains(\"describe(\") || \n           content.contains(\"expect(\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }\n    \n    /// REQ-V090-003.4: Python test detection\n    /// \n    /// Detects tests via:\n    /// - `test_*.py`, `*_test.py` files\n    /// - Functions/classes starting with `test_`, `Test`\n    fn detect_python_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\"_test.py\") || \n           path_str.starts_with(\"test_\") && path_str.ends_with(\".py\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test patterns\n        if content.contains(\"def test_\") || \n           content.contains(\"class Test\") || \n           content.contains(\"@pytest\") || \n           content.contains(\"unittest\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }\n    \n    /// REQ-V090-003.5: Java test detection\n    /// \n    /// Detects tests via:\n    /// - `*Test.java`, `*Tests.java` files\n    /// - Methods with `@Test` annotation\n    fn detect_java_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\"Test.java\") || \n           path_str.ends_with(\"Tests.java\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for JUnit annotations\n        if content.contains(\"@Test\") || \n           content.contains(\"@BeforeEach\") || \n           content.contains(\"@AfterEach\") || \n           content.contains(\"junit\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }\n}",
      "current_ind": 1,
      "entity_name": "DefaultTestDetector",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DefaultTestDetector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":71,\"end\":208},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DefaultTestDetector:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:71-208",
      "line_number": 0
    },
    {
      "current_code": "impl DependencyEdge {\n    /// Creates new dependency edge (validated)\n    pub fn new(\n        from_key: impl Into<String>,\n        to_key: impl Into<String>,\n        edge_type: EdgeType,\n        source_location: Option<String>,\n    ) -> Result<Self> {\n        Ok(Self {\n            from_key: Isgl1Key::new(from_key)?,\n            to_key: Isgl1Key::new(to_key)?,\n            edge_type,\n            source_location,\n        })\n    }\n\n    /// Returns a builder for constructing dependency edges\n    pub fn builder() -> DependencyEdgeBuilder {\n        DependencyEdgeBuilder::default()\n    }\n}",
      "current_ind": 1,
      "entity_name": "DependencyEdge",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DependencyEdge\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1012,\"end\":1032},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DependencyEdge:__crates_parseltongue-core_src_entities_rs:1012-1032",
      "line_number": 0
    },
    {
      "current_code": "impl DependencyEdgeBuilder {\n    /// Sets the source entity key\n    pub fn from_key(mut self, key: impl Into<String>) -> Self {\n        self.from_key = Some(key.into());\n        self\n    }\n\n    /// Sets the target entity key\n    pub fn to_key(mut self, key: impl Into<String>) -> Self {\n        self.to_key = Some(key.into());\n        self\n    }\n\n    /// Sets the edge type\n    pub fn edge_type(mut self, edge_type: EdgeType) -> Self {\n        self.edge_type = Some(edge_type);\n        self\n    }\n\n    /// Sets the source location (optional)\n    pub fn source_location(mut self, location: impl Into<String>) -> Self {\n        self.source_location = Some(location.into());\n        self\n    }\n\n    /// Builds the DependencyEdge\n    ///\n    /// # Errors\n    ///\n    /// Returns error if required fields are missing or invalid.\n    pub fn build(self) -> Result<DependencyEdge> {\n        DependencyEdge::new(\n            self.from_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"from_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.to_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"to_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.edge_type.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"EdgeType\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.source_location,\n        )\n    }\n}",
      "current_ind": 1,
      "entity_name": "DependencyEdgeBuilder",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DependencyEdgeBuilder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1043,\"end\":1093},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DependencyEdgeBuilder:__crates_parseltongue-core_src_entities_rs:1043-1093",
      "line_number": 0
    },
    {
      "current_code": "impl DiffGenerator {\n    /// Create a new diff generator (dependency injection pattern)\n    pub fn new(storage: Arc<CozoDbStorage>) -> Self {\n        Self { storage }\n    }\n\n    /// Generate CodeDiff from all entities with future_action\n    pub async fn generate_diff(&self) -> Result<CodeDiff> {\n        // Get all changed entities from CozoDB\n        let changed_entities = self\n            .storage\n            .get_changed_entities()\n            .await\n            .context(\"Failed to get changed entities from CozoDB\")?;\n\n        let mut diff = CodeDiff::new();\n\n        for entity in changed_entities {\n            if let Some(change) = self.entity_to_change(&entity)? {\n                diff.add_change(change);\n            }\n        }\n\n        Ok(diff)\n    }\n\n    /// Convert CodeEntity to Change (with enhanced fields)\n    fn entity_to_change(&self, entity: &CodeEntity) -> Result<Option<Change>> {\n        // Determine operation from temporal state's future_action\n        let operation = match entity.temporal_state.future_action {\n            Some(TemporalAction::Create) => Operation::Create,\n            Some(TemporalAction::Edit) => Operation::Edit,\n            Some(TemporalAction::Delete) => Operation::Delete,\n            None => return Ok(None), // Skip entities with no future action (unchanged)\n        };\n\n        // Extract file path from ISGL1 key\n        let file_path = self.extract_file_path(&entity.isgl1_key)?;\n\n        // Extract line range from ISGL1 key (if line-based format)\n        let line_range = self.extract_line_range(&entity.isgl1_key);\n\n        // Extract current_code based on operation:\n        // - CREATE: None (entity doesn't exist yet)\n        // - EDIT/DELETE: Some (need to know what to replace/remove)\n        let current_code = match operation {\n            Operation::Create => None,\n            Operation::Edit | Operation::Delete => entity.current_code.clone(),\n        };\n\n        // Extract future_code based on operation:\n        // - CREATE/EDIT: Some (what to write)\n        // - DELETE: None (removing code)\n        let future_code = match operation {\n            Operation::Create | Operation::Edit => entity.future_code.clone(),\n            Operation::Delete => None,\n        };\n\n        // Format interface signature from components\n        let interface_signature = format!(\n            \"{:?} {}\",\n            entity.interface_signature.entity_type,\n            entity.interface_signature.name\n        );\n\n        // Create change with enhanced fields\n        let change = Change {\n            isgl1_key: entity.isgl1_key.clone(),\n            file_path,\n            operation,\n            current_code,\n            future_code,\n            line_range,\n            interface_signature,\n        };\n\n        Ok(Some(change))\n    }\n\n    /// Extract file path from ISGL1 key\n    fn extract_file_path(&self, isgl1_key: &str) -> Result<PathBuf> {\n        // ISGL1 key formats:\n        // - Line-based: \"rust:fn:name:src_lib_rs:42-56\"\n        // - Hash-based: \"src_lib_rs-new_feature-fn-abc12345\"\n        //\n        // Sanitized paths encode \"src/lib.rs\" as \"src_lib_rs\"\n        // The \"_rs\" suffix represents the \".rs\" extension\n        // Other underscores represent directory separators\n\n        if isgl1_key.contains(':') {\n            // Line-based format\n            let parts: Vec<&str> = isgl1_key.split(':').collect();\n            if parts.len() >= 4 {\n                let sanitized_path = parts[3]; // \"src_lib_rs\"\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        } else {\n            // Hash-based format\n            let parts: Vec<&str> = isgl1_key.split('-').collect();\n            if !parts.is_empty() {\n                // First part is sanitized file path\n                let sanitized_path = parts[0];\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        }\n\n        anyhow::bail!(\"Invalid ISGL1 key format: {}\", isgl1_key)\n    }\n\n    /// Desanitize file path from ISGL1 key format\n    /// Converts \"src_lib_rs\"  \"src/lib.rs\"\n    fn desanitize_path(&self, sanitized: &str) -> PathBuf {\n        // Common file extensions\n        let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n        // Find and replace extension suffix\n        for ext in extensions {\n            if let Some(idx) = sanitized.rfind(ext) {\n                if idx + ext.len() == sanitized.len() {\n                    // Found extension at end\n                    let path_part = &sanitized[..idx]; // \"src_lib\"\n                    let ext_part = &ext[1..]; // \"rs\"\n                    let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                    return PathBuf::from(file_path);\n                }\n            }\n        }\n\n        // No known extension found, treat as-is\n        PathBuf::from(sanitized.replace('_', \"/\"))\n    }\n\n    /// Extract line range from ISGL1 key (returns None for hash-based keys)\n    fn extract_line_range(&self, isgl1_key: &str) -> Option<LineRange> {\n        // Only line-based keys have line ranges: \"rust:fn:name:src_lib_rs:42-56\"\n        // Hash-based keys do not: \"src_lib_rs-new_feature-fn-abc12345\"\n\n        if !isgl1_key.contains(':') {\n            return None; // Hash-based key\n        }\n\n        // Line-based format: last part is \"start-end\"\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() < 5 {\n            return None;\n        }\n\n        let line_part = parts[4]; // \"42-56\"\n        let line_nums: Vec<&str> = line_part.split('-').collect();\n        if line_nums.len() != 2 {\n            return None;\n        }\n\n        let start = line_nums[0].parse::<u32>().ok()?;\n        let end = line_nums[1].parse::<u32>().ok()?;\n\n        Some(LineRange { start, end })\n    }\n}",
      "current_ind": 1,
      "entity_name": "DiffGenerator",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"DiffGenerator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":53,\"end\":211},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:DiffGenerator:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:53-211",
      "line_number": 0
    },
    {
      "current_code": "impl EdgeType {\n    /// Returns string representation of edge type\n    pub fn as_str(self) -> &'static str {\n        match self {\n            Self::Calls => \"Calls\",\n            Self::Uses => \"Uses\",\n            Self::Implements => \"Implements\",\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "EdgeType",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EdgeType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":939,\"end\":948},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EdgeType:__crates_parseltongue-core_src_entities_rs:939-948",
      "line_number": 0
    },
    {
      "current_code": "impl std::str::FromStr for EdgeType {\n    type Err = ParseltongError;\n\n    fn from_str(s: &str) -> Result<Self> {\n        match s {\n            \"Calls\" => Ok(Self::Calls),\n            \"Uses\" => Ok(Self::Uses),\n            \"Implements\" => Ok(Self::Implements),\n            _ => Err(ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"Calls, Uses, or Implements\".to_string(),\n                actual: s.to_owned(),\n            }),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "EdgeType",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EdgeType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":957,\"end\":972},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EdgeType:__crates_parseltongue-core_src_entities_rs:957-972",
      "line_number": 0
    },
    {
      "current_code": "impl std::fmt::Display for EdgeType {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}",
      "current_ind": 1,
      "entity_name": "EdgeType",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EdgeType\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":974,\"end\":978},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EdgeType:__crates_parseltongue-core_src_entities_rs:974-978",
      "line_number": 0
    },
    {
      "current_code": "impl EntityAction {\n    /// Convert action to temporal state tuple (pure function)\n    ///\n    /// Returns: (current_ind, future_ind, action_string)\n    ///\n    /// # Examples\n    /// ```ignore\n    /// let (curr, fut, action) = EntityAction::Create.to_temporal_state();\n    /// assert_eq!((curr, fut, action), (\"false\", \"true\", \"Create\"));\n    /// ```\n    pub const fn to_temporal_state(self) -> (&'static str, &'static str, &'static str) {\n        match self {\n            EntityAction::Create => (\"false\", \"true\", \"Create\"),\n            EntityAction::Edit => (\"true\", \"true\", \"Edit\"),\n            EntityAction::Delete => (\"true\", \"false\", \"Delete\"),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "EntityAction",
      "entity_type": "impl",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EntityAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":38,\"end\":55},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EntityAction:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:38-55",
      "line_number": 0
    },
    {
      "current_code": "impl fmt::Display for EntityClass {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EntityClass::TestImplementation => write!(f, \"TEST\"),\n            EntityClass::CodeImplementation => write!(f, \"CODE\"),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "EntityClass",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EntityClass\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":492,\"end\":499},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EntityClass:__crates_parseltongue-core_src_entities_rs:492-499",
      "line_number": 0
    },
    {
      "current_code": "impl EntityMetadata {\n    pub fn new() -> Result<Self> {\n        Ok(Self {\n            created_at: chrono::Utc::now(),\n            modified_at: chrono::Utc::now(),\n            content_hash: String::new(), // Will be set when content is available\n            additional: HashMap::new(),\n        })\n    }\n}",
      "current_ind": 1,
      "entity_name": "EntityMetadata",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"EntityMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":829,\"end\":838},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:EntityMetadata:__crates_parseltongue-core_src_entities_rs:829-838",
      "line_number": 0
    },
    {
      "current_code": "impl ExportMetadata {\n    /// Create metadata for Level 0 (edges)\n    pub fn for_level0(total_edges: usize, where_filter: String) -> Self {\n        Self {\n            level: 0,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n            total_edges: Some(total_edges),\n            total_entities: None,\n            include_code: None,\n            where_filter,\n        }\n    }\n\n    /// Create metadata for Level 1-2 (entities)\n    pub fn for_entities(level: u8, total_entities: usize, include_code: bool, where_filter: String) -> Self {\n        Self {\n            level,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n            total_edges: None,\n            total_entities: Some(total_entities),\n            include_code: Some(include_code),\n            where_filter,\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ExportMetadata",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ExportMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":236,\"end\":260},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ExportMetadata:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:236-260",
      "line_number": 0
    },
    {
      "current_code": "impl ExportOutput {\n    /// Create output for Level 0 (edges)\n    pub fn with_edges(edges: Vec<DependencyEdge>, where_filter: String) -> Self {\n        let metadata = ExportMetadata::for_level0(edges.len(), where_filter);\n        Self {\n            export_metadata: metadata,\n            edges: Some(edges),\n            entities: None,\n        }\n    }\n\n    /// Create output for Level 1-2 (entities)\n    pub fn with_entities(level: u8, entities: serde_json::Value, include_code: bool, where_filter: String) -> Self {\n        let total = if let Some(arr) = entities.as_array() {\n            arr.len()\n        } else {\n            0\n        };\n\n        let metadata = ExportMetadata::for_entities(level, total, include_code, where_filter);\n        Self {\n            export_metadata: metadata,\n            edges: None,\n            entities: Some(entities),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ExportOutput",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ExportOutput\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":262,\"end\":288},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ExportOutput:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:262-288",
      "line_number": 0
    },
    {
      "current_code": "impl FileStreamer for FileStreamerImpl {\n    async fn stream_directory(&self) -> Result<StreamResult> {\n        let start_time = Instant::now();\n        let mut total_files = 0;\n        let mut processed_files = 0;\n        let mut entities_created = 0;\n        let mut errors = Vec::new();\n\n        println!(\n            \"{}\",\n            style(\"Starting directory streaming...\").blue().bold()\n        );\n\n        // Setup progress bar\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} [{elapsed_precise}] {msg}\")\n                .unwrap()\n        );\n        pb.set_message(\"Scanning files...\");\n\n        // Walk through directory\n        for entry in WalkDir::new(&self.config.root_dir)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let path = entry.path();\n\n            if path.is_file() && self.should_process_file(path) {\n                total_files += 1;\n                pb.set_message(format!(\"Processing: {}\", path.display()));\n\n                match self.stream_file(path).await {\n                    Ok(result) => {\n                        processed_files += 1;\n                        entities_created += result.entities_created;\n                    }\n                    Err(e) => {\n                        let error_msg = format!(\"{}: {}\", path.display(), e);\n                        errors.push(error_msg.clone());\n                        pb.println(format!(\"{} {}\", style(\"\").yellow().for_stderr(), error_msg));\n                        self.update_stats(0, true);\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(\"Directory streaming completed\");\n\n        let duration = start_time.elapsed();\n\n        // Print summary\n        println!(\"\\n{}\", style(\"Streaming Summary:\").green().bold());\n        println!(\"Total files found: {}\", total_files);\n        println!(\"Files processed: {}\", processed_files);\n        println!(\"Entities created: {}\", entities_created);\n        println!(\"Errors encountered: {}\", errors.len());\n        println!(\"Duration: {:?}\", duration);\n\n        Ok(StreamResult {\n            total_files,\n            processed_files,\n            entities_created,\n            errors,\n            duration,\n        })\n    }\n\n    async fn stream_file(&self, file_path: &Path) -> Result<FileResult> {\n        let file_path_str = file_path.to_string_lossy().to_string();\n\n        // Read file content\n        let content = self.read_file_content(file_path).await?;\n\n        // Parse code entities AND dependencies (two-pass extraction)\n        let (parsed_entities, dependencies) = self.key_generator.parse_source(&content, file_path)?;\n\n        let mut entities_created = 0;\n        let mut errors: Vec<String> = Vec::new();\n\n        // Process each parsed entity\n        for parsed_entity in parsed_entities {\n            // Generate ISGL1 key\n            let isgl1_key = self.key_generator.generate_key(&parsed_entity)?;\n\n            // Enrich with LSP metadata for Rust files (sequential hover requests)\n            let lsp_metadata = self.fetch_lsp_metadata_for_entity(&parsed_entity, file_path).await;\n\n            // Convert ParsedEntity to CodeEntity\n            match self.parsed_entity_to_code_entity(&parsed_entity, &isgl1_key, &content, file_path) {\n                Ok(mut code_entity) => {\n                    // Store LSP metadata as JSON string if available\n                    if let Some(metadata) = lsp_metadata {\n                        code_entity.lsp_metadata = Some(metadata);\n                    }\n\n                    // Store in real database\n                    match self.db.insert_entity(&code_entity).await {\n                        Ok(_) => {\n                            entities_created += 1;\n                        }\n                        Err(e) => {\n                            let error_msg = format!(\"Failed to insert entity {}: {}\", isgl1_key, e);\n                            errors.push(error_msg);\n                        }\n                    }\n                }\n                Err(e) => {\n                    let error_msg = format!(\"Failed to convert entity {}: {}\", isgl1_key, e);\n                    errors.push(error_msg);\n                }\n            }\n        }\n\n        // ALWAYS create DependencyEdges schema, even if no dependencies\n        // This ensures pt02-level00 can query the table (returns empty array if no edges)\n        // Bug fix: Previously only created schema if dependencies.is_empty() == false\n        if let Err(e) = self.db.create_dependency_edges_schema().await {\n            // Schema might already exist - that's ok\n            if !e.to_string().contains(\"already exists\") && !e.to_string().contains(\"conflicts with an existing\") {\n                errors.push(format!(\"Failed to create dependency schema: {}\", e));\n            }\n        }\n\n        // Batch insert dependencies after all entities are stored\n        if !dependencies.is_empty() {\n            // Insert dependency edges\n            match self.db.insert_edges_batch(&dependencies).await {\n                Ok(_) => {\n                    // Successfully inserted dependencies\n                }\n                Err(e) => {\n                    errors.push(format!(\"Failed to insert {} dependencies: {}\", dependencies.len(), e));\n                }\n            }\n        }\n\n        self.update_stats(entities_created, !errors.is_empty());\n\n        Ok(FileResult {\n            file_path: file_path_str,\n            entities_created,\n            success: errors.is_empty(),\n            error: if errors.is_empty() {\n                None\n            } else {\n                Some(errors.join(\"; \"))\n            },\n        })\n    }\n\n    fn get_stats(&self) -> StreamStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }\n}",
      "current_ind": 1,
      "entity_name": "FileStreamerImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"FileStreamerImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":405,\"end\":561},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:FileStreamerImpl:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:405-561",
      "line_number": 0
    },
    {
      "current_code": "impl FileStreamerImpl {\n    /// Fetch LSP metadata for an entity using rust-analyzer hover\n    /// Returns LspMetadata if successful, None if unavailable or failed (graceful degradation)\n    async fn fetch_lsp_metadata_for_entity(\n        &self,\n        entity: &ParsedEntity,\n        file_path: &Path,\n    ) -> Option<LspMetadata> {\n        // Only fetch for Rust files\n        if entity.language != Language::Rust {\n            return None;\n        }\n\n        // Calculate hover position at the start of the entity (line is 0-indexed in LSP)\n        let line = entity.line_range.0.saturating_sub(1) as u32;\n        let character = 0u32; // Start of line (tree-sitter gives us the entity name position)\n\n        // Request hover metadata\n        match self.lsp_client.hover(file_path, line, character).await {\n            Ok(Some(hover_response)) => {\n                // Convert hover response to LspMetadata (stub/MVP implementation)\n                Self::hover_response_to_lsp_metadata(&hover_response)\n            }\n            Ok(None) => None, // Graceful degradation\n            Err(_) => None,   // Graceful degradation\n        }\n    }\n\n    /// Convert hover response to LspMetadata (stub implementation for MVP)\n    /// Future enhancement: parse rust-analyzer response for richer metadata\n    fn hover_response_to_lsp_metadata(hover: &HoverResponse) -> Option<LspMetadata> {\n        Some(LspMetadata {\n            type_information: TypeInformation {\n                resolved_type: hover.contents.clone(),\n                module_path: vec![],\n                generic_parameters: vec![],\n                definition_location: None,\n            },\n            usage_analysis: UsageAnalysis {\n                total_references: 0,\n                usage_locations: vec![],\n                dependents: vec![],\n            },\n            semantic_tokens: vec![],\n        })\n    }\n}",
      "current_ind": 1,
      "entity_name": "FileStreamerImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"FileStreamerImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":563,\"end\":609},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:FileStreamerImpl:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:563-609",
      "line_number": 0
    },
    {
      "current_code": "impl FileStreamerImpl {\n    /// Create new file streamer with database connection\n    pub async fn new(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        test_detector: Arc<dyn TestDetector>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        // Initialize LSP client (graceful degradation if unavailable)\n        let lsp_client = RustAnalyzerClientImpl::new().await;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client: Arc::new(lsp_client),\n            test_detector,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }\n\n    /// Create new file streamer with custom LSP client (for testing)\n    #[cfg(test)]\n    pub async fn new_with_lsp(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        lsp_client: Arc<dyn RustAnalyzerClient>,\n        test_detector: Arc<dyn TestDetector>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client,\n            test_detector,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }\n\n    /// Convert ParsedEntity to CodeEntity for database storage\n    fn parsed_entity_to_code_entity(\n        &self,\n        parsed: &ParsedEntity,\n        isgl1_key: &str,\n        source_code: &str,\n        file_path: &Path,\n    ) -> std::result::Result<CodeEntity, parseltongue_core::error::ParseltongError> {\n        // Create InterfaceSignature\n        let interface_signature = InterfaceSignature {\n            entity_type: self.convert_entity_type(&parsed.entity_type),\n            name: parsed.name.clone(),\n            visibility: Visibility::Public, // Default to public for now\n            file_path: PathBuf::from(&parsed.file_path),\n            line_range: LineRange::new(parsed.line_range.0 as u32, parsed.line_range.1 as u32)?,\n            module_path: vec![], // TODO: Extract from file path\n            documentation: None,\n            language_specific: self.create_language_signature(&parsed.language),\n        };\n\n        // Create CodeEntity with temporal state initialized to \"unchanged\" (current=true, future=true, action=none)\n        // v0.9.0: Include EntityClass classification using test_detector\n        let local_entity_class = self.test_detector.detect_test_from_path_and_name(\n            file_path, \n            &parsed.name\n        );\n        \n        // Convert from local EntityClass to parseltongue_core EntityClass\n        let entity_class = match local_entity_class {\n            EntityClass::Test => parseltongue_core::EntityClass::TestImplementation,\n            EntityClass::Code => parseltongue_core::EntityClass::CodeImplementation,\n        };\n        \n        let mut entity = CodeEntity::new(isgl1_key.to_string(), interface_signature, entity_class)?;\n\n        // Extract the code snippet from the source\n        let code_snippet = self.extract_code_snippet(source_code, parsed.line_range.0, parsed.line_range.1);\n\n        // Set current_code and future_code to the same value (unchanged state)\n        entity.current_code = Some(code_snippet.clone());\n        entity.future_code = Some(code_snippet);\n\n        // GREEN Phase: Apply TDD classification based on parsed metadata\n        entity.tdd_classification = self.classify_entity(parsed);\n\n        Ok(entity)\n    }\n\n    /// Classify entity as TEST or CODE based on metadata\n    ///\n    /// FP Pattern: Pure function - deterministic classification based on metadata\n    ///\n    /// Preconditions:\n    /// - parsed.metadata contains \"is_test\" key if entity is a test\n    ///\n    /// Postconditions:\n    /// - Returns TddClassification with correct EntityClass\n    fn classify_entity(&self, parsed: &ParsedEntity) -> parseltongue_core::entities::TddClassification {\n        use parseltongue_core::entities::{EntityClass, TddClassification};\n\n        // Pure FP: Check metadata for test indicator\n        let is_test = parsed\n            .metadata\n            .get(\"is_test\")\n            .map(|v| v == \"true\")\n            .unwrap_or(false);\n\n        // Minimal GREEN implementation: Just set entity_class\n        TddClassification {\n            entity_class: if is_test {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            },\n            ..TddClassification::default()\n        }\n    }\n\n    /// Convert Tool 1's EntityType to parseltongue-core's EntityType\n    ///\n    /// **Design Pattern**: Functional mapping with exhaustive pattern matching\n    /// **Post-v0.8.9**: All 11 entity types supported across 12 languages\n    ///\n    /// **Mapping Strategy** (MVP):\n    /// - Namespace  Module (semantic equivalence for namespaces/packages)\n    /// - Typedef  Variable (type aliases stored as variables for now)\n    /// - Future: Add Namespace and Typedef to parseltongue-core EntityType enum\n    fn convert_entity_type(&self, entity_type: &crate::isgl1_generator::EntityType) -> parseltongue_core::entities::EntityType {\n        match entity_type {\n            // Universal entities\n            crate::isgl1_generator::EntityType::Function => parseltongue_core::entities::EntityType::Function,\n            crate::isgl1_generator::EntityType::Class => parseltongue_core::entities::EntityType::Class,\n            crate::isgl1_generator::EntityType::Method => parseltongue_core::entities::EntityType::Method,\n            crate::isgl1_generator::EntityType::Module => parseltongue_core::entities::EntityType::Module,\n            crate::isgl1_generator::EntityType::Variable => parseltongue_core::entities::EntityType::Variable,\n\n            // Pragmatic mappings (v0.8.9 MVP)\n            crate::isgl1_generator::EntityType::Namespace => parseltongue_core::entities::EntityType::Module,   // C++/C# namespace  Module\n            crate::isgl1_generator::EntityType::Typedef => parseltongue_core::entities::EntityType::Variable,   // C typedef  Variable\n\n            // Rust-specific entities\n            crate::isgl1_generator::EntityType::Struct => parseltongue_core::entities::EntityType::Struct,\n            crate::isgl1_generator::EntityType::Enum => parseltongue_core::entities::EntityType::Enum,\n            crate::isgl1_generator::EntityType::Trait => parseltongue_core::entities::EntityType::Trait,\n            crate::isgl1_generator::EntityType::Impl => parseltongue_core::entities::EntityType::ImplBlock {\n                trait_name: None,\n                struct_name: \"Unknown\".to_string(), // TODO: Extract from parsed entity\n            },\n        }\n    }\n\n    /// Create language-specific signature\n    fn create_language_signature(&self, language: &Language) -> LanguageSpecificSignature {\n        match language {\n            Language::Rust => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n            Language::Python => LanguageSpecificSignature::Python(PythonSignature {\n                parameters: vec![],\n                return_type: None,\n                is_async: false,\n                decorators: vec![],\n            }),\n            _ => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        }\n    }\n\n    /// Extract code snippet from source by line range\n    fn extract_code_snippet(&self, source: &str, start_line: usize, end_line: usize) -> String {\n        source\n            .lines()\n            .enumerate()\n            .filter(|(idx, _)| *idx + 1 >= start_line && *idx < end_line)\n            .map(|(_, line)| line)\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }\n\n    /// Check if file should be processed based on patterns\n    fn should_process_file(&self, file_path: &Path) -> bool {\n        let path_str = file_path.to_string_lossy();\n\n        // REQ-V090-002.0: Check for git subdirectories (always-on detection)\n        if self.is_under_git_subdirectory(file_path) {\n            return false;\n        }\n\n        // Check exclude patterns\n        for pattern in &self.config.exclude_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return false;\n            }\n        }\n\n        // Check include patterns\n        for pattern in &self.config.include_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Simple glob pattern matching\n    fn matches_pattern(&self, path: &str, pattern: &str) -> bool {\n        if pattern.contains('*') {\n            // Simple pattern matching: check if path ends with extension\n            // TODO: Implement proper glob matching for complex patterns\n            path.contains(&pattern.replace('*', \"\")) || path == pattern\n        } else {\n            path.contains(pattern)\n        }\n    }\n\n    /// REQ-V090-002.0: Check if path is under a directory containing .git (but not project root)\n    /// \n    /// # Performance Contract\n    /// - Completes in <50s per path\n    /// - Stops traversal at project root boundary\n    /// - Handles permission errors gracefully\n    fn is_under_git_subdirectory(&self, path: &Path) -> bool {\n        let root = &self.config.root_dir;\n        let mut current = path;\n\n        // Walk up parent directories looking for .git\n        while let Some(parent) = current.parent() {\n            // Stop at project root (don't exclude project root itself)\n            if parent == root {\n                break;\n            }\n            \n            // Don't go beyond project root\n            if !parent.starts_with(root) {\n                break;\n            }\n\n            // Check if this parent directory contains .git\n            if parent.join(\".git\").exists() {\n                return true; // Found nested git repo\n            }\n\n            current = parent;\n        }\n\n        false\n    }\n\n    /// Read file content with size limit\n    async fn read_file_content(&self, file_path: &Path) -> Result<String> {\n        let metadata = fs::metadata(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        if metadata.len() as usize > self.config.max_file_size {\n            return Err(StreamerError::FileTooLarge {\n                path: file_path.to_string_lossy().to_string(),\n                size: metadata.len() as usize,\n                limit: self.config.max_file_size,\n            });\n        }\n\n        let mut content = String::new();\n        let mut file = fs::File::open(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        file.read_to_string(&mut content).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        Ok(content)\n    }\n\n    /// Update streaming statistics\n    fn update_stats(&self, entities_created: usize, had_error: bool) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.files_processed += 1;\n            stats.entities_created += entities_created;\n            if had_error {\n                stats.errors_encountered += 1;\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "FileStreamerImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"FileStreamerImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":73,\"end\":402},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:FileStreamerImpl:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:73-402",
      "line_number": 0
    },
    {
      "current_code": "impl FileWriter {\n    /// Create a new file writer with the given root path\n    pub fn new(root_path: PathBuf) -> Self {\n        Self { root_path }\n    }\n\n    /// Write a single entity to disk\n    ///\n    /// # Ultra-Minimalist Principles\n    /// - NO backup files created\n    /// - Direct write operations\n    /// - Fail-fast error handling\n    pub async fn write_entity(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        match &entity.temporal_state.future_action {\n            Some(FutureAction::Create) => self.create_file(entity).await,\n            Some(FutureAction::Edit) => self.modify_file(entity).await,\n            Some(FutureAction::Delete) => self.delete_file(entity).await,\n            None => Ok(WriteResult::no_op()),\n        }\n    }\n\n    /// Create a new file (fails if file already exists)\n    async fn create_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ensure parent directory exists\n        if let Some(parent) = file_path.parent() {\n            tokio::fs::create_dir_all(parent).await?;\n        }\n\n        // Get content to write\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Create operation\"))?;\n\n        // Write file directly (ultra-minimalist: no backups)\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Create))\n    }\n\n    /// Modify an existing file (direct overwrite, NO backup)\n    async fn modify_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - direct overwrite\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Edit operation\"))?;\n\n        // Ultra-minimalist: Direct overwrite, NO backup\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Edit))\n    }\n\n    /// Delete a file permanently (NO trash/recycle)\n    async fn delete_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - permanent deletion\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ultra-minimalist: Permanent deletion, NO trash\n        tokio::fs::remove_file(&file_path).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Delete))\n    }\n\n    /// Parse ISGL1 key to extract file path\n    ///\n    /// Format: \"src-models-rs-User\"  \"src/models.rs\"\n    fn resolve_file_path(&self, isgl1_key: &str) -> Result<PathBuf, FileWriterError> {\n        // GREEN phase: Simple string parsing\n        // Format: filepath-filename-rs-EntityName\n        // Example: \"src-models-rs-User\"  \"src/models.rs\"\n\n        // Find last occurrence of \"-rs-\" to separate path from entity name\n        let rs_marker = \"-rs-\";\n        let pos = isgl1_key.rfind(rs_marker)\n            .ok_or_else(|| FileWriterError::invalid_isgl1_key(isgl1_key.to_string()))?;\n\n        // Extract path part (everything before \"-rs-\")\n        let path_part = &isgl1_key[..pos];\n\n        // Convert hyphens to path separators and add .rs extension\n        let file_path = path_part.replace('-', \"/\") + \".rs\";\n\n        Ok(self.root_path.join(file_path))\n    }\n}",
      "current_ind": 1,
      "entity_name": "FileWriter",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"FileWriter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":19,\"end\":108},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:FileWriter:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:19-108",
      "line_number": 0
    },
    {
      "current_code": "impl FileWriterError {\n    /// Create a file already exists error\n    pub fn file_already_exists(path: PathBuf) -> Self {\n        Self::FileAlreadyExists { path }\n    }\n\n    /// Create a file not found error\n    pub fn file_not_found(path: PathBuf) -> Self {\n        Self::FileNotFound { path }\n    }\n\n    /// Create an invalid ISGL1 key error\n    pub fn invalid_isgl1_key(key: String) -> Self {\n        Self::InvalidIsgl1Key { key }\n    }\n}",
      "current_ind": 1,
      "entity_name": "FileWriterError",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"FileWriterError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":29,\"end\":44},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:FileWriterError:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:29-44",
      "line_number": 0
    },
    {
      "current_code": "    impl<'a> ParserCombinator<'a, &'a str> for Identifier {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {\n            let end = input\n                .char_indices()\n                .find(|(i, c)| {\n                    if *i == 0 {\n                        !c.is_alphabetic() && *c != '_'\n                    } else {\n                        !c.is_alphanumeric() && *c != '_'\n                    }\n                })\n                .map(|(i, _)| i)\n                .unwrap_or(input.len());\n            \n            if end == 0 {\n                Err(ParseError::Failed(\"Expected identifier\".to_string()))\n            } else {\n                Ok((&input[..end], &input[end..]))\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "Identifier",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Identifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1329,\"end\":1349},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Identifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1329-1349",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for IntegrationMockDatabase {\n    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }\n\n    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            return Ok(self.entities.clone());\n        }\n\n        // Simulate Datalog filtering\n        let filtered: Vec<Entity> = self.entities.iter()\n            .filter(|e| {\n                // Parse simple Datalog clauses\n                if where_clause.contains(\"is_public = true\") {\n                    e.is_public == Some(true)\n                } else if where_clause.contains(\"is_async = true\") {\n                    e.is_async == Some(true)\n                } else if where_clause.contains(\"entity_type = 'fn'\") {\n                    e.entity_type == \"fn\"\n                } else if where_clause.contains(\"future_action != null\") {\n                    e.future_action.is_some()\n                } else {\n                    true\n                }\n            })\n            .cloned()\n            .collect();\n\n        Ok(filtered)\n    }\n\n    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(self.edges.clone())\n    }\n\n    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        if where_clause == \"ALL\" {\n            return Ok(self.edges.clone());\n        }\n\n        let filtered: Vec<Edge> = self.edges.iter()\n            .filter(|e| {\n                if where_clause.contains(\"edge_type = 'depends_on'\") {\n                    e.edge_type == \"depends_on\"\n                } else if where_clause.contains(\"edge_type = 'implements'\") {\n                    e.edge_type == \"implements\"\n                } else {\n                    true\n                }\n            })\n            .cloned()\n            .collect();\n\n        Ok(filtered)\n    }\n}",
      "current_ind": 1,
      "entity_name": "IntegrationMockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"IntegrationMockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":158,\"end\":214},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:IntegrationMockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:158-214",
      "line_number": 0
    },
    {
      "current_code": "impl IntegrationMockDatabase {\n    /// Create database with realistic Parseltongue-like data\n    fn create_realistic() -> Self {\n        Self {\n            entities: vec![\n                // Public async function with type information\n                Entity {\n                    isgl1_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    forward_deps: vec![\n                        \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                        \"rust:trait:LevelExporter:src_export_trait_rs:10\".to_string(),\n                    ],\n                    reverse_deps: vec![],\n                    current_ind: 1,\n                    future_ind: 0,\n                    future_action: None,\n                    future_code: None,\n                    current_code: Some(\"pub async fn export_level1(config: &ExportConfig) -> Result<ExportOutput> { todo!() }\".to_string()),\n                    entity_name: \"export_level1\".to_string(),\n                    entity_type: \"fn\".to_string(),\n                    file_path: \"src/exporters.rs\".to_string(),\n                    line_number: 42,\n                    interface_signature: \"pub async fn export_level1(config: &ExportConfig) -> Result<ExportOutput>\".to_string(),\n                    doc_comment: Some(\"Export Level 1 entities to JSON\".to_string()),\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    // Level 2 type fields\n                    return_type: Some(\"Result<ExportOutput>\".to_string()),\n                    param_types: Some(vec![\"&ExportConfig\".to_string()]),\n                    param_names: Some(vec![\"config\".to_string()]),\n                    generic_constraints: None,\n                    trait_impls: None,\n                    is_public: Some(true),\n                    is_async: Some(true),\n                    is_unsafe: Some(false),\n                },\n\n                // Private sync function without type info\n                Entity {\n                    isgl1_key: \"rust:fn:helper:src_utils_rs:100\".to_string(),\n                    forward_deps: vec![],\n                    reverse_deps: vec![\"rust:fn:export_level1:src_exporters_rs:42\".to_string()],\n                    current_ind: 1,\n                    future_ind: 1,\n                    future_action: Some(\"refactor\".to_string()),\n                    future_code: Some(\"fn helper_v2() -> bool { true }\".to_string()),\n                    current_code: Some(\"fn helper() -> bool { false }\".to_string()),\n                    entity_name: \"helper\".to_string(),\n                    entity_type: \"fn\".to_string(),\n                    file_path: \"src/utils.rs\".to_string(),\n                    line_number: 100,\n                    interface_signature: \"fn helper() -> bool\".to_string(),\n                    doc_comment: None,\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    return_type: Some(\"bool\".to_string()),\n                    param_types: None,\n                    param_names: None,\n                    generic_constraints: None,\n                    trait_impls: None,\n                    is_public: Some(false),\n                    is_async: Some(false),\n                    is_unsafe: Some(false),\n                },\n\n                // Struct with trait implementations\n                Entity {\n                    isgl1_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    forward_deps: vec![],\n                    reverse_deps: vec![\"rust:fn:export_level1:src_exporters_rs:42\".to_string()],\n                    current_ind: 1,\n                    future_ind: 0,\n                    future_action: None,\n                    future_code: None,\n                    current_code: Some(\"#[derive(Debug, Clone)]\\npub struct ExportConfig { level: u8 }\".to_string()),\n                    entity_name: \"ExportConfig\".to_string(),\n                    entity_type: \"struct\".to_string(),\n                    file_path: \"src/models.rs\".to_string(),\n                    line_number: 15,\n                    interface_signature: \"pub struct ExportConfig\".to_string(),\n                    doc_comment: Some(\"Configuration for export operations\".to_string()),\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    return_type: None,\n                    param_types: None,\n                    param_names: None,\n                    generic_constraints: None,\n                    trait_impls: Some(vec![\"Debug\".to_string(), \"Clone\".to_string()]),\n                    is_public: Some(true),\n                    is_async: None,\n                    is_unsafe: None,\n                },\n            ],\n            edges: vec![\n                Edge {\n                    from_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    to_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    edge_type: \"depends_on\".to_string(),\n                },\n                Edge {\n                    from_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    to_key: \"rust:trait:LevelExporter:src_export_trait_rs:10\".to_string(),\n                    edge_type: \"depends_on\".to_string(),\n                },\n                Edge {\n                    from_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    to_key: \"rust:trait:Debug:external:0\".to_string(),\n                    edge_type: \"implements\".to_string(),\n                },\n            ],\n        }\n    }\n\n    fn empty() -> Self {\n        Self {\n            entities: vec![],\n            edges: vec![],\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "IntegrationMockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"IntegrationMockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":36,\"end\":155},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:IntegrationMockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:36-155",
      "line_number": 0
    },
    {
      "current_code": "impl Isgl1Key {\n    /// Creates new ISGL1 key, validating non-empty\n    ///\n    /// # Errors\n    ///\n    /// Returns `InvalidIsgl1Key` if the key is empty.\n    pub fn new(key: impl Into<String>) -> Result<Self> {\n        let key = key.into();\n        if key.is_empty() {\n            Err(ParseltongError::InvalidIsgl1Key {\n                key,\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            })\n        } else {\n            Ok(Self(key))\n        }\n    }\n\n    /// Creates key without validation (for trusted sources like database reads)\n    ///\n    /// # Safety\n    ///\n    /// Caller must ensure the key is non-empty.\n    pub fn new_unchecked(key: impl Into<String>) -> Self {\n        Self(key.into())\n    }\n\n    /// Returns key as string slice\n    pub fn as_str(&self) -> &str {\n        &self.0\n    }\n\n    /// Consumes the Isgl1Key and returns the inner String\n    pub fn into_inner(self) -> String {\n        self.0\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1Key",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1Key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":865,\"end\":901},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1Key:__crates_parseltongue-core_src_entities_rs:865-901",
      "line_number": 0
    },
    {
      "current_code": "impl AsRef<str> for Isgl1Key {\n    fn as_ref(&self) -> &str {\n        &self.0\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1Key",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1Key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":904,\"end\":908},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1Key:__crates_parseltongue-core_src_entities_rs:904-908",
      "line_number": 0
    },
    {
      "current_code": "impl std::fmt::Display for Isgl1Key {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1Key",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1Key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":910,\"end\":914},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1Key:__crates_parseltongue-core_src_entities_rs:910-914",
      "line_number": 0
    },
    {
      "current_code": "impl Isgl1KeyGeneratorFactory {\n    /// Create new ISGL1 key generator instance\n    pub fn new() -> Arc<dyn Isgl1KeyGenerator> {\n        Arc::new(Isgl1KeyGeneratorImpl::new())\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorFactory",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1KeyGeneratorFactory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":390,\"end\":395},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1KeyGeneratorFactory:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:390-395",
      "line_number": 0
    },
    {
      "current_code": "impl Default for Isgl1KeyGeneratorImpl {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1KeyGeneratorImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":100,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1KeyGeneratorImpl:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:100-104",
      "line_number": 0
    },
    {
      "current_code": "impl Isgl1KeyGeneratorImpl {\n    /// Create new ISGL1 key generator with support for 13 languages\n    pub fn new() -> Self {\n        let mut parsers = HashMap::new();\n\n        // Helper macro to initialize parser for a language\n        macro_rules! init_parser {\n            ($lang:expr, $grammar:expr) => {\n                let mut parser = Parser::new();\n                if parser.set_language($grammar).is_ok() {\n                    parsers.insert($lang, Arc::new(Mutex::new(parser)));\n                }\n            };\n        }\n\n        // Initialize all language parsers\n        // LanguageFn must be converted to Language using .into() for tree-sitter 0.24+\n        init_parser!(Language::Rust, &tree_sitter_rust::LANGUAGE.into());\n        init_parser!(Language::Python, &tree_sitter_python::LANGUAGE.into());\n        init_parser!(Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into());\n        init_parser!(Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into());\n        init_parser!(Language::Go, &tree_sitter_go::LANGUAGE.into());\n        init_parser!(Language::Java, &tree_sitter_java::LANGUAGE.into());\n        init_parser!(Language::Cpp, &tree_sitter_cpp::LANGUAGE.into());\n        init_parser!(Language::Ruby, &tree_sitter_ruby::LANGUAGE.into());\n        init_parser!(Language::Php, &tree_sitter_php::LANGUAGE_PHP.into());\n        init_parser!(Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into());\n        init_parser!(Language::Swift, &tree_sitter_swift::LANGUAGE.into());\n        // Note: Kotlin not supported in v0.8.7 - tree-sitter-kotlin v0.3 uses incompatible tree-sitter 0.20\n        // Will be added when tree-sitter-kotlin updates to 0.24+\n        init_parser!(Language::Scala, &tree_sitter_scala::LANGUAGE.into());\n\n        // v0.8.9: Initialize QueryBasedExtractor for multi-language entity extraction\n        let query_extractor = QueryBasedExtractor::new()\n            .expect(\"Failed to initialize QueryBasedExtractor - .scm query files missing\");\n\n        Self {\n            parsers,\n            query_extractor: Mutex::new(query_extractor),\n        }\n    }\n\n    /// Generate ISGL1 key format: {language}:{type}:{name}:{location}\n    fn format_key(&self, entity: &ParsedEntity) -> String {\n        let type_str = match entity.entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Class => \"class\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Impl => \"impl\",\n            EntityType::Module => \"mod\",\n            EntityType::Namespace => \"namespace\",\n            EntityType::Typedef => \"typedef\",\n            EntityType::Variable => \"var\",\n        };\n\n        format!(\n            \"{}:{}:{}:{}:{}-{}\",\n            entity.language,\n            type_str,\n            entity.name,\n            self.sanitize_path(&entity.file_path),\n            entity.line_range.0,\n            entity.line_range.1\n        )\n    }\n\n    /// Sanitize file path for ISGL1 key\n    fn sanitize_path(&self, path: &str) -> String {\n        path.replace(['/', '\\\\', '.'], \"_\")\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1KeyGeneratorImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":106,\"end\":179},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1KeyGeneratorImpl:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:106-179",
      "line_number": 0
    },
    {
      "current_code": "impl Isgl1KeyGenerator for Isgl1KeyGeneratorImpl {\n    fn generate_key(&self, entity: &ParsedEntity) -> Result<String> {\n        Ok(self.format_key(entity))\n    }\n\n    fn parse_source(&self, source: &str, file_path: &Path) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        let language_type = self.get_language_type(file_path)?;\n\n        let parser_mutex = self.parsers.get(&language_type)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: format!(\"No parser available for language: {:?}\", language_type),\n            })?;\n\n        let mut parser = parser_mutex.lock().unwrap();\n        let tree = parser\n            .parse(source, None)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: \"Failed to parse source code\".to_string(),\n            })?;\n\n        let mut entities = Vec::new();\n        let mut dependencies = Vec::new();\n        self.extract_entities(&tree, source, file_path, language_type, &mut entities, &mut dependencies);\n\n        Ok((entities, dependencies))\n    }\n\n    fn get_language_type(&self, file_path: &Path) -> Result<Language> {\n        // Use Language::from_file_path to detect language from extension\n        let path_buf = file_path.to_path_buf();\n        let language = Language::from_file_path(&path_buf)\n            .ok_or_else(|| StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            })?;\n\n        // Verify we have a parser for this language\n        if self.parsers.contains_key(&language) {\n            Ok(language)\n        } else {\n            Err(StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            })\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1KeyGeneratorImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":181,\"end\":227},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1KeyGeneratorImpl:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:181-227",
      "line_number": 0
    },
    {
      "current_code": "impl Isgl1KeyGeneratorImpl {\n    /// Map QueryBasedExtractor's EntityType to pt01's EntityType\n    ///\n    /// **Design Pattern**: Pure function with exhaustive pattern matching\n    /// **v0.8.9**: Bridges query-based extraction (parseltongue-core) to pt01's type system\n    fn map_query_entity_type(\n        &self,\n        query_type: &parseltongue_core::query_extractor::EntityType\n    ) -> EntityType {\n        match query_type {\n            parseltongue_core::query_extractor::EntityType::Function => EntityType::Function,\n            parseltongue_core::query_extractor::EntityType::Class => EntityType::Class,\n            parseltongue_core::query_extractor::EntityType::Method => EntityType::Method,\n            parseltongue_core::query_extractor::EntityType::Struct => EntityType::Struct,\n            parseltongue_core::query_extractor::EntityType::Enum => EntityType::Enum,\n            parseltongue_core::query_extractor::EntityType::Trait => EntityType::Trait,\n            parseltongue_core::query_extractor::EntityType::Interface => EntityType::Trait,  // Map Interface to Trait (protocols, interfaces)\n            parseltongue_core::query_extractor::EntityType::Impl => EntityType::Impl,\n            parseltongue_core::query_extractor::EntityType::Module => EntityType::Module,\n            parseltongue_core::query_extractor::EntityType::Namespace => EntityType::Namespace,\n            parseltongue_core::query_extractor::EntityType::Typedef => EntityType::Typedef,\n        }\n    }\n\n    /// Enrich Rust entities with attribute metadata (#[test], #[tokio::test], etc.)\n    ///\n    /// **v0.9.0 Feature**: Rust-specific attribute parsing layer\n    ///\n    /// **Design Pattern**: Post-processing enrichment\n    /// - QueryBasedExtractor extracts entities (language-agnostic)\n    /// - This method adds Rust-specific metadata (attributes)\n    ///\n    /// **Preconditions**:\n    /// - entities vec populated by QueryBasedExtractor\n    /// - source contains valid Rust code\n    ///\n    /// **Postconditions**:\n    /// - Entities with #[test] have metadata[\"is_test\"] = \"true\"\n    /// - Entities with #[tokio::test] have metadata[\"is_test\"] = \"true\"\n    /// - Entities with #[async_test] have metadata[\"is_test\"] = \"true\"\n    ///\n    /// **Performance**: O(lines * entities) - efficient for typical files\n    fn enrich_rust_entities_with_attributes(\n        &self,\n        entities: &mut [ParsedEntity],\n        source: &str,\n    ) {\n        let lines: Vec<&str> = source.lines().collect();\n\n        // Build map of entity start lines for O(1) lookup\n        let mut entity_lines: std::collections::HashMap<usize, &mut ParsedEntity> =\n            std::collections::HashMap::new();\n\n        for entity in entities.iter_mut() {\n            entity_lines.insert(entity.line_range.0, entity);\n        }\n\n        // Scan source for attributes and match to entities\n        for (idx, line) in lines.iter().enumerate() {\n            let trimmed = line.trim();\n\n            // Check if this line is a test attribute\n            if trimmed == \"#[test]\" || trimmed == \"#[tokio::test]\" || trimmed == \"#[async_test]\" {\n                // Look for entity on next non-attribute line\n                for next_idx in (idx + 1)..lines.len() {\n                    let next_line = lines[next_idx].trim();\n\n                    // Skip more attributes\n                    if next_line.starts_with(\"#[\") {\n                        continue;\n                    }\n\n                    // Check if next line starts a function\n                    if next_line.starts_with(\"fn \") || next_line.starts_with(\"async fn \") || next_line.starts_with(\"pub fn \") || next_line.starts_with(\"pub async fn \") {\n                        let entity_line = next_idx + 1;\n\n                        // Find entity at this line and mark as test\n                        if let Some(entity) = entity_lines.get_mut(&entity_line) {\n                            entity.metadata.insert(\"is_test\".to_string(), \"true\".to_string());\n                        }\n                        break;\n                    }\n\n                    // If we hit non-whitespace that's not a function, stop looking\n                    if !next_line.is_empty() {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// Extract entities AND dependencies from parse tree (two-pass for correctness)\n    ///\n    /// ## v0.8.9 Hybrid Approach\n    ///\n    /// **Pass 1** (All languages): Use QueryBasedExtractor for entity extraction\n    /// - Replaces manual walk_node() which only worked for Rust\n    /// - Fixes Ruby, Python, JS, TS, Go, Java, C, C++, PHP, C#, Swift extraction\n    ///\n    /// **Pass 2** (Rust only): Use manual traversal for dependency extraction\n    /// - Function call graphs require custom logic not yet in .scm queries\n    /// - Future: Move dependency extraction to queries as well\n    fn extract_entities(\n        &self,\n        _tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // v0.8.9 CRITICAL FIX: Use QueryBasedExtractor for entity extraction\n        //\n        // This replaces the broken walk_node() approach that only worked for Rust.\n        // Now ALL 12 languages extract entities correctly via .scm query files.\n        match self.query_extractor.lock() {\n            Ok(mut extractor) => {\n                match extractor.parse_source(source, file_path, language) {\n                    Ok((query_entities, query_deps)) => {\n                        // Convert QueryBasedExtractor entities to pt01 ParsedEntity format\n                        for query_entity in query_entities {\n                            entities.push(ParsedEntity {\n                                entity_type: self.map_query_entity_type(&query_entity.entity_type),\n                                name: query_entity.name,\n                                language: query_entity.language,\n                                line_range: query_entity.line_range,\n                                file_path: query_entity.file_path,\n                                metadata: query_entity.metadata,\n                            });\n                        }\n\n                        // v0.9.0 FEATURE: Rust-specific attribute parsing\n                        // Enrich Rust entities with #[test] metadata after extraction\n                        if language == Language::Rust {\n                            self.enrich_rust_entities_with_attributes(entities, source);\n                        }\n\n                        // v0.9.0 CRITICAL FIX: Use query-based dependency extraction\n                        // This replaces manual tree-walking for dependency extraction\n                        dependencies.extend(query_deps);\n                    }\n                    Err(e) => {\n                        // Graceful degradation: log error but continue\n                        eprintln!(\"QueryBasedExtractor failed for {:?}: {}\", language, e);\n                    }\n                }\n            }\n            Err(e) => {\n                eprintln!(\"Failed to lock query_extractor: {}\", e);\n            }\n        }\n\n        // v0.9.0: Manual dependency extraction replaced by query-based approach (REFACTORED)\n        // All entity and dependency extraction now handled by QueryBasedExtractor\n    }\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Isgl1KeyGeneratorImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":229,\"end\":385},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Isgl1KeyGeneratorImpl:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:229-385",
      "line_number": 0
    },
    {
      "current_code": "impl Language {\n    /// Get file extensions associated with this language\n    pub fn file_extensions(&self) -> Vec<&'static str> {\n        match self {\n            Language::Rust => vec![\"rs\"],\n            Language::JavaScript => vec![\"js\", \"jsx\"],\n            Language::TypeScript => vec![\"ts\", \"tsx\"],\n            Language::Python => vec![\"py\"],\n            Language::Java => vec![\"java\"],\n            Language::C => vec![\"c\", \"h\"],\n            Language::Cpp => vec![\"cpp\", \"cc\", \"cxx\", \"hpp\"],\n            Language::Go => vec![\"go\"],\n            Language::Ruby => vec![\"rb\"],\n            Language::Php => vec![\"php\"],\n            Language::CSharp => vec![\"cs\"],\n            Language::Swift => vec![\"swift\"],\n            Language::Kotlin => vec![\"kt\", \"kts\"],\n            Language::Scala => vec![\"scala\", \"sc\"],\n        }\n    }\n\n    /// Detect language from file path\n    pub fn from_file_path(path: &PathBuf) -> Option<Self> {\n        let extension = path.extension()?.to_str()?;\n\n        [\n            Language::Rust,\n            Language::JavaScript,\n            Language::TypeScript,\n            Language::Python,\n            Language::Java,\n            Language::C,\n            Language::Cpp,\n            Language::Go,\n            Language::Ruby,\n            Language::Php,\n            Language::CSharp,\n            Language::Swift,\n            Language::Kotlin,\n            Language::Scala,\n        ].into_iter().find(|&language| language.file_extensions().contains(&extension))\n    }\n}",
      "current_ind": 1,
      "entity_name": "Language",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Language\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":31,\"end\":73},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Language:__crates_parseltongue-core_src_entities_rs:31-73",
      "line_number": 0
    },
    {
      "current_code": "impl fmt::Display for Language {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Language::Rust => write!(f, \"rust\"),\n            Language::JavaScript => write!(f, \"javascript\"),\n            Language::TypeScript => write!(f, \"typescript\"),\n            Language::Python => write!(f, \"python\"),\n            Language::Java => write!(f, \"java\"),\n            Language::C => write!(f, \"c\"),\n            Language::Cpp => write!(f, \"cpp\"),\n            Language::Go => write!(f, \"go\"),\n            Language::Ruby => write!(f, \"ruby\"),\n            Language::Php => write!(f, \"php\"),\n            Language::CSharp => write!(f, \"csharp\"),\n            Language::Swift => write!(f, \"swift\"),\n            Language::Kotlin => write!(f, \"kotlin\"),\n            Language::Scala => write!(f, \"scala\"),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Language",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Language\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":75,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Language:__crates_parseltongue-core_src_entities_rs:75-94",
      "line_number": 0
    },
    {
      "current_code": "impl Level0Exporter {\n    pub fn new() -> Self {\n        Self\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level0Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level0Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":29,\"end\":33},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level0Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:29-33",
      "line_number": 0
    },
    {
      "current_code": "impl Default for Level0Exporter {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level0Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level0Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":35,\"end\":39},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level0Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:35-39",
      "line_number": 0
    },
    {
      "current_code": "impl LevelExporter for Level0Exporter {\n    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 3 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query edges from database\n        let edges = if config.where_filter == \"ALL\" {\n            db.get_all_edges().await?\n        } else {\n            db.query_edges(&config.where_filter).await?\n        };\n\n        // 2. Convert to DependencyEdge format\n        let dependency_edges: Vec<DependencyEdge> = edges\n            .into_iter()\n            .map(|edge| DependencyEdge {\n                from_key: edge.from_key,\n                to_key: edge.to_key,\n                edge_type: edge.edge_type,\n            })\n            .collect();\n\n        // 3. Count edges for metadata\n        let total_edges = dependency_edges.len();\n\n        // 4. Build metadata\n        let metadata = ExportMetadata {\n            level: 0,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: None,  // Level 0 has no entities\n            total_edges: Some(total_edges),\n            include_code: None,    // N/A for Level 0\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 5. Build output\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: None,                    // Level 0 has no entities\n            edges: Some(dependency_edges),     // Only edges\n        })\n    }\n\n    fn level(&self) -> u8 {\n        0\n    }\n\n    fn estimated_tokens(&self) -> usize {\n        // Conservative estimate: ~2.5 tokens per edge (from_key + to_key + edge_type)\n        // For 2000 edges: ~5000 tokens\n        5_000\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level0Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level0Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":42,\"end\":97},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level0Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:42-97",
      "line_number": 0
    },
    {
      "current_code": "impl Level1Exporter {\n    pub fn new() -> Self {\n        Self\n    }\n\n    /// Convert Entity to EntityExportLevel1 with null-skipping\n    fn convert_entity(\n        entity: &crate::export_trait::Entity,\n        include_code: bool,\n    ) -> EntityExportLevel1 {\n        EntityExportLevel1 {\n            isgl1_key: entity.isgl1_key.clone(),\n            forward_deps: entity.forward_deps.clone(),\n            reverse_deps: entity.reverse_deps.clone(),\n            current_ind: entity.current_ind,\n            future_ind: entity.future_ind,\n            future_action: entity.future_action.clone(),\n            // future_code: Only include when future_action is Some\n            future_code: if entity.future_action.is_some() {\n                entity.future_code.clone()\n            } else {\n                None\n            },\n            // current_code: Only include when config.include_code = true\n            current_code: if include_code {\n                entity.current_code.clone()\n            } else {\n                None\n            },\n            entity_name: entity.entity_name.clone(),\n            entity_type: entity.entity_type.clone(),\n            file_path: entity.file_path.clone(),\n            line_number: entity.line_number,\n            interface_signature: entity.interface_signature.clone(),\n            doc_comment: entity.doc_comment.clone(),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level1Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level1Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":51,\"end\":88},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level1Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:51-88",
      "line_number": 0
    },
    {
      "current_code": "impl Default for Level1Exporter {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level1Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level1Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":90,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level1Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:90-94",
      "line_number": 0
    },
    {
      "current_code": "impl LevelExporter for Level1Exporter {\n    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 3 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query entities from database\n        let entities = if config.where_filter == \"ALL\" {\n            db.get_all_entities().await?\n        } else {\n            db.query_entities(&config.where_filter).await?\n        };\n\n        // v0.9.0: Separate entities by EntityClass for dual output\n        let (code_entities, test_entities): (Vec<_>, Vec<_>) = entities\n            .iter()\n            .partition(|e| e.entity_class == \"CODE\");\n\n        // 2. Convert to Level1 format (separate for code and tests)\n        let code_level1_entities: Vec<EntityExportLevel1> = code_entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n        \n        let test_level1_entities: Vec<EntityExportLevel1> = test_entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n\n        // 3. Count entities for metadata\n        let total_entities = entities.len();\n        let code_entities_count = code_level1_entities.len();\n        let test_entities_count = test_level1_entities.len();\n\n        // v0.9.0: Generate dual outputs based on ExportConfig\n        let outputs = if config.code_output_path.is_some() || config.tests_output_path.is_some() {\n            // Dual output mode: separate files for code and tests\n            let mut outputs = std::collections::HashMap::new();\n            \n            // Code output\n            if let Some(code_path) = &config.code_output_path {\n                let code_json = serde_json::to_value(&code_level1_entities)?;\n                outputs.insert(code_path.clone(), code_json);\n            }\n            \n            // Tests output\n            if let Some(tests_path) = &config.tests_output_path {\n                let tests_json = serde_json::to_value(&test_level1_entities)?;\n                outputs.insert(tests_path.clone(), tests_json);\n            }\n            \n            outputs\n        } else {\n            // Legacy mode: single output with all entities\n            let all_entities = serde_json::to_value(&code_level1_entities)?;\n            let mut outputs = std::collections::HashMap::new();\n            outputs.insert(config.output_path.clone(), all_entities);\n            outputs\n        };\n\n        // 4. Build metadata with EntityClass information\n        let metadata = ExportMetadata {\n            level: 1,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: Some(total_entities),\n            total_edges: None,  // Level 1 has no edges\n            include_code: Some(config.include_code),\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 5. Build output (v0.9.0: support dual outputs)\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: Some(serde_json::to_value(&code_level1_entities)?), // Primary output\n            edges: None,  // Level 1 has no edges\n        })\n    }\n\n    fn level(&self) -> u8 {\n        1\n    }\n\n    fn estimated_tokens(&self) -> usize {\n        // Estimate: ~50 tokens per entity (signatures only)\n        // For 590 entities: ~30K tokens\n        30_000\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level1Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level1Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":97,\"end\":186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level1Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:97-186",
      "line_number": 0
    },
    {
      "current_code": "impl Default for Level2Exporter {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level2Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level2Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":100,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level2Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:100-104",
      "line_number": 0
    },
    {
      "current_code": "impl LevelExporter for Level2Exporter {\n    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 4 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query entities from database\n        let entities = if config.where_filter == \"ALL\" {\n            db.get_all_entities().await?\n        } else {\n            db.query_entities(&config.where_filter).await?\n        };\n\n        // 2. Convert to Level2 format\n        let level2_entities: Vec<EntityExportLevel2> = entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n\n        // 3. Count entities for metadata\n        let total_entities = level2_entities.len();\n\n        // 4. Serialize entities to JSON (serde handles null-skipping via attributes)\n        let entities_json = serde_json::to_value(&level2_entities)?;\n\n        // 5. Build metadata\n        let metadata = ExportMetadata {\n            level: 2,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: Some(total_entities),\n            total_edges: None,  // Level 2 has no edges\n            include_code: Some(config.include_code),\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 6. Build output\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: Some(entities_json),\n            edges: None,  // Level 2 has no edges\n        })\n    }\n\n    fn level(&self) -> u8 {\n        2\n    }\n\n    fn estimated_tokens(&self) -> usize {\n        // Estimate: ~100 tokens per entity (signatures + type info)\n        // For 590 entities: ~60K tokens\n        60_000\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level2Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level2Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":107,\"end\":161},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level2Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:107-161",
      "line_number": 0
    },
    {
      "current_code": "impl Level2Exporter {\n    pub fn new() -> Self {\n        Self\n    }\n\n    /// Convert Entity to EntityExportLevel2 with type information\n    fn convert_entity(\n        entity: &crate::export_trait::Entity,\n        include_code: bool,\n    ) -> EntityExportLevel2 {\n        EntityExportLevel2 {\n            // Level 1 fields (inherited)\n            isgl1_key: entity.isgl1_key.clone(),\n            forward_deps: entity.forward_deps.clone(),\n            reverse_deps: entity.reverse_deps.clone(),\n            current_ind: entity.current_ind,\n            future_ind: entity.future_ind,\n            future_action: entity.future_action.clone(),\n            // future_code: Only include when future_action is Some\n            future_code: if entity.future_action.is_some() {\n                entity.future_code.clone()\n            } else {\n                None\n            },\n            // current_code: Only include when config.include_code = true\n            current_code: if include_code {\n                entity.current_code.clone()\n            } else {\n                None\n            },\n            entity_name: entity.entity_name.clone(),\n            entity_type: entity.entity_type.clone(),\n            file_path: entity.file_path.clone(),\n            line_number: entity.line_number,\n            interface_signature: entity.interface_signature.clone(),\n            doc_comment: entity.doc_comment.clone(),\n\n            // Level 2 fields (type system)\n            return_type: entity.return_type.clone(),\n            // Convert Option<Vec<T>> to Vec<T> for serde skip_serializing_if\n            param_types: entity.param_types.clone().unwrap_or_default(),\n            param_names: entity.param_names.clone().unwrap_or_default(),\n            generic_constraints: entity.generic_constraints.clone().unwrap_or_default(),\n            trait_impls: entity.trait_impls.clone().unwrap_or_default(),\n            // Safety flags with defaults\n            is_public: entity.is_public.unwrap_or(false),\n            is_async: entity.is_async.unwrap_or(false),\n            is_unsafe: entity.is_unsafe.unwrap_or(false),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "Level2Exporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Level2Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":48,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Level2Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:48-98",
      "line_number": 0
    },
    {
      "current_code": "impl LineRange {\n    /// Create new line range\n    pub fn new(start: u32, end: u32) -> Result<Self> {\n        if start == 0 || end == 0 {\n            return Err(ParseltongError::ValidationError {\n                field: \"line numbers\".to_string(),\n                expected: \"1-based line numbers\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        if start > end {\n            return Err(ParseltongError::ValidationError {\n                field: \"line range\".to_string(),\n                expected: \"start <= end\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        Ok(Self { start, end })\n    }\n\n    /// Get the span (number of lines)\n    pub fn span(&self) -> u32 {\n        self.end - self.start + 1\n    }\n\n    /// Check if a line is within this range\n    pub fn contains(&self, line: u32) -> bool {\n        line >= self.start && line <= self.end\n    }\n}",
      "current_ind": 1,
      "entity_name": "LineRange",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"LineRange\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":284,\"end\":315},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:LineRange:__crates_parseltongue-core_src_entities_rs:284-315",
      "line_number": 0
    },
    {
      "current_code": "impl Default for LlmWriterConfig {\n    fn default() -> Self {\n        Self {\n            query: String::new(),\n            db_path: \"parseltongue.db\".to_string(),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "LlmWriterConfig",
      "entity_type": "impl",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"LlmWriterConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":174,\"end\":181},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:LlmWriterConfig:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:174-181",
      "line_number": 0
    },
    {
      "current_code": "    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }\n\n        async fn query_entities(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n            Ok(self.edges.clone())\n        }\n\n        async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n            if where_clause == \"ALL\" {\n                Ok(self.edges.clone())\n            } else if where_clause.contains(\"edge_type = 'depends_on'\") {\n                Ok(self.edges.iter()\n                    .filter(|e| e.edge_type == \"depends_on\")\n                    .cloned()\n                    .collect())\n            } else {\n                Ok(self.edges.clone())\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":110,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:110-135",
      "line_number": 0
    },
    {
      "current_code": "    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }\n\n        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else if where_clause.contains(\"future_action != null\") {\n                        e.future_action.is_some()\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n\n        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":199,\"end\":234},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:199-234",
      "line_number": 0
    },
    {
      "current_code": "    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }\n\n        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_async = true\") {\n                        e.is_async == Some(true)\n                    } else if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n\n        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":174,\"end\":209},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:174-209",
      "line_number": 0
    },
    {
      "current_code": "impl MockDatabase {\n    fn new() -> Self {\n        Self {\n            edges: vec![],\n            entities: vec![],\n        }\n    }\n\n    fn with_edges(edges: Vec<Edge>) -> Self {\n        Self {\n            edges,\n            entities: vec![],\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":37,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:37-51",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for MockDatabase {\n    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }\n\n    async fn query_entities(&self, _where_clause: &str) -> Result<Vec<Entity>> {\n        // Simple filter implementation for testing\n        Ok(self.entities.clone())\n    }\n\n    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(self.edges.clone())\n    }\n\n    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        // Simple filter implementation for testing\n        if where_clause == \"ALL\" {\n            Ok(self.edges.clone())\n        } else if where_clause.contains(\"edge_type = 'depends_on'\") {\n            Ok(self.edges.iter()\n                .filter(|e| e.edge_type == \"depends_on\")\n                .cloned()\n                .collect())\n        } else {\n            Ok(self.edges.clone())\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":54,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:54-81",
      "line_number": 0
    },
    {
      "current_code": "impl MockDatabase {\n    fn with_entities(entities: Vec<Entity>) -> Self {\n        Self { entities }\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":42,\"end\":46},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:42-46",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for MockDatabase {\n    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }\n\n    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            Ok(self.entities.clone())\n        } else if where_clause.contains(\"is_public = true\") {\n            Ok(self.entities.iter()\n                .filter(|e| e.is_public == Some(true))\n                .cloned()\n                .collect())\n        } else if where_clause.contains(\"future_action != null\") {\n            Ok(self.entities.iter()\n                .filter(|e| e.future_action.is_some())\n                .cloned()\n                .collect())\n        } else {\n            Ok(self.entities.clone())\n        }\n    }\n\n    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }\n\n    async fn query_edges(&self, _where_clause: &str) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":49,\"end\":79},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:49-79",
      "line_number": 0
    },
    {
      "current_code": "impl MockDatabase {\n    fn with_entities(entities: Vec<Entity>) -> Self {\n        Self { entities }\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":38,\"end\":42},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:38-42",
      "line_number": 0
    },
    {
      "current_code": "impl CodeGraphRepository for MockDatabase {\n    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }\n\n    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            Ok(self.entities.clone())\n        } else {\n            Ok(self.entities.clone())\n        }\n    }\n\n    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }\n\n    async fn query_edges(&self, _where_clause: &str) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":45,\"end\":65},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:45-65",
      "line_number": 0
    },
    {
      "current_code": "    impl LevelExporter for MockExporter {\n        async fn export(&self, _db: &dyn CodeGraphRepository, _config: &ExportConfig) -> Result<ExportOutput> {\n            todo!(\"Mock implementation\")\n        }\n\n        fn level(&self) -> u8 {\n            self.level\n        }\n\n        fn estimated_tokens(&self) -> usize {\n            self.tokens\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockExporter",
      "entity_type": "impl",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockExporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":166,\"end\":178},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockExporter:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:166-178",
      "line_number": 0
    },
    {
      "current_code": "impl MockRustAnalyzerClient {\n    pub fn new() -> Self {\n        Self {\n            responses: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn add_response(&mut self, key: String, response: HoverResponse) {\n        self.responses.insert(key, response);\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockRustAnalyzerClient",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockRustAnalyzerClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":106,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockRustAnalyzerClient:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:106-116",
      "line_number": 0
    },
    {
      "current_code": "impl RustAnalyzerClient for MockRustAnalyzerClient {\n    async fn hover(\n        &self,\n        file_path: &Path,\n        line: u32,\n        character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        let key = format!(\"{}:{}:{}\", file_path.display(), line, character);\n        Ok(self.responses.get(&key).cloned())\n    }\n\n    async fn is_available(&self) -> bool {\n        true\n    }\n}",
      "current_ind": 1,
      "entity_name": "MockRustAnalyzerClient",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockRustAnalyzerClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":120,\"end\":134},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockRustAnalyzerClient:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:120-134",
      "line_number": 0
    },
    {
      "current_code": "    impl MockTool {\n        pub fn new(name: &str) -> Self {\n            Self {\n                metadata: ToolMetadata {\n                    id: format!(\"mock-{}\", name),\n                    name: name.to_string(),\n                    version: \"1.0.0\".to_string(),\n                    description: format!(\"Mock implementation of {}\", name),\n                    supported_inputs: vec![],\n                    capabilities: ToolCapabilities {\n                        async_execution: true,\n                        parallel_processing: false,\n                        incremental_processing: false,\n                        requires_network: false,\n                        max_input_size: None,\n                    },\n                },\n                execute_result: None,\n                should_fail: false,\n            }\n        }\n\n        pub fn with_execute_result(mut self, result: Result<ToolOutput>) -> Self {\n            self.execute_result = Some(result);\n            self\n        }\n\n        pub fn with_failure(mut self) -> Self {\n            self.should_fail = true;\n            self\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockTool",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockTool\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":548,\"end\":579},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockTool:__crates_parseltongue-core_src_interfaces_rs:548-579",
      "line_number": 0
    },
    {
      "current_code": "    impl Tool for MockTool {\n        async fn execute(&self, _input: ToolInput) -> Result<ToolOutput> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ConfigurationError {\n                    details: \"Mock tool configured to fail\".to_string(),\n                });\n            }\n\n            self.execute_result\n                .clone()\n                .unwrap_or(Ok(ToolOutput::IndexingComplete {\n                    entities_count: 0,\n                    duration_ms: 0,\n                }))\n        }\n\n        fn validate_input(&self, _input: &ToolInput) -> Result<()> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ValidationError {\n                    field: \"input\".to_string(),\n                    expected: \"valid input\".to_string(),\n                    actual: \"mock failure\".to_string(),\n                });\n            }\n            Ok(())\n        }\n\n        fn metadata(&self) -> ToolMetadata {\n            self.metadata.clone()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "MockTool",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"MockTool\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":582,\"end\":612},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:MockTool:__crates_parseltongue-core_src_interfaces_rs:582-612",
      "line_number": 0
    },
    {
      "current_code": "impl Default for NoCircularDependenciesRule {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "NoCircularDependenciesRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"NoCircularDependenciesRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":270,\"end\":274},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:NoCircularDependenciesRule:__crates_parseltongue-core_src_temporal_rs:270-274",
      "line_number": 0
    },
    {
      "current_code": "impl NoCircularDependenciesRule {\n    pub fn new() -> Self {\n        Self { _private: () }\n    }\n}",
      "current_ind": 1,
      "entity_name": "NoCircularDependenciesRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"NoCircularDependenciesRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":276,\"end\":280},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:NoCircularDependenciesRule:__crates_parseltongue-core_src_temporal_rs:276-280",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalValidationRule for NoCircularDependenciesRule {\n    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        // Simplified circular dependency detection\n        // In a real implementation, this would build a dependency graph\n        // and check for cycles\n\n        for entity in entities.values() {\n            if entity.is_modified() {\n                // Check if entity depends on itself (simplified)\n                if entity.isgl1_key.contains(&entity.interface_signature.name) {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Potential circular dependency detected for entity {}\",\n                            entity.isgl1_key\n                        ),\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "NoCircularDependenciesRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"NoCircularDependenciesRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":282,\"end\":304},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:NoCircularDependenciesRule:__crates_parseltongue-core_src_temporal_rs:282-304",
      "line_number": 0
    },
    {
      "current_code": "impl From<StreamerError> for ParseltongError {\n    fn from(err: StreamerError) -> Self {\n        match err {\n            StreamerError::FileSystemError { path, source } => {\n                ParseltongError::FileSystemError { path, source }\n            }\n            StreamerError::ParsingError { file, reason } => {\n                ParseltongError::ParseError { reason, location: file }\n            }\n            StreamerError::StorageError { details } => {\n                ParseltongError::DatabaseError {\n                    operation: \"storage\".to_string(),\n                    details,\n                }\n            }\n            StreamerError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError { details: format!(\"{}: {}\", field, reason) }\n            }\n            _ => ParseltongError::ConfigurationError {\n                details: err.to_string(),\n            },\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ParseltongError",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ParseltongError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/errors.rs\",\"line_range\":{\"start\":59,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ParseltongError:__crates_pt01-folder-to-cozodb-streamer_src_errors_rs:59-82",
      "line_number": 0
    },
    {
      "current_code": "impl From<LlmWriterError> for ParseltongError {\n    fn from(err: LlmWriterError) -> Self {\n        match err {\n            LlmWriterError::DatabaseQueryError { query, reason } => {\n                ParseltongError::DatabaseError {\n                    operation: \"query\".to_string(),\n                    details: format!(\"Query: {} - {}\", query, reason),\n                }\n            }\n            LlmWriterError::ValidationError { field, reason } => {\n                ParseltongError::ValidationError {\n                    field,\n                    expected: \"valid temporal change\".to_string(),\n                    actual: reason,\n                }\n            }\n            LlmWriterError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError {\n                    details: format!(\"{}: {}\", field, reason),\n                }\n            }\n            LlmWriterError::ResponseParseError { reason } => {\n                ParseltongError::ParseError {\n                    reason,\n                    location: \"LLM response\".to_string(),\n                }\n            }\n            _ => ParseltongError::LlmError {\n                reason: err.to_string(),\n            },\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ParseltongError",
      "entity_type": "impl",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ParseltongError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/errors.rs\",\"line_range\":{\"start\":62,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ParseltongError:__crates_pt03-llm-to-cozodb-writer_src_errors_rs:62-94",
      "line_number": 0
    },
    {
      "current_code": "impl QueryBasedExtractor {\n    /// Create new extractor with embedded query files\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use parseltongue_core::query_extractor::QueryBasedExtractor;\n    ///\n    /// let extractor = QueryBasedExtractor::new().unwrap();\n    /// // Now ready to parse Rust, Python, C, C++, Ruby code\n    /// ```\n    ///\n    /// # Performance\n    ///\n    /// Initializes parsers for all supported languages (~1ms overhead).\n    /// Query files are embedded at compile time (zero runtime I/O).\n    pub fn new() -> Result<Self> {\n        let mut queries = HashMap::new();\n\n        // Embed query files at compile time\n        queries.insert(\n            Language::Rust,\n            include_str!(\"../../../entity_queries/rust.scm\").to_string()\n        );\n        queries.insert(\n            Language::Python,\n            include_str!(\"../../../entity_queries/python.scm\").to_string()\n        );\n        queries.insert(\n            Language::C,\n            include_str!(\"../../../entity_queries/c.scm\").to_string()\n        );\n        queries.insert(\n            Language::Cpp,\n            include_str!(\"../../../entity_queries/cpp.scm\").to_string()\n        );\n        queries.insert(\n            Language::Ruby,\n            include_str!(\"../../../entity_queries/ruby.scm\").to_string()\n        );\n        queries.insert(\n            Language::JavaScript,\n            include_str!(\"../../../entity_queries/javascript.scm\").to_string()\n        );\n        queries.insert(\n            Language::TypeScript,\n            include_str!(\"../../../entity_queries/typescript.scm\").to_string()\n        );\n        queries.insert(\n            Language::Go,\n            include_str!(\"../../../entity_queries/go.scm\").to_string()\n        );\n        queries.insert(\n            Language::Java,\n            include_str!(\"../../../entity_queries/java.scm\").to_string()\n        );\n        queries.insert(\n            Language::Php,\n            include_str!(\"../../../entity_queries/php.scm\").to_string()\n        );\n        queries.insert(\n            Language::CSharp,\n            include_str!(\"../../../entity_queries/c_sharp.scm\").to_string()\n        );\n        queries.insert(\n            Language::Swift,\n            include_str!(\"../../../entity_queries/swift.scm\").to_string()\n        );\n        // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility (0.20 vs 0.25)\n        // queries.insert(\n        //     Language::Kotlin,\n        //     include_str!(\"../../../entity_queries/kotlin.scm\").to_string()\n        // );\n\n        // Initialize parsers\n        let mut parsers = HashMap::new();\n        Self::init_parser(&mut parsers, Language::Rust, &tree_sitter_rust::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Python, &tree_sitter_python::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::C, &tree_sitter_c::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Cpp, &tree_sitter_cpp::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Ruby, &tree_sitter_ruby::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into())?;\n        Self::init_parser(&mut parsers, Language::Go, &tree_sitter_go::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Java, &tree_sitter_java::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Php, &tree_sitter_php::LANGUAGE_PHP.into())?;\n        Self::init_parser(&mut parsers, Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Swift, &tree_sitter_swift::LANGUAGE.into())?;\n        // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility\n        // Self::init_parser(&mut parsers, Language::Kotlin, &tree_sitter_kotlin::language())?;\n\n        // v0.9.0: Load dependency query files for ALL languages\n        let mut dependency_queries = HashMap::new();\n        dependency_queries.insert(\n            Language::Rust,\n            include_str!(\"../../../dependency_queries/rust.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Python,\n            include_str!(\"../../../dependency_queries/python.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::JavaScript,\n            include_str!(\"../../../dependency_queries/javascript.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::TypeScript,\n            include_str!(\"../../../dependency_queries/typescript.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Go,\n            include_str!(\"../../../dependency_queries/go.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Java,\n            include_str!(\"../../../dependency_queries/java.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::C,\n            include_str!(\"../../../dependency_queries/c.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Cpp,\n            include_str!(\"../../../dependency_queries/cpp.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Ruby,\n            include_str!(\"../../../dependency_queries/ruby.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Php,\n            include_str!(\"../../../dependency_queries/php.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::CSharp,\n            include_str!(\"../../../dependency_queries/c_sharp.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Swift,\n            include_str!(\"../../../dependency_queries/swift.scm\").to_string()\n        );\n\n        Ok(Self { queries, dependency_queries, parsers })\n    }\n\n    fn init_parser(\n        parsers: &mut HashMap<Language, Parser>,\n        lang: Language,\n        grammar: &tree_sitter::Language\n    ) -> Result<()> {\n        let mut parser = Parser::new();\n        parser.set_language(grammar)\n            .context(format!(\"Failed to set language for {:?}\", lang))?;\n        parsers.insert(lang, parser);\n        Ok(())\n    }\n\n    /// Parse source code and extract entities using tree-sitter queries\n    ///\n    /// # Arguments\n    ///\n    /// * `source` - The source code to parse\n    /// * `file_path` - Path to the file (for entity metadata)\n    /// * `language` - The programming language\n    ///\n    /// # Returns\n    ///\n    /// A tuple of (entities, dependencies). Dependencies are not yet implemented\n    /// and will return an empty vec.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// use parseltongue_core::query_extractor::QueryBasedExtractor;\n    /// use parseltongue_core::entities::Language;\n    /// use std::path::Path;\n    ///\n    /// let mut extractor = QueryBasedExtractor::new().unwrap();\n    /// let code = \"fn hello() { println!(\\\"world\\\"); }\";\n    /// let (entities, _deps) = extractor.parse_source(\n    ///     code,\n    ///     Path::new(\"test.rs\"),\n    ///     Language::Rust\n    /// ).unwrap();\n    ///\n    /// assert_eq!(entities.len(), 1);\n    /// assert_eq!(entities[0].name, \"hello\");\n    /// ```\n    ///\n    /// # Performance\n    ///\n    /// <20ms per 1K LOC in release mode, <50ms in debug mode.\n    pub fn parse_source(\n        &mut self,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n    ) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        // Get parser\n        let parser = self.parsers.get_mut(&language)\n            .context(format!(\"No parser for language {:?}\", language))?;\n\n        // Parse tree\n        let tree = parser.parse(source, None)\n            .context(\"Failed to parse source\")?;\n\n        // Get entity query\n        let query_source = self.queries.get(&language)\n            .context(format!(\"No query for language {:?}\", language))?;\n\n        // Execute entity query\n        let entities = self.execute_query(&tree, source, file_path, language, query_source)?;\n\n        // v0.9.0: Execute dependency query if available\n        let dependencies = if let Some(dep_query_source) = self.dependency_queries.get(&language) {\n            self.execute_dependency_query(&tree, source, file_path, language, dep_query_source, &entities)?\n        } else {\n            // Graceful degradation: if no dependency query, return empty vec\n            vec![]\n        };\n\n        Ok((entities, dependencies))\n    }\n\n    fn execute_query(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        query_source: &str,\n    ) -> Result<Vec<ParsedEntity>> {\n        // Create query\n        let ts_lang = self.get_ts_language(language)?;\n        let query = Query::new(&ts_lang, query_source)\n            .context(\"Failed to create query\")?;\n\n        // Execute query using streaming iterator\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n        let mut entities = Vec::new();\n        let mut seen = std::collections::HashSet::new();\n\n        while let Some(m) = matches.next() {\n            if let Some(entity) = self.process_match(m, &query, source, file_path, language) {\n                // Deduplicate based on (name, line_range) - prevents duplicate extraction\n                let key = (entity.name.clone(), entity.line_range);\n                if seen.insert(key) {\n                    entities.push(entity);\n                }\n            }\n        }\n\n        Ok(entities)\n    }\n\n    fn process_match<'a>(\n        &self,\n        m: &tree_sitter::QueryMatch<'a, 'a>,\n        query: &Query,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n    ) -> Option<ParsedEntity> {\n        let mut entity_name = None;\n        let mut entity_type = None;\n        let mut node = None;\n\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n\n            if *capture_name == \"name\" {\n                entity_name = Some(source[capture.node.byte_range()].to_string());\n            } else if capture_name.starts_with(\"definition.\") {\n                entity_type = self.parse_entity_type(capture_name);\n                node = Some(capture.node);\n            }\n        }\n\n        if let (Some(name), Some(entity_type), Some(node)) = (entity_name, entity_type, node) {\n            Some(ParsedEntity {\n                entity_type,\n                name,\n                language,\n                line_range: (\n                    node.start_position().row + 1,\n                    node.end_position().row + 1,\n                ),\n                file_path: file_path.to_string_lossy().to_string(),\n                metadata: HashMap::new(),\n            })\n        } else {\n            None\n        }\n    }\n\n    fn parse_entity_type(&self, capture_name: &str) -> Option<EntityType> {\n        match capture_name {\n            \"definition.function\" => Some(EntityType::Function),\n            \"definition.struct\" => Some(EntityType::Struct),\n            \"definition.class\" => Some(EntityType::Class),\n            \"definition.enum\" => Some(EntityType::Enum),\n            \"definition.trait\" => Some(EntityType::Trait),\n            \"definition.interface\" => Some(EntityType::Interface),\n            \"definition.impl\" => Some(EntityType::Impl),\n            \"definition.module\" => Some(EntityType::Module),\n            \"definition.method\" => Some(EntityType::Method),\n            \"definition.typedef\" => Some(EntityType::Typedef),\n            \"definition.namespace\" => Some(EntityType::Namespace),\n            _ => None,\n        }\n    }\n\n    fn get_ts_language(&self, language: Language) -> Result<tree_sitter::Language> {\n        Ok(match language {\n            Language::Rust => tree_sitter_rust::LANGUAGE.into(),\n            Language::Python => tree_sitter_python::LANGUAGE.into(),\n            Language::C => tree_sitter_c::LANGUAGE.into(),\n            Language::Cpp => tree_sitter_cpp::LANGUAGE.into(),\n            Language::Ruby => tree_sitter_ruby::LANGUAGE.into(),\n            Language::JavaScript => tree_sitter_javascript::LANGUAGE.into(),\n            Language::TypeScript => tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into(),\n            Language::Go => tree_sitter_go::LANGUAGE.into(),\n            Language::Java => tree_sitter_java::LANGUAGE.into(),\n            Language::Php => tree_sitter_php::LANGUAGE_PHP.into(),\n            Language::CSharp => tree_sitter_c_sharp::LANGUAGE.into(),\n            Language::Swift => tree_sitter_swift::LANGUAGE.into(),\n            // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility\n            // Language::Kotlin => tree_sitter_kotlin::language(),\n            _ => anyhow::bail!(\"Unsupported language: {:?}\", language),\n        })\n    }\n\n    /// Execute dependency query and extract relationships (v0.9.0)\n    ///\n    /// Processes tree-sitter query matches to build DependencyEdge objects.\n    /// Handles three edge types: Calls, Uses, Implements.\n    fn execute_dependency_query(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        dep_query_source: &str,\n        entities: &[ParsedEntity],\n    ) -> Result<Vec<DependencyEdge>> {\n        // Compile query\n        let ts_lang = self.get_ts_language(language)?;\n        let query = Query::new(&ts_lang, dep_query_source)\n            .context(\"Failed to create dependency query\")?;\n\n        // Execute query\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n        let mut dependencies = Vec::new();\n\n        while let Some(m) = matches.next() {\n            // Process each match to extract dependency relationship\n            if let Some(edge) = self.process_dependency_match(&m, &query, source, file_path, language, entities) {\n                dependencies.push(edge);\n            }\n        }\n\n        Ok(dependencies)\n    }\n\n    /// Process a single dependency query match\n    fn process_dependency_match<'a>(\n        &self,\n        m: &tree_sitter::QueryMatch<'a, 'a>,\n        query: &Query,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &[ParsedEntity],\n    ) -> Option<DependencyEdge> {\n        let mut dependency_type = None;\n        let mut from_entity = None;\n        let mut to_name = None;\n        let mut location = None;\n\n        // Parse captures to identify relationship type and participants\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let node = capture.node;\n            let node_text = &source[node.byte_range()];\n\n            // Identify dependency type\n            if capture_name.starts_with(\"dependency.\") {\n                location = Some(format!(\"{}:{}\", file_path.display(), node.start_position().row + 1));\n\n                if capture_name.contains(\"call\") || capture_name.contains(\"method_call\") {\n                    dependency_type = Some(EdgeType::Calls);\n                    // For calls, find containing function\n                    from_entity = self.find_containing_entity(node, entities);\n                } else if capture_name.contains(\"use\") || capture_name.contains(\"import\") || capture_name.contains(\"type_ref\") {\n                    dependency_type = Some(EdgeType::Uses);\n                } else if capture_name.contains(\"implement\") || capture_name.contains(\"inherits\") {\n                    dependency_type = Some(EdgeType::Implements);\n                }\n            }\n\n            // Extract reference name (what is being called/used/implemented)\n            if capture_name.starts_with(\"reference.\") {\n                to_name = Some(node_text.to_string());\n            }\n\n            // Extract definition name (for impl blocks)\n            if capture_name.starts_with(\"definition.impl\") {\n                from_entity = entities.iter().find(|e| {\n                    e.name == node_text && e.line_range.0 <= node.start_position().row + 1\n                        && e.line_range.1 >= node.end_position().row + 1\n                });\n            }\n        }\n\n        // Build DependencyEdge if we have enough information\n        if let (Some(edge_type), Some(to)) = (dependency_type, to_name) {\n            // For Uses edges (imports, use declarations), create simplified keys\n            if edge_type == EdgeType::Uses {\n                let from_key = format!(\"{}:file:{}:1-1\", language, file_path.display());\n                let to_key = format!(\"{}:module:{}:0-0\", language, to);\n\n                return DependencyEdge::builder()\n                    .from_key(from_key)\n                    .to_key(to_key)\n                    .edge_type(edge_type)\n                    .source_location(location.unwrap_or_default())\n                    .build()\n                    .ok();\n            }\n\n            // For Calls and Implements, we need a from_entity\n            if let Some(from) = from_entity {\n                let from_key = format!(\n                    \"{}:{}:{}:{}:{}-{}\",\n                    language,\n                    self.entity_type_to_key_component(&from.entity_type),\n                    from.name,\n                    from.file_path,\n                    from.line_range.0,\n                    from.line_range.1\n                );\n\n                let to_key = format!(\n                    \"{}:fn:{}:unknown:0-0\",\n                    language,\n                    to\n                );\n\n                return DependencyEdge::builder()\n                    .from_key(from_key)\n                    .to_key(to_key)\n                    .edge_type(edge_type)\n                    .source_location(location.unwrap_or_default())\n                    .build()\n                    .ok();\n            }\n        }\n\n        None\n    }\n\n    /// Find the entity that contains a given AST node\n    ///\n    /// Prefers the most specific entity (smallest line range) when multiple\n    /// entities contain the node. This ensures method calls are attributed to\n    /// the method, not the enclosing impl block.\n    fn find_containing_entity<'a>(\n        &self,\n        node: tree_sitter::Node<'_>,\n        entities: &'a [ParsedEntity],\n    ) -> Option<&'a ParsedEntity> {\n        let node_line = node.start_position().row + 1;\n\n        // Find all entities that contain this line\n        let mut candidates: Vec<&ParsedEntity> = entities\n            .iter()\n            .filter(|e| e.line_range.0 <= node_line && node_line <= e.line_range.1)\n            .collect();\n\n        if candidates.is_empty() {\n            return None;\n        }\n\n        // Sort by specificity\n        candidates.sort_by(|a, b| {\n            // Primary: Prefer smaller line ranges (more specific)\n            let a_range = a.line_range.1 - a.line_range.0;\n            let b_range = b.line_range.1 - b.line_range.0;\n\n            match a_range.cmp(&b_range) {\n                std::cmp::Ordering::Equal => {\n                    // Secondary: Prefer methods/functions over impl blocks\n                    match (&a.entity_type, &b.entity_type) {\n                        (EntityType::Method, EntityType::Impl) => std::cmp::Ordering::Less,\n                        (EntityType::Impl, EntityType::Method) => std::cmp::Ordering::Greater,\n                        (EntityType::Function, EntityType::Impl) => std::cmp::Ordering::Less,\n                        (EntityType::Impl, EntityType::Function) => std::cmp::Ordering::Greater,\n                        _ => std::cmp::Ordering::Equal,\n                    }\n                },\n                other => other,\n            }\n        });\n\n        // Return most specific entity\n        Some(candidates[0])\n    }\n\n    /// Convert EntityType to ISGL1 key component\n    fn entity_type_to_key_component(&self, entity_type: &EntityType) -> &'static str {\n        match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Class => \"class\",\n            EntityType::Module => \"module\",\n            EntityType::Impl => \"impl\",\n            EntityType::Typedef => \"typedef\",\n            EntityType::Namespace => \"namespace\",\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "QueryBasedExtractor",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"QueryBasedExtractor\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":68,\"end\":594},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:QueryBasedExtractor:__crates_parseltongue-core_src_query_extractor_rs:68-594",
      "line_number": 0
    },
    {
      "current_code": "    impl Parser for RailsParser {\n        type Input = String;\n        type Output = RailsAst;\n        type Error = RailsParseError;\n        type Config = RailsParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "RailsParser",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"RailsParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":853,\"end\":867},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:RailsParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:853-867",
      "line_number": 0
    },
    {
      "current_code": "impl Default for RecoveryAction {\n    fn default() -> Self {\n        Self::RetryWithBackoff(std::time::Duration::from_millis(1000))\n    }\n}",
      "current_ind": 1,
      "entity_name": "RecoveryAction",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"RecoveryAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":158,\"end\":162},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:RecoveryAction:__crates_parseltongue-core_src_error_rs:158-162",
      "line_number": 0
    },
    {
      "current_code": "impl ResetResult {\n    /// Create a successful reset result\n    pub fn success(entities_deleted: usize) -> Self {\n        Self {\n            success: true,\n            entities_deleted,\n            schema_recreated: true,\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ResetResult",
      "entity_type": "impl",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ResetResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":82,\"end\":91},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ResetResult:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:82-91",
      "line_number": 0
    },
    {
      "current_code": "impl RustAnalyzerClientImpl {\n    /// Create new rust-analyzer client\n    /// Attempts to spawn rust-analyzer process; if it fails, gracefully disables LSP\n    pub async fn new() -> Self {\n        // TODO: Implement actual LSP process spawning\n        // For now, stub implementation\n        Self { enabled: false }\n    }\n}",
      "current_ind": 1,
      "entity_name": "RustAnalyzerClientImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"RustAnalyzerClientImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":67,\"end\":75},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:RustAnalyzerClientImpl:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:67-75",
      "line_number": 0
    },
    {
      "current_code": "impl RustAnalyzerClient for RustAnalyzerClientImpl {\n    async fn hover(\n        &self,\n        _file_path: &Path,\n        _line: u32,\n        _character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        // Graceful degradation: return None if not enabled\n        if !self.enabled {\n            return Ok(None);\n        }\n\n        // TODO: Implement actual LSP hover request\n        Ok(None)\n    }\n\n    async fn is_available(&self) -> bool {\n        self.enabled\n    }\n}",
      "current_ind": 1,
      "entity_name": "RustAnalyzerClientImpl",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"RustAnalyzerClientImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":78,\"end\":97},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:RustAnalyzerClientImpl:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:78-97",
      "line_number": 0
    },
    {
      "current_code": "impl SimpleSyntaxValidator {\n    /// Create a new multi-language syntax validator\n    pub fn new() -> Result<Self> {\n        let mut parsers = HashMap::new();\n\n        // Helper macro to initialize parser for a language\n        macro_rules! init_parser {\n            ($lang:expr, $grammar:expr) => {\n                let mut parser = Parser::new();\n                if parser.set_language($grammar).is_ok() {\n                    parsers.insert($lang, parser);\n                }\n            };\n        }\n\n        // Initialize all language parsers\n        // LanguageFn must be converted to Language using .into() for tree-sitter 0.22+\n        init_parser!(Language::Rust, &tree_sitter_rust::LANGUAGE.into());\n        init_parser!(Language::Python, &tree_sitter_python::LANGUAGE.into());\n        init_parser!(Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into());\n        init_parser!(Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into());\n        init_parser!(Language::Go, &tree_sitter_go::LANGUAGE.into());\n        init_parser!(Language::Java, &tree_sitter_java::LANGUAGE.into());\n        init_parser!(Language::Cpp, &tree_sitter_cpp::LANGUAGE.into());\n        init_parser!(Language::Ruby, &tree_sitter_ruby::LANGUAGE.into());\n        init_parser!(Language::Php, &tree_sitter_php::LANGUAGE_PHP.into());\n        init_parser!(Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into());\n        init_parser!(Language::Swift, &tree_sitter_swift::LANGUAGE.into());\n        // Note: Kotlin not supported in v0.8.7 - tree-sitter-kotlin v0.3 uses incompatible tree-sitter 0.20\n        init_parser!(Language::Scala, &tree_sitter_scala::LANGUAGE.into());\n\n        Ok(Self { parsers })\n    }\n\n    /// Validate syntax of code string for a specific language\n    ///\n    /// Returns ValidationResult with is_valid and error details\n    pub fn validate_syntax(&mut self, code: &str, language: Language) -> Result<ValidationResult> {\n        // Get parser for the specified language\n        let parser = self.parsers.get_mut(&language)\n            .ok_or_else(|| anyhow::anyhow!(\"No parser available for language: {:?}\", language))?;\n\n        // Parse code with tree-sitter\n        let tree = parser\n            .parse(code, None)\n            .context(\"Failed to parse code with tree-sitter\")?;\n\n        let root = tree.root_node();\n\n        // Check for syntax errors in parse tree\n        if root.has_error() {\n            let errors = self.collect_syntax_errors(&root, code);\n            return Ok(ValidationResult {\n                is_valid: false,\n                errors,\n            });\n        }\n\n        Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        })\n    }\n\n    /// Recursively collect syntax errors from parse tree\n    fn collect_syntax_errors(&self, node: &Node, source: &str) -> Vec<String> {\n        let mut errors = Vec::new();\n\n        // Check if this node is an error node\n        if node.is_error() || node.is_missing() {\n            let line = node.start_position().row + 1;\n            let col = node.start_position().column + 1;\n            let end_line = node.end_position().row + 1;\n            let end_col = node.end_position().column + 1;\n\n            let error_msg = if node.is_missing() {\n                format!(\n                    \"Missing syntax element at line {}, column {}\",\n                    line, col\n                )\n            } else {\n                format!(\n                    \"Syntax error at line {}, column {} (ends at line {}, column {})\",\n                    line, col, end_line, end_col\n                )\n            };\n\n            errors.push(error_msg);\n        }\n\n        // Recursively check children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            errors.extend(self.collect_syntax_errors(&child, source));\n        }\n\n        errors\n    }\n}",
      "current_ind": 1,
      "entity_name": "SimpleSyntaxValidator",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"SimpleSyntaxValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":46,\"end\":144},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:SimpleSyntaxValidator:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:46-144",
      "line_number": 0
    },
    {
      "current_code": "impl SimpleUpdateConfig {\n    /// L3: Generate Datalog :put query from simple interface\n    ///\n    /// Following S01 Executable Specifications:\n    /// - Create: (current_ind=0, future_ind=1, Future_Action=\"Create\")\n    /// - Edit: (current_ind=1, future_ind=1, Future_Action=\"Edit\")\n    /// - Delete: (current_ind=1, future_ind=0, Future_Action=\"Delete\")\n    ///\n    /// # Preconditions\n    /// - Create/Edit actions require `future_code` to be Some(_)\n    /// - Delete action allows `future_code` to be None\n    ///\n    /// # Returns\n    /// Valid CozoDB Datalog query string\n    ///\n    /// # Panics\n    /// Panics if Create/Edit action is called without future_code.\n    /// This is a precondition violation (contract-based programming).\n    ///\n    /// # Examples\n    /// ```ignore\n    /// let config = SimpleUpdateConfig {\n    ///     entity_key: \"rust:fn:hello:lib_rs:1-5\".to_string(),\n    ///     action: EntityAction::Edit,\n    ///     future_code: Some(\"fn hello() {}\".to_string()),\n    ///     db_path: \"test.db\".to_string(),\n    /// };\n    /// let datalog = config.to_datalog();\n    /// ```\n    pub fn to_datalog(&self) -> String {\n        // Precondition validation (contract-based programming)\n        // Using panic! is intentional - this is a programming error, not a runtime error\n        self.validate_preconditions();\n\n        let (current_ind, future_ind, action_str) = self.action.to_temporal_state();\n        let future_code_value = self.escape_future_code();\n\n        // Generate Datalog matching actual CodeGraph schema (13 fields)\n        // Note: ISGL1_key => indicates primary key in :put syntax\n        format!(\n            r#\"?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[\"{}\", null, {}, \"\", \"\",\n              null, {}, {}, \"{}\", \"\",\n              \"\", \"\", \"\"]]\n\n            :put CodeGraph {{\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }}\"#,\n            self.entity_key, future_code_value, current_ind, future_ind, action_str\n        )\n    }\n\n    /// Validate preconditions (pure function - no side effects)\n    fn validate_preconditions(&self) {\n        match self.action {\n            EntityAction::Create | EntityAction::Edit if self.future_code.is_none() => {\n                panic!(\"{:?} action requires future_code\", self.action);\n            }\n            _ => {}\n        }\n    }\n\n    /// Escape future_code for Datalog (pure function)\n    fn escape_future_code(&self) -> String {\n        match &self.future_code {\n            Some(code) => {\n                // Properly escape quotes and backslashes for Datalog string literals\n                let escaped = code\n                    .replace('\\\\', \"\\\\\\\\\")  // Escape backslashes first\n                    .replace('\"', \"\\\\\\\"\");   // Then escape quotes\n                format!(\"\\\"{}\\\"\", escaped)\n            }\n            None => \"null\".to_string(),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "SimpleUpdateConfig",
      "entity_type": "impl",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"SimpleUpdateConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":66,\"end\":146},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:SimpleUpdateConfig:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:66-146",
      "line_number": 0
    },
    {
      "current_code": "impl StateResetManager {\n    /// Create a new state reset manager\n    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }\n\n    /// Reset database state completely\n    ///\n    /// # Ultra-Minimalist Principles\n    /// - Deletes CodeGraph table (NO backups)\n    /// - Recreates schema\n    /// - Returns success for re-indexing trigger\n    pub async fn reset(&self, _project_path: &Path) -> Result<ResetResult> {\n        // Count entities before deletion (for reporting)\n        let entities_before = self.storage.get_all_entities().await?;\n        let entities_deleted = entities_before.len();\n\n        // Delete all entities (NO backups - ultra-minimalist)\n        self.delete_table().await?;\n\n        // Recreate schema\n        self.recreate_schema().await?;\n\n        // Note: Re-indexing (Tool 1 integration) would happen externally\n        // Tool 6 just resets the state, doesn't trigger indexing itself\n\n        Ok(ResetResult::success(entities_deleted))\n    }\n\n    /// Delete CodeGraph table (ultra-minimalist: NO backups)\n    ///\n    /// GREEN Phase: Minimal implementation using brute-force deletion\n    /// Ultra-minimalist approach: iterate and delete, no fancy table operations\n    async fn delete_table(&self) -> Result<()> {\n        // Get all entities (simple, direct)\n        let entities = self.storage.get_all_entities().await?;\n\n        // Delete each one (brute-force, ultra-minimalist)\n        for entity in entities {\n            self.storage.delete_entity(&entity.isgl1_key).await?;\n        }\n\n        Ok(())\n    }\n\n    /// Recreate CodeGraph schema\n    ///\n    /// GREEN Phase: Schema recreation is optional since we only deleted entities\n    /// The schema structure remains intact after entity deletion\n    async fn recreate_schema(&self) -> Result<()> {\n        // GREEN phase: Schema already exists, no need to recreate\n        // CozoDB doesn't support DROP TABLE, we just deleted all entities\n        // Schema structure remains valid\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "StateResetManager",
      "entity_type": "impl",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"StateResetManager\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":14,\"end\":69},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:StateResetManager:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:14-69",
      "line_number": 0
    },
    {
      "current_code": "impl Default for StreamerConfig {\n    fn default() -> Self {\n        Self {\n            root_dir: PathBuf::from(\".\"),\n            db_path: \"mem\".to_string(), // Use in-memory database by default\n            max_file_size: 1024 * 1024, // 1MB\n            include_patterns: vec![\"*.rs\".to_string(), \"*.py\".to_string()], // Simplified patterns that work\n            exclude_patterns: vec![\"target/**\".to_string(), \"node_modules/**\".to_string()],\n            parsing_library: \"tree-sitter\".to_string(), // PRD default\n            chunking: \"ISGL1\".to_string(), // PRD default\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "StreamerConfig",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"StreamerConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":62,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:StreamerConfig:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:62-74",
      "line_number": 0
    },
    {
      "current_code": "impl From<EdgeType> for String {\n    fn from(edge_type: EdgeType) -> Self {\n        edge_type.as_str().to_owned()\n    }\n}",
      "current_ind": 1,
      "entity_name": "String",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"String\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":951,\"end\":955},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:String:__crates_parseltongue-core_src_entities_rs:951-955",
      "line_number": 0
    },
    {
      "current_code": "impl Default for TddClassification {\n    fn default() -> Self {\n        Self {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Medium,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Medium,\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "TddClassification",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TddClassification\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":815,\"end\":827},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TddClassification:__crates_parseltongue-core_src_entities_rs:815-827",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalAction {\n    /// Validate action compatibility with temporal indicators\n    pub fn validate_with_indicators(\n        &self,\n        current_ind: bool,\n        future_ind: bool,\n    ) -> Result<()> {\n        match (current_ind, future_ind, self) {\n            (true, false, TemporalAction::Delete) => Ok(()),\n            (true, true, TemporalAction::Edit) => Ok(()),\n            (false, true, TemporalAction::Create) => Ok(()),\n            _ => Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Invalid temporal combination: current={}, future={}, action={:?}\",\n                    current_ind, future_ind, self\n                ),\n            }),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "TemporalAction",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TemporalAction\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":129,\"end\":148},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TemporalAction:__crates_parseltongue-core_src_entities_rs:129-148",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalState {\n    /// Create new initial state (for Tool 1 indexing)\n    ///\n    /// PRD Spec (P01:96-101): Tool 1 initializes entities as:\n    /// - current_ind: 1 (exists in current codebase)\n    /// - future_ind: 0 (future state unknown until Tool 2 processes)\n    /// - Future_Action: None\n    pub fn initial() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,  // Future state unknown at index time\n            future_action: None,\n        }\n    }\n\n    /// Create new unchanged state (for entities reviewed by Tool 2)\n    ///\n    /// Represents: Entity exists in current codebase, LLM decided no changes needed\n    pub fn unchanged() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,  // Unchanged state exists in both present and future\n            future_action: None,\n        }\n    }\n\n    /// Create new creation state\n    pub fn create() -> Self {\n        Self {\n            current_ind: false,\n            future_ind: true,\n            future_action: Some(TemporalAction::Create),\n        }\n    }\n\n    /// Create new edit state\n    pub fn edit() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,\n            future_action: Some(TemporalAction::Edit),\n        }\n    }\n\n    /// Create new delete state\n    pub fn delete() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,\n            future_action: Some(TemporalAction::Delete),\n        }\n    }\n\n    /// Validate temporal state consistency\n    pub fn validate(&self) -> Result<()> {\n        // Cannot have both indicators false\n        if !self.current_ind && !self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Both current_ind and future_ind cannot be false\".to_string(),\n            });\n        }\n\n        // Validate action compatibility\n        if let Some(ref action) = self.future_action {\n            action.validate_with_indicators(self.current_ind, self.future_ind)?;\n        }\n\n        // If no action, indicators should be the same\n        if self.future_action.is_none() && self.current_ind != self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Temporal indicators differ but no action specified\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n\n    /// Check if this state represents a change\n    pub fn is_changed(&self) -> bool {\n        self.future_action.is_some()\n    }\n}",
      "current_ind": 1,
      "entity_name": "TemporalState",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TemporalState\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":161,\"end\":242},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TemporalState:__crates_parseltongue-core_src_entities_rs:161-242",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalTransitionBuilder {\n    /// Create new transition builder\n    pub fn new(isgl1_key: String) -> Self {\n        Self {\n            isgl1_key,\n            action: None,\n            future_code: None,\n            updated_signature: None,\n        }\n    }\n\n    /// Set the action to perform\n    pub fn action(mut self, action: TemporalAction) -> Self {\n        self.action = Some(action);\n        self\n    }\n\n    /// Set the future code\n    pub fn future_code(mut self, code: String) -> Self {\n        self.future_code = Some(code);\n        self\n    }\n\n    /// Set the updated signature\n    pub fn updated_signature(mut self, signature: InterfaceSignature) -> Self {\n        self.updated_signature = Some(signature);\n        self\n    }\n\n    /// Build the temporal change\n    pub fn build(self) -> Result<TemporalChange> {\n        let action = self.action.ok_or_else(|| ParseltongError::TemporalError {\n            details: \"Temporal action is required\".to_string(),\n        })?;\n\n        Ok(TemporalChange {\n            isgl1_key: self.isgl1_key,\n            action,\n            future_code: self.future_code,\n            updated_signature: self.updated_signature,\n        })\n    }\n}",
      "current_ind": 1,
      "entity_name": "TemporalTransitionBuilder",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TemporalTransitionBuilder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":405,\"end\":447},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TemporalTransitionBuilder:__crates_parseltongue-core_src_temporal_rs:405-447",
      "line_number": 0
    },
    {
      "current_code": "impl Default for TemporalVersioningManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "TemporalVersioningManager",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TemporalVersioningManager\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":252,\"end\":256},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TemporalVersioningManager:__crates_parseltongue-core_src_temporal_rs:252-256",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalVersioningManager {\n    /// Create new temporal versioning manager\n    pub fn new() -> Self {\n        Self {\n            entities: HashMap::new(),\n            pending_changes: Vec::new(),\n            validation_rules: vec![\n                Box::new(NoCircularDependenciesRule::new()),\n                Box::new(ConsistentStateRule::new()),\n                Box::new(ValidTransitionsRule::new()),\n            ],\n        }\n    }\n\n    /// Add an entity to the temporal state\n    pub fn add_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        // Validate entity\n        entity.validate()?;\n\n        // Check for conflicts with existing entity\n        if let Some(existing) = self.entities.get(&entity.isgl1_key) {\n            self.validate_entity_compatibility(existing, &entity)?;\n        }\n\n        self.entities.insert(entity.isgl1_key.clone(), entity);\n        Ok(())\n    }\n\n    /// Apply temporal changes to entities\n    pub fn apply_changes(&mut self, changes: Vec<TemporalChange>) -> Result<Vec<String>> {\n        let mut affected_entities = Vec::new();\n\n        for change in changes {\n            let isgl1_key = &change.isgl1_key;\n\n            // Validate change\n            self.validate_temporal_change(&change)?;\n\n            // Apply change to entity\n            if let Some(entity) = self.entities.get_mut(isgl1_key) {\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                affected_entities.push(isgl1_key.clone());\n            } else {\n                // Entity doesn't exist, create new one\n                let mut entity = self.create_entity_for_change(&change)?;\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                self.entities.insert(isgl1_key.clone(), entity);\n                affected_entities.push(isgl1_key.clone());\n            }\n        }\n\n        // Run validation rules\n        self.run_validation_rules()?;\n\n        Ok(affected_entities)\n    }\n\n    /// Reset temporal state (Tool 6 operation)\n    pub fn reset_temporal_state(&mut self) -> Result<usize> {\n        let mut reset_count = 0;\n\n        for entity in self.entities.values_mut() {\n            if entity.is_modified() {\n                // Apply temporal state changes\n                match &entity.temporal_state.future_action {\n                    Some(TemporalAction::Create) => {\n                        // New entity becomes current\n                        entity.temporal_state.current_ind = true;\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Edit) => {\n                        // Apply edit\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Delete) => {\n                        // Mark for deletion (will be removed by caller)\n                        entity.temporal_state.current_ind = false;\n                    }\n                    None => {}\n                }\n\n                // Reset temporal indicators\n                entity.temporal_state.future_ind = entity.temporal_state.current_ind;\n                entity.temporal_state.future_action = None;\n                entity.future_code = None;\n\n                reset_count += 1;\n            }\n        }\n\n        // Remove deleted entities\n        self.entities.retain(|_, entity| entity.temporal_state.current_ind);\n\n        Ok(reset_count)\n    }\n\n    /// Get entities with pending changes\n    pub fn get_changed_entities(&self) -> Vec<&CodeEntity> {\n        self.entities\n            .values()\n            .filter(|entity| entity.is_modified())\n            .collect()\n    }\n\n    /// Get entity by ISGL1 key\n    pub fn get_entity(&self, isgl1_key: &str) -> Option<&CodeEntity> {\n        self.entities.get(isgl1_key)\n    }\n\n    /// Get all entities\n    pub fn get_all_entities(&self) -> Vec<&CodeEntity> {\n        self.entities.values().collect()\n    }\n\n    /// Validate temporal state consistency\n    pub fn validate_state(&self) -> Result<()> {\n        self.run_validation_rules()\n    }\n\n    /// Get entities that depend on a given entity\n    pub fn get_dependents(&self, isgl1_key: &str) -> Vec<String> {\n        self.entities\n            .values()\n            .filter(|entity| {\n                // Check if entity depends on the given entity\n                // This is a simplified implementation\n                entity.interface_signature.file_path\n                    .to_string_lossy()\n                    .contains(isgl1_key)\n            })\n            .map(|entity| entity.isgl1_key.clone())\n            .collect()\n    }\n\n    // Private helper methods\n\n    fn validate_entity_compatibility(&self, existing: &CodeEntity, new: &CodeEntity) -> Result<()> {\n        // Check if both entities have conflicting temporal states\n        if existing.is_modified() && new.is_modified() {\n            return Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Concurrent modifications detected for entity {}\",\n                    existing.isgl1_key\n                ),\n            });\n        }\n\n        Ok(())\n    }\n\n    fn validate_temporal_change(&self, change: &TemporalChange) -> Result<()> {\n        // Validate temporal action compatibility\n        let entity = self.entities.get(&change.isgl1_key);\n\n        match (&entity, &change.action) {\n            (None, TemporalAction::Edit | TemporalAction::Delete) => {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Cannot {} non-existent entity {}\",\n                        match change.action {\n                            TemporalAction::Edit => \"edit\",\n                            TemporalAction::Delete => \"delete\",\n                            _ => unreachable!(),\n                        },\n                        change.isgl1_key\n                    ),\n                });\n            }\n            (Some(entity), TemporalAction::Create) => {\n                if entity.temporal_state.current_ind {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Cannot create entity {} that already exists\",\n                            change.isgl1_key\n                        ),\n                    });\n                }\n            }\n            _ => {}\n        }\n\n        Ok(())\n    }\n\n    fn create_entity_for_change(&self, change: &TemporalChange) -> Result<CodeEntity> {\n        let mut entity = CodeEntity::new(\n            change.isgl1_key.clone(),\n            InterfaceSignature {\n                entity_type: EntityType::Function, // Default\n                name: \"unknown\".to_string(),\n                visibility: Visibility::Private,\n                file_path: std::path::PathBuf::new(),\n                line_range: LineRange::new(1, 1)?,\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for temporal changes\n            crate::entities::EntityClass::CodeImplementation,\n        )?;\n\n        // Set initial temporal state based on action\n        entity.temporal_state = match change.action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        };\n\n        Ok(entity)\n    }\n\n    fn run_validation_rules(&self) -> Result<()> {\n        for rule in &self.validation_rules {\n            rule.validate(&self.entities)?;\n        }\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "TemporalVersioningManager",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TemporalVersioningManager\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":27,\"end\":250},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TemporalVersioningManager:__crates_parseltongue-core_src_temporal_rs:27-250",
      "line_number": 0
    },
    {
      "current_code": "    impl Arbitrary for TestAst {\n        fn arbitrary(g: &mut Gen) -> Self {\n            TestAst {\n                nodes: Vec::arbitrary(g),\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "TestAst",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TestAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1403,\"end\":1409},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TestAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1403-1409",
      "line_number": 0
    },
    {
      "current_code": "    impl std::fmt::Display for TestAst {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            // Simple serialization for testing\n            write!(f, \"{:?}\", self)\n        }\n    }",
      "current_ind": 1,
      "entity_name": "TestAst",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TestAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1411,\"end\":1416},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TestAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1411-1416",
      "line_number": 0
    },
    {
      "current_code": "    impl Parser for TestParser {\n        type Input = String;\n        type Output = TestAst;\n        type Error = std::io::Error;\n        type Config = ();\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Stub implementation\n            Ok(TestAst { nodes: vec![] })\n        }\n        \n        fn parse_with_config(&self, _input: Self::Input, _config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            Ok(TestAst { nodes: vec![] })\n        }\n    }",
      "current_ind": 1,
      "entity_name": "TestParser",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"TestParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1420,\"end\":1435},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:TestParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1420-1435",
      "line_number": 0
    },
    {
      "current_code": "impl ToolFactory {\n    /// Create a new file streamer instance with database connection\n    pub async fn create_streamer(config: StreamerConfig) -> Result<Arc<FileStreamerImpl>> {\n        let generator = Isgl1KeyGeneratorFactory::new();\n        let test_detector = Arc::new(crate::test_detector::DefaultTestDetector::new());\n        let streamer = FileStreamerImpl::new(config, generator, test_detector).await?;\n        Ok(Arc::new(streamer))\n    }\n}",
      "current_ind": 1,
      "entity_name": "ToolFactory",
      "entity_type": "impl",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ToolFactory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":79,\"end\":87},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ToolFactory:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:79-87",
      "line_number": 0
    },
    {
      "current_code": "impl Default for ValidTransitionsRule {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidTransitionsRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidTransitionsRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":360,\"end\":364},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidTransitionsRule:__crates_parseltongue-core_src_temporal_rs:360-364",
      "line_number": 0
    },
    {
      "current_code": "impl ValidTransitionsRule {\n    pub fn new() -> Self {\n        Self { _private: () }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidTransitionsRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidTransitionsRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":366,\"end\":370},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidTransitionsRule:__crates_parseltongue-core_src_temporal_rs:366-370",
      "line_number": 0
    },
    {
      "current_code": "impl TemporalValidationRule for ValidTransitionsRule {\n    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            if let Some(ref action) = entity.temporal_state.future_action {\n                // Validate action is compatible with temporal indicators\n                action.validate_with_indicators(\n                    entity.temporal_state.current_ind,\n                    entity.temporal_state.future_ind,\n                ).map_err(|e| ParseltongError::TemporalError {\n                    details: format!(\n                        \"Invalid transition for entity {}: {}\",\n                        key,\n                        e\n                    ),\n                })?;\n            }\n        }\n\n        Ok(())\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidTransitionsRule",
      "entity_type": "impl",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidTransitionsRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":372,\"end\":392},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidTransitionsRule:__crates_parseltongue-core_src_temporal_rs:372-392",
      "line_number": 0
    },
    {
      "current_code": "impl ValidationError {\n    /// Get the severity level of this error\n    pub fn severity(&self) -> Severity {\n        match self {\n            Self::SyntaxError { .. }\n            | Self::TypeError { .. }\n            | Self::BorrowError { .. }\n            | Self::CompilationError { .. }\n            | Self::TestError { .. } => Severity::Error,\n            Self::Timeout { .. } => Severity::Error,\n            Self::Io(_) => Severity::Error,\n            Self::Parse(_) => Severity::Error,\n        }\n    }\n\n    /// Get the line number if available\n    pub fn line(&self) -> Option<usize> {\n        match self {\n            Self::SyntaxError { line, .. }\n            | Self::TypeError { line, .. }\n            | Self::BorrowError { line, .. } => Some(*line),\n            _ => None,\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidationError",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidationError\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":65,\"end\":89},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidationError:__crates_pt04-syntax-preflight-validator_src_errors_rs:65-89",
      "line_number": 0
    },
    {
      "current_code": "impl ValidationOutput {\n    /// Create a successful validation output\n    pub fn success(validation_type: ValidationType) -> Self {\n        Self {\n            is_valid: true,\n            validation_type,\n            errors: Vec::new(),\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }\n\n    /// Create a failed validation output\n    pub fn failure(validation_type: ValidationType, error: ValidationError) -> Self {\n        Self {\n            is_valid: false,\n            validation_type,\n            errors: vec![error.to_string()],\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }\n\n    /// Add timing information\n    pub fn with_timing(mut self, execution_time_ms: u64, memory_usage_bytes: usize) -> Self {\n        self.execution_time_ms = execution_time_ms;\n        self.memory_usage_bytes = memory_usage_bytes;\n        self\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidationOutput",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidationOutput\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":63,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidationOutput:__crates_pt04-syntax-preflight-validator_src_types_rs:63-94",
      "line_number": 0
    },
    {
      "current_code": "impl ValidationReport {\n    /// Create a new validation report\n    pub fn new(file_path: Option<PathBuf>, code_snippet: String) -> Self {\n        Self {\n            file_path,\n            code_snippet,\n            individual_results: Vec::new(),\n            overall_valid: true,\n            total_execution_time_ms: 0,\n            total_memory_usage_bytes: 0,\n            generated_at: Utc::now(),\n        }\n    }\n\n    /// Add a validation result to this report\n    pub fn add_result(&mut self, result: ValidationOutput) {\n        self.overall_valid = self.overall_valid && result.is_valid;\n        self.total_execution_time_ms += result.execution_time_ms;\n        self.total_memory_usage_bytes += result.memory_usage_bytes;\n        self.individual_results.push(result);\n    }\n\n    /// Get all errors from all validation results\n    pub fn all_errors(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.errors.iter().cloned())\n            .collect()\n    }\n\n    /// Get all warnings from all validation results\n    pub fn all_warnings(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.warnings.iter().cloned())\n            .collect()\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidationReport",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidationReport\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":115,\"end\":152},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidationReport:__crates_pt04-syntax-preflight-validator_src_types_rs:115-152",
      "line_number": 0
    },
    {
      "current_code": "impl ValidationResult {\n    /// Create a valid result\n    pub fn valid() -> Self {\n        Self {\n            is_valid: true,\n            errors: vec![],\n        }\n    }\n\n    /// Create an invalid result with errors\n    pub fn invalid(errors: Vec<String>) -> Self {\n        Self {\n            is_valid: false,\n            errors,\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidationResult",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidationResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":155,\"end\":171},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidationResult:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:155-171",
      "line_number": 0
    },
    {
      "current_code": "impl ValidationType {\n    /// Get all validation types in order\n    pub fn all() -> Vec<Self> {\n        vec![\n            Self::Syntax,\n            Self::Type,\n            Self::BorrowChecker,\n            Self::Compilation,\n            Self::Test,\n        ]\n    }\n\n    /// Get validation types up to and including this one\n    pub fn up_to(self) -> Vec<Self> {\n        match self {\n            Self::Syntax => vec![Self::Syntax],\n            Self::Type => vec![Self::Syntax, Self::Type],\n            Self::BorrowChecker => vec![Self::Syntax, Self::Type, Self::BorrowChecker],\n            Self::Compilation => vec![Self::Syntax, Self::Type, Self::BorrowChecker, Self::Compilation],\n            Self::Test => Self::all(),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "ValidationType",
      "entity_type": "impl",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"ValidationType\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":22,\"end\":44},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:ValidationType:__crates_pt04-syntax-preflight-validator_src_types_rs:22-44",
      "line_number": 0
    },
    {
      "current_code": "    impl std::hash::Hash for Value {\n        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n            match self {\n                Value::Nil => 0.hash(state),\n                Value::Boolean(b) => b.hash(state),\n                Value::Integer(i) => i.hash(state),\n                Value::Float(f) => f.to_bits().hash(state),\n                Value::String(s) => s.hash(state),\n                Value::Symbol(s) => s.hash(state),\n                Value::Array(a) => a.hash(state),\n                Value::Hash(_) => 0.hash(state), // Simplified\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "Value",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Value\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":816,\"end\":829},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Value:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:816-829",
      "line_number": 0
    },
    {
      "current_code": "    impl Eq for Value {}",
      "current_ind": 1,
      "entity_name": "Value",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Value\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":831,\"end\":831},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Value:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:831-831",
      "line_number": 0
    },
    {
      "current_code": "    impl PartialEq for Value {\n        fn eq(&self, other: &Self) -> bool {\n            match (self, other) {\n                (Value::Nil, Value::Nil) => true,\n                (Value::Boolean(a), Value::Boolean(b)) => a == b,\n                (Value::Integer(a), Value::Integer(b)) => a == b,\n                (Value::Float(a), Value::Float(b)) => a == b,\n                (Value::String(a), Value::String(b)) => a == b,\n                (Value::Symbol(a), Value::Symbol(b)) => a == b,\n                (Value::Array(a), Value::Array(b)) => a == b,\n                (Value::Hash(a), Value::Hash(b)) => a == b,\n                _ => false,\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "Value",
      "entity_type": "impl",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"Value\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":832,\"end\":846},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:Value:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:832-846",
      "line_number": 0
    },
    {
      "current_code": "impl WriteResult {\n    /// Create a successful write result\n    pub fn success(file_path: PathBuf, operation: WriteOperation) -> Self {\n        Self {\n            success: true,\n            file_path,\n            operation,\n            message: None,\n        }\n    }\n\n    /// Create a no-op result (nothing to do)\n    pub fn no_op() -> Self {\n        Self {\n            success: true,\n            file_path: PathBuf::new(),\n            operation: WriteOperation::NoOp,\n            message: Some(\"No operation required\".to_string()),\n        }\n    }\n\n    /// Add a message to this result\n    pub fn with_message(mut self, message: String) -> Self {\n        self.message = Some(message);\n        self\n    }\n}",
      "current_ind": 1,
      "entity_name": "WriteResult",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"WriteResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":17,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:WriteResult:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:17-43",
      "line_number": 0
    },
    {
      "current_code": "impl Default for WriteSummary {\n    fn default() -> Self {\n        Self::new()\n    }\n}",
      "current_ind": 1,
      "entity_name": "WriteSummary",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"WriteSummary\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":102,\"end\":106},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:WriteSummary:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:102-106",
      "line_number": 0
    },
    {
      "current_code": "impl WriteSummary {\n    /// Create a new empty summary\n    pub fn new() -> Self {\n        Self {\n            created: 0,\n            edited: 0,\n            deleted: 0,\n            total: 0,\n            errors: 0,\n        }\n    }\n\n    /// Add a result to this summary\n    pub fn add_result(&mut self, result: &WriteResult) {\n        if !result.success {\n            self.errors += 1;\n            return;\n        }\n\n        match result.operation {\n            WriteOperation::Create => self.created += 1,\n            WriteOperation::Edit => self.edited += 1,\n            WriteOperation::Delete => self.deleted += 1,\n            WriteOperation::NoOp => {}\n        }\n        self.total += 1;\n    }\n}",
      "current_ind": 1,
      "entity_name": "WriteSummary",
      "entity_type": "impl",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":{\"ImplBlock\":{\"trait_name\":null,\"struct_name\":\"Unknown\"}},\"name\":\"WriteSummary\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":73,\"end\":100},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:impl:WriteSummary:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:73-100",
      "line_number": 0
    },
    {
      "current_code": "    pub fn action(mut self, action: TemporalAction) -> Self {\n        self.action = Some(action);\n        self\n    }",
      "current_ind": 1,
      "entity_name": "action",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"action\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":417,\"end\":420},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:action:__crates_parseltongue-core_src_temporal_rs:417-420",
      "line_number": 0
    },
    {
      "current_code": "    pub fn add_change(&mut self, change: Change) {\n        match change.operation {\n            Operation::Create => self.metadata.create_count += 1,\n            Operation::Edit => self.metadata.edit_count += 1,\n            Operation::Delete => self.metadata.delete_count += 1,\n        }\n        self.metadata.total_changes += 1;\n        self.changes.push(change);\n    }",
      "current_ind": 1,
      "entity_name": "add_change",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"add_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":145,\"end\":153},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:add_change:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:145-153",
      "line_number": 0
    },
    {
      "current_code": "    pub fn add_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        // Validate entity\n        entity.validate()?;\n\n        // Check for conflicts with existing entity\n        if let Some(existing) = self.entities.get(&entity.isgl1_key) {\n            self.validate_entity_compatibility(existing, &entity)?;\n        }\n\n        self.entities.insert(entity.isgl1_key.clone(), entity);\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "add_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"add_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":42,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:add_entity:__crates_parseltongue-core_src_temporal_rs:42-53",
      "line_number": 0
    },
    {
      "current_code": "    pub fn add_response(&mut self, key: String, response: HoverResponse) {\n        self.responses.insert(key, response);\n    }",
      "current_ind": 1,
      "entity_name": "add_response",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"add_response\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":113,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:add_response:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:113-115",
      "line_number": 0
    },
    {
      "current_code": "    pub fn add_result(&mut self, result: ValidationOutput) {\n        self.overall_valid = self.overall_valid && result.is_valid;\n        self.total_execution_time_ms += result.execution_time_ms;\n        self.total_memory_usage_bytes += result.memory_usage_bytes;\n        self.individual_results.push(result);\n    }",
      "current_ind": 1,
      "entity_name": "add_result",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"add_result\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":130,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:add_result:__crates_pt04-syntax-preflight-validator_src_types_rs:130-135",
      "line_number": 0
    },
    {
      "current_code": "    pub fn add_result(&mut self, result: &WriteResult) {\n        if !result.success {\n            self.errors += 1;\n            return;\n        }\n\n        match result.operation {\n            WriteOperation::Create => self.created += 1,\n            WriteOperation::Edit => self.edited += 1,\n            WriteOperation::Delete => self.deleted += 1,\n            WriteOperation::NoOp => {}\n        }\n        self.total += 1;\n    }",
      "current_ind": 1,
      "entity_name": "add_result",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"add_result\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":86,\"end\":99},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:add_result:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:86-99",
      "line_number": 0
    },
    {
      "current_code": "    pub fn all() -> Vec<Self> {\n        vec![\n            Self::Syntax,\n            Self::Type,\n            Self::BorrowChecker,\n            Self::Compilation,\n            Self::Test,\n        ]\n    }",
      "current_ind": 1,
      "entity_name": "all",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"all\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":24,\"end\":32},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:all:__crates_pt04-syntax-preflight-validator_src_types_rs:24-32",
      "line_number": 0
    },
    {
      "current_code": "    pub fn all_errors(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.errors.iter().cloned())\n            .collect()\n    }",
      "current_ind": 1,
      "entity_name": "all_errors",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"all_errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":138,\"end\":143},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:all_errors:__crates_pt04-syntax-preflight-validator_src_types_rs:138-143",
      "line_number": 0
    },
    {
      "current_code": "    pub fn all_warnings(&self) -> Vec<String> {\n        self.individual_results\n            .iter()\n            .flat_map(|r| r.warnings.iter().cloned())\n            .collect()\n    }",
      "current_ind": 1,
      "entity_name": "all_warnings",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"all_warnings\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":146,\"end\":151},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:all_warnings:__crates_pt04-syntax-preflight-validator_src_types_rs:146-151",
      "line_number": 0
    },
    {
      "current_code": "    pub fn apply_changes(&mut self, changes: Vec<TemporalChange>) -> Result<Vec<String>> {\n        let mut affected_entities = Vec::new();\n\n        for change in changes {\n            let isgl1_key = &change.isgl1_key;\n\n            // Validate change\n            self.validate_temporal_change(&change)?;\n\n            // Apply change to entity\n            if let Some(entity) = self.entities.get_mut(isgl1_key) {\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                affected_entities.push(isgl1_key.clone());\n            } else {\n                // Entity doesn't exist, create new one\n                let mut entity = self.create_entity_for_change(&change)?;\n                entity.apply_temporal_change(change.action.clone(), change.future_code.clone())?;\n                self.entities.insert(isgl1_key.clone(), entity);\n                affected_entities.push(isgl1_key.clone());\n            }\n        }\n\n        // Run validation rules\n        self.run_validation_rules()?;\n\n        Ok(affected_entities)\n    }",
      "current_ind": 1,
      "entity_name": "apply_changes",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"apply_changes\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":56,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:apply_changes:__crates_parseltongue-core_src_temporal_rs:56-82",
      "line_number": 0
    },
    {
      "current_code": "    pub fn apply_temporal_change(\n        &mut self,\n        action: TemporalAction,\n        future_code: Option<String>,\n    ) -> Result<()> {\n        match action {\n            TemporalAction::Create => {\n                self.temporal_state = TemporalState::create();\n                self.future_code = future_code;\n            }\n            TemporalAction::Edit => {\n                self.temporal_state = TemporalState::edit();\n                self.future_code = future_code;\n            }\n            TemporalAction::Delete => {\n                self.temporal_state = TemporalState::delete();\n                self.future_code = None;\n            }\n        }\n\n        self.temporal_state.validate()?;\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "apply_temporal_change",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"apply_temporal_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":638,\"end\":660},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:apply_temporal_change:__crates_parseltongue-core_src_entities_rs:638-660",
      "line_number": 0
    },
    {
      "current_code": "        fn arbitrary(g: &mut Gen) -> Self {\n            TestAst {\n                nodes: Vec::arbitrary(g),\n            }\n        }",
      "current_ind": 1,
      "entity_name": "arbitrary",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"arbitrary\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1404,\"end\":1408},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:arbitrary:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1404-1408",
      "line_number": 0
    },
    {
      "current_code": "    fn as_ref(&self) -> &str {\n        &self.0\n    }",
      "current_ind": 1,
      "entity_name": "as_ref",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"as_ref\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":905,\"end\":907},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:as_ref:__crates_parseltongue-core_src_entities_rs:905-907",
      "line_number": 0
    },
    {
      "current_code": "    pub fn as_str(&self) -> &str {\n        &self.0\n    }",
      "current_ind": 1,
      "entity_name": "as_str",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"as_str\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":893,\"end\":895},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:as_str:__crates_parseltongue-core_src_entities_rs:893-895",
      "line_number": 0
    },
    {
      "current_code": "    pub fn as_str(self) -> &'static str {\n        match self {\n            Self::Calls => \"Calls\",\n            Self::Uses => \"Uses\",\n            Self::Implements => \"Implements\",\n        }\n    }",
      "current_ind": 1,
      "entity_name": "as_str",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"as_str\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":941,\"end\":947},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:as_str:__crates_parseltongue-core_src_entities_rs:941-947",
      "line_number": 0
    },
    {
      "current_code": "    fn attempt_merge(&self, _changes: Vec<TemporalChange>, _conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        // Simplified merge implementation\n        // In a real implementation, this would be more sophisticated\n        Err(ParseltongError::TemporalError {\n            details: \"Merge conflict resolution not yet implemented\".to_string(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "attempt_merge",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"attempt_merge\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":562,\"end\":568},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:attempt_merge:__crates_parseltongue-core_src_temporal_rs:562-568",
      "line_number": 0
    },
    {
      "current_code": "    pub fn build(self) -> Result<DependencyEdge> {\n        DependencyEdge::new(\n            self.from_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"from_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.to_key.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"to_key\".to_string(),\n                expected: \"non-empty string\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.edge_type.ok_or_else(|| ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"EdgeType\".to_string(),\n                actual: \"None\".to_string(),\n            })?,\n            self.source_location,\n        )\n    }",
      "current_ind": 1,
      "entity_name": "build",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"build\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1073,\"end\":1092},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:build:__crates_parseltongue-core_src_entities_rs:1073-1092",
      "line_number": 0
    },
    {
      "current_code": "    pub fn build(self) -> Result<TemporalChange> {\n        let action = self.action.ok_or_else(|| ParseltongError::TemporalError {\n            details: \"Temporal action is required\".to_string(),\n        })?;\n\n        Ok(TemporalChange {\n            isgl1_key: self.isgl1_key,\n            action,\n            future_code: self.future_code,\n            updated_signature: self.updated_signature,\n        })\n    }",
      "current_ind": 1,
      "entity_name": "build",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"build\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":435,\"end\":446},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:build:__crates_parseltongue-core_src_temporal_rs:435-446",
      "line_number": 0
    },
    {
      "current_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-01\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 01: folder-to-cozoDB-streamer\")\n            .long_about(\n                \"Ultra-minimalist streaming tool that reads code files from a directory,\\n\\\n                generates ISGL1 keys using tree-sitter, and stores them in CozoDB.\\n\\\n                \\n\\\n                Following TDD-first principles with executable specifications.\",\n            )\n            .arg(\n                Arg::new(\"directory\")\n                    .help(\"Directory to index\")\n                    .required(true)\n                    .index(1),\n            )\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database connection string (use 'mem' for in-memory)\")\n                    .default_value(\"mem\"),\n            )\n            .arg(\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .help(\"Enable verbose output\")\n                    .action(clap::ArgAction::SetTrue),\n            )\n            .arg(\n                Arg::new(\"quiet\")\n                    .short('q')\n                    .long(\"quiet\")\n                    .help(\"Suppress output except errors\")\n                    .action(clap::ArgAction::SetTrue)\n                    .conflicts_with(\"verbose\"),\n            )\n            .arg(\n                Arg::new(\"exclude\")\n                    .short('e')\n                    .long(\"exclude\")\n                    .value_name(\"PATTERN\")\n                    .help(\"Exclude pattern (can be specified multiple times)\")\n                    .action(ArgAction::Append)\n                    .long_help(\"Exclude files/directories matching pattern.\nExamples: -e '.ref' -e 'archive' -e 'tmp/**'\nPatterns are simple substring matches (not regex).\"),\n            )\n    }",
      "current_ind": 1,
      "entity_name": "build_cli",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"build_cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":32,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:build_cli:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:32-82",
      "line_number": 0
    },
    {
      "current_code": "    pub fn build_cli() -> Command {\n        Command::new(\"parseltongue-02\")\n            .version(\"0.7.1\")\n            .author(\"Parseltongue Team\")\n            .about(\"Tool 02: LLM-to-cozoDB-writer\")\n            .long_about(\n                \"Ultra-minimalist temporal state writer for CozoDB.\\n\\\n                \\n\\\n                Two interfaces:\\n\\\n                \\n\\\n                1. Simple Interface (80% use cases):\\n  \\\n                llm-to-cozodb-writer --entity <KEY> --action <create|edit|delete> --future-code <CODE>\\n\\\n                \\n\\\n                2. Advanced Interface (20% power users):\\n  \\\n                llm-to-cozodb-writer --query \\\"?[...] := [[...]] :put CodeGraph {...}\\\"\\n\\\n                \",\n            )\n            // Simple interface arguments\n            .arg(\n                Arg::new(\"entity\")\n                    .long(\"entity\")\n                    .value_name(\"ISGL1_KEY\")\n                    .help(\"ISGL1 entity key to modify\")\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"action\")\n                    .long(\"action\")\n                    .value_name(\"ACTION\")\n                    .help(\"Action to perform: create, edit, or delete\")\n                    .value_parser([\"create\", \"edit\", \"delete\"])\n                    .conflicts_with(\"query\"),\n            )\n            .arg(\n                Arg::new(\"future-code\")\n                    .long(\"future-code\")\n                    .value_name(\"CODE\")\n                    .help(\"Future code content (required for create/edit)\")\n                    .conflicts_with(\"query\"),\n            )\n            // Advanced interface arguments\n            .arg(\n                Arg::new(\"query\")\n                    .long(\"query\")\n                    .value_name(\"DATALOG\")\n                    .help(\"Raw Datalog query to execute\")\n                    .conflicts_with(\"entity\"),\n            )\n            // Common argument\n            .arg(\n                Arg::new(\"database\")\n                    .long(\"db\")\n                    .value_name(\"PATH\")\n                    .help(\"Database file path\")\n                    .default_value(\"parseltongue.db\"),\n            )\n            // Mutual exclusion groups\n            .group(\n                ArgGroup::new(\"interface\")\n                    .args([\"query\", \"entity\"])\n                    .required(true),\n            )\n    }",
      "current_ind": 1,
      "entity_name": "build_cli",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"build_cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":60,\"end\":122},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:build_cli:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:60-122",
      "line_number": 0
    },
    {
      "current_code": "    pub fn builder() -> DependencyEdgeBuilder {\n        DependencyEdgeBuilder::default()\n    }",
      "current_ind": 1,
      "entity_name": "builder",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"builder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1029,\"end\":1031},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:builder:__crates_parseltongue-core_src_entities_rs:1029-1031",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn calculate_blast_radius(\n        &self,\n        changed_key: &str,\n        max_hops: usize,\n    ) -> Result<Vec<(String, usize)>> {\n        // Validation\n        if max_hops == 0 {\n            return Ok(Vec::new());\n        }\n\n        // CozoDB recursive query for bounded BFS\n        // Strategy: Iteratively hop through edges, tracking minimum distance\n        let query = r#\"\n            # Recursive blast radius query\n            # Find all nodes reachable from start_node within max_hops\n\n            # Base case: Starting node at distance 0\n            reachable[to_key, distance] := *DependencyEdges{from_key, to_key},\n                                            from_key == $start_key,\n                                            distance = 1\n\n            # Recursive case: Follow edges, incrementing distance\n            reachable[to_key, new_distance] := reachable[from, dist],\n                                                *DependencyEdges{from_key: from, to_key},\n                                                dist < $max_hops,\n                                                new_distance = dist + 1\n\n            # Aggregate to get minimum distance for each node\n            ?[node, min_dist] := reachable[node, dist],\n                                 min_dist = min(dist)\n\n            :order min_dist\n            \"#.to_string();\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(changed_key.into()));\n        params.insert(\"max_hops\".to_string(), DataValue::from(max_hops as i64));\n\n        let result = self\n            .db\n            .run_script(&query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"calculate_blast_radius\".to_string(),\n                reason: format!(\"Failed to execute blast radius query: {}\", e),\n            })?;\n\n        // Parse results into (key, distance) tuples\n        let mut affected = Vec::new();\n        for row in result.rows {\n            if row.len() >= 2 {\n                if let (Some(DataValue::Str(node)), Some(distance_val)) =\n                    (row.first(), row.get(1))\n                {\n                    // Distance is stored as Num enum (Int or Float)\n                    let distance = match distance_val {\n                        DataValue::Num(n) => match n {\n                            cozo::Num::Int(i) => *i as usize,\n                            cozo::Num::Float(f) => *f as usize,\n                        },\n                        _ => continue,\n                    };\n                    affected.push((node.to_string(), distance));\n                }\n            }\n        }\n\n        Ok(affected)\n    }",
      "current_ind": 1,
      "entity_name": "calculate_blast_radius",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"calculate_blast_radius\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":307,\"end\":374},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:calculate_blast_radius:__crates_parseltongue-core_src_storage_cozo_client_rs:307-374",
      "line_number": 0
    },
    {
      "current_code": "    fn classify_entity(&self, parsed: &ParsedEntity) -> parseltongue_core::entities::TddClassification {\n        use parseltongue_core::entities::{EntityClass, TddClassification};\n\n        // Pure FP: Check metadata for test indicator\n        let is_test = parsed\n            .metadata\n            .get(\"is_test\")\n            .map(|v| v == \"true\")\n            .unwrap_or(false);\n\n        // Minimal GREEN implementation: Just set entity_class\n        TddClassification {\n            entity_class: if is_test {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            },\n            ..TddClassification::default()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "classify_entity",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"classify_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":196,\"end\":215},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:classify_entity:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:196-215",
      "line_number": 0
    },
    {
      "current_code": "    fn collect_syntax_errors(&self, node: &Node, source: &str) -> Vec<String> {\n        let mut errors = Vec::new();\n\n        // Check if this node is an error node\n        if node.is_error() || node.is_missing() {\n            let line = node.start_position().row + 1;\n            let col = node.start_position().column + 1;\n            let end_line = node.end_position().row + 1;\n            let end_col = node.end_position().column + 1;\n\n            let error_msg = if node.is_missing() {\n                format!(\n                    \"Missing syntax element at line {}, column {}\",\n                    line, col\n                )\n            } else {\n                format!(\n                    \"Syntax error at line {}, column {} (ends at line {}, column {})\",\n                    line, col, end_line, end_col\n                )\n            };\n\n            errors.push(error_msg);\n        }\n\n        // Recursively check children\n        let mut cursor = node.walk();\n        for child in node.children(&mut cursor) {\n            errors.extend(self.collect_syntax_errors(&child, source));\n        }\n\n        errors\n    }",
      "current_ind": 1,
      "entity_name": "collect_syntax_errors",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"collect_syntax_errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":111,\"end\":143},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:collect_syntax_errors:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:111-143",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn connect(db_path: &str) -> Result<Self> {\n        let storage = CozoDbStorage::new(db_path)\n            .await\n            .map_err(|e| anyhow!(\"Failed to connect to CozoDB: {}\", e))?;\n        Ok(Self::new(storage))\n    }",
      "current_ind": 1,
      "entity_name": "connect",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"connect\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":33,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:connect:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:33-38",
      "line_number": 0
    },
    {
      "current_code": "    pub fn contains(&self, line: u32) -> bool {\n        line >= self.start && line <= self.end\n    }",
      "current_ind": 1,
      "entity_name": "contains",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"contains\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":312,\"end\":314},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:contains:__crates_parseltongue-core_src_entities_rs:312-314",
      "line_number": 0
    },
    {
      "current_code": "    fn convert_entity(\n        entity: &crate::export_trait::Entity,\n        include_code: bool,\n    ) -> EntityExportLevel1 {\n        EntityExportLevel1 {\n            isgl1_key: entity.isgl1_key.clone(),\n            forward_deps: entity.forward_deps.clone(),\n            reverse_deps: entity.reverse_deps.clone(),\n            current_ind: entity.current_ind,\n            future_ind: entity.future_ind,\n            future_action: entity.future_action.clone(),\n            // future_code: Only include when future_action is Some\n            future_code: if entity.future_action.is_some() {\n                entity.future_code.clone()\n            } else {\n                None\n            },\n            // current_code: Only include when config.include_code = true\n            current_code: if include_code {\n                entity.current_code.clone()\n            } else {\n                None\n            },\n            entity_name: entity.entity_name.clone(),\n            entity_type: entity.entity_type.clone(),\n            file_path: entity.file_path.clone(),\n            line_number: entity.line_number,\n            interface_signature: entity.interface_signature.clone(),\n            doc_comment: entity.doc_comment.clone(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "convert_entity",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"convert_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":57,\"end\":87},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:convert_entity:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:57-87",
      "line_number": 0
    },
    {
      "current_code": "    fn convert_entity(\n        entity: &crate::export_trait::Entity,\n        include_code: bool,\n    ) -> EntityExportLevel2 {\n        EntityExportLevel2 {\n            // Level 1 fields (inherited)\n            isgl1_key: entity.isgl1_key.clone(),\n            forward_deps: entity.forward_deps.clone(),\n            reverse_deps: entity.reverse_deps.clone(),\n            current_ind: entity.current_ind,\n            future_ind: entity.future_ind,\n            future_action: entity.future_action.clone(),\n            // future_code: Only include when future_action is Some\n            future_code: if entity.future_action.is_some() {\n                entity.future_code.clone()\n            } else {\n                None\n            },\n            // current_code: Only include when config.include_code = true\n            current_code: if include_code {\n                entity.current_code.clone()\n            } else {\n                None\n            },\n            entity_name: entity.entity_name.clone(),\n            entity_type: entity.entity_type.clone(),\n            file_path: entity.file_path.clone(),\n            line_number: entity.line_number,\n            interface_signature: entity.interface_signature.clone(),\n            doc_comment: entity.doc_comment.clone(),\n\n            // Level 2 fields (type system)\n            return_type: entity.return_type.clone(),\n            // Convert Option<Vec<T>> to Vec<T> for serde skip_serializing_if\n            param_types: entity.param_types.clone().unwrap_or_default(),\n            param_names: entity.param_names.clone().unwrap_or_default(),\n            generic_constraints: entity.generic_constraints.clone().unwrap_or_default(),\n            trait_impls: entity.trait_impls.clone().unwrap_or_default(),\n            // Safety flags with defaults\n            is_public: entity.is_public.unwrap_or(false),\n            is_async: entity.is_async.unwrap_or(false),\n            is_unsafe: entity.is_unsafe.unwrap_or(false),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "convert_entity",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"convert_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":54,\"end\":97},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:convert_entity:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:54-97",
      "line_number": 0
    },
    {
      "current_code": "    fn convert_entity_type(&self, entity_type: &crate::isgl1_generator::EntityType) -> parseltongue_core::entities::EntityType {\n        match entity_type {\n            // Universal entities\n            crate::isgl1_generator::EntityType::Function => parseltongue_core::entities::EntityType::Function,\n            crate::isgl1_generator::EntityType::Class => parseltongue_core::entities::EntityType::Class,\n            crate::isgl1_generator::EntityType::Method => parseltongue_core::entities::EntityType::Method,\n            crate::isgl1_generator::EntityType::Module => parseltongue_core::entities::EntityType::Module,\n            crate::isgl1_generator::EntityType::Variable => parseltongue_core::entities::EntityType::Variable,\n\n            // Pragmatic mappings (v0.8.9 MVP)\n            crate::isgl1_generator::EntityType::Namespace => parseltongue_core::entities::EntityType::Module,   // C++/C# namespace  Module\n            crate::isgl1_generator::EntityType::Typedef => parseltongue_core::entities::EntityType::Variable,   // C typedef  Variable\n\n            // Rust-specific entities\n            crate::isgl1_generator::EntityType::Struct => parseltongue_core::entities::EntityType::Struct,\n            crate::isgl1_generator::EntityType::Enum => parseltongue_core::entities::EntityType::Enum,\n            crate::isgl1_generator::EntityType::Trait => parseltongue_core::entities::EntityType::Trait,\n            crate::isgl1_generator::EntityType::Impl => parseltongue_core::entities::EntityType::ImplBlock {\n                trait_name: None,\n                struct_name: \"Unknown\".to_string(), // TODO: Extract from parsed entity\n            },\n        }\n    }",
      "current_ind": 1,
      "entity_name": "convert_entity_type",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"convert_entity_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":226,\"end\":248},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:convert_entity_type:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:226-248",
      "line_number": 0
    },
    {
      "current_code": "    pub fn create() -> Self {\n        Self {\n            current_ind: false,\n            future_ind: true,\n            future_action: Some(TemporalAction::Create),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":188,\"end\":194},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create:__crates_parseltongue-core_src_entities_rs:188-194",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn create_dependency_edges_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create DependencyEdges {\n                from_key: String,\n                to_key: String,\n                edge_type: String\n                =>\n                source_location: String?\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"create_dependency_edges_schema\".to_string(),\n                reason: format!(\"Failed to create DependencyEdges schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "create_dependency_edges_schema",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_dependency_edges_schema\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":117,\"end\":136},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_dependency_edges_schema:__crates_parseltongue-core_src_storage_cozo_client_rs:117-136",
      "line_number": 0
    },
    {
      "current_code": "    fn create_entity_for_change(&self, change: &TemporalChange) -> Result<CodeEntity> {\n        let mut entity = CodeEntity::new(\n            change.isgl1_key.clone(),\n            InterfaceSignature {\n                entity_type: EntityType::Function, // Default\n                name: \"unknown\".to_string(),\n                visibility: Visibility::Private,\n                file_path: std::path::PathBuf::new(),\n                line_range: LineRange::new(1, 1)?,\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for temporal changes\n            crate::entities::EntityClass::CodeImplementation,\n        )?;\n\n        // Set initial temporal state based on action\n        entity.temporal_state = match change.action {\n            TemporalAction::Create => TemporalState::create(),\n            TemporalAction::Edit => TemporalState::edit(),\n            TemporalAction::Delete => TemporalState::delete(),\n        };\n\n        Ok(entity)\n    }",
      "current_ind": 1,
      "entity_name": "create_entity_for_change",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_entity_for_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":211,\"end\":242},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_entity_for_change:__crates_parseltongue-core_src_temporal_rs:211-242",
      "line_number": 0
    },
    {
      "current_code": "    async fn create_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ensure parent directory exists\n        if let Some(parent) = file_path.parent() {\n            tokio::fs::create_dir_all(parent).await?;\n        }\n\n        // Get content to write\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Create operation\"))?;\n\n        // Write file directly (ultra-minimalist: no backups)\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Create))\n    }",
      "current_ind": 1,
      "entity_name": "create_file",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":41,\"end\":59},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:41-59",
      "line_number": 0
    },
    {
      "current_code": "    fn create_language_signature(&self, language: &Language) -> LanguageSpecificSignature {\n        match language {\n            Language::Rust => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n            Language::Python => LanguageSpecificSignature::Python(PythonSignature {\n                parameters: vec![],\n                return_type: None,\n                is_async: false,\n                decorators: vec![],\n            }),\n            _ => LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create_language_signature",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_language_signature\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":251,\"end\":274},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_language_signature:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:251-274",
      "line_number": 0
    },
    {
      "current_code": "    fn create_realistic() -> Self {\n        Self {\n            entities: vec![\n                // Public async function with type information\n                Entity {\n                    isgl1_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    forward_deps: vec![\n                        \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                        \"rust:trait:LevelExporter:src_export_trait_rs:10\".to_string(),\n                    ],\n                    reverse_deps: vec![],\n                    current_ind: 1,\n                    future_ind: 0,\n                    future_action: None,\n                    future_code: None,\n                    current_code: Some(\"pub async fn export_level1(config: &ExportConfig) -> Result<ExportOutput> { todo!() }\".to_string()),\n                    entity_name: \"export_level1\".to_string(),\n                    entity_type: \"fn\".to_string(),\n                    file_path: \"src/exporters.rs\".to_string(),\n                    line_number: 42,\n                    interface_signature: \"pub async fn export_level1(config: &ExportConfig) -> Result<ExportOutput>\".to_string(),\n                    doc_comment: Some(\"Export Level 1 entities to JSON\".to_string()),\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    // Level 2 type fields\n                    return_type: Some(\"Result<ExportOutput>\".to_string()),\n                    param_types: Some(vec![\"&ExportConfig\".to_string()]),\n                    param_names: Some(vec![\"config\".to_string()]),\n                    generic_constraints: None,\n                    trait_impls: None,\n                    is_public: Some(true),\n                    is_async: Some(true),\n                    is_unsafe: Some(false),\n                },\n\n                // Private sync function without type info\n                Entity {\n                    isgl1_key: \"rust:fn:helper:src_utils_rs:100\".to_string(),\n                    forward_deps: vec![],\n                    reverse_deps: vec![\"rust:fn:export_level1:src_exporters_rs:42\".to_string()],\n                    current_ind: 1,\n                    future_ind: 1,\n                    future_action: Some(\"refactor\".to_string()),\n                    future_code: Some(\"fn helper_v2() -> bool { true }\".to_string()),\n                    current_code: Some(\"fn helper() -> bool { false }\".to_string()),\n                    entity_name: \"helper\".to_string(),\n                    entity_type: \"fn\".to_string(),\n                    file_path: \"src/utils.rs\".to_string(),\n                    line_number: 100,\n                    interface_signature: \"fn helper() -> bool\".to_string(),\n                    doc_comment: None,\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    return_type: Some(\"bool\".to_string()),\n                    param_types: None,\n                    param_names: None,\n                    generic_constraints: None,\n                    trait_impls: None,\n                    is_public: Some(false),\n                    is_async: Some(false),\n                    is_unsafe: Some(false),\n                },\n\n                // Struct with trait implementations\n                Entity {\n                    isgl1_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    forward_deps: vec![],\n                    reverse_deps: vec![\"rust:fn:export_level1:src_exporters_rs:42\".to_string()],\n                    current_ind: 1,\n                    future_ind: 0,\n                    future_action: None,\n                    future_code: None,\n                    current_code: Some(\"#[derive(Debug, Clone)]\\npub struct ExportConfig { level: u8 }\".to_string()),\n                    entity_name: \"ExportConfig\".to_string(),\n                    entity_type: \"struct\".to_string(),\n                    file_path: \"src/models.rs\".to_string(),\n                    line_number: 15,\n                    interface_signature: \"pub struct ExportConfig\".to_string(),\n                    doc_comment: Some(\"Configuration for export operations\".to_string()),\n                    // v0.9.0: EntityClass for code/test separation\n                    entity_class: \"CODE\".to_string(),\n                    return_type: None,\n                    param_types: None,\n                    param_names: None,\n                    generic_constraints: None,\n                    trait_impls: Some(vec![\"Debug\".to_string(), \"Clone\".to_string()]),\n                    is_public: Some(true),\n                    is_async: None,\n                    is_unsafe: None,\n                },\n            ],\n            edges: vec![\n                Edge {\n                    from_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    to_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    edge_type: \"depends_on\".to_string(),\n                },\n                Edge {\n                    from_key: \"rust:fn:export_level1:src_exporters_rs:42\".to_string(),\n                    to_key: \"rust:trait:LevelExporter:src_export_trait_rs:10\".to_string(),\n                    edge_type: \"depends_on\".to_string(),\n                },\n                Edge {\n                    from_key: \"rust:struct:ExportConfig:src_models_rs:15\".to_string(),\n                    to_key: \"rust:trait:Debug:external:0\".to_string(),\n                    edge_type: \"implements\".to_string(),\n                },\n            ],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "create_realistic",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_realistic\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":38,\"end\":147},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_realistic:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:38-147",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn create_schema(&self) -> Result<()> {\n        let schema = r#\"\n            :create CodeGraph {\n                ISGL1_key: String =>\n                Current_Code: String?,\n                Future_Code: String?,\n                interface_signature: String,\n                TDD_Classification: String,\n                lsp_meta_data: String?,\n                current_ind: Bool,\n                future_ind: Bool,\n                Future_Action: String?,\n                file_path: String,\n                language: String,\n                last_modified: String,\n                entity_type: String,\n                entity_class: String\n            }\n        \"#;\n\n        self.db\n            .run_script(schema, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"schema_creation\".to_string(),\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "create_schema",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_schema\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":68,\"end\":96},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_schema:__crates_parseltongue-core_src_storage_cozo_client_rs:68-96",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn create_streamer(config: StreamerConfig) -> Result<Arc<FileStreamerImpl>> {\n        let generator = Isgl1KeyGeneratorFactory::new();\n        let test_detector = Arc::new(crate::test_detector::DefaultTestDetector::new());\n        let streamer = FileStreamerImpl::new(config, generator, test_detector).await?;\n        Ok(Arc::new(streamer))\n    }",
      "current_ind": 1,
      "entity_name": "create_streamer",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"create_streamer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":81,\"end\":86},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:create_streamer:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:81-86",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self {\n            entity_class: EntityClass::CodeImplementation,\n            testability: TestabilityLevel::Medium,\n            complexity: ComplexityLevel::Simple,\n            dependencies: 0,\n            test_coverage_estimate: 0.0,\n            critical_path: false,\n            change_risk: RiskLevel::Medium,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":816,\"end\":826},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_entities_rs:816-826",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::RetryWithBackoff(std::time::Duration::from_millis(1000))\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":159,\"end\":161},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_error_rs:159-161",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":253,\"end\":255},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_temporal_rs:253-255",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":271,\"end\":273},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_temporal_rs:271-273",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":313,\"end\":315},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_temporal_rs:313-315",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":361,\"end\":363},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_parseltongue-core_src_temporal_rs:361-363",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":101,\"end\":103},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:101-103",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self {\n            root_dir: PathBuf::from(\".\"),\n            db_path: \"mem\".to_string(), // Use in-memory database by default\n            max_file_size: 1024 * 1024, // 1MB\n            include_patterns: vec![\"*.rs\".to_string(), \"*.py\".to_string()], // Simplified patterns that work\n            exclude_patterns: vec![\"target/**\".to_string(), \"node_modules/**\".to_string()],\n            parsing_library: \"tree-sitter\".to_string(), // PRD default\n            chunking: \"ISGL1\".to_string(), // PRD default\n        }\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":63,\"end\":73},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:63-73",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":36,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:36-38",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":91,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:91-93",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":101,\"end\":103},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:101-103",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self {\n            query: String::new(),\n            db_path: \"parseltongue.db\".to_string(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":175,\"end\":180},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:175-180",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":85,\"end\":87},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt04-syntax-preflight-validator_src_validator_rs:85-87",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":162,\"end\":164},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:162-164",
      "line_number": 0
    },
    {
      "current_code": "    fn default() -> Self {\n        Self::new()\n    }",
      "current_ind": 1,
      "entity_name": "default",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"default\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":103,\"end\":105},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:default:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:103-105",
      "line_number": 0
    },
    {
      "current_code": "    pub fn delete() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,\n            future_action: Some(TemporalAction::Delete),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "delete",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"delete\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":206,\"end\":212},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:delete:__crates_parseltongue-core_src_entities_rs:206-212",
      "line_number": 0
    },
    {
      "current_code": "    async fn delete_entity(&mut self, isgl1_key: &str) -> Result<()> {\n        self.delete_entity(isgl1_key).await\n    }",
      "current_ind": 1,
      "entity_name": "delete_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"delete_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1287,\"end\":1289},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:delete_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:1287-1289",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn delete_entity(&self, isgl1_key: &str) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key] <- [[$key]]\n            :rm CodeGraph { ISGL1_key }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"delete_entity\".to_string(),\n                details: format!(\"Failed to delete entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "delete_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"delete_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":843,\"end\":860},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:delete_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:843-860",
      "line_number": 0
    },
    {
      "current_code": "    async fn delete_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - permanent deletion\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        // Ultra-minimalist: Permanent deletion, NO trash\n        tokio::fs::remove_file(&file_path).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Delete))\n    }",
      "current_ind": 1,
      "entity_name": "delete_file",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"delete_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":77,\"end\":85},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:delete_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:77-85",
      "line_number": 0
    },
    {
      "current_code": "    async fn delete_table(&self) -> Result<()> {\n        // Get all entities (simple, direct)\n        let entities = self.storage.get_all_entities().await?;\n\n        // Delete each one (brute-force, ultra-minimalist)\n        for entity in entities {\n            self.storage.delete_entity(&entity.isgl1_key).await?;\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "delete_table",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"delete_table\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":47,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:delete_table:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:47-57",
      "line_number": 0
    },
    {
      "current_code": "    fn desanitize_path(&self, sanitized: &str) -> PathBuf {\n        // Common file extensions\n        let extensions = [\"_rs\", \"_js\", \"_ts\", \"_py\", \"_go\", \"_java\", \"_cpp\", \"_c\", \"_h\"];\n\n        // Find and replace extension suffix\n        for ext in extensions {\n            if let Some(idx) = sanitized.rfind(ext) {\n                if idx + ext.len() == sanitized.len() {\n                    // Found extension at end\n                    let path_part = &sanitized[..idx]; // \"src_lib\"\n                    let ext_part = &ext[1..]; // \"rs\"\n                    let file_path = path_part.replace('_', \"/\") + \".\" + ext_part;\n                    return PathBuf::from(file_path);\n                }\n            }\n        }\n\n        // No known extension found, treat as-is\n        PathBuf::from(sanitized.replace('_', \"/\"))\n    }",
      "current_ind": 1,
      "entity_name": "desanitize_path",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"desanitize_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":164,\"end\":183},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:desanitize_path:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:164-183",
      "line_number": 0
    },
    {
      "current_code": "    pub fn detect_conflicts(&self, changes: &[TemporalChange]) -> Vec<Conflict> {\n        let mut conflicts = Vec::new();\n\n        // Check for multiple changes to same entity\n        let mut entity_changes: HashMap<String, Vec<&TemporalChange>> = HashMap::new();\n        for change in changes {\n            entity_changes\n                .entry(change.isgl1_key.clone())\n                .or_default()\n                .push(change);\n        }\n\n        for (entity, entity_changes) in entity_changes {\n            if entity_changes.len() > 1 {\n                conflicts.push(Conflict::MultipleChanges {\n                    entity,\n                    changes: entity_changes.iter().map(|c| (*c).clone()).collect(),\n                });\n            }\n        }\n\n        conflicts\n    }",
      "current_ind": 1,
      "entity_name": "detect_conflicts",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_conflicts\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":475,\"end\":497},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_conflicts:__crates_parseltongue-core_src_temporal_rs:475-497",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_go_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename pattern: *_test.go\n        if path_str.ends_with(\"_test.go\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test functions\n        if content.contains(\"func Test\") || \n           content.contains(\"func Example\") || \n           content.contains(\"func Benchmark\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_go_test",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_go_test\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":106,\"end\":122},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_go_test:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:106-122",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_java_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\"Test.java\") || \n           path_str.ends_with(\"Tests.java\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for JUnit annotations\n        if content.contains(\"@Test\") || \n           content.contains(\"@BeforeEach\") || \n           content.contains(\"@AfterEach\") || \n           content.contains(\"junit\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_java_test",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_java_test\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":189,\"end\":207},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_java_test:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:189-207",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_javascript_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\".test.js\") || \n           path_str.ends_with(\".test.ts\") || \n           path_str.ends_with(\".test.tsx\") || \n           path_str.ends_with(\".spec.js\") || \n           path_str.ends_with(\".spec.ts\") || \n           path_str.ends_with(\".spec.jsx\") {\n            return EntityClass::Test;\n        }\n        \n        // Check directory pattern: __tests__/\n        if path_str.contains(\"__tests__/\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test patterns\n        if content.contains(\"test(\") || \n           content.contains(\"it(\") || \n           content.contains(\"describe(\") || \n           content.contains(\"expect(\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_javascript_test",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_javascript_test\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":130,\"end\":157},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_javascript_test:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:130-157",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_python_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check filename patterns\n        if path_str.ends_with(\"_test.py\") || \n           path_str.starts_with(\"test_\") && path_str.ends_with(\".py\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test patterns\n        if content.contains(\"def test_\") || \n           content.contains(\"class Test\") || \n           content.contains(\"@pytest\") || \n           content.contains(\"unittest\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_python_test",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_python_test\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":164,\"end\":182},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_python_test:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:164-182",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_rust_test(&self, file_path: &Path, content: &str) -> EntityClass {\n        let path_str = file_path.to_string_lossy();\n        \n        // Check directory pattern: tests/ directory\n        if path_str.contains(\"tests/\") {\n            return EntityClass::Test;\n        }\n        \n        // Check filename pattern: _test.rs\n        if path_str.ends_with(\"_test.rs\") {\n            return EntityClass::Test;\n        }\n        \n        // Check content for test attributes\n        if content.contains(\"#[test]\") || \n           content.contains(\"#[tokio::test]\") || \n           content.contains(\"#[cfg(test)]\") {\n            return EntityClass::Test;\n        }\n        \n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_rust_test",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_rust_test\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":78,\"end\":99},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_rust_test:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:78-99",
      "line_number": 0
    },
    {
      "current_code": "    fn detect_test_from_path_and_name(&self, file_path: &Path, content: &str) -> EntityClass {\n        // REQ-V090-003.0: Language-specific test detection\n        \n        let path_str = file_path.to_string_lossy();\n        \n        // Rust test detection\n        if path_str.ends_with(\".rs\") {\n            return self.detect_rust_test(file_path, content);\n        }\n        \n        // Go test detection\n        if path_str.ends_with(\".go\") {\n            return self.detect_go_test(file_path, content);\n        }\n        \n        // JavaScript/TypeScript test detection\n        if path_str.ends_with(\".js\") || path_str.ends_with(\".ts\") || \n           path_str.ends_with(\".jsx\") || path_str.ends_with(\".tsx\") {\n            return self.detect_javascript_test(file_path, content);\n        }\n        \n        // Python test detection\n        if path_str.ends_with(\".py\") {\n            return self.detect_python_test(file_path, content);\n        }\n        \n        // Java test detection\n        if path_str.ends_with(\".java\") {\n            return self.detect_java_test(file_path, content);\n        }\n        \n        // Unknown file extensions are treated as non-test files\n        EntityClass::Code\n    }",
      "current_ind": 1,
      "entity_name": "detect_test_from_path_and_name",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"detect_test_from_path_and_name\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":35,\"end\":68},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:detect_test_from_path_and_name:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:35-68",
      "line_number": 0
    },
    {
      "current_code": "    pub fn edge_type(mut self, edge_type: EdgeType) -> Self {\n        self.edge_type = Some(edge_type);\n        self\n    }",
      "current_ind": 1,
      "entity_name": "edge_type",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"edge_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1057,\"end\":1060},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:edge_type:__crates_parseltongue-core_src_entities_rs:1057-1060",
      "line_number": 0
    },
    {
      "current_code": "    pub fn edit() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,\n            future_action: Some(TemporalAction::Edit),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "edit",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"edit\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":197,\"end\":203},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:edit:__crates_parseltongue-core_src_entities_rs:197-203",
      "line_number": 0
    },
    {
      "current_code": "    pub fn effective_code(&self) -> Option<&String> {\n        if self.temporal_state.future_action.is_some() {\n            self.future_code.as_ref()\n        } else {\n            self.current_code.as_ref()\n        }\n    }",
      "current_ind": 1,
      "entity_name": "effective_code",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"effective_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":668,\"end\":674},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:effective_code:__crates_parseltongue-core_src_entities_rs:668-674",
      "line_number": 0
    },
    {
      "current_code": "    fn empty() -> Self {\n        Self {\n            entities: vec![],\n            edges: vec![],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "empty",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"empty\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":149,\"end\":154},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:empty:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:149-154",
      "line_number": 0
    },
    {
      "current_code": "    fn enrich_rust_entities_with_attributes(\n        &self,\n        entities: &mut [ParsedEntity],\n        source: &str,\n    ) {\n        let lines: Vec<&str> = source.lines().collect();\n\n        // Build map of entity start lines for O(1) lookup\n        let mut entity_lines: std::collections::HashMap<usize, &mut ParsedEntity> =\n            std::collections::HashMap::new();\n\n        for entity in entities.iter_mut() {\n            entity_lines.insert(entity.line_range.0, entity);\n        }\n\n        // Scan source for attributes and match to entities\n        for (idx, line) in lines.iter().enumerate() {\n            let trimmed = line.trim();\n\n            // Check if this line is a test attribute\n            if trimmed == \"#[test]\" || trimmed == \"#[tokio::test]\" || trimmed == \"#[async_test]\" {\n                // Look for entity on next non-attribute line\n                for next_idx in (idx + 1)..lines.len() {\n                    let next_line = lines[next_idx].trim();\n\n                    // Skip more attributes\n                    if next_line.starts_with(\"#[\") {\n                        continue;\n                    }\n\n                    // Check if next line starts a function\n                    if next_line.starts_with(\"fn \") || next_line.starts_with(\"async fn \") || next_line.starts_with(\"pub fn \") || next_line.starts_with(\"pub async fn \") {\n                        let entity_line = next_idx + 1;\n\n                        // Find entity at this line and mark as test\n                        if let Some(entity) = entity_lines.get_mut(&entity_line) {\n                            entity.metadata.insert(\"is_test\".to_string(), \"true\".to_string());\n                        }\n                        break;\n                    }\n\n                    // If we hit non-whitespace that's not a function, stop looking\n                    if !next_line.is_empty() {\n                        break;\n                    }\n                }\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "enrich_rust_entities_with_attributes",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"enrich_rust_entities_with_attributes\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":271,\"end\":319},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:enrich_rust_entities_with_attributes:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:271-319",
      "line_number": 0
    },
    {
      "current_code": "    fn entity_to_change(&self, entity: &CodeEntity) -> Result<Option<Change>> {\n        // Determine operation from temporal state's future_action\n        let operation = match entity.temporal_state.future_action {\n            Some(TemporalAction::Create) => Operation::Create,\n            Some(TemporalAction::Edit) => Operation::Edit,\n            Some(TemporalAction::Delete) => Operation::Delete,\n            None => return Ok(None), // Skip entities with no future action (unchanged)\n        };\n\n        // Extract file path from ISGL1 key\n        let file_path = self.extract_file_path(&entity.isgl1_key)?;\n\n        // Extract line range from ISGL1 key (if line-based format)\n        let line_range = self.extract_line_range(&entity.isgl1_key);\n\n        // Extract current_code based on operation:\n        // - CREATE: None (entity doesn't exist yet)\n        // - EDIT/DELETE: Some (need to know what to replace/remove)\n        let current_code = match operation {\n            Operation::Create => None,\n            Operation::Edit | Operation::Delete => entity.current_code.clone(),\n        };\n\n        // Extract future_code based on operation:\n        // - CREATE/EDIT: Some (what to write)\n        // - DELETE: None (removing code)\n        let future_code = match operation {\n            Operation::Create | Operation::Edit => entity.future_code.clone(),\n            Operation::Delete => None,\n        };\n\n        // Format interface signature from components\n        let interface_signature = format!(\n            \"{:?} {}\",\n            entity.interface_signature.entity_type,\n            entity.interface_signature.name\n        );\n\n        // Create change with enhanced fields\n        let change = Change {\n            isgl1_key: entity.isgl1_key.clone(),\n            file_path,\n            operation,\n            current_code,\n            future_code,\n            line_range,\n            interface_signature,\n        };\n\n        Ok(Some(change))\n    }",
      "current_ind": 1,
      "entity_name": "entity_to_change",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"entity_to_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":80,\"end\":130},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:entity_to_change:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:80-130",
      "line_number": 0
    },
    {
      "current_code": "    fn entity_to_params(&self, entity: &CodeEntity) -> Result<BTreeMap<String, DataValue>> {\n        let mut params = BTreeMap::new();\n\n        params.insert(\n            \"ISGL1_key\".to_string(),\n            DataValue::Str(entity.isgl1_key.clone().into()),\n        );\n\n        params.insert(\n            \"Current_Code\".to_string(),\n            entity\n                .current_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"Future_Code\".to_string(),\n            entity\n                .future_code\n                .as_ref()\n                .map(|s| DataValue::Str(s.clone().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        // Serialize complex types as JSON\n        let signature_json = serde_json::to_string(&entity.interface_signature)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize interface_signature: {}\", e),\n            })?;\n        params.insert(\n            \"interface_signature\".to_string(),\n            DataValue::Str(signature_json.into()),\n        );\n\n        let tdd_json = serde_json::to_string(&entity.tdd_classification)\n            .map_err(|e| ParseltongError::SerializationError {\n                details: format!(\"Failed to serialize TDD_Classification: {}\", e),\n            })?;\n        params.insert(\n            \"TDD_Classification\".to_string(),\n            DataValue::Str(tdd_json.into()),\n        );\n\n        params.insert(\n            \"lsp_meta_data\".to_string(),\n            if let Some(ref lsp) = entity.lsp_metadata {\n                let lsp_json = serde_json::to_string(lsp)\n                    .map_err(|e| ParseltongError::SerializationError {\n                        details: format!(\"Failed to serialize lsp_meta_data: {}\", e),\n                    })?;\n                DataValue::Str(lsp_json.into())\n            } else {\n                DataValue::Null\n            },\n        );\n\n        params.insert(\n            \"current_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.current_ind),\n        );\n\n        params.insert(\n            \"future_ind\".to_string(),\n            DataValue::Bool(entity.temporal_state.future_ind),\n        );\n\n        params.insert(\n            \"Future_Action\".to_string(),\n            entity\n                .temporal_state\n                .future_action\n                .as_ref()\n                .map(|action| {\n                    DataValue::Str(\n                        match action {\n                            TemporalAction::Create => \"Create\",\n                            TemporalAction::Edit => \"Edit\",\n                            TemporalAction::Delete => \"Delete\",\n                        }\n                        .into(),\n                    )\n                })\n                .unwrap_or(DataValue::Null),\n        );\n\n        params.insert(\n            \"file_path\".to_string(),\n            DataValue::Str(\n                entity\n                    .interface_signature\n                    .file_path\n                    .to_string_lossy()\n                    .to_string()\n                    .into(),\n            ),\n        );\n\n        params.insert(\n            \"language\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.language_specific {\n                    LanguageSpecificSignature::Rust(_) => \"rust\",\n                    LanguageSpecificSignature::JavaScript(_) => \"javascript\",\n                    LanguageSpecificSignature::TypeScript(_) => \"typescript\",\n                    LanguageSpecificSignature::Python(_) => \"python\",\n                    LanguageSpecificSignature::Java(_) => \"java\",\n                }\n                .into(),\n            ),\n        );\n\n        params.insert(\n            \"last_modified\".to_string(),\n            DataValue::Str(entity.metadata.modified_at.to_rfc3339().into()),\n        );\n\n        params.insert(\n            \"entity_type\".to_string(),\n            DataValue::Str(\n                match &entity.interface_signature.entity_type {\n                    EntityType::Function => \"function\",\n                    EntityType::Method => \"method\",\n                    EntityType::Struct => \"struct\",\n                    EntityType::Enum => \"enum\",\n                    EntityType::Trait => \"trait\",\n                    EntityType::Interface => \"interface\",\n                    EntityType::Module => \"module\",\n                    EntityType::ImplBlock { .. } => \"impl\",\n                    EntityType::Macro => \"macro\",\n                    EntityType::ProcMacro => \"proc_macro\",\n                    EntityType::TestFunction => \"test\",\n                    EntityType::Class => \"class\",\n                    EntityType::Variable => \"variable\",\n                    EntityType::Constant => \"constant\",\n                }\n                .into(),\n            ),\n        );\n\n        // v0.9.0: Add entity_class parameter\n        params.insert(\n            \"entity_class\".to_string(),\n            DataValue::Str(\"CODE\".into()), // Default to CODE, will be updated by test detection\n        );\n\n        Ok(params)\n    }",
      "current_ind": 1,
      "entity_name": "entity_to_params",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"entity_to_params\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":948,\"end\":1096},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:entity_to_params:__crates_parseltongue-core_src_storage_cozo_client_rs:948-1096",
      "line_number": 0
    },
    {
      "current_code": "    fn entity_type_to_key_component(&self, entity_type: &EntityType) -> &'static str {\n        match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Class => \"class\",\n            EntityType::Module => \"module\",\n            EntityType::Impl => \"impl\",\n            EntityType::Typedef => \"typedef\",\n            EntityType::Namespace => \"namespace\",\n        }\n    }",
      "current_ind": 1,
      "entity_name": "entity_type_to_key_component",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"entity_type_to_key_component\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":579,\"end\":593},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:entity_type_to_key_component:__crates_parseltongue-core_src_query_extractor_rs:579-593",
      "line_number": 0
    },
    {
      "current_code": "        fn eq(&self, other: &Self) -> bool {\n            match (self, other) {\n                (Value::Nil, Value::Nil) => true,\n                (Value::Boolean(a), Value::Boolean(b)) => a == b,\n                (Value::Integer(a), Value::Integer(b)) => a == b,\n                (Value::Float(a), Value::Float(b)) => a == b,\n                (Value::String(a), Value::String(b)) => a == b,\n                (Value::Symbol(a), Value::Symbol(b)) => a == b,\n                (Value::Array(a), Value::Array(b)) => a == b,\n                (Value::Hash(a), Value::Hash(b)) => a == b,\n                _ => false,\n            }\n        }",
      "current_ind": 1,
      "entity_name": "eq",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"eq\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":833,\"end\":845},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:eq:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:833-845",
      "line_number": 0
    },
    {
      "current_code": "    fn escape_future_code(&self) -> String {\n        match &self.future_code {\n            Some(code) => {\n                // Properly escape quotes and backslashes for Datalog string literals\n                let escaped = code\n                    .replace('\\\\', \"\\\\\\\\\")  // Escape backslashes first\n                    .replace('\"', \"\\\\\\\"\");   // Then escape quotes\n                format!(\"\\\"{}\\\"\", escaped)\n            }\n            None => \"null\".to_string(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "escape_future_code",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"escape_future_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":134,\"end\":145},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:escape_future_code:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:134-145",
      "line_number": 0
    },
    {
      "current_code": "        fn estimated_tokens(&self) -> usize {\n            self.tokens\n        }",
      "current_ind": 1,
      "entity_name": "estimated_tokens",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"estimated_tokens\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":175,\"end\":177},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:estimated_tokens:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:175-177",
      "line_number": 0
    },
    {
      "current_code": "    fn estimated_tokens(&self) -> usize {\n        // Conservative estimate: ~2.5 tokens per edge (from_key + to_key + edge_type)\n        // For 2000 edges: ~5000 tokens\n        5_000\n    }",
      "current_ind": 1,
      "entity_name": "estimated_tokens",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"estimated_tokens\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":92,\"end\":96},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:estimated_tokens:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:92-96",
      "line_number": 0
    },
    {
      "current_code": "    fn estimated_tokens(&self) -> usize {\n        // Estimate: ~50 tokens per entity (signatures only)\n        // For 590 entities: ~30K tokens\n        30_000\n    }",
      "current_ind": 1,
      "entity_name": "estimated_tokens",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"estimated_tokens\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":181,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:estimated_tokens:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:181-185",
      "line_number": 0
    },
    {
      "current_code": "    fn estimated_tokens(&self) -> usize {\n        // Estimate: ~100 tokens per entity (signatures + type info)\n        // For 590 entities: ~60K tokens\n        60_000\n    }",
      "current_ind": 1,
      "entity_name": "estimated_tokens",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"estimated_tokens\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":156,\"end\":160},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:estimated_tokens:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:156-160",
      "line_number": 0
    },
    {
      "current_code": "        async fn execute(&self, _input: ToolInput) -> Result<ToolOutput> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ConfigurationError {\n                    details: \"Mock tool configured to fail\".to_string(),\n                });\n            }\n\n            self.execute_result\n                .clone()\n                .unwrap_or(Ok(ToolOutput::IndexingComplete {\n                    entities_count: 0,\n                    duration_ms: 0,\n                }))\n        }",
      "current_ind": 1,
      "entity_name": "execute",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"execute\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":583,\"end\":596},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:execute:__crates_parseltongue-core_src_interfaces_rs:583-596",
      "line_number": 0
    },
    {
      "current_code": "    fn execute_dependency_query(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        dep_query_source: &str,\n        entities: &[ParsedEntity],\n    ) -> Result<Vec<DependencyEdge>> {\n        // Compile query\n        let ts_lang = self.get_ts_language(language)?;\n        let query = Query::new(&ts_lang, dep_query_source)\n            .context(\"Failed to create dependency query\")?;\n\n        // Execute query\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n        let mut dependencies = Vec::new();\n\n        while let Some(m) = matches.next() {\n            // Process each match to extract dependency relationship\n            if let Some(edge) = self.process_dependency_match(&m, &query, source, file_path, language, entities) {\n                dependencies.push(edge);\n            }\n        }\n\n        Ok(dependencies)\n    }",
      "current_ind": 1,
      "entity_name": "execute_dependency_query",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"execute_dependency_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":405,\"end\":432},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:execute_dependency_query:__crates_parseltongue-core_src_query_extractor_rs:405-432",
      "line_number": 0
    },
    {
      "current_code": "    fn execute_query(\n        &self,\n        tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        query_source: &str,\n    ) -> Result<Vec<ParsedEntity>> {\n        // Create query\n        let ts_lang = self.get_ts_language(language)?;\n        let query = Query::new(&ts_lang, query_source)\n            .context(\"Failed to create query\")?;\n\n        // Execute query using streaming iterator\n        let mut cursor = QueryCursor::new();\n        let mut matches = cursor.matches(&query, tree.root_node(), source.as_bytes());\n        let mut entities = Vec::new();\n        let mut seen = std::collections::HashSet::new();\n\n        while let Some(m) = matches.next() {\n            if let Some(entity) = self.process_match(m, &query, source, file_path, language) {\n                // Deduplicate based on (name, line_range) - prevents duplicate extraction\n                let key = (entity.name.clone(), entity.line_range);\n                if seen.insert(key) {\n                    entities.push(entity);\n                }\n            }\n        }\n\n        Ok(entities)\n    }",
      "current_ind": 1,
      "entity_name": "execute_query",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"execute_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":292,\"end\":322},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:execute_query:__crates_parseltongue-core_src_query_extractor_rs:292-322",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn execute_query(&self, query: &str) -> Result<()> {\n        self.db\n            .run_script(query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"execute_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "execute_query",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"execute_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":717,\"end\":725},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:execute_query:__crates_parseltongue-core_src_storage_cozo_client_rs:717-725",
      "line_number": 0
    },
    {
      "current_code": "        async fn export(&self, _db: &dyn CodeGraphRepository, _config: &ExportConfig) -> Result<ExportOutput> {\n            todo!(\"Mock implementation\")\n        }",
      "current_ind": 1,
      "entity_name": "export",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"export\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":167,\"end\":169},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:export:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:167-169",
      "line_number": 0
    },
    {
      "current_code": "    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 3 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query edges from database\n        let edges = if config.where_filter == \"ALL\" {\n            db.get_all_edges().await?\n        } else {\n            db.query_edges(&config.where_filter).await?\n        };\n\n        // 2. Convert to DependencyEdge format\n        let dependency_edges: Vec<DependencyEdge> = edges\n            .into_iter()\n            .map(|edge| DependencyEdge {\n                from_key: edge.from_key,\n                to_key: edge.to_key,\n                edge_type: edge.edge_type,\n            })\n            .collect();\n\n        // 3. Count edges for metadata\n        let total_edges = dependency_edges.len();\n\n        // 4. Build metadata\n        let metadata = ExportMetadata {\n            level: 0,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: None,  // Level 0 has no entities\n            total_edges: Some(total_edges),\n            include_code: None,    // N/A for Level 0\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 5. Build output\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: None,                    // Level 0 has no entities\n            edges: Some(dependency_edges),     // Only edges\n        })\n    }",
      "current_ind": 1,
      "entity_name": "export",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"export\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":43,\"end\":86},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:export:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:43-86",
      "line_number": 0
    },
    {
      "current_code": "    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 3 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query entities from database\n        let entities = if config.where_filter == \"ALL\" {\n            db.get_all_entities().await?\n        } else {\n            db.query_entities(&config.where_filter).await?\n        };\n\n        // v0.9.0: Separate entities by EntityClass for dual output\n        let (code_entities, test_entities): (Vec<_>, Vec<_>) = entities\n            .iter()\n            .partition(|e| e.entity_class == \"CODE\");\n\n        // 2. Convert to Level1 format (separate for code and tests)\n        let code_level1_entities: Vec<EntityExportLevel1> = code_entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n        \n        let test_level1_entities: Vec<EntityExportLevel1> = test_entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n\n        // 3. Count entities for metadata\n        let total_entities = entities.len();\n        let code_entities_count = code_level1_entities.len();\n        let test_entities_count = test_level1_entities.len();\n\n        // v0.9.0: Generate dual outputs based on ExportConfig\n        let outputs = if config.code_output_path.is_some() || config.tests_output_path.is_some() {\n            // Dual output mode: separate files for code and tests\n            let mut outputs = std::collections::HashMap::new();\n            \n            // Code output\n            if let Some(code_path) = &config.code_output_path {\n                let code_json = serde_json::to_value(&code_level1_entities)?;\n                outputs.insert(code_path.clone(), code_json);\n            }\n            \n            // Tests output\n            if let Some(tests_path) = &config.tests_output_path {\n                let tests_json = serde_json::to_value(&test_level1_entities)?;\n                outputs.insert(tests_path.clone(), tests_json);\n            }\n            \n            outputs\n        } else {\n            // Legacy mode: single output with all entities\n            let all_entities = serde_json::to_value(&code_level1_entities)?;\n            let mut outputs = std::collections::HashMap::new();\n            outputs.insert(config.output_path.clone(), all_entities);\n            outputs\n        };\n\n        // 4. Build metadata with EntityClass information\n        let metadata = ExportMetadata {\n            level: 1,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: Some(total_entities),\n            total_edges: None,  // Level 1 has no edges\n            include_code: Some(config.include_code),\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 5. Build output (v0.9.0: support dual outputs)\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: Some(serde_json::to_value(&code_level1_entities)?), // Primary output\n            edges: None,  // Level 1 has no edges\n        })\n    }",
      "current_ind": 1,
      "entity_name": "export",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"export\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":98,\"end\":175},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:export:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:98-175",
      "line_number": 0
    },
    {
      "current_code": "    async fn export(\n        &self,\n        db: &dyn CodeGraphRepository,\n        config: &ExportConfig,\n    ) -> Result<ExportOutput> {\n        // Phase 4 (GREEN): Minimal implementation to make tests pass\n\n        // 1. Query entities from database\n        let entities = if config.where_filter == \"ALL\" {\n            db.get_all_entities().await?\n        } else {\n            db.query_entities(&config.where_filter).await?\n        };\n\n        // 2. Convert to Level2 format\n        let level2_entities: Vec<EntityExportLevel2> = entities\n            .iter()\n            .map(|e| Self::convert_entity(e, config.include_code))\n            .collect();\n\n        // 3. Count entities for metadata\n        let total_entities = level2_entities.len();\n\n        // 4. Serialize entities to JSON (serde handles null-skipping via attributes)\n        let entities_json = serde_json::to_value(&level2_entities)?;\n\n        // 5. Build metadata\n        let metadata = ExportMetadata {\n            level: 2,\n            timestamp: Utc::now().to_rfc3339(),\n            total_entities: Some(total_entities),\n            total_edges: None,  // Level 2 has no edges\n            include_code: Some(config.include_code),\n            where_filter: config.where_filter.clone(),\n        };\n\n        // 6. Build output\n        Ok(ExportOutput {\n            export_metadata: metadata,\n            entities: Some(entities_json),\n            edges: None,  // Level 2 has no edges\n        })\n    }",
      "current_ind": 1,
      "entity_name": "export",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"export\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":108,\"end\":150},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:export:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:108-150",
      "line_number": 0
    },
    {
      "current_code": "    fn extract_code_snippet(&self, source: &str, start_line: usize, end_line: usize) -> String {\n        source\n            .lines()\n            .enumerate()\n            .filter(|(idx, _)| *idx + 1 >= start_line && *idx < end_line)\n            .map(|(_, line)| line)\n            .collect::<Vec<_>>()\n            .join(\"\\n\")\n    }",
      "current_ind": 1,
      "entity_name": "extract_code_snippet",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"extract_code_snippet\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":277,\"end\":285},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:extract_code_snippet:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:277-285",
      "line_number": 0
    },
    {
      "current_code": "    fn extract_entities(\n        &self,\n        _tree: &Tree,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &mut Vec<ParsedEntity>,\n        dependencies: &mut Vec<DependencyEdge>,\n    ) {\n        // v0.8.9 CRITICAL FIX: Use QueryBasedExtractor for entity extraction\n        //\n        // This replaces the broken walk_node() approach that only worked for Rust.\n        // Now ALL 12 languages extract entities correctly via .scm query files.\n        match self.query_extractor.lock() {\n            Ok(mut extractor) => {\n                match extractor.parse_source(source, file_path, language) {\n                    Ok((query_entities, query_deps)) => {\n                        // Convert QueryBasedExtractor entities to pt01 ParsedEntity format\n                        for query_entity in query_entities {\n                            entities.push(ParsedEntity {\n                                entity_type: self.map_query_entity_type(&query_entity.entity_type),\n                                name: query_entity.name,\n                                language: query_entity.language,\n                                line_range: query_entity.line_range,\n                                file_path: query_entity.file_path,\n                                metadata: query_entity.metadata,\n                            });\n                        }\n\n                        // v0.9.0 FEATURE: Rust-specific attribute parsing\n                        // Enrich Rust entities with #[test] metadata after extraction\n                        if language == Language::Rust {\n                            self.enrich_rust_entities_with_attributes(entities, source);\n                        }\n\n                        // v0.9.0 CRITICAL FIX: Use query-based dependency extraction\n                        // This replaces manual tree-walking for dependency extraction\n                        dependencies.extend(query_deps);\n                    }\n                    Err(e) => {\n                        // Graceful degradation: log error but continue\n                        eprintln!(\"QueryBasedExtractor failed for {:?}: {}\", language, e);\n                    }\n                }\n            }\n            Err(e) => {\n                eprintln!(\"Failed to lock query_extractor: {}\", e);\n            }\n        }\n\n        // v0.9.0: Manual dependency extraction replaced by query-based approach (REFACTORED)\n        // All entity and dependency extraction now handled by QueryBasedExtractor\n    }",
      "current_ind": 1,
      "entity_name": "extract_entities",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"extract_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":332,\"end\":384},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:extract_entities:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:332-384",
      "line_number": 0
    },
    {
      "current_code": "    fn extract_file_path(&self, isgl1_key: &str) -> Result<PathBuf> {\n        // ISGL1 key formats:\n        // - Line-based: \"rust:fn:name:src_lib_rs:42-56\"\n        // - Hash-based: \"src_lib_rs-new_feature-fn-abc12345\"\n        //\n        // Sanitized paths encode \"src/lib.rs\" as \"src_lib_rs\"\n        // The \"_rs\" suffix represents the \".rs\" extension\n        // Other underscores represent directory separators\n\n        if isgl1_key.contains(':') {\n            // Line-based format\n            let parts: Vec<&str> = isgl1_key.split(':').collect();\n            if parts.len() >= 4 {\n                let sanitized_path = parts[3]; // \"src_lib_rs\"\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        } else {\n            // Hash-based format\n            let parts: Vec<&str> = isgl1_key.split('-').collect();\n            if !parts.is_empty() {\n                // First part is sanitized file path\n                let sanitized_path = parts[0];\n                return Ok(self.desanitize_path(sanitized_path));\n            }\n        }\n\n        anyhow::bail!(\"Invalid ISGL1 key format: {}\", isgl1_key)\n    }",
      "current_ind": 1,
      "entity_name": "extract_file_path",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"extract_file_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":133,\"end\":160},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:extract_file_path:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:133-160",
      "line_number": 0
    },
    {
      "current_code": "    fn extract_line_range(&self, isgl1_key: &str) -> Option<LineRange> {\n        // Only line-based keys have line ranges: \"rust:fn:name:src_lib_rs:42-56\"\n        // Hash-based keys do not: \"src_lib_rs-new_feature-fn-abc12345\"\n\n        if !isgl1_key.contains(':') {\n            return None; // Hash-based key\n        }\n\n        // Line-based format: last part is \"start-end\"\n        let parts: Vec<&str> = isgl1_key.split(':').collect();\n        if parts.len() < 5 {\n            return None;\n        }\n\n        let line_part = parts[4]; // \"42-56\"\n        let line_nums: Vec<&str> = line_part.split('-').collect();\n        if line_nums.len() != 2 {\n            return None;\n        }\n\n        let start = line_nums[0].parse::<u32>().ok()?;\n        let end = line_nums[1].parse::<u32>().ok()?;\n\n        Some(LineRange { start, end })\n    }",
      "current_ind": 1,
      "entity_name": "extract_line_range",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"extract_line_range\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":186,\"end\":210},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:extract_line_range:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:186-210",
      "line_number": 0
    },
    {
      "current_code": "    pub fn failure(validation_type: ValidationType, error: ValidationError) -> Self {\n        Self {\n            is_valid: false,\n            validation_type,\n            errors: vec![error.to_string()],\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "failure",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"failure\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":77,\"end\":86},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:failure:__crates_pt04-syntax-preflight-validator_src_types_rs:77-86",
      "line_number": 0
    },
    {
      "current_code": "    async fn fetch_lsp_metadata_for_entity(\n        &self,\n        entity: &ParsedEntity,\n        file_path: &Path,\n    ) -> Option<LspMetadata> {\n        // Only fetch for Rust files\n        if entity.language != Language::Rust {\n            return None;\n        }\n\n        // Calculate hover position at the start of the entity (line is 0-indexed in LSP)\n        let line = entity.line_range.0.saturating_sub(1) as u32;\n        let character = 0u32; // Start of line (tree-sitter gives us the entity name position)\n\n        // Request hover metadata\n        match self.lsp_client.hover(file_path, line, character).await {\n            Ok(Some(hover_response)) => {\n                // Convert hover response to LspMetadata (stub/MVP implementation)\n                Self::hover_response_to_lsp_metadata(&hover_response)\n            }\n            Ok(None) => None, // Graceful degradation\n            Err(_) => None,   // Graceful degradation\n        }\n    }",
      "current_ind": 1,
      "entity_name": "fetch_lsp_metadata_for_entity",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fetch_lsp_metadata_for_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":566,\"end\":589},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fetch_lsp_metadata_for_entity:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:566-589",
      "line_number": 0
    },
    {
      "current_code": "    pub fn file_already_exists(path: PathBuf) -> Self {\n        Self::FileAlreadyExists { path }\n    }",
      "current_ind": 1,
      "entity_name": "file_already_exists",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"file_already_exists\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":31,\"end\":33},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:file_already_exists:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:31-33",
      "line_number": 0
    },
    {
      "current_code": "    pub fn file_extensions(&self) -> Vec<&'static str> {\n        match self {\n            Language::Rust => vec![\"rs\"],\n            Language::JavaScript => vec![\"js\", \"jsx\"],\n            Language::TypeScript => vec![\"ts\", \"tsx\"],\n            Language::Python => vec![\"py\"],\n            Language::Java => vec![\"java\"],\n            Language::C => vec![\"c\", \"h\"],\n            Language::Cpp => vec![\"cpp\", \"cc\", \"cxx\", \"hpp\"],\n            Language::Go => vec![\"go\"],\n            Language::Ruby => vec![\"rb\"],\n            Language::Php => vec![\"php\"],\n            Language::CSharp => vec![\"cs\"],\n            Language::Swift => vec![\"swift\"],\n            Language::Kotlin => vec![\"kt\", \"kts\"],\n            Language::Scala => vec![\"scala\", \"sc\"],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "file_extensions",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"file_extensions\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":33,\"end\":50},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:file_extensions:__crates_parseltongue-core_src_entities_rs:33-50",
      "line_number": 0
    },
    {
      "current_code": "    pub fn file_not_found(path: PathBuf) -> Self {\n        Self::FileNotFound { path }\n    }",
      "current_ind": 1,
      "entity_name": "file_not_found",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"file_not_found\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":36,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:file_not_found:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:36-38",
      "line_number": 0
    },
    {
      "current_code": "    fn find_containing_entity<'a>(\n        &self,\n        node: tree_sitter::Node<'_>,\n        entities: &'a [ParsedEntity],\n    ) -> Option<&'a ParsedEntity> {\n        let node_line = node.start_position().row + 1;\n\n        // Find all entities that contain this line\n        let mut candidates: Vec<&ParsedEntity> = entities\n            .iter()\n            .filter(|e| e.line_range.0 <= node_line && node_line <= e.line_range.1)\n            .collect();\n\n        if candidates.is_empty() {\n            return None;\n        }\n\n        // Sort by specificity\n        candidates.sort_by(|a, b| {\n            // Primary: Prefer smaller line ranges (more specific)\n            let a_range = a.line_range.1 - a.line_range.0;\n            let b_range = b.line_range.1 - b.line_range.0;\n\n            match a_range.cmp(&b_range) {\n                std::cmp::Ordering::Equal => {\n                    // Secondary: Prefer methods/functions over impl blocks\n                    match (&a.entity_type, &b.entity_type) {\n                        (EntityType::Method, EntityType::Impl) => std::cmp::Ordering::Less,\n                        (EntityType::Impl, EntityType::Method) => std::cmp::Ordering::Greater,\n                        (EntityType::Function, EntityType::Impl) => std::cmp::Ordering::Less,\n                        (EntityType::Impl, EntityType::Function) => std::cmp::Ordering::Greater,\n                        _ => std::cmp::Ordering::Equal,\n                    }\n                },\n                other => other,\n            }\n        });\n\n        // Return most specific entity\n        Some(candidates[0])\n    }",
      "current_ind": 1,
      "entity_name": "find_containing_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"find_containing_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":536,\"end\":576},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:find_containing_entity:__crates_parseltongue-core_src_query_extractor_rs:536-576",
      "line_number": 0
    },
    {
      "current_code": "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            // Simple serialization for testing\n            write!(f, \"{:?}\", self)\n        }",
      "current_ind": 1,
      "entity_name": "fmt",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fmt\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1412,\"end\":1415},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fmt:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1412-1415",
      "line_number": 0
    },
    {
      "current_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EntityClass::TestImplementation => write!(f, \"TEST\"),\n            EntityClass::CodeImplementation => write!(f, \"CODE\"),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "fmt",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fmt\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":493,\"end\":498},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fmt:__crates_parseltongue-core_src_entities_rs:493-498",
      "line_number": 0
    },
    {
      "current_code": "    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Language::Rust => write!(f, \"rust\"),\n            Language::JavaScript => write!(f, \"javascript\"),\n            Language::TypeScript => write!(f, \"typescript\"),\n            Language::Python => write!(f, \"python\"),\n            Language::Java => write!(f, \"java\"),\n            Language::C => write!(f, \"c\"),\n            Language::Cpp => write!(f, \"cpp\"),\n            Language::Go => write!(f, \"go\"),\n            Language::Ruby => write!(f, \"ruby\"),\n            Language::Php => write!(f, \"php\"),\n            Language::CSharp => write!(f, \"csharp\"),\n            Language::Swift => write!(f, \"swift\"),\n            Language::Kotlin => write!(f, \"kotlin\"),\n            Language::Scala => write!(f, \"scala\"),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "fmt",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fmt\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":76,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fmt:__crates_parseltongue-core_src_entities_rs:76-93",
      "line_number": 0
    },
    {
      "current_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }",
      "current_ind": 1,
      "entity_name": "fmt",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fmt\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":911,\"end\":913},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fmt:__crates_parseltongue-core_src_entities_rs:911-913",
      "line_number": 0
    },
    {
      "current_code": "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }",
      "current_ind": 1,
      "entity_name": "fmt",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"fmt\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":975,\"end\":977},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:fmt:__crates_parseltongue-core_src_entities_rs:975-977",
      "line_number": 0
    },
    {
      "current_code": "    pub fn for_entities(level: u8, total_entities: usize, include_code: bool, where_filter: String) -> Self {\n        Self {\n            level,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n            total_edges: None,\n            total_entities: Some(total_entities),\n            include_code: Some(include_code),\n            where_filter,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "for_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"for_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":250,\"end\":259},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:for_entities:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:250-259",
      "line_number": 0
    },
    {
      "current_code": "    pub fn for_level0(total_edges: usize, where_filter: String) -> Self {\n        Self {\n            level: 0,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n            total_edges: Some(total_edges),\n            total_entities: None,\n            include_code: None,\n            where_filter,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "for_level0",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"for_level0\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":238,\"end\":247},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:for_level0:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:238-247",
      "line_number": 0
    },
    {
      "current_code": "    fn format_key(&self, entity: &ParsedEntity) -> String {\n        let type_str = match entity.entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Class => \"class\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Impl => \"impl\",\n            EntityType::Module => \"mod\",\n            EntityType::Namespace => \"namespace\",\n            EntityType::Typedef => \"typedef\",\n            EntityType::Variable => \"var\",\n        };\n\n        format!(\n            \"{}:{}:{}:{}:{}-{}\",\n            entity.language,\n            type_str,\n            entity.name,\n            self.sanitize_path(&entity.file_path),\n            entity.line_range.0,\n            entity.line_range.1\n        )\n    }",
      "current_ind": 1,
      "entity_name": "format_key",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"format_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":149,\"end\":173},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:format_key:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:149-173",
      "line_number": 0
    },
    {
      "current_code": "    fn from(edge_type: EdgeType) -> Self {\n        edge_type.as_str().to_owned()\n    }",
      "current_ind": 1,
      "entity_name": "from",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":952,\"end\":954},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from:__crates_parseltongue-core_src_entities_rs:952-954",
      "line_number": 0
    },
    {
      "current_code": "    fn from(err: StreamerError) -> Self {\n        match err {\n            StreamerError::FileSystemError { path, source } => {\n                ParseltongError::FileSystemError { path, source }\n            }\n            StreamerError::ParsingError { file, reason } => {\n                ParseltongError::ParseError { reason, location: file }\n            }\n            StreamerError::StorageError { details } => {\n                ParseltongError::DatabaseError {\n                    operation: \"storage\".to_string(),\n                    details,\n                }\n            }\n            StreamerError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError { details: format!(\"{}: {}\", field, reason) }\n            }\n            _ => ParseltongError::ConfigurationError {\n                details: err.to_string(),\n            },\n        }\n    }",
      "current_ind": 1,
      "entity_name": "from",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/errors.rs\",\"line_range\":{\"start\":60,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from:__crates_pt01-folder-to-cozodb-streamer_src_errors_rs:60-81",
      "line_number": 0
    },
    {
      "current_code": "    fn from(err: LlmWriterError) -> Self {\n        match err {\n            LlmWriterError::DatabaseQueryError { query, reason } => {\n                ParseltongError::DatabaseError {\n                    operation: \"query\".to_string(),\n                    details: format!(\"Query: {} - {}\", query, reason),\n                }\n            }\n            LlmWriterError::ValidationError { field, reason } => {\n                ParseltongError::ValidationError {\n                    field,\n                    expected: \"valid temporal change\".to_string(),\n                    actual: reason,\n                }\n            }\n            LlmWriterError::ConfigurationError { field, reason } => {\n                ParseltongError::ConfigurationError {\n                    details: format!(\"{}: {}\", field, reason),\n                }\n            }\n            LlmWriterError::ResponseParseError { reason } => {\n                ParseltongError::ParseError {\n                    reason,\n                    location: \"LLM response\".to_string(),\n                }\n            }\n            _ => ParseltongError::LlmError {\n                reason: err.to_string(),\n            },\n        }\n    }",
      "current_ind": 1,
      "entity_name": "from",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/errors.rs\",\"line_range\":{\"start\":63,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from:__crates_pt03-llm-to-cozodb-writer_src_errors_rs:63-93",
      "line_number": 0
    },
    {
      "current_code": "    pub fn from_file_path(path: &PathBuf) -> Option<Self> {\n        let extension = path.extension()?.to_str()?;\n\n        [\n            Language::Rust,\n            Language::JavaScript,\n            Language::TypeScript,\n            Language::Python,\n            Language::Java,\n            Language::C,\n            Language::Cpp,\n            Language::Go,\n            Language::Ruby,\n            Language::Php,\n            Language::CSharp,\n            Language::Swift,\n            Language::Kotlin,\n            Language::Scala,\n        ].into_iter().find(|&language| language.file_extensions().contains(&extension))\n    }",
      "current_ind": 1,
      "entity_name": "from_file_path",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from_file_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":53,\"end\":72},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from_file_path:__crates_parseltongue-core_src_entities_rs:53-72",
      "line_number": 0
    },
    {
      "current_code": "    pub fn from_key(mut self, key: impl Into<String>) -> Self {\n        self.from_key = Some(key.into());\n        self\n    }",
      "current_ind": 1,
      "entity_name": "from_key",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1045,\"end\":1048},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from_key:__crates_parseltongue-core_src_entities_rs:1045-1048",
      "line_number": 0
    },
    {
      "current_code": "    fn from_str(s: &str) -> Result<Self> {\n        match s {\n            \"Calls\" => Ok(Self::Calls),\n            \"Uses\" => Ok(Self::Uses),\n            \"Implements\" => Ok(Self::Implements),\n            _ => Err(ParseltongError::ValidationError {\n                field: \"edge_type\".to_string(),\n                expected: \"Calls, Uses, or Implements\".to_string(),\n                actual: s.to_owned(),\n            }),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "from_str",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"from_str\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":960,\"end\":971},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:from_str:__crates_parseltongue-core_src_entities_rs:960-971",
      "line_number": 0
    },
    {
      "current_code": "    pub fn future_code(mut self, code: String) -> Self {\n        self.future_code = Some(code);\n        self\n    }",
      "current_ind": 1,
      "entity_name": "future_code",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"future_code\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":423,\"end\":426},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:future_code:__crates_parseltongue-core_src_temporal_rs:423-426",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn generate_diff(&self) -> Result<CodeDiff> {\n        // Get all changed entities from CozoDB\n        let changed_entities = self\n            .storage\n            .get_changed_entities()\n            .await\n            .context(\"Failed to get changed entities from CozoDB\")?;\n\n        let mut diff = CodeDiff::new();\n\n        for entity in changed_entities {\n            if let Some(change) = self.entity_to_change(&entity)? {\n                diff.add_change(change);\n            }\n        }\n\n        Ok(diff)\n    }",
      "current_ind": 1,
      "entity_name": "generate_diff",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"generate_diff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":60,\"end\":77},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:generate_diff:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:60-77",
      "line_number": 0
    },
    {
      "current_code": "    fn generate_key(&self, entity: &ParsedEntity) -> Result<String> {\n        Ok(self.format_key(entity))\n    }",
      "current_ind": 1,
      "entity_name": "generate_key",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"generate_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":182,\"end\":184},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:generate_key:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:182-184",
      "line_number": 0
    },
    {
      "current_code": "    pub fn generate_new_entity_key(\n        file_path: &str,\n        entity_name: &str,\n        entity_type: &EntityType,\n        timestamp: chrono::DateTime<chrono::Utc>,\n    ) -> String {\n        use sha2::{Sha256, Digest};\n\n        // Sanitize file path: replace /, \\, and . with _\n        let sanitized_path = file_path\n            .replace(['/', '\\\\', '.'], \"_\");\n\n        // Get type abbreviation\n        let type_abbrev = match entity_type {\n            EntityType::Function => \"fn\",\n            EntityType::Method => \"method\",\n            EntityType::Struct => \"struct\",\n            EntityType::Enum => \"enum\",\n            EntityType::Trait => \"trait\",\n            EntityType::Interface => \"interface\",\n            EntityType::Module => \"mod\",\n            EntityType::ImplBlock { .. } => \"impl\",\n            EntityType::Macro => \"macro\",\n            EntityType::ProcMacro => \"proc_macro\",\n            EntityType::TestFunction => \"test\",\n            EntityType::Class => \"class\",\n            EntityType::Variable => \"var\",\n            EntityType::Constant => \"const\",\n        };\n\n        // Create hash input: filepath + name + type + timestamp\n        let mut hasher = Sha256::new();\n        hasher.update(file_path.as_bytes());\n        hasher.update(entity_name.as_bytes());\n        hasher.update(format!(\"{:?}\", entity_type).as_bytes());\n        hasher.update(timestamp.to_rfc3339().as_bytes());\n\n        // Get hash result and take first 8 characters\n        let hash_bytes = hasher.finalize();\n        let hash_str = format!(\"{:x}\", hash_bytes);\n        let short_hash = &hash_str[0..8];\n\n        // Format: sanitized_path-entity_name-type_abbrev-hash8\n        format!(\"{}-{}-{}-{}\", sanitized_path, entity_name, type_abbrev, short_hash)\n    }",
      "current_ind": 1,
      "entity_name": "generate_new_entity_key",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"generate_new_entity_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":768,\"end\":812},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:generate_new_entity_key:__crates_parseltongue-core_src_entities_rs:768-812",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_all_dependencies(&self) -> Result<Vec<DependencyEdge>> {\n        let query = \"?[from_key, to_key, edge_type, source_location] := *DependencyEdges{from_key, to_key, edge_type, source_location}\";\n\n        let result = self\n            .db\n            .run_script(query, BTreeMap::new(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_all_dependencies\".to_string(),\n                reason: format!(\"Failed to query all dependencies: {}\", e),\n            })?;\n\n        // Parse results into DependencyEdge structs\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if row.len() >= 3 {\n                if let (Some(DataValue::Str(from_key)), Some(DataValue::Str(to_key)), Some(DataValue::Str(edge_type_str))) =\n                    (row.get(0), row.get(1), row.get(2))\n                {\n                    let edge_type = match edge_type_str.as_str() {\n                        \"Calls\" => EdgeType::Calls,\n                        \"Uses\" => EdgeType::Uses,\n                        \"Implements\" => EdgeType::Implements,\n                        _ => continue, // Skip unknown edge types\n                    };\n\n                    let source_location = row.get(3).and_then(|v| {\n                        if let DataValue::Str(loc) = v {\n                            Some(loc.to_string())\n                        } else {\n                            None\n                        }\n                    });\n\n                    let edge = DependencyEdge::builder()\n                        .from_key(from_key.to_string())\n                        .to_key(to_key.to_string())\n                        .edge_type(edge_type)\n                        .source_location(source_location.unwrap_or_default())\n                        .build()\n                        .map_err(|e| ParseltongError::DependencyError {\n                            operation: \"get_all_dependencies\".to_string(),\n                            reason: format!(\"Failed to build DependencyEdge: {}\", e),\n                        })?;\n\n                    dependencies.push(edge);\n                }\n            }\n        }\n\n        Ok(dependencies)\n    }",
      "current_ind": 1,
      "entity_name": "get_all_dependencies",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":550,\"end\":600},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_dependencies:__crates_parseltongue-core_src_storage_cozo_client_rs:550-600",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        // Query all dependency edges\n        let query = r#\"\n            ?[from_key, to_key, edge_type] :=\n            *DependencyEdges{from_key, to_key, edge_type}\n        \"#;\n\n        let result = self.storage.raw_query(query).await\n            .map_err(|e| anyhow!(\"Failed to query edges: {}\", e))?;\n\n        let edges = parse_edges_from_query_result(&result)?;\n        Ok(edges)\n    }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":104,\"end\":116},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:104-116",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n            Ok(self.edges.clone())\n        }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":119,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:119-121",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":227,\"end\":229},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:227-229",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":202,\"end\":204},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:202-204",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(self.edges.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":190,\"end\":192},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:190-192",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(self.edges.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":64,\"end\":66},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:64-66",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":72,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:72-74",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }",
      "current_ind": 1,
      "entity_name": "get_all_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":58,\"end\":60},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:58-60",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_all_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            }\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_all_entities\".to_string(),\n                details: format!(\"Failed to query all entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":917,\"end\":943},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_parseltongue-core_src_storage_cozo_client_rs:917-943",
      "line_number": 0
    },
    {
      "current_code": "    pub fn get_all_entities(&self) -> Vec<&CodeEntity> {\n        self.entities.values().collect()\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":137,\"end\":139},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_parseltongue-core_src_temporal_rs:137-139",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        // Query all entities from CodeGraph\n        let query = r#\"\n            ?[ISGL1_key, interface_signature, entity_type, file_path,\n              Current_Code, Future_Code, current_ind, future_ind, Future_Action, entity_class] :=\n            *CodeGraph{\n                ISGL1_key,\n                interface_signature,\n                entity_type,\n                file_path,\n                Current_Code,\n                Future_Code,\n                current_ind,\n                future_ind,\n                Future_Action,\n                entity_class\n            }\n        \"#;\n\n        let result = self.storage.raw_query(query).await\n            .map_err(|e| anyhow!(\"Failed to query entities: {}\", e))?;\n\n        // Parse result into Entity structs\n        let entities = parse_entities_from_query_result(&result)?;\n        Ok(entities)\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":43,\"end\":68},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:43-68",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_entities(&self) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":111,\"end\":113},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:111-113",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":200,\"end\":202},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:200-202",
      "line_number": 0
    },
    {
      "current_code": "        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":175,\"end\":177},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:175-177",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":159,\"end\":161},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:159-161",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":55,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:55-57",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":50,\"end\":52},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:50-52",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n        Ok(self.entities.clone())\n    }",
      "current_ind": 1,
      "entity_name": "get_all_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_all_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":46,\"end\":48},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_all_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:46-48",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        self.get_changed_entities().await\n    }",
      "current_ind": 1,
      "entity_name": "get_changed_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_changed_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1297,\"end\":1299},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_changed_entities:__crates_parseltongue-core_src_storage_cozo_client_rs:1297-1299",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            },\n            Future_Action != null\n        \"#;\n\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"get_changed_entities\".to_string(),\n                details: format!(\"Failed to query changed entities: {}\", e),\n            })?;\n\n        let mut entities = Vec::new();\n        for row in result.rows {\n            entities.push(self.row_to_entity(&row)?);\n        }\n\n        Ok(entities)\n    }",
      "current_ind": 1,
      "entity_name": "get_changed_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_changed_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":884,\"end\":911},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_changed_entities:__crates_parseltongue-core_src_storage_cozo_client_rs:884-911",
      "line_number": 0
    },
    {
      "current_code": "    pub fn get_changed_entities(&self) -> Vec<&CodeEntity> {\n        self.entities\n            .values()\n            .filter(|entity| entity.is_modified())\n            .collect()\n    }",
      "current_ind": 1,
      "entity_name": "get_changed_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_changed_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":124,\"end\":129},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_changed_entities:__crates_parseltongue-core_src_temporal_rs:124-129",
      "line_number": 0
    },
    {
      "current_code": "    pub fn get_dependents(&self, isgl1_key: &str) -> Vec<String> {\n        self.entities\n            .values()\n            .filter(|entity| {\n                // Check if entity depends on the given entity\n                // This is a simplified implementation\n                entity.interface_signature.file_path\n                    .to_string_lossy()\n                    .contains(isgl1_key)\n            })\n            .map(|entity| entity.isgl1_key.clone())\n            .collect()\n    }",
      "current_ind": 1,
      "entity_name": "get_dependents",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_dependents\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":147,\"end\":159},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_dependents:__crates_parseltongue-core_src_temporal_rs:147-159",
      "line_number": 0
    },
    {
      "current_code": "    async fn get_entity(&self, isgl1_key: &str) -> Result<Option<CodeEntity>> {\n        match self.get_entity(isgl1_key).await {\n            Ok(entity) => Ok(Some(entity)),\n            Err(ParseltongError::EntityNotFound { .. }) => Ok(None),\n            Err(e) => Err(e),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "get_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1275,\"end\":1281},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:1275-1281",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_entity(&self, isgl1_key: &str) -> Result<CodeEntity> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] :=\n            *CodeGraph{\n                ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            },\n            ISGL1_key == $key\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self.db.run_script(query, params, ScriptMutability::Immutable).map_err(|e| {\n            ParseltongError::DatabaseError {\n                operation: \"get_entity\".to_string(),\n                details: format!(\"Failed to get entity: {}\", e),\n            }\n        })?;\n\n        if result.rows.is_empty() {\n            return Err(ParseltongError::EntityNotFound {\n                isgl1_key: isgl1_key.to_string(),\n            });\n        }\n\n        self.row_to_entity(&result.rows[0])\n    }",
      "current_ind": 1,
      "entity_name": "get_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":804,\"end\":834},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:804-834",
      "line_number": 0
    },
    {
      "current_code": "    pub fn get_entity(&self, isgl1_key: &str) -> Option<&CodeEntity> {\n        self.entities.get(isgl1_key)\n    }",
      "current_ind": 1,
      "entity_name": "get_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":132,\"end\":134},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_entity:__crates_parseltongue-core_src_temporal_rs:132-134",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_forward_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[to_key] := *DependencyEdges{from_key, to_key}, from_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_forward_dependencies\".to_string(),\n                reason: format!(\"Failed to query forward dependencies: {}\", e),\n            })?;\n\n        // Extract to_key values from results\n        let mut dependencies = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependencies.push(key.to_string());\n            }\n        }\n\n        Ok(dependencies)\n    }",
      "current_ind": 1,
      "entity_name": "get_forward_dependencies",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_forward_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":422,\"end\":445},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_forward_dependencies:__crates_parseltongue-core_src_storage_cozo_client_rs:422-445",
      "line_number": 0
    },
    {
      "current_code": "    fn get_language_type(&self, file_path: &Path) -> Result<Language> {\n        // Use Language::from_file_path to detect language from extension\n        let path_buf = file_path.to_path_buf();\n        let language = Language::from_file_path(&path_buf)\n            .ok_or_else(|| StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            })?;\n\n        // Verify we have a parser for this language\n        if self.parsers.contains_key(&language) {\n            Ok(language)\n        } else {\n            Err(StreamerError::UnsupportedFileType {\n                path: file_path.to_string_lossy().to_string(),\n            })\n        }\n    }",
      "current_ind": 1,
      "entity_name": "get_language_type",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_language_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":210,\"end\":226},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_language_type:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:210-226",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_reverse_dependencies(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        let query = \"?[from_key] := *DependencyEdges{from_key, to_key}, to_key == $key\";\n\n        let mut params = BTreeMap::new();\n        params.insert(\"key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_reverse_dependencies\".to_string(),\n                reason: format!(\"Failed to query reverse dependencies: {}\", e),\n            })?;\n\n        // Extract from_key values from results\n        let mut dependents = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                dependents.push(key.to_string());\n            }\n        }\n\n        Ok(dependents)\n    }",
      "current_ind": 1,
      "entity_name": "get_reverse_dependencies",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_reverse_dependencies\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":493,\"end\":516},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_reverse_dependencies:__crates_parseltongue-core_src_storage_cozo_client_rs:493-516",
      "line_number": 0
    },
    {
      "current_code": "    fn get_stats(&self) -> StreamStats {\n        self.stats.lock().unwrap_or_else(|poisoned| poisoned.into_inner()).clone()\n    }",
      "current_ind": 1,
      "entity_name": "get_stats",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_stats\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":558,\"end\":560},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_stats:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:558-560",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn get_transitive_closure(&self, isgl1_key: &str) -> Result<Vec<String>> {\n        // CozoDB recursive query for unbounded reachability\n        let query = r#\"\n            # Transitive closure: Find all nodes reachable from start node\n\n            # Base case: Direct edges from start node\n            reachable[to_key] := *DependencyEdges{from_key, to_key},\n                                 from_key == $start_key\n\n            # Recursive case: Follow edges transitively (CozoDB handles cycle termination)\n            reachable[to_key] := reachable[from],\n                                 *DependencyEdges{from_key: from, to_key}\n\n            # Return all unique reachable nodes\n            ?[node] := reachable[node]\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"start_key\".to_string(), DataValue::Str(isgl1_key.into()));\n\n        let result = self\n            .db\n            .run_script(query, params, ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"get_transitive_closure\".to_string(),\n                reason: format!(\"Failed to compute transitive closure: {}\", e),\n            })?;\n\n        // Extract all reachable keys\n        let mut reachable = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(key)) = row.first() {\n                reachable.push(key.to_string());\n            }\n        }\n\n        Ok(reachable)\n    }",
      "current_ind": 1,
      "entity_name": "get_transitive_closure",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_transitive_closure\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":674,\"end\":711},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_transitive_closure:__crates_parseltongue-core_src_storage_cozo_client_rs:674-711",
      "line_number": 0
    },
    {
      "current_code": "    fn get_ts_language(&self, language: Language) -> Result<tree_sitter::Language> {\n        Ok(match language {\n            Language::Rust => tree_sitter_rust::LANGUAGE.into(),\n            Language::Python => tree_sitter_python::LANGUAGE.into(),\n            Language::C => tree_sitter_c::LANGUAGE.into(),\n            Language::Cpp => tree_sitter_cpp::LANGUAGE.into(),\n            Language::Ruby => tree_sitter_ruby::LANGUAGE.into(),\n            Language::JavaScript => tree_sitter_javascript::LANGUAGE.into(),\n            Language::TypeScript => tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into(),\n            Language::Go => tree_sitter_go::LANGUAGE.into(),\n            Language::Java => tree_sitter_java::LANGUAGE.into(),\n            Language::Php => tree_sitter_php::LANGUAGE_PHP.into(),\n            Language::CSharp => tree_sitter_c_sharp::LANGUAGE.into(),\n            Language::Swift => tree_sitter_swift::LANGUAGE.into(),\n            // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility\n            // Language::Kotlin => tree_sitter_kotlin::language(),\n            _ => anyhow::bail!(\"Unsupported language: {:?}\", language),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "get_ts_language",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"get_ts_language\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":381,\"end\":399},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:get_ts_language:__crates_parseltongue-core_src_query_extractor_rs:381-399",
      "line_number": 0
    },
    {
      "current_code": "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n            match self {\n                Value::Nil => 0.hash(state),\n                Value::Boolean(b) => b.hash(state),\n                Value::Integer(i) => i.hash(state),\n                Value::Float(f) => f.to_bits().hash(state),\n                Value::String(s) => s.hash(state),\n                Value::Symbol(s) => s.hash(state),\n                Value::Array(a) => a.hash(state),\n                Value::Hash(_) => 0.hash(state), // Simplified\n            }\n        }",
      "current_ind": 1,
      "entity_name": "hash",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"hash\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":817,\"end\":828},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:hash:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:817-828",
      "line_number": 0
    },
    {
      "current_code": "    async fn hover(\n        &self,\n        file_path: &Path,\n        line: u32,\n        character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        let key = format!(\"{}:{}:{}\", file_path.display(), line, character);\n        Ok(self.responses.get(&key).cloned())\n    }",
      "current_ind": 1,
      "entity_name": "hover",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"hover\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":121,\"end\":129},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:hover:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:121-129",
      "line_number": 0
    },
    {
      "current_code": "    async fn hover(\n        &self,\n        _file_path: &Path,\n        _line: u32,\n        _character: u32,\n    ) -> Result<Option<HoverResponse>> {\n        // Graceful degradation: return None if not enabled\n        if !self.enabled {\n            return Ok(None);\n        }\n\n        // TODO: Implement actual LSP hover request\n        Ok(None)\n    }",
      "current_ind": 1,
      "entity_name": "hover",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"hover\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":79,\"end\":92},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:hover:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:79-92",
      "line_number": 0
    },
    {
      "current_code": "    fn hover_response_to_lsp_metadata(hover: &HoverResponse) -> Option<LspMetadata> {\n        Some(LspMetadata {\n            type_information: TypeInformation {\n                resolved_type: hover.contents.clone(),\n                module_path: vec![],\n                generic_parameters: vec![],\n                definition_location: None,\n            },\n            usage_analysis: UsageAnalysis {\n                total_references: 0,\n                usage_locations: vec![],\n                dependents: vec![],\n            },\n            semantic_tokens: vec![],\n        })\n    }",
      "current_ind": 1,
      "entity_name": "hover_response_to_lsp_metadata",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"hover_response_to_lsp_metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":593,\"end\":608},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:hover_response_to_lsp_metadata:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:593-608",
      "line_number": 0
    },
    {
      "current_code": "    fn init_parser(\n        parsers: &mut HashMap<Language, Parser>,\n        lang: Language,\n        grammar: &tree_sitter::Language\n    ) -> Result<()> {\n        let mut parser = Parser::new();\n        parser.set_language(grammar)\n            .context(format!(\"Failed to set language for {:?}\", lang))?;\n        parsers.insert(lang, parser);\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "init_parser",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"init_parser\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":213,\"end\":223},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:init_parser:__crates_parseltongue-core_src_query_extractor_rs:213-223",
      "line_number": 0
    },
    {
      "current_code": "    pub fn initial() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: false,  // Future state unknown at index time\n            future_action: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "initial",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"initial\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":168,\"end\":174},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:initial:__crates_parseltongue-core_src_entities_rs:168-174",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn insert_edge(&self, edge: &DependencyEdge) -> Result<()> {\n        let query = r#\"\n            ?[from_key, to_key, edge_type, source_location] <-\n            [[$from_key, $to_key, $edge_type, $source_location]]\n\n            :put DependencyEdges {\n                from_key, to_key, edge_type =>\n                source_location\n            }\n        \"#;\n\n        let mut params = BTreeMap::new();\n        params.insert(\"from_key\".to_string(), DataValue::Str(edge.from_key.as_ref().into()));\n        params.insert(\"to_key\".to_string(), DataValue::Str(edge.to_key.as_ref().into()));\n        params.insert(\"edge_type\".to_string(), DataValue::Str(edge.edge_type.as_str().into()));\n        params.insert(\n            \"source_location\".to_string(),\n            edge.source_location\n                .as_ref()\n                .map(|s| DataValue::Str(s.as_str().into()))\n                .unwrap_or(DataValue::Null),\n        );\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edge\".to_string(),\n                reason: format!(\"Failed to insert dependency edge: {}\", e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "insert_edge",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"insert_edge\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":155,\"end\":186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:insert_edge:__crates_parseltongue-core_src_storage_cozo_client_rs:155-186",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn insert_edges_batch(&self, edges: &[DependencyEdge]) -> Result<()> {\n        if edges.is_empty() {\n            return Ok(());\n        }\n\n        // Build query with inline data for batch insert\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type, source_location] <- [{}]\n\n            :put DependencyEdges {{\n                from_key, to_key, edge_type =>\n                source_location\n            }}\n            \"#,\n            edges\n                .iter()\n                .map(|edge| {\n                    let source_loc = edge\n                        .source_location\n                        .as_ref()\n                        .map(|s| format!(\"'{}'\", s.replace('\\'', \"\\\\'\")))\n                        .unwrap_or_else(|| \"null\".to_string());\n\n                    format!(\n                        \"['{}', '{}', '{}', {}]\",\n                        edge.from_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.to_key.as_ref().replace('\\'', \"\\\\'\"),\n                        edge.edge_type.as_str(),\n                        source_loc\n                    )\n                })\n                .collect::<Vec<_>>()\n                .join(\", \")\n        );\n\n        self.db\n            .run_script(&query, Default::default(), ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DependencyError {\n                operation: \"insert_edges_batch\".to_string(),\n                reason: format!(\"Failed to batch insert {} edges: {}\", edges.len(), e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "insert_edges_batch",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"insert_edges_batch\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":203,\"end\":247},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:insert_edges_batch:__crates_parseltongue-core_src_storage_cozo_client_rs:203-247",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn insert_entity(&self, entity: &CodeEntity) -> Result<()> {\n        let query = r#\"\n            ?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type, entity_class] <-\n            [[$ISGL1_key, $Current_Code, $Future_Code, $interface_signature, $TDD_Classification,\n              $lsp_meta_data, $current_ind, $future_ind, $Future_Action, $file_path, $language,\n              $last_modified, $entity_type, $entity_class]]\n\n            :put CodeGraph {\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type, entity_class\n            }\n        \"#;\n\n        let params = self.entity_to_params(entity)?;\n\n        self.db\n            .run_script(query, params, ScriptMutability::Mutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"insert_entity\".to_string(),\n                details: format!(\"Failed to insert entity: {}\", e),\n            })?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "insert_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"insert_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":774,\"end\":801},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:insert_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:774-801",
      "line_number": 0
    },
    {
      "current_code": "    pub fn into_inner(self) -> String {\n        self.0\n    }",
      "current_ind": 1,
      "entity_name": "into_inner",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"into_inner\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":898,\"end\":900},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:into_inner:__crates_parseltongue-core_src_entities_rs:898-900",
      "line_number": 0
    },
    {
      "current_code": "    pub fn invalid(errors: Vec<String>) -> Self {\n        Self {\n            is_valid: false,\n            errors,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "invalid",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"invalid\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":165,\"end\":170},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:invalid:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:165-170",
      "line_number": 0
    },
    {
      "current_code": "    pub fn invalid_isgl1_key(key: String) -> Self {\n        Self::InvalidIsgl1Key { key }\n    }",
      "current_ind": 1,
      "entity_name": "invalid_isgl1_key",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"invalid_isgl1_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":41,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:invalid_isgl1_key:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:41-43",
      "line_number": 0
    },
    {
      "current_code": "    async fn is_available(&self) -> bool {\n        true\n    }",
      "current_ind": 1,
      "entity_name": "is_available",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_available\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":131,\"end\":133},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_available:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:131-133",
      "line_number": 0
    },
    {
      "current_code": "    async fn is_available(&self) -> bool {\n        self.enabled\n    }",
      "current_ind": 1,
      "entity_name": "is_available",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_available\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":94,\"end\":96},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_available:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:94-96",
      "line_number": 0
    },
    {
      "current_code": "    pub fn is_changed(&self) -> bool {\n        self.future_action.is_some()\n    }",
      "current_ind": 1,
      "entity_name": "is_changed",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_changed\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":239,\"end\":241},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_changed:__crates_parseltongue-core_src_entities_rs:239-241",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn is_connected(&self) -> bool {\n        // Test query to verify connection - use ::relations which always works\n        self.db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .is_ok()\n    }",
      "current_ind": 1,
      "entity_name": "is_connected",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_connected\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":57,\"end\":62},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_connected:__crates_parseltongue-core_src_storage_cozo_client_rs:57-62",
      "line_number": 0
    },
    {
      "current_code": "    pub fn is_modified(&self) -> bool {\n        self.temporal_state.is_changed()\n    }",
      "current_ind": 1,
      "entity_name": "is_modified",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_modified\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":663,\"end\":665},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_modified:__crates_parseltongue-core_src_entities_rs:663-665",
      "line_number": 0
    },
    {
      "current_code": "    fn is_under_git_subdirectory(&self, path: &Path) -> bool {\n        let root = &self.config.root_dir;\n        let mut current = path;\n\n        // Walk up parent directories looking for .git\n        while let Some(parent) = current.parent() {\n            // Stop at project root (don't exclude project root itself)\n            if parent == root {\n                break;\n            }\n            \n            // Don't go beyond project root\n            if !parent.starts_with(root) {\n                break;\n            }\n\n            // Check if this parent directory contains .git\n            if parent.join(\".git\").exists() {\n                return true; // Found nested git repo\n            }\n\n            current = parent;\n        }\n\n        false\n    }",
      "current_ind": 1,
      "entity_name": "is_under_git_subdirectory",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"is_under_git_subdirectory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":330,\"end\":355},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:is_under_git_subdirectory:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:330-355",
      "line_number": 0
    },
    {
      "current_code": "        fn level(&self) -> u8 {\n            self.level\n        }",
      "current_ind": 1,
      "entity_name": "level",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":171,\"end\":173},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:level:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:171-173",
      "line_number": 0
    },
    {
      "current_code": "    fn level(&self) -> u8 {\n        0\n    }",
      "current_ind": 1,
      "entity_name": "level",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":88,\"end\":90},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:level:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:88-90",
      "line_number": 0
    },
    {
      "current_code": "    fn level(&self) -> u8 {\n        1\n    }",
      "current_ind": 1,
      "entity_name": "level",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":177,\"end\":179},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:level:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:177-179",
      "line_number": 0
    },
    {
      "current_code": "    fn level(&self) -> u8 {\n        2\n    }",
      "current_ind": 1,
      "entity_name": "level",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"level\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":152,\"end\":154},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:level:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:152-154",
      "line_number": 0
    },
    {
      "current_code": "    pub fn line(&self) -> Option<usize> {\n        match self {\n            Self::SyntaxError { line, .. }\n            | Self::TypeError { line, .. }\n            | Self::BorrowError { line, .. } => Some(*line),\n            _ => None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "line",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"line\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":81,\"end\":88},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:line:__crates_pt04-syntax-preflight-validator_src_errors_rs:81-88",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn list_relations(&self) -> Result<Vec<String>> {\n        let result = self\n            .db\n            .run_script(\"::relations\", Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"list_relations\".to_string(),\n                details: format!(\"Failed to list relations: {}\", e),\n            })?;\n\n        let mut relations = Vec::new();\n        for row in result.rows {\n            if let Some(DataValue::Str(name)) = row.first() {\n                relations.push(name.to_string());\n            }\n        }\n\n        Ok(relations)\n    }",
      "current_ind": 1,
      "entity_name": "list_relations",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"list_relations\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":754,\"end\":771},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:list_relations:__crates_parseltongue-core_src_storage_cozo_client_rs:754-771",
      "line_number": 0
    },
    {
      "current_code": "    fn map_query_entity_type(\n        &self,\n        query_type: &parseltongue_core::query_extractor::EntityType\n    ) -> EntityType {\n        match query_type {\n            parseltongue_core::query_extractor::EntityType::Function => EntityType::Function,\n            parseltongue_core::query_extractor::EntityType::Class => EntityType::Class,\n            parseltongue_core::query_extractor::EntityType::Method => EntityType::Method,\n            parseltongue_core::query_extractor::EntityType::Struct => EntityType::Struct,\n            parseltongue_core::query_extractor::EntityType::Enum => EntityType::Enum,\n            parseltongue_core::query_extractor::EntityType::Trait => EntityType::Trait,\n            parseltongue_core::query_extractor::EntityType::Interface => EntityType::Trait,  // Map Interface to Trait (protocols, interfaces)\n            parseltongue_core::query_extractor::EntityType::Impl => EntityType::Impl,\n            parseltongue_core::query_extractor::EntityType::Module => EntityType::Module,\n            parseltongue_core::query_extractor::EntityType::Namespace => EntityType::Namespace,\n            parseltongue_core::query_extractor::EntityType::Typedef => EntityType::Typedef,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "map_query_entity_type",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"map_query_entity_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":234,\"end\":251},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:map_query_entity_type:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:234-251",
      "line_number": 0
    },
    {
      "current_code": "    fn matches_pattern(&self, path: &str, pattern: &str) -> bool {\n        if pattern.contains('*') {\n            // Simple pattern matching: check if path ends with extension\n            // TODO: Implement proper glob matching for complex patterns\n            path.contains(&pattern.replace('*', \"\")) || path == pattern\n        } else {\n            path.contains(pattern)\n        }\n    }",
      "current_ind": 1,
      "entity_name": "matches_pattern",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"matches_pattern\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":314,\"end\":322},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:matches_pattern:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:314-322",
      "line_number": 0
    },
    {
      "current_code": "        fn metadata(&self) -> ToolMetadata {\n            self.metadata.clone()\n        }",
      "current_ind": 1,
      "entity_name": "metadata",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"metadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":609,\"end\":611},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:metadata:__crates_parseltongue-core_src_interfaces_rs:609-611",
      "line_number": 0
    },
    {
      "current_code": "    async fn modify_file(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        // GREEN phase: Minimal implementation - direct overwrite\n        let file_path = self.resolve_file_path(&entity.isgl1_key)?;\n\n        let content = entity.future_code\n            .as_ref()\n            .ok_or_else(|| anyhow::anyhow!(\"Future code missing for Edit operation\"))?;\n\n        // Ultra-minimalist: Direct overwrite, NO backup\n        tokio::fs::write(&file_path, content).await?;\n\n        Ok(WriteResult::success(file_path, WriteOperation::Edit))\n    }",
      "current_ind": 1,
      "entity_name": "modify_file",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"modify_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":62,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:modify_file:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:62-74",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(\n        from_key: impl Into<String>,\n        to_key: impl Into<String>,\n        edge_type: EdgeType,\n        source_location: Option<String>,\n    ) -> Result<Self> {\n        Ok(Self {\n            from_key: Isgl1Key::new(from_key)?,\n            to_key: Isgl1Key::new(to_key)?,\n            edge_type,\n            source_location,\n        })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1014,\"end\":1026},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_entities_rs:1014-1026",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(start: u32, end: u32) -> Result<Self> {\n        if start == 0 || end == 0 {\n            return Err(ParseltongError::ValidationError {\n                field: \"line numbers\".to_string(),\n                expected: \"1-based line numbers\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        if start > end {\n            return Err(ParseltongError::ValidationError {\n                field: \"line range\".to_string(),\n                expected: \"start <= end\".to_string(),\n                actual: format!(\"start={}, end={}\", start, end),\n            });\n        }\n\n        Ok(Self { start, end })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":286,\"end\":304},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_entities_rs:286-304",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(\n        isgl1_key: String,\n        interface_signature: InterfaceSignature,\n        entity_class: EntityClass,\n    ) -> Result<Self> {\n        let entity = Self {\n            temporal_state: TemporalState::initial(),  // Tool 1 initial state: (1,0,None)\n            interface_signature,\n            current_code: None,\n            future_code: None,\n            tdd_classification: TddClassification::default(),\n            lsp_metadata: None,\n            metadata: EntityMetadata::new()?,\n            isgl1_key,\n            entity_class, // v0.9.0: mandatory classification\n        };\n\n        Ok(entity)\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":617,\"end\":635},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_entities_rs:617-635",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Result<Self> {\n        Ok(Self {\n            created_at: chrono::Utc::now(),\n            modified_at: chrono::Utc::now(),\n            content_hash: String::new(), // Will be set when content is available\n            additional: HashMap::new(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":830,\"end\":837},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_entities_rs:830-837",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(key: impl Into<String>) -> Result<Self> {\n        let key = key.into();\n        if key.is_empty() {\n            Err(ParseltongError::InvalidIsgl1Key {\n                key,\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            })\n        } else {\n            Ok(Self(key))\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":871,\"end\":881},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_entities_rs:871-881",
      "line_number": 0
    },
    {
      "current_code": "        pub fn new(name: &str) -> Self {\n            Self {\n                metadata: ToolMetadata {\n                    id: format!(\"mock-{}\", name),\n                    name: name.to_string(),\n                    version: \"1.0.0\".to_string(),\n                    description: format!(\"Mock implementation of {}\", name),\n                    supported_inputs: vec![],\n                    capabilities: ToolCapabilities {\n                        async_execution: true,\n                        parallel_processing: false,\n                        incremental_processing: false,\n                        requires_network: false,\n                        max_input_size: None,\n                    },\n                },\n                execute_result: None,\n                should_fail: false,\n            }\n        }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":549,\"end\":568},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_interfaces_rs:549-568",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Result<Self> {\n        let mut queries = HashMap::new();\n\n        // Embed query files at compile time\n        queries.insert(\n            Language::Rust,\n            include_str!(\"../../../entity_queries/rust.scm\").to_string()\n        );\n        queries.insert(\n            Language::Python,\n            include_str!(\"../../../entity_queries/python.scm\").to_string()\n        );\n        queries.insert(\n            Language::C,\n            include_str!(\"../../../entity_queries/c.scm\").to_string()\n        );\n        queries.insert(\n            Language::Cpp,\n            include_str!(\"../../../entity_queries/cpp.scm\").to_string()\n        );\n        queries.insert(\n            Language::Ruby,\n            include_str!(\"../../../entity_queries/ruby.scm\").to_string()\n        );\n        queries.insert(\n            Language::JavaScript,\n            include_str!(\"../../../entity_queries/javascript.scm\").to_string()\n        );\n        queries.insert(\n            Language::TypeScript,\n            include_str!(\"../../../entity_queries/typescript.scm\").to_string()\n        );\n        queries.insert(\n            Language::Go,\n            include_str!(\"../../../entity_queries/go.scm\").to_string()\n        );\n        queries.insert(\n            Language::Java,\n            include_str!(\"../../../entity_queries/java.scm\").to_string()\n        );\n        queries.insert(\n            Language::Php,\n            include_str!(\"../../../entity_queries/php.scm\").to_string()\n        );\n        queries.insert(\n            Language::CSharp,\n            include_str!(\"../../../entity_queries/c_sharp.scm\").to_string()\n        );\n        queries.insert(\n            Language::Swift,\n            include_str!(\"../../../entity_queries/swift.scm\").to_string()\n        );\n        // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility (0.20 vs 0.25)\n        // queries.insert(\n        //     Language::Kotlin,\n        //     include_str!(\"../../../entity_queries/kotlin.scm\").to_string()\n        // );\n\n        // Initialize parsers\n        let mut parsers = HashMap::new();\n        Self::init_parser(&mut parsers, Language::Rust, &tree_sitter_rust::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Python, &tree_sitter_python::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::C, &tree_sitter_c::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Cpp, &tree_sitter_cpp::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Ruby, &tree_sitter_ruby::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into())?;\n        Self::init_parser(&mut parsers, Language::Go, &tree_sitter_go::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Java, &tree_sitter_java::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Php, &tree_sitter_php::LANGUAGE_PHP.into())?;\n        Self::init_parser(&mut parsers, Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into())?;\n        Self::init_parser(&mut parsers, Language::Swift, &tree_sitter_swift::LANGUAGE.into())?;\n        // NOTE: Kotlin temporarily disabled due to tree-sitter version incompatibility\n        // Self::init_parser(&mut parsers, Language::Kotlin, &tree_sitter_kotlin::language())?;\n\n        // v0.9.0: Load dependency query files for ALL languages\n        let mut dependency_queries = HashMap::new();\n        dependency_queries.insert(\n            Language::Rust,\n            include_str!(\"../../../dependency_queries/rust.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Python,\n            include_str!(\"../../../dependency_queries/python.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::JavaScript,\n            include_str!(\"../../../dependency_queries/javascript.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::TypeScript,\n            include_str!(\"../../../dependency_queries/typescript.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Go,\n            include_str!(\"../../../dependency_queries/go.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Java,\n            include_str!(\"../../../dependency_queries/java.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::C,\n            include_str!(\"../../../dependency_queries/c.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Cpp,\n            include_str!(\"../../../dependency_queries/cpp.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Ruby,\n            include_str!(\"../../../dependency_queries/ruby.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Php,\n            include_str!(\"../../../dependency_queries/php.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::CSharp,\n            include_str!(\"../../../dependency_queries/c_sharp.scm\").to_string()\n        );\n        dependency_queries.insert(\n            Language::Swift,\n            include_str!(\"../../../dependency_queries/swift.scm\").to_string()\n        );\n\n        Ok(Self { queries, dependency_queries, parsers })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":84,\"end\":211},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_query_extractor_rs:84-211",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn new(engine_spec: &str) -> Result<Self> {\n        // Parse engine specification: \"engine:path\" or just \"engine\" (for mem)\n        let (engine, path) = if engine_spec.contains(':') {\n            let parts: Vec<&str> = engine_spec.splitn(2, ':').collect();\n            (parts[0], parts[1])\n        } else {\n            (engine_spec, \"\")\n        };\n\n        let db = DbInstance::new(engine, path, Default::default())\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"connection\".to_string(),\n                details: format!(\"Failed to create CozoDB instance with engine '{}' and path '{}': {}\", engine, path, e),\n            })?;\n\n        Ok(Self { db })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":38,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_storage_cozo_client_rs:38-54",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":277,\"end\":279},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:277-279",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self {\n            entities: HashMap::new(),\n            pending_changes: Vec::new(),\n            validation_rules: vec![\n                Box::new(NoCircularDependenciesRule::new()),\n                Box::new(ConsistentStateRule::new()),\n                Box::new(ValidTransitionsRule::new()),\n            ],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":29,\"end\":39},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:29-39",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":319,\"end\":321},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:319-321",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self { _private: () }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":367,\"end\":369},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:367-369",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(isgl1_key: String) -> Self {\n        Self {\n            isgl1_key,\n            action: None,\n            future_code: None,\n            updated_signature: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":407,\"end\":414},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:407-414",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(strategy: ConflictResolutionStrategy) -> Self {\n        Self { strategy }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":470,\"end\":472},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_parseltongue-core_src_temporal_rs:470-472",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        let mut parsers = HashMap::new();\n\n        // Helper macro to initialize parser for a language\n        macro_rules! init_parser {\n            ($lang:expr, $grammar:expr) => {\n                let mut parser = Parser::new();\n                if parser.set_language($grammar).is_ok() {\n                    parsers.insert($lang, Arc::new(Mutex::new(parser)));\n                }\n            };\n        }\n\n        // Initialize all language parsers\n        // LanguageFn must be converted to Language using .into() for tree-sitter 0.24+\n        init_parser!(Language::Rust, &tree_sitter_rust::LANGUAGE.into());\n        init_parser!(Language::Python, &tree_sitter_python::LANGUAGE.into());\n        init_parser!(Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into());\n        init_parser!(Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into());\n        init_parser!(Language::Go, &tree_sitter_go::LANGUAGE.into());\n        init_parser!(Language::Java, &tree_sitter_java::LANGUAGE.into());\n        init_parser!(Language::Cpp, &tree_sitter_cpp::LANGUAGE.into());\n        init_parser!(Language::Ruby, &tree_sitter_ruby::LANGUAGE.into());\n        init_parser!(Language::Php, &tree_sitter_php::LANGUAGE_PHP.into());\n        init_parser!(Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into());\n        init_parser!(Language::Swift, &tree_sitter_swift::LANGUAGE.into());\n        // Note: Kotlin not supported in v0.8.7 - tree-sitter-kotlin v0.3 uses incompatible tree-sitter 0.20\n        // Will be added when tree-sitter-kotlin updates to 0.24+\n        init_parser!(Language::Scala, &tree_sitter_scala::LANGUAGE.into());\n\n        // v0.8.9: Initialize QueryBasedExtractor for multi-language entity extraction\n        let query_extractor = QueryBasedExtractor::new()\n            .expect(\"Failed to initialize QueryBasedExtractor - .scm query files missing\");\n\n        Self {\n            parsers,\n            query_extractor: Mutex::new(query_extractor),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":108,\"end\":146},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:108-146",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Arc<dyn Isgl1KeyGenerator> {\n        Arc::new(Isgl1KeyGeneratorImpl::new())\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":392,\"end\":394},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:392-394",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self {\n            responses: std::collections::HashMap::new(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":107,\"end\":111},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:107-111",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn new() -> Self {\n        // TODO: Implement actual LSP process spawning\n        // For now, stub implementation\n        Self { enabled: false }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":70,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:70-74",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn new(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        test_detector: Arc<dyn TestDetector>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        // Initialize LSP client (graceful degradation if unavailable)\n        let lsp_client = RustAnalyzerClientImpl::new().await;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client: Arc::new(lsp_client),\n            test_detector,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":75,\"end\":105},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:75-105",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":29,\"end\":31},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:29-31",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":28,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:28-30",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":30,\"end\":32},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:30-32",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":52,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:52-54",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":49,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:49-51",
      "line_number": 0
    },
    {
      "current_code": "    fn new() -> Self {\n        Self {\n            edges: vec![],\n            entities: vec![],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":38,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:38-43",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Result<Self> {\n        let mut parsers = HashMap::new();\n\n        // Helper macro to initialize parser for a language\n        macro_rules! init_parser {\n            ($lang:expr, $grammar:expr) => {\n                let mut parser = Parser::new();\n                if parser.set_language($grammar).is_ok() {\n                    parsers.insert($lang, parser);\n                }\n            };\n        }\n\n        // Initialize all language parsers\n        // LanguageFn must be converted to Language using .into() for tree-sitter 0.22+\n        init_parser!(Language::Rust, &tree_sitter_rust::LANGUAGE.into());\n        init_parser!(Language::Python, &tree_sitter_python::LANGUAGE.into());\n        init_parser!(Language::JavaScript, &tree_sitter_javascript::LANGUAGE.into());\n        init_parser!(Language::TypeScript, &tree_sitter_typescript::LANGUAGE_TYPESCRIPT.into());\n        init_parser!(Language::Go, &tree_sitter_go::LANGUAGE.into());\n        init_parser!(Language::Java, &tree_sitter_java::LANGUAGE.into());\n        init_parser!(Language::Cpp, &tree_sitter_cpp::LANGUAGE.into());\n        init_parser!(Language::Ruby, &tree_sitter_ruby::LANGUAGE.into());\n        init_parser!(Language::Php, &tree_sitter_php::LANGUAGE_PHP.into());\n        init_parser!(Language::CSharp, &tree_sitter_c_sharp::LANGUAGE.into());\n        init_parser!(Language::Swift, &tree_sitter_swift::LANGUAGE.into());\n        // Note: Kotlin not supported in v0.8.7 - tree-sitter-kotlin v0.3 uses incompatible tree-sitter 0.20\n        init_parser!(Language::Scala, &tree_sitter_scala::LANGUAGE.into());\n\n        Ok(Self { parsers })\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":48,\"end\":78},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:48-78",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(file_path: Option<PathBuf>, code_snippet: String) -> Self {\n        Self {\n            file_path,\n            code_snippet,\n            individual_results: Vec::new(),\n            overall_valid: true,\n            total_execution_time_ms: 0,\n            total_memory_usage_bytes: 0,\n            generated_at: Utc::now(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":117,\"end\":127},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt04-syntax-preflight-validator_src_types_rs:117-127",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":79,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt04-syntax-preflight-validator_src_validator_rs:79-81",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(storage: Arc<CozoDbStorage>) -> Self {\n        Self { storage }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":55,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:55-57",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self {\n            changes: Vec::new(),\n            metadata: DiffMetadata {\n                total_changes: 0,\n                create_count: 0,\n                edit_count: 0,\n                delete_count: 0,\n                generated_at: chrono::Utc::now().to_rfc3339(),\n            },\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":131,\"end\":142},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:131-142",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new() -> Self {\n        Self {\n            created: 0,\n            edited: 0,\n            deleted: 0,\n            total: 0,\n            errors: 0,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":75,\"end\":83},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:75-83",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(root_path: PathBuf) -> Self {\n        Self { root_path }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":21,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:21-23",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new(storage: CozoDbStorage) -> Self {\n        Self { storage }\n    }",
      "current_ind": 1,
      "entity_name": "new",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":16,\"end\":18},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:16-18",
      "line_number": 0
    },
    {
      "current_code": "    pub fn new_unchecked(key: impl Into<String>) -> Self {\n        Self(key.into())\n    }",
      "current_ind": 1,
      "entity_name": "new_unchecked",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new_unchecked\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":888,\"end\":890},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new_unchecked:__crates_parseltongue-core_src_entities_rs:888-890",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn new_with_lsp(\n        config: StreamerConfig,\n        key_generator: Arc<dyn Isgl1KeyGenerator>,\n        lsp_client: Arc<dyn RustAnalyzerClient>,\n        test_detector: Arc<dyn TestDetector>,\n    ) -> Result<Self> {\n        // Initialize database connection\n        let db = CozoDbStorage::new(&config.db_path)\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create database: {}\", e),\n            })?;\n\n        // Create schema\n        db.create_schema()\n            .await\n            .map_err(|e| StreamerError::StorageError {\n                details: format!(\"Failed to create schema: {}\", e),\n            })?;\n\n        Ok(Self {\n            config,\n            key_generator,\n            lsp_client,\n            test_detector,\n            db: Arc::new(db),\n            stats: std::sync::Mutex::new(StreamStats::default()),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "new_with_lsp",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"new_with_lsp\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":109,\"end\":137},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:new_with_lsp:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:109-137",
      "line_number": 0
    },
    {
      "current_code": "    pub fn no_op() -> Self {\n        Self {\n            success: true,\n            file_path: PathBuf::new(),\n            operation: WriteOperation::NoOp,\n            message: Some(\"No operation required\".to_string()),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "no_op",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"no_op\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":29,\"end\":36},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:no_op:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:29-36",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, U> {\n            let (result, rest) = self.parser.parse(input)?;\n            Ok((self.mapper)(result), rest))\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1199,\"end\":1202},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1199-1202",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, (T1, T2)> {\n            let (result1, rest1) = self.first.parse(input)?;\n            let (result2, rest2) = self.second.parse(rest1)?;\n            Ok(((result1, result2), rest2))\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1216,\"end\":1220},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1216-1220",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, T> {\n            self.first.parse(input).or_else(|_| self.second.parse(input))\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1234,\"end\":1236},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1234-1236",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, Option<T>> {\n            match self.parser.parse(input) {\n                Ok((result, rest)) => Ok((Some(result), rest)),\n                Err(_) => Ok((None, input)),\n            }\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1248,\"end\":1253},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1248-1253",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {\n            let mut results = Vec::new();\n            let mut rest = input;\n            \n            while let Ok((result, new_rest)) = self.parser.parse(rest) {\n                results.push(result);\n                rest = new_rest;\n            }\n            \n            Ok((results, rest))\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1265,\"end\":1275},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1265-1275",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {\n            let (first, mut rest) = self.parser.parse(input)?;\n            let mut results = vec![first];\n            \n            while let Ok((result, new_rest)) = self.parser.parse(rest) {\n                results.push(result);\n                rest = new_rest;\n            }\n            \n            Ok((results, rest))\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1287,\"end\":1297},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1287-1297",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {\n            if input.starts_with(self.expected) {\n                Ok((self.expected, &input[self.expected.len()..]))\n            } else {\n                Err(ParseError::Unexpected {\n                    expected: self.expected.to_string(),\n                    found: input.chars().next().map(|c| c.to_string()).unwrap_or_default(),\n                })\n            }\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1310,\"end\":1319},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1310-1319",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {\n            let end = input\n                .char_indices()\n                .find(|(i, c)| {\n                    if *i == 0 {\n                        !c.is_alphabetic() && *c != '_'\n                    } else {\n                        !c.is_alphanumeric() && *c != '_'\n                    }\n                })\n                .map(|(i, _)| i)\n                .unwrap_or(input.len());\n            \n            if end == 0 {\n                Err(ParseError::Failed(\"Expected identifier\".to_string()))\n            } else {\n                Ok((&input[..end], &input[end..]))\n            }\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1330,\"end\":1348},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1330-1348",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Stub implementation\n            Ok(TestAst { nodes: vec![] })\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1426,\"end\":1429},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1426-1429",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Implementation following Option 1, 2, or 3 from design doc\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":335,\"end\":338},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:335-338",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":587,\"end\":589},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:587-589",
      "line_number": 0
    },
    {
      "current_code": "        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":859,\"end\":861},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:859-861",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
      "current_ind": 1,
      "entity_name": "parse_args",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_args\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":55,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_args:__crates_pt04-syntax-preflight-validator_src_cli_rs:55-57",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
      "current_ind": 1,
      "entity_name": "parse_args",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_args\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs\",\"line_range\":{\"start\":27,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_args:__crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:27-29",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_args() -> Self {\n        Self::parse()\n    }",
      "current_ind": 1,
      "entity_name": "parse_args",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_args\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/cli.rs\",\"line_range\":{\"start\":27,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_args:__crates_pt06-cozodb-make-future-code-current_src_cli_rs:27-29",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> StreamerConfig {\n        // Start with default exclusion patterns\n        let mut exclude_patterns = vec![\n            \"target\".to_string(),      // Rust build\n            \"node_modules\".to_string(), // Node.js dependencies\n            \".git\".to_string(),        // Git metadata\n            \"build\".to_string(),       // Generic build dir\n            \"dist\".to_string(),        // Distribution files\n            \"__pycache__\".to_string(), // Python cache\n            \".venv\".to_string(),       // Python virtual env\n            \"venv\".to_string(),        // Python virtual env\n        ];\n        \n        // Add user-specified exclusion patterns (if any)\n        if let Some(user_excludes) = matches.get_many::<String>(\"exclude\") {\n            for pattern in user_excludes {\n                exclude_patterns.push(pattern.clone());\n            }\n        }\n        \n        StreamerConfig {\n            root_dir: PathBuf::from(matches.get_one::<String>(\"directory\").unwrap()),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n            // Hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n            max_file_size: 100 * 1024 * 1024,  // 100MB - let tree-sitter decide\n            include_patterns: vec![\"*\".to_string()],  // ALL files - tree-sitter handles it\n            exclude_patterns,\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "parse_config",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":92,\"end\":122},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_config:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:92-122",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_config(matches: &clap::ArgMatches) -> LlmWriterConfig {\n        LlmWriterConfig {\n            query: matches.get_one::<String>(\"query\").unwrap().clone(),\n            db_path: matches.get_one::<String>(\"database\").unwrap().clone(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "parse_config",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_config\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":127,\"end\":132},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_config:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:127-132",
      "line_number": 0
    },
    {
      "current_code": "    fn parse_entity_type(&self, capture_name: &str) -> Option<EntityType> {\n        match capture_name {\n            \"definition.function\" => Some(EntityType::Function),\n            \"definition.struct\" => Some(EntityType::Struct),\n            \"definition.class\" => Some(EntityType::Class),\n            \"definition.enum\" => Some(EntityType::Enum),\n            \"definition.trait\" => Some(EntityType::Trait),\n            \"definition.interface\" => Some(EntityType::Interface),\n            \"definition.impl\" => Some(EntityType::Impl),\n            \"definition.module\" => Some(EntityType::Module),\n            \"definition.method\" => Some(EntityType::Method),\n            \"definition.typedef\" => Some(EntityType::Typedef),\n            \"definition.namespace\" => Some(EntityType::Namespace),\n            _ => None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "parse_entity_type",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_entity_type\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":364,\"end\":379},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_entity_type:__crates_parseltongue-core_src_query_extractor_rs:364-379",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_interface_mode(matches: &clap::ArgMatches) -> InterfaceMode {\n        let db_path = matches\n            .get_one::<String>(\"database\")\n            .unwrap()\n            .clone();\n\n        // Check which interface mode\n        if let Some(entity_key) = matches.get_one::<String>(\"entity\") {\n            // Simple Interface\n            let action_str = matches.get_one::<String>(\"action\").unwrap();\n            let action = match action_str.as_str() {\n                \"create\" => EntityAction::Create,\n                \"edit\" => EntityAction::Edit,\n                \"delete\" => EntityAction::Delete,\n                _ => unreachable!(\"clap validates this\"),\n            };\n\n            let future_code = matches.get_one::<String>(\"future-code\").cloned();\n\n            InterfaceMode::Simple(SimpleUpdateConfig {\n                entity_key: entity_key.clone(),\n                action,\n                future_code,\n                db_path,\n            })\n        } else {\n            // Advanced Interface\n            let query = matches.get_one::<String>(\"query\").unwrap().clone();\n            InterfaceMode::Advanced(AdvancedQueryConfig { query, db_path })\n        }\n    }",
      "current_ind": 1,
      "entity_name": "parse_interface_mode",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_interface_mode\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":137,\"end\":167},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_interface_mode:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:137-167",
      "line_number": 0
    },
    {
      "current_code": "    pub fn parse_source(\n        &mut self,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n    ) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        // Get parser\n        let parser = self.parsers.get_mut(&language)\n            .context(format!(\"No parser for language {:?}\", language))?;\n\n        // Parse tree\n        let tree = parser.parse(source, None)\n            .context(\"Failed to parse source\")?;\n\n        // Get entity query\n        let query_source = self.queries.get(&language)\n            .context(format!(\"No query for language {:?}\", language))?;\n\n        // Execute entity query\n        let entities = self.execute_query(&tree, source, file_path, language, query_source)?;\n\n        // v0.9.0: Execute dependency query if available\n        let dependencies = if let Some(dep_query_source) = self.dependency_queries.get(&language) {\n            self.execute_dependency_query(&tree, source, file_path, language, dep_query_source, &entities)?\n        } else {\n            // Graceful degradation: if no dependency query, return empty vec\n            vec![]\n        };\n\n        Ok((entities, dependencies))\n    }",
      "current_ind": 1,
      "entity_name": "parse_source",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_source\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":260,\"end\":290},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_source:__crates_parseltongue-core_src_query_extractor_rs:260-290",
      "line_number": 0
    },
    {
      "current_code": "    fn parse_source(&self, source: &str, file_path: &Path) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)> {\n        let language_type = self.get_language_type(file_path)?;\n\n        let parser_mutex = self.parsers.get(&language_type)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: format!(\"No parser available for language: {:?}\", language_type),\n            })?;\n\n        let mut parser = parser_mutex.lock().unwrap();\n        let tree = parser\n            .parse(source, None)\n            .ok_or_else(|| StreamerError::ParsingError {\n                file: file_path.to_string_lossy().to_string(),\n                reason: \"Failed to parse source code\".to_string(),\n            })?;\n\n        let mut entities = Vec::new();\n        let mut dependencies = Vec::new();\n        self.extract_entities(&tree, source, file_path, language_type, &mut entities, &mut dependencies);\n\n        Ok((entities, dependencies))\n    }",
      "current_ind": 1,
      "entity_name": "parse_source",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_source\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":186,\"end\":208},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_source:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:186-208",
      "line_number": 0
    },
    {
      "current_code": "        fn parse_with_config(&self, _input: Self::Input, _config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            Ok(TestAst { nodes: vec![] })\n        }",
      "current_ind": 1,
      "entity_name": "parse_with_config",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_with_config\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1431,\"end\":1434},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_with_config:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1431-1434",
      "line_number": 0
    },
    {
      "current_code": "        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse_with_config",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_with_config\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":340,\"end\":343},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_with_config:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:340-343",
      "line_number": 0
    },
    {
      "current_code": "        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse_with_config",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_with_config\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":591,\"end\":594},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_with_config:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:591-594",
      "line_number": 0
    },
    {
      "current_code": "        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }",
      "current_ind": 1,
      "entity_name": "parse_with_config",
      "entity_type": "method",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parse_with_config\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":863,\"end\":866},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parse_with_config:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:863-866",
      "line_number": 0
    },
    {
      "current_code": "    fn parsed_entity_to_code_entity(\n        &self,\n        parsed: &ParsedEntity,\n        isgl1_key: &str,\n        source_code: &str,\n        file_path: &Path,\n    ) -> std::result::Result<CodeEntity, parseltongue_core::error::ParseltongError> {\n        // Create InterfaceSignature\n        let interface_signature = InterfaceSignature {\n            entity_type: self.convert_entity_type(&parsed.entity_type),\n            name: parsed.name.clone(),\n            visibility: Visibility::Public, // Default to public for now\n            file_path: PathBuf::from(&parsed.file_path),\n            line_range: LineRange::new(parsed.line_range.0 as u32, parsed.line_range.1 as u32)?,\n            module_path: vec![], // TODO: Extract from file path\n            documentation: None,\n            language_specific: self.create_language_signature(&parsed.language),\n        };\n\n        // Create CodeEntity with temporal state initialized to \"unchanged\" (current=true, future=true, action=none)\n        // v0.9.0: Include EntityClass classification using test_detector\n        let local_entity_class = self.test_detector.detect_test_from_path_and_name(\n            file_path, \n            &parsed.name\n        );\n        \n        // Convert from local EntityClass to parseltongue_core EntityClass\n        let entity_class = match local_entity_class {\n            EntityClass::Test => parseltongue_core::EntityClass::TestImplementation,\n            EntityClass::Code => parseltongue_core::EntityClass::CodeImplementation,\n        };\n        \n        let mut entity = CodeEntity::new(isgl1_key.to_string(), interface_signature, entity_class)?;\n\n        // Extract the code snippet from the source\n        let code_snippet = self.extract_code_snippet(source_code, parsed.line_range.0, parsed.line_range.1);\n\n        // Set current_code and future_code to the same value (unchanged state)\n        entity.current_code = Some(code_snippet.clone());\n        entity.future_code = Some(code_snippet);\n\n        // GREEN Phase: Apply TDD classification based on parsed metadata\n        entity.tdd_classification = self.classify_entity(parsed);\n\n        Ok(entity)\n    }",
      "current_ind": 1,
      "entity_name": "parsed_entity_to_code_entity",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"parsed_entity_to_code_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":140,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:parsed_entity_to_code_entity:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:140-185",
      "line_number": 0
    },
    {
      "current_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
      "current_ind": 1,
      "entity_name": "print_usage",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"print_usage\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":125,\"end\":129},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:print_usage:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:125-129",
      "line_number": 0
    },
    {
      "current_code": "    pub fn print_usage() {\n        let mut cli = Self::build_cli();\n        cli.print_help().unwrap();\n        println!();\n    }",
      "current_ind": 1,
      "entity_name": "print_usage",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"print_usage\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":170,\"end\":174},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:print_usage:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:170-174",
      "line_number": 0
    },
    {
      "current_code": "    pub fn print_version() {\n        println!(\"parseltongue-01 version 0.7.1\");\n    }",
      "current_ind": 1,
      "entity_name": "print_version",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"print_version\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":132,\"end\":134},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:print_version:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:132-134",
      "line_number": 0
    },
    {
      "current_code": "    pub fn print_version() {\n        println!(\"parseltongue-02 version 0.7.1\");\n    }",
      "current_ind": 1,
      "entity_name": "print_version",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"print_version\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":177,\"end\":179},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:print_version:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:177-179",
      "line_number": 0
    },
    {
      "current_code": "    fn process_dependency_match<'a>(\n        &self,\n        m: &tree_sitter::QueryMatch<'a, 'a>,\n        query: &Query,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n        entities: &[ParsedEntity],\n    ) -> Option<DependencyEdge> {\n        let mut dependency_type = None;\n        let mut from_entity = None;\n        let mut to_name = None;\n        let mut location = None;\n\n        // Parse captures to identify relationship type and participants\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n            let node = capture.node;\n            let node_text = &source[node.byte_range()];\n\n            // Identify dependency type\n            if capture_name.starts_with(\"dependency.\") {\n                location = Some(format!(\"{}:{}\", file_path.display(), node.start_position().row + 1));\n\n                if capture_name.contains(\"call\") || capture_name.contains(\"method_call\") {\n                    dependency_type = Some(EdgeType::Calls);\n                    // For calls, find containing function\n                    from_entity = self.find_containing_entity(node, entities);\n                } else if capture_name.contains(\"use\") || capture_name.contains(\"import\") || capture_name.contains(\"type_ref\") {\n                    dependency_type = Some(EdgeType::Uses);\n                } else if capture_name.contains(\"implement\") || capture_name.contains(\"inherits\") {\n                    dependency_type = Some(EdgeType::Implements);\n                }\n            }\n\n            // Extract reference name (what is being called/used/implemented)\n            if capture_name.starts_with(\"reference.\") {\n                to_name = Some(node_text.to_string());\n            }\n\n            // Extract definition name (for impl blocks)\n            if capture_name.starts_with(\"definition.impl\") {\n                from_entity = entities.iter().find(|e| {\n                    e.name == node_text && e.line_range.0 <= node.start_position().row + 1\n                        && e.line_range.1 >= node.end_position().row + 1\n                });\n            }\n        }\n\n        // Build DependencyEdge if we have enough information\n        if let (Some(edge_type), Some(to)) = (dependency_type, to_name) {\n            // For Uses edges (imports, use declarations), create simplified keys\n            if edge_type == EdgeType::Uses {\n                let from_key = format!(\"{}:file:{}:1-1\", language, file_path.display());\n                let to_key = format!(\"{}:module:{}:0-0\", language, to);\n\n                return DependencyEdge::builder()\n                    .from_key(from_key)\n                    .to_key(to_key)\n                    .edge_type(edge_type)\n                    .source_location(location.unwrap_or_default())\n                    .build()\n                    .ok();\n            }\n\n            // For Calls and Implements, we need a from_entity\n            if let Some(from) = from_entity {\n                let from_key = format!(\n                    \"{}:{}:{}:{}:{}-{}\",\n                    language,\n                    self.entity_type_to_key_component(&from.entity_type),\n                    from.name,\n                    from.file_path,\n                    from.line_range.0,\n                    from.line_range.1\n                );\n\n                let to_key = format!(\n                    \"{}:fn:{}:unknown:0-0\",\n                    language,\n                    to\n                );\n\n                return DependencyEdge::builder()\n                    .from_key(from_key)\n                    .to_key(to_key)\n                    .edge_type(edge_type)\n                    .source_location(location.unwrap_or_default())\n                    .build()\n                    .ok();\n            }\n        }\n\n        None\n    }",
      "current_ind": 1,
      "entity_name": "process_dependency_match",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"process_dependency_match\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":435,\"end\":529},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:process_dependency_match:__crates_parseltongue-core_src_query_extractor_rs:435-529",
      "line_number": 0
    },
    {
      "current_code": "    fn process_match<'a>(\n        &self,\n        m: &tree_sitter::QueryMatch<'a, 'a>,\n        query: &Query,\n        source: &str,\n        file_path: &Path,\n        language: Language,\n    ) -> Option<ParsedEntity> {\n        let mut entity_name = None;\n        let mut entity_type = None;\n        let mut node = None;\n\n        for capture in m.captures {\n            let capture_name = &query.capture_names()[capture.index as usize];\n\n            if *capture_name == \"name\" {\n                entity_name = Some(source[capture.node.byte_range()].to_string());\n            } else if capture_name.starts_with(\"definition.\") {\n                entity_type = self.parse_entity_type(capture_name);\n                node = Some(capture.node);\n            }\n        }\n\n        if let (Some(name), Some(entity_type), Some(node)) = (entity_name, entity_type, node) {\n            Some(ParsedEntity {\n                entity_type,\n                name,\n                language,\n                line_range: (\n                    node.start_position().row + 1,\n                    node.end_position().row + 1,\n                ),\n                file_path: file_path.to_string_lossy().to_string(),\n                metadata: HashMap::new(),\n            })\n        } else {\n            None\n        }\n    }",
      "current_ind": 1,
      "entity_name": "process_match",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"process_match\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":324,\"end\":362},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:process_match:__crates_parseltongue-core_src_query_extractor_rs:324-362",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        if where_clause == \"ALL\" {\n            return self.get_all_edges().await;\n        }\n\n        // Build Datalog query with WHERE clause\n        let query = format!(\n            r#\"\n            ?[from_key, to_key, edge_type] :=\n            *DependencyEdges{{from_key, to_key, edge_type}},\n            {}\n            \"#,\n            where_clause\n        );\n\n        let result = self.storage.raw_query(&query).await\n            .map_err(|e| anyhow!(\"Failed to query edges with WHERE clause: {}\", e))?;\n\n        let edges = parse_edges_from_query_result(&result)?;\n        Ok(edges)\n    }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":118,\"end\":138},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:118-138",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n            if where_clause == \"ALL\" {\n                Ok(self.edges.clone())\n            } else if where_clause.contains(\"edge_type = 'depends_on'\") {\n                Ok(self.edges.iter()\n                    .filter(|e| e.edge_type == \"depends_on\")\n                    .cloned()\n                    .collect())\n            } else {\n                Ok(self.edges.clone())\n            }\n        }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":123,\"end\":134},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:123-134",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":231,\"end\":233},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:231-233",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":206,\"end\":208},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:206-208",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        if where_clause == \"ALL\" {\n            return Ok(self.edges.clone());\n        }\n\n        let filtered: Vec<Edge> = self.edges.iter()\n            .filter(|e| {\n                if where_clause.contains(\"edge_type = 'depends_on'\") {\n                    e.edge_type == \"depends_on\"\n                } else if where_clause.contains(\"edge_type = 'implements'\") {\n                    e.edge_type == \"implements\"\n                } else {\n                    true\n                }\n            })\n            .cloned()\n            .collect();\n\n        Ok(filtered)\n    }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":194,\"end\":213},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:194-213",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n        // Simple filter implementation for testing\n        if where_clause == \"ALL\" {\n            Ok(self.edges.clone())\n        } else if where_clause.contains(\"edge_type = 'depends_on'\") {\n            Ok(self.edges.iter()\n                .filter(|e| e.edge_type == \"depends_on\")\n                .cloned()\n                .collect())\n        } else {\n            Ok(self.edges.clone())\n        }\n    }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":68,\"end\":80},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:68-80",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_edges(&self, _where_clause: &str) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":76,\"end\":78},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:76-78",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_edges(&self, _where_clause: &str) -> Result<Vec<Edge>> {\n        Ok(vec![])\n    }",
      "current_ind": 1,
      "entity_name": "query_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":62,\"end\":64},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:62-64",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, _query: &TemporalQuery) -> Result<Vec<CodeEntity>> {\n        // Simplified implementation for MVP\n        // Full query support to be added later\n        Ok(Vec::new())\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1291,\"end\":1295},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_parseltongue-core_src_storage_cozo_client_rs:1291-1295",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            return self.get_all_entities().await;\n        }\n\n        // Build Datalog query with WHERE clause\n        let query = format!(\n            r#\"\n            ?[ISGL1_key, interface_signature, entity_type, file_path,\n              Current_Code, Future_Code, current_ind, future_ind, Future_Action, entity_class] :=\n            *CodeGraph{{\n                ISGL1_key,\n                interface_signature,\n                entity_type,\n                file_path,\n                Current_Code,\n                Future_Code,\n                current_ind,\n                future_ind,\n                Future_Action,\n                entity_class\n            }},\n            {}\n            \"#,\n            where_clause\n        );\n\n        let result = self.storage.raw_query(&query).await\n            .map_err(|e| anyhow!(\"Failed to query entities with WHERE clause: {}\", e))?;\n\n        let entities = parse_entities_from_query_result(&result)?;\n        Ok(entities)\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":70,\"end\":102},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:70-102",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_entities(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":115,\"end\":117},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:115-117",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else if where_clause.contains(\"future_action != null\") {\n                        e.future_action.is_some()\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":204,\"end\":225},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:204-225",
      "line_number": 0
    },
    {
      "current_code": "        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_async = true\") {\n                        e.is_async == Some(true)\n                    } else if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":179,\"end\":200},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:179-200",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            return Ok(self.entities.clone());\n        }\n\n        // Simulate Datalog filtering\n        let filtered: Vec<Entity> = self.entities.iter()\n            .filter(|e| {\n                // Parse simple Datalog clauses\n                if where_clause.contains(\"is_public = true\") {\n                    e.is_public == Some(true)\n                } else if where_clause.contains(\"is_async = true\") {\n                    e.is_async == Some(true)\n                } else if where_clause.contains(\"entity_type = 'fn'\") {\n                    e.entity_type == \"fn\"\n                } else if where_clause.contains(\"future_action != null\") {\n                    e.future_action.is_some()\n                } else {\n                    true\n                }\n            })\n            .cloned()\n            .collect();\n\n        Ok(filtered)\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":163,\"end\":188},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:163-188",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, _where_clause: &str) -> Result<Vec<Entity>> {\n        // Simple filter implementation for testing\n        Ok(self.entities.clone())\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":59,\"end\":62},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:59-62",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            Ok(self.entities.clone())\n        } else if where_clause.contains(\"is_public = true\") {\n            Ok(self.entities.iter()\n                .filter(|e| e.is_public == Some(true))\n                .cloned()\n                .collect())\n        } else if where_clause.contains(\"future_action != null\") {\n            Ok(self.entities.iter()\n                .filter(|e| e.future_action.is_some())\n                .cloned()\n                .collect())\n        } else {\n            Ok(self.entities.clone())\n        }\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":54,\"end\":70},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:54-70",
      "line_number": 0
    },
    {
      "current_code": "    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n        if where_clause == \"ALL\" {\n            Ok(self.entities.clone())\n        } else {\n            Ok(self.entities.clone())\n        }\n    }",
      "current_ind": 1,
      "entity_name": "query_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"query_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":50,\"end\":56},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:query_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:50-56",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn raw_query(&self, query: &str) -> Result<cozo::NamedRows> {\n        let result = self\n            .db\n            .run_script(query, Default::default(), ScriptMutability::Immutable)\n            .map_err(|e| ParseltongError::DatabaseError {\n                operation: \"raw_query\".to_string(),\n                details: format!(\"Datalog query failed: {}\", e),\n            })?;\n        Ok(result)\n    }",
      "current_ind": 1,
      "entity_name": "raw_query",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"raw_query\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":742,\"end\":751},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:raw_query:__crates_parseltongue-core_src_storage_cozo_client_rs:742-751",
      "line_number": 0
    },
    {
      "current_code": "    async fn read_file_content(&self, file_path: &Path) -> Result<String> {\n        let metadata = fs::metadata(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        if metadata.len() as usize > self.config.max_file_size {\n            return Err(StreamerError::FileTooLarge {\n                path: file_path.to_string_lossy().to_string(),\n                size: metadata.len() as usize,\n                limit: self.config.max_file_size,\n            });\n        }\n\n        let mut content = String::new();\n        let mut file = fs::File::open(file_path).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        file.read_to_string(&mut content).await.map_err(|e| {\n            StreamerError::FileSystemError {\n                path: file_path.to_string_lossy().to_string(),\n                source: e,\n            }\n        })?;\n\n        Ok(content)\n    }",
      "current_ind": 1,
      "entity_name": "read_file_content",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"read_file_content\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":358,\"end\":390},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:read_file_content:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:358-390",
      "line_number": 0
    },
    {
      "current_code": "    async fn recreate_schema(&self) -> Result<()> {\n        // GREEN phase: Schema already exists, no need to recreate\n        // CozoDB doesn't support DROP TABLE, we just deleted all entities\n        // Schema structure remains valid\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "recreate_schema",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"recreate_schema\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":63,\"end\":68},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:recreate_schema:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:63-68",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn reset(&self, _project_path: &Path) -> Result<ResetResult> {\n        // Count entities before deletion (for reporting)\n        let entities_before = self.storage.get_all_entities().await?;\n        let entities_deleted = entities_before.len();\n\n        // Delete all entities (NO backups - ultra-minimalist)\n        self.delete_table().await?;\n\n        // Recreate schema\n        self.recreate_schema().await?;\n\n        // Note: Re-indexing (Tool 1 integration) would happen externally\n        // Tool 6 just resets the state, doesn't trigger indexing itself\n\n        Ok(ResetResult::success(entities_deleted))\n    }",
      "current_ind": 1,
      "entity_name": "reset",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"reset\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":26,\"end\":41},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:reset:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:26-41",
      "line_number": 0
    },
    {
      "current_code": "    async fn reset_temporal_state(&mut self) -> Result<()> {\n        // Get all changed entities\n        let changed = self.get_changed_entities().await?;\n\n        for entity in changed {\n            let mut updated_entity = entity.clone();\n\n            // Apply temporal changes to current state\n            match updated_entity.temporal_state.future_action {\n                Some(TemporalAction::Create) => {\n                    // New entity becomes current\n                    updated_entity.temporal_state.current_ind = true;\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Edit) => {\n                    // Apply edit\n                    updated_entity.current_code = updated_entity.future_code.clone();\n                }\n                Some(TemporalAction::Delete) => {\n                    // Delete entity\n                    self.delete_entity(&entity.isgl1_key).await?;\n                    continue;\n                }\n                None => {}\n            }\n\n            // Reset temporal indicators\n            updated_entity.temporal_state.future_ind = updated_entity.temporal_state.current_ind;\n            updated_entity.temporal_state.future_action = None;\n            updated_entity.future_code = None;\n\n            self.update_entity_internal(&updated_entity).await?;\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "reset_temporal_state",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"reset_temporal_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1301,\"end\":1336},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:reset_temporal_state:__crates_parseltongue-core_src_storage_cozo_client_rs:1301-1336",
      "line_number": 0
    },
    {
      "current_code": "    pub fn reset_temporal_state(&mut self) -> Result<usize> {\n        let mut reset_count = 0;\n\n        for entity in self.entities.values_mut() {\n            if entity.is_modified() {\n                // Apply temporal state changes\n                match &entity.temporal_state.future_action {\n                    Some(TemporalAction::Create) => {\n                        // New entity becomes current\n                        entity.temporal_state.current_ind = true;\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Edit) => {\n                        // Apply edit\n                        entity.current_code = entity.future_code.clone();\n                    }\n                    Some(TemporalAction::Delete) => {\n                        // Mark for deletion (will be removed by caller)\n                        entity.temporal_state.current_ind = false;\n                    }\n                    None => {}\n                }\n\n                // Reset temporal indicators\n                entity.temporal_state.future_ind = entity.temporal_state.current_ind;\n                entity.temporal_state.future_action = None;\n                entity.future_code = None;\n\n                reset_count += 1;\n            }\n        }\n\n        // Remove deleted entities\n        self.entities.retain(|_, entity| entity.temporal_state.current_ind);\n\n        Ok(reset_count)\n    }",
      "current_ind": 1,
      "entity_name": "reset_temporal_state",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"reset_temporal_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":85,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:reset_temporal_state:__crates_parseltongue-core_src_temporal_rs:85-121",
      "line_number": 0
    },
    {
      "current_code": "    pub fn resolve_conflicts(&self, changes: Vec<TemporalChange>) -> Result<Vec<TemporalChange>> {\n        let conflicts = self.detect_conflicts(&changes);\n\n        if conflicts.is_empty() {\n            return Ok(changes);\n        }\n\n        match self.strategy {\n            ConflictResolutionStrategy::FailFast => {\n                Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Conflicts detected: {:?}\",\n                        conflicts\n                    ),\n                })\n            }\n            ConflictResolutionStrategy::UseLatest => {\n                self.resolve_with_latest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::UseEarliest => {\n                self.resolve_with_earliest(changes, conflicts)\n            }\n            ConflictResolutionStrategy::AttemptMerge => {\n                self.attempt_merge(changes, conflicts)\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "resolve_conflicts",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"resolve_conflicts\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":500,\"end\":526},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:resolve_conflicts:__crates_parseltongue-core_src_temporal_rs:500-526",
      "line_number": 0
    },
    {
      "current_code": "    fn resolve_file_path(&self, isgl1_key: &str) -> Result<PathBuf, FileWriterError> {\n        // GREEN phase: Simple string parsing\n        // Format: filepath-filename-rs-EntityName\n        // Example: \"src-models-rs-User\"  \"src/models.rs\"\n\n        // Find last occurrence of \"-rs-\" to separate path from entity name\n        let rs_marker = \"-rs-\";\n        let pos = isgl1_key.rfind(rs_marker)\n            .ok_or_else(|| FileWriterError::invalid_isgl1_key(isgl1_key.to_string()))?;\n\n        // Extract path part (everything before \"-rs-\")\n        let path_part = &isgl1_key[..pos];\n\n        // Convert hyphens to path separators and add .rs extension\n        let file_path = path_part.replace('-', \"/\") + \".rs\";\n\n        Ok(self.root_path.join(file_path))\n    }",
      "current_ind": 1,
      "entity_name": "resolve_file_path",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"resolve_file_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":90,\"end\":107},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:resolve_file_path:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:90-107",
      "line_number": 0
    },
    {
      "current_code": "    fn resolve_with_earliest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the first change\n                for i in 1..conflicting_changes.len() {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
      "current_ind": 1,
      "entity_name": "resolve_with_earliest",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"resolve_with_earliest\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":545,\"end\":560},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:resolve_with_earliest:__crates_parseltongue-core_src_temporal_rs:545-560",
      "line_number": 0
    },
    {
      "current_code": "    fn resolve_with_latest(&self, changes: Vec<TemporalChange>, conflicts: Vec<Conflict>) -> Result<Vec<TemporalChange>> {\n        let mut resolved = changes;\n        let mut to_remove = Vec::new();\n\n        for conflict in conflicts {\n            if let Conflict::MultipleChanges { changes: conflicting_changes, .. } = conflict {\n                // Keep only the last change\n                for i in 0..conflicting_changes.len() - 1 {\n                    to_remove.push(conflicting_changes[i].isgl1_key.clone());\n                }\n            }\n        }\n\n        resolved.retain(|change| !to_remove.contains(&change.isgl1_key));\n        Ok(resolved)\n    }",
      "current_ind": 1,
      "entity_name": "resolve_with_latest",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"resolve_with_latest\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":528,\"end\":543},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:resolve_with_latest:__crates_parseltongue-core_src_temporal_rs:528-543",
      "line_number": 0
    },
    {
      "current_code": "    fn row_to_entity(&self, row: &[DataValue]) -> Result<CodeEntity> {\n        if row.len() < 14 {\n            return Err(ParseltongError::DatabaseError {\n                operation: \"row_to_entity\".to_string(),\n                details: format!(\"Invalid row length: expected 14, got {}\", row.len()),\n            });\n        }\n\n        // Extract ISGL1 key\n        let isgl1_key = match &row[0] {\n            DataValue::Str(s) => s.to_string(),\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"ISGL1_key is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Extract current_code\n        let current_code = match &row[1] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Current_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract future_code\n        let future_code = match &row[2] {\n            DataValue::Str(s) => Some(s.to_string()),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Code has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize interface_signature\n        let interface_signature: InterfaceSignature = match &row[3] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize interface_signature: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"interface_signature is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize TDD_Classification\n        let tdd_classification: TddClassification = match &row[4] {\n            DataValue::Str(s) => serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize TDD_Classification: {}\", e),\n                }\n            })?,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"TDD_Classification is not a string\".to_string(),\n                })\n            }\n        };\n\n        // Deserialize lsp_meta_data\n        let lsp_metadata: Option<LspMetadata> = match &row[5] {\n            DataValue::Str(s) => Some(serde_json::from_str(s).map_err(|e| {\n                ParseltongError::SerializationError {\n                    details: format!(\"Failed to deserialize lsp_meta_data: {}\", e),\n                }\n            })?),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"lsp_meta_data has invalid type\".to_string(),\n                })\n            }\n        };\n\n        // Extract temporal state\n        let current_ind = match &row[6] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"current_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_ind = match &row[7] {\n            DataValue::Bool(b) => *b,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"future_ind is not a bool\".to_string(),\n                })\n            }\n        };\n\n        let future_action = match &row[8] {\n            DataValue::Str(s) => Some(match s.as_ref() {\n                \"Create\" => TemporalAction::Create,\n                \"Edit\" => TemporalAction::Edit,\n                \"Delete\" => TemporalAction::Delete,\n                _ => {\n                    return Err(ParseltongError::DatabaseError {\n                        operation: \"row_to_entity\".to_string(),\n                        details: format!(\"Invalid Future_Action value: {}\", s),\n                    })\n                }\n            }),\n            DataValue::Null => None,\n            _ => {\n                return Err(ParseltongError::DatabaseError {\n                    operation: \"row_to_entity\".to_string(),\n                    details: \"Future_Action has invalid type\".to_string(),\n                })\n            }\n        };\n\n        let temporal_state = TemporalState {\n            current_ind,\n            future_ind,\n            future_action,\n        };\n\n        // Extract entity_class (v0.9.0) - currently ignored in CodeEntity\n        let _entity_class = match &row[13] {\n            DataValue::Str(s) => s.to_string(),\n            _ => \"CODE\".to_string(), // Default fallback\n        };\n\n        // Build CodeEntity\n        let mut entity = CodeEntity::new(\n            isgl1_key, \n            interface_signature,\n            // v0.9.0: Extract entity_class from database row\n            match &row[13] {\n                cozo::DataValue::Str(s) => {\n                    if s == \"TEST\" {\n                        crate::entities::EntityClass::TestImplementation\n                    } else {\n                        crate::entities::EntityClass::CodeImplementation\n                    }\n                },\n                _ => crate::entities::EntityClass::CodeImplementation, // Default fallback\n            }\n        )?;\n        entity.current_code = current_code;\n        entity.future_code = future_code;\n        entity.temporal_state = temporal_state;\n        entity.tdd_classification = tdd_classification;\n        entity.lsp_metadata = lsp_metadata;\n\n        Ok(entity)\n    }",
      "current_ind": 1,
      "entity_name": "row_to_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"row_to_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1099,\"end\":1265},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:row_to_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:1099-1265",
      "line_number": 0
    },
    {
      "current_code": "    fn run_validation_rules(&self) -> Result<()> {\n        for rule in &self.validation_rules {\n            rule.validate(&self.entities)?;\n        }\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "run_validation_rules",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"run_validation_rules\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":244,\"end\":249},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:run_validation_rules:__crates_parseltongue-core_src_temporal_rs:244-249",
      "line_number": 0
    },
    {
      "current_code": "    fn sanitize_path(&self, path: &str) -> String {\n        path.replace(['/', '\\\\', '.'], \"_\")\n    }",
      "current_ind": 1,
      "entity_name": "sanitize_path",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"sanitize_path\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":176,\"end\":178},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:sanitize_path:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:176-178",
      "line_number": 0
    },
    {
      "current_code": "    pub fn severity(&self) -> Severity {\n        match self {\n            Self::SyntaxError { .. }\n            | Self::TypeError { .. }\n            | Self::BorrowError { .. }\n            | Self::CompilationError { .. }\n            | Self::TestError { .. } => Severity::Error,\n            Self::Timeout { .. } => Severity::Error,\n            Self::Io(_) => Severity::Error,\n            Self::Parse(_) => Severity::Error,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "severity",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"severity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":67,\"end\":78},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:severity:__crates_pt04-syntax-preflight-validator_src_errors_rs:67-78",
      "line_number": 0
    },
    {
      "current_code": "    fn should_process_file(&self, file_path: &Path) -> bool {\n        let path_str = file_path.to_string_lossy();\n\n        // REQ-V090-002.0: Check for git subdirectories (always-on detection)\n        if self.is_under_git_subdirectory(file_path) {\n            return false;\n        }\n\n        // Check exclude patterns\n        for pattern in &self.config.exclude_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return false;\n            }\n        }\n\n        // Check include patterns\n        for pattern in &self.config.include_patterns {\n            if self.matches_pattern(&path_str, pattern) {\n                return true;\n            }\n        }\n\n        false\n    }",
      "current_ind": 1,
      "entity_name": "should_process_file",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"should_process_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":288,\"end\":311},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:should_process_file:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:288-311",
      "line_number": 0
    },
    {
      "current_code": "    pub fn source_location(mut self, location: impl Into<String>) -> Self {\n        self.source_location = Some(location.into());\n        self\n    }",
      "current_ind": 1,
      "entity_name": "source_location",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"source_location\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1063,\"end\":1066},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:source_location:__crates_parseltongue-core_src_entities_rs:1063-1066",
      "line_number": 0
    },
    {
      "current_code": "    pub fn span(&self) -> u32 {\n        self.end - self.start + 1\n    }",
      "current_ind": 1,
      "entity_name": "span",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"span\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":307,\"end\":309},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:span:__crates_parseltongue-core_src_entities_rs:307-309",
      "line_number": 0
    },
    {
      "current_code": "    async fn store_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.insert_entity(&entity).await\n    }",
      "current_ind": 1,
      "entity_name": "store_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"store_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1271,\"end\":1273},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:store_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:1271-1273",
      "line_number": 0
    },
    {
      "current_code": "    async fn stream_directory(&self) -> Result<StreamResult> {\n        let start_time = Instant::now();\n        let mut total_files = 0;\n        let mut processed_files = 0;\n        let mut entities_created = 0;\n        let mut errors = Vec::new();\n\n        println!(\n            \"{}\",\n            style(\"Starting directory streaming...\").blue().bold()\n        );\n\n        // Setup progress bar\n        let pb = ProgressBar::new_spinner();\n        pb.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} [{elapsed_precise}] {msg}\")\n                .unwrap()\n        );\n        pb.set_message(\"Scanning files...\");\n\n        // Walk through directory\n        for entry in WalkDir::new(&self.config.root_dir)\n            .follow_links(false)\n            .into_iter()\n            .filter_map(|e| e.ok())\n        {\n            let path = entry.path();\n\n            if path.is_file() && self.should_process_file(path) {\n                total_files += 1;\n                pb.set_message(format!(\"Processing: {}\", path.display()));\n\n                match self.stream_file(path).await {\n                    Ok(result) => {\n                        processed_files += 1;\n                        entities_created += result.entities_created;\n                    }\n                    Err(e) => {\n                        let error_msg = format!(\"{}: {}\", path.display(), e);\n                        errors.push(error_msg.clone());\n                        pb.println(format!(\"{} {}\", style(\"\").yellow().for_stderr(), error_msg));\n                        self.update_stats(0, true);\n                    }\n                }\n            }\n        }\n\n        pb.finish_with_message(\"Directory streaming completed\");\n\n        let duration = start_time.elapsed();\n\n        // Print summary\n        println!(\"\\n{}\", style(\"Streaming Summary:\").green().bold());\n        println!(\"Total files found: {}\", total_files);\n        println!(\"Files processed: {}\", processed_files);\n        println!(\"Entities created: {}\", entities_created);\n        println!(\"Errors encountered: {}\", errors.len());\n        println!(\"Duration: {:?}\", duration);\n\n        Ok(StreamResult {\n            total_files,\n            processed_files,\n            entities_created,\n            errors,\n            duration,\n        })\n    }",
      "current_ind": 1,
      "entity_name": "stream_directory",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"stream_directory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":406,\"end\":473},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:stream_directory:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:406-473",
      "line_number": 0
    },
    {
      "current_code": "    async fn stream_file(&self, file_path: &Path) -> Result<FileResult> {\n        let file_path_str = file_path.to_string_lossy().to_string();\n\n        // Read file content\n        let content = self.read_file_content(file_path).await?;\n\n        // Parse code entities AND dependencies (two-pass extraction)\n        let (parsed_entities, dependencies) = self.key_generator.parse_source(&content, file_path)?;\n\n        let mut entities_created = 0;\n        let mut errors: Vec<String> = Vec::new();\n\n        // Process each parsed entity\n        for parsed_entity in parsed_entities {\n            // Generate ISGL1 key\n            let isgl1_key = self.key_generator.generate_key(&parsed_entity)?;\n\n            // Enrich with LSP metadata for Rust files (sequential hover requests)\n            let lsp_metadata = self.fetch_lsp_metadata_for_entity(&parsed_entity, file_path).await;\n\n            // Convert ParsedEntity to CodeEntity\n            match self.parsed_entity_to_code_entity(&parsed_entity, &isgl1_key, &content, file_path) {\n                Ok(mut code_entity) => {\n                    // Store LSP metadata as JSON string if available\n                    if let Some(metadata) = lsp_metadata {\n                        code_entity.lsp_metadata = Some(metadata);\n                    }\n\n                    // Store in real database\n                    match self.db.insert_entity(&code_entity).await {\n                        Ok(_) => {\n                            entities_created += 1;\n                        }\n                        Err(e) => {\n                            let error_msg = format!(\"Failed to insert entity {}: {}\", isgl1_key, e);\n                            errors.push(error_msg);\n                        }\n                    }\n                }\n                Err(e) => {\n                    let error_msg = format!(\"Failed to convert entity {}: {}\", isgl1_key, e);\n                    errors.push(error_msg);\n                }\n            }\n        }\n\n        // ALWAYS create DependencyEdges schema, even if no dependencies\n        // This ensures pt02-level00 can query the table (returns empty array if no edges)\n        // Bug fix: Previously only created schema if dependencies.is_empty() == false\n        if let Err(e) = self.db.create_dependency_edges_schema().await {\n            // Schema might already exist - that's ok\n            if !e.to_string().contains(\"already exists\") && !e.to_string().contains(\"conflicts with an existing\") {\n                errors.push(format!(\"Failed to create dependency schema: {}\", e));\n            }\n        }\n\n        // Batch insert dependencies after all entities are stored\n        if !dependencies.is_empty() {\n            // Insert dependency edges\n            match self.db.insert_edges_batch(&dependencies).await {\n                Ok(_) => {\n                    // Successfully inserted dependencies\n                }\n                Err(e) => {\n                    errors.push(format!(\"Failed to insert {} dependencies: {}\", dependencies.len(), e));\n                }\n            }\n        }\n\n        self.update_stats(entities_created, !errors.is_empty());\n\n        Ok(FileResult {\n            file_path: file_path_str,\n            entities_created,\n            success: errors.is_empty(),\n            error: if errors.is_empty() {\n                None\n            } else {\n                Some(errors.join(\"; \"))\n            },\n        })\n    }",
      "current_ind": 1,
      "entity_name": "stream_file",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"stream_file\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":475,\"end\":556},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:stream_file:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:475-556",
      "line_number": 0
    },
    {
      "current_code": "    pub fn success(validation_type: ValidationType) -> Self {\n        Self {\n            is_valid: true,\n            validation_type,\n            errors: Vec::new(),\n            warnings: Vec::new(),\n            execution_time_ms: 0,\n            memory_usage_bytes: 0,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "success",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":65,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:success:__crates_pt04-syntax-preflight-validator_src_types_rs:65-74",
      "line_number": 0
    },
    {
      "current_code": "    pub fn success(file_path: PathBuf, operation: WriteOperation) -> Self {\n        Self {\n            success: true,\n            file_path,\n            operation,\n            message: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "success",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":19,\"end\":26},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:success:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:19-26",
      "line_number": 0
    },
    {
      "current_code": "    pub fn success(entities_deleted: usize) -> Self {\n        Self {\n            success: true,\n            entities_deleted,\n            schema_recreated: true,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "success",
      "entity_type": "method",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"success\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":84,\"end\":90},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:success:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:84-90",
      "line_number": 0
    },
    {
      "current_code": "    pub fn to_datalog(&self) -> String {\n        // Precondition validation (contract-based programming)\n        // Using panic! is intentional - this is a programming error, not a runtime error\n        self.validate_preconditions();\n\n        let (current_ind, future_ind, action_str) = self.action.to_temporal_state();\n        let future_code_value = self.escape_future_code();\n\n        // Generate Datalog matching actual CodeGraph schema (13 fields)\n        // Note: ISGL1_key => indicates primary key in :put syntax\n        format!(\n            r#\"?[ISGL1_key, Current_Code, Future_Code, interface_signature, TDD_Classification,\n              lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n              last_modified, entity_type] <-\n            [[\"{}\", null, {}, \"\", \"\",\n              null, {}, {}, \"{}\", \"\",\n              \"\", \"\", \"\"]]\n\n            :put CodeGraph {{\n                ISGL1_key =>\n                Current_Code, Future_Code, interface_signature, TDD_Classification,\n                lsp_meta_data, current_ind, future_ind, Future_Action, file_path, language,\n                last_modified, entity_type\n            }}\"#,\n            self.entity_key, future_code_value, current_ind, future_ind, action_str\n        )\n    }",
      "current_ind": 1,
      "entity_name": "to_datalog",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"to_datalog\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":95,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:to_datalog:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:95-121",
      "line_number": 0
    },
    {
      "current_code": "    pub fn to_json_pretty(&self) -> serde_json::Result<String> {\n        serde_json::to_string_pretty(self)\n    }",
      "current_ind": 1,
      "entity_name": "to_json_pretty",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"to_json_pretty\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":156,\"end\":158},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:to_json_pretty:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:156-158",
      "line_number": 0
    },
    {
      "current_code": "    pub fn to_key(mut self, key: impl Into<String>) -> Self {\n        self.to_key = Some(key.into());\n        self\n    }",
      "current_ind": 1,
      "entity_name": "to_key",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"to_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1051,\"end\":1054},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:to_key:__crates_parseltongue-core_src_entities_rs:1051-1054",
      "line_number": 0
    },
    {
      "current_code": "    pub const fn to_temporal_state(self) -> (&'static str, &'static str, &'static str) {\n        match self {\n            EntityAction::Create => (\"false\", \"true\", \"Create\"),\n            EntityAction::Edit => (\"true\", \"true\", \"Edit\"),\n            EntityAction::Delete => (\"true\", \"false\", \"Delete\"),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "to_temporal_state",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"to_temporal_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":48,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:to_temporal_state:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:48-54",
      "line_number": 0
    },
    {
      "current_code": "    pub fn unchanged() -> Self {\n        Self {\n            current_ind: true,\n            future_ind: true,  // Unchanged state exists in both present and future\n            future_action: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "unchanged",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"unchanged\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":179,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:unchanged:__crates_parseltongue-core_src_entities_rs:179-185",
      "line_number": 0
    },
    {
      "current_code": "    pub fn up_to(self) -> Vec<Self> {\n        match self {\n            Self::Syntax => vec![Self::Syntax],\n            Self::Type => vec![Self::Syntax, Self::Type],\n            Self::BorrowChecker => vec![Self::Syntax, Self::Type, Self::BorrowChecker],\n            Self::Compilation => vec![Self::Syntax, Self::Type, Self::BorrowChecker, Self::Compilation],\n            Self::Test => Self::all(),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "up_to",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"up_to\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":35,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:up_to:__crates_pt04-syntax-preflight-validator_src_types_rs:35-43",
      "line_number": 0
    },
    {
      "current_code": "    async fn update_entity(&mut self, entity: CodeEntity) -> Result<()> {\n        self.update_entity_internal(&entity).await\n    }",
      "current_ind": 1,
      "entity_name": "update_entity",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"update_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":1283,\"end\":1285},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:update_entity:__crates_parseltongue-core_src_storage_cozo_client_rs:1283-1285",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn update_entity_internal(&self, entity: &CodeEntity) -> Result<()> {\n        // Update is same as insert with :put which replaces existing\n        self.insert_entity(entity).await\n    }",
      "current_ind": 1,
      "entity_name": "update_entity_internal",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"update_entity_internal\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":837,\"end\":840},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:update_entity_internal:__crates_parseltongue-core_src_storage_cozo_client_rs:837-840",
      "line_number": 0
    },
    {
      "current_code": "    fn update_stats(&self, entities_created: usize, had_error: bool) {\n        if let Ok(mut stats) = self.stats.lock() {\n            stats.files_processed += 1;\n            stats.entities_created += entities_created;\n            if had_error {\n                stats.errors_encountered += 1;\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "update_stats",
      "entity_type": "method",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"update_stats\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":393,\"end\":401},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:update_stats:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:393-401",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn update_temporal_state(\n        &self,\n        isgl1_key: &str,\n        future_ind: bool,\n        future_action: Option<TemporalAction>,\n    ) -> Result<()> {\n        // Get current entity\n        let mut entity = self.get_entity(isgl1_key).await?;\n\n        // Update temporal state\n        entity.temporal_state.future_ind = future_ind;\n        entity.temporal_state.future_action = future_action.clone();\n\n        // Validate temporal state\n        entity.temporal_state.validate()?;\n\n        // Update in database\n        self.update_entity_internal(&entity).await\n    }",
      "current_ind": 1,
      "entity_name": "update_temporal_state",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"update_temporal_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":863,\"end\":881},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:update_temporal_state:__crates_parseltongue-core_src_storage_cozo_client_rs:863-881",
      "line_number": 0
    },
    {
      "current_code": "    pub fn updated_signature(mut self, signature: InterfaceSignature) -> Self {\n        self.updated_signature = Some(signature);\n        self\n    }",
      "current_ind": 1,
      "entity_name": "updated_signature",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"updated_signature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":429,\"end\":432},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:updated_signature:__crates_parseltongue-core_src_temporal_rs:429-432",
      "line_number": 0
    },
    {
      "current_code": "    pub fn valid() -> Self {\n        Self {\n            is_valid: true,\n            errors: vec![],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "valid",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"valid\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":157,\"end\":162},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:valid:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:157-162",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate(&self) -> Result<()> {\n        // Cannot have both indicators false\n        if !self.current_ind && !self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Both current_ind and future_ind cannot be false\".to_string(),\n            });\n        }\n\n        // Validate action compatibility\n        if let Some(ref action) = self.future_action {\n            action.validate_with_indicators(self.current_ind, self.future_ind)?;\n        }\n\n        // If no action, indicators should be the same\n        if self.future_action.is_none() && self.current_ind != self.future_ind {\n            return Err(ParseltongError::TemporalError {\n                details: \"Temporal indicators differ but no action specified\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":215,\"end\":236},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_parseltongue-core_src_entities_rs:215-236",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate(&self) -> Result<()> {\n        // Validate ISGL1 key format\n        self.validate_isgl1_key()?;\n\n        // Validate temporal state\n        self.temporal_state.validate()?;\n\n        // Validate line range\n        LineRange::new(self.interface_signature.line_range.start, self.interface_signature.line_range.end)\n            .map_err(|e| ParseltongError::ValidationError {\n                field: \"line_range\".to_string(),\n                expected: \"valid line range\".to_string(),\n                actual: e.to_string(),\n            })?;\n\n        // Validate code consistency\n        self.validate_code_consistency()?;\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":677,\"end\":696},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_parseltongue-core_src_entities_rs:677-696",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        // Simplified circular dependency detection\n        // In a real implementation, this would build a dependency graph\n        // and check for cycles\n\n        for entity in entities.values() {\n            if entity.is_modified() {\n                // Check if entity depends on itself (simplified)\n                if entity.isgl1_key.contains(&entity.interface_signature.name) {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Potential circular dependency detected for entity {}\",\n                            entity.isgl1_key\n                        ),\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":283,\"end\":303},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_parseltongue-core_src_temporal_rs:283-303",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            // Validate temporal state consistency\n            entity.validate()?;\n\n            // Ensure code consistency\n            if entity.temporal_state.current_ind && entity.current_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has current_ind=true but no current_code\",\n                        key\n                    ),\n                });\n            }\n\n            if entity.temporal_state.future_ind && entity.future_code.is_none() {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Entity {} has future_ind=true but no future_code\",\n                        key\n                    ),\n                });\n            }\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":325,\"end\":351},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_parseltongue-core_src_temporal_rs:325-351",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()> {\n        for (key, entity) in entities {\n            if let Some(ref action) = entity.temporal_state.future_action {\n                // Validate action is compatible with temporal indicators\n                action.validate_with_indicators(\n                    entity.temporal_state.current_ind,\n                    entity.temporal_state.future_ind,\n                ).map_err(|e| ParseltongError::TemporalError {\n                    details: format!(\n                        \"Invalid transition for entity {}: {}\",\n                        key,\n                        e\n                    ),\n                })?;\n            }\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":373,\"end\":391},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_parseltongue-core_src_temporal_rs:373-391",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all edges.\"\n            ));\n        }\n\n        // Build config\n        let base_output = self.output.clone().unwrap_or_else(|| {\n            PathBuf::from(\"ISGLevel00.json\")\n        });\n        \n        // v0.9.0: Create dual outputs for code vs tests separation\n        let (code_output, tests_output) = if base_output.file_stem() == Some(std::ffi::OsStr::new(\"ISGLevel00\")) {\n            // Default case: create level00-code.json and level00-tests.json\n            (\n                PathBuf::from(\"level00-code.json\"),\n                PathBuf::from(\"level00-tests.json\"),\n            )\n        } else {\n            // Custom case: append -code and -tests to user provided base name\n            let stem = base_output.file_stem().unwrap_or_default();\n            let extension = base_output.extension().and_then(|s| s.to_str()).unwrap_or(\"json\");\n            \n            let code_path = base_output.with_file_name(format!(\"{}-code.{}\", stem.to_string_lossy(), extension));\n            let tests_path = base_output.with_file_name(format!(\"{}-tests.{}\", stem.to_string_lossy(), extension));\n            \n            (code_path, tests_path)\n        };\n\n        Ok(ExportConfig {\n            level: 0,\n            include_code: false,  // N/A for Level 0\n            where_filter: self.where_clause.clone(),\n            output_path: base_output,\n            // v0.9.0: Dual outputs for code/test separation\n            code_output_path: Some(code_output),\n            tests_output_path: Some(tests_output),\n            db_path: self.db.clone(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs\",\"line_range\":{\"start\":65,\"end\":106},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level00_rs:65-106",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all entities.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: 1,\n            include_code: self.include_code == 1,\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(\"ISGLevel01.json\")\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for level01)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs\",\"line_range\":{\"start\":77,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level01_rs:77-98",
      "line_number": 0
    },
    {
      "current_code": "    fn validate(&self) -> Result<ExportConfig> {\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow::anyhow!(\n                \"WHERE clause cannot be empty. Use --where \\\"ALL\\\" to export all entities.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: 2,\n            include_code: self.include_code == 1,\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(\"ISGLevel02.json\")\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for level02)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs\",\"line_range\":{\"start\":82,\"end\":103},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level02_rs:82-103",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate(&self) -> Result<ExportConfig> {\n        // Validate Level 0: Should NOT have include_code\n        if self.level == 0 && self.include_code.is_some() {\n            return Err(anyhow!(\n                \"Level 0 exports edges only (from_key, to_key, edge_type). \\\n                 --include-code flag not applicable. \\\n                 Remove --include-code for Level 0.\"\n            ));\n        }\n\n        // Validate Level 1-2: Must HAVE include_code\n        if self.level > 0 && self.include_code.is_none() {\n            return Err(anyhow!(\n                \"Level {} exports entities which may include code. \\\n                 --include-code [0|1] is MANDATORY. \\\n                 Use 0 for signatures only (cheap), 1 for full code (expensive).\",\n                self.level\n            ));\n        }\n\n        // Validate WHERE clause non-empty\n        if self.where_clause.trim().is_empty() {\n            return Err(anyhow!(\n                \"WHERE clause cannot be empty. \\\n                 Use --where \\\"ALL\\\" to export all entities/edges.\"\n            ));\n        }\n\n        // Build config\n        Ok(ExportConfig {\n            level: self.level,\n            include_code: self.include_code.map(|v| v == 1).unwrap_or(false),\n            where_filter: self.where_clause.clone(),\n            output_path: self.output.clone().unwrap_or_else(|| {\n                PathBuf::from(format!(\"ISGLevel{:02}.json\", self.level))\n            }),\n            // v0.9.0: Dual outputs for code/test separation (None for general CLI)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: self.db.clone(),\n        })\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":116,\"end\":157},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:116-157",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate(&self) -> anyhow::Result<()> {\n        if self.code_snippet.is_none() && self.file.is_none() {\n            anyhow::bail!(\"Either --code-snippet or --file must be provided\");\n        }\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":60,\"end\":65},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate:__crates_pt04-syntax-preflight-validator_src_cli_rs:60-65",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_borrow_checker(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::BorrowChecker))\n    }",
      "current_ind": 1,
      "entity_name": "validate_borrow_checker",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_borrow_checker\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":128,\"end\":131},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_borrow_checker:__crates_pt04-syntax-preflight-validator_src_validator_rs:128-131",
      "line_number": 0
    },
    {
      "current_code": "    fn validate_code_consistency(&self) -> Result<()> {\n        // If entity exists in current state, it should have current code\n        if self.temporal_state.current_ind && self.current_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"current_code\".to_string(),\n                expected: \"present when current_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        // If entity will exist in future state, it should have future code\n        if self.temporal_state.future_ind && self.future_code.is_none() {\n            return Err(ParseltongError::ValidationError {\n                field: \"future_code\".to_string(),\n                expected: \"present when future_ind is true\".to_string(),\n                actual: \"None\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate_code_consistency",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_code_consistency\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":716,\"end\":736},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_code_consistency:__crates_parseltongue-core_src_entities_rs:716-736",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_compilation(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Compilation))\n    }",
      "current_ind": 1,
      "entity_name": "validate_compilation",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_compilation\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":133,\"end\":136},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_compilation:__crates_pt04-syntax-preflight-validator_src_validator_rs:133-136",
      "line_number": 0
    },
    {
      "current_code": "    fn validate_entity_compatibility(&self, existing: &CodeEntity, new: &CodeEntity) -> Result<()> {\n        // Check if both entities have conflicting temporal states\n        if existing.is_modified() && new.is_modified() {\n            return Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Concurrent modifications detected for entity {}\",\n                    existing.isgl1_key\n                ),\n            });\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate_entity_compatibility",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_entity_compatibility\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":163,\"end\":175},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_entity_compatibility:__crates_parseltongue-core_src_temporal_rs:163-175",
      "line_number": 0
    },
    {
      "current_code": "        fn validate_input(&self, _input: &ToolInput) -> Result<()> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ValidationError {\n                    field: \"input\".to_string(),\n                    expected: \"valid input\".to_string(),\n                    actual: \"mock failure\".to_string(),\n                });\n            }\n            Ok(())\n        }",
      "current_ind": 1,
      "entity_name": "validate_input",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_input\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":598,\"end\":607},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_input:__crates_parseltongue-core_src_interfaces_rs:598-607",
      "line_number": 0
    },
    {
      "current_code": "    fn validate_isgl1_key(&self) -> Result<()> {\n        if self.isgl1_key.is_empty() {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key cannot be empty\".to_string(),\n            });\n        }\n\n        if !self.isgl1_key.contains('-') {\n            return Err(ParseltongError::InvalidIsgl1Key {\n                key: self.isgl1_key.clone(),\n                reason: \"ISGL1 key must contain hyphens\".to_string(),\n            });\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate_isgl1_key",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_isgl1_key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":698,\"end\":714},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_isgl1_key:__crates_parseltongue-core_src_entities_rs:698-714",
      "line_number": 0
    },
    {
      "current_code": "    fn validate_preconditions(&self) {\n        match self.action {\n            EntityAction::Create | EntityAction::Edit if self.future_code.is_none() => {\n                panic!(\"{:?} action requires future_code\", self.action);\n            }\n            _ => {}\n        }\n    }",
      "current_ind": 1,
      "entity_name": "validate_preconditions",
      "entity_type": "method",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_preconditions\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":124,\"end\":131},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_preconditions:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:124-131",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate_state(&self) -> Result<()> {\n        self.run_validation_rules()\n    }",
      "current_ind": 1,
      "entity_name": "validate_state",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_state\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":142,\"end\":144},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_state:__crates_parseltongue-core_src_temporal_rs:142-144",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate_syntax(&mut self, code: &str, language: Language) -> Result<ValidationResult> {\n        // Get parser for the specified language\n        let parser = self.parsers.get_mut(&language)\n            .ok_or_else(|| anyhow::anyhow!(\"No parser available for language: {:?}\", language))?;\n\n        // Parse code with tree-sitter\n        let tree = parser\n            .parse(code, None)\n            .context(\"Failed to parse code with tree-sitter\")?;\n\n        let root = tree.root_node();\n\n        // Check for syntax errors in parse tree\n        if root.has_error() {\n            let errors = self.collect_syntax_errors(&root, code);\n            return Ok(ValidationResult {\n                is_valid: false,\n                errors,\n            });\n        }\n\n        Ok(ValidationResult {\n            is_valid: true,\n            errors: vec![],\n        })\n    }",
      "current_ind": 1,
      "entity_name": "validate_syntax",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":83,\"end\":108},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_syntax:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:83-108",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_syntax(&self, code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Minimal implementation using syn\n        let start = std::time::Instant::now();\n\n        let result = syn::parse_file(code);\n\n        let execution_time_ms = start.elapsed().as_millis() as u64;\n\n        match result {\n            Ok(_) => Ok(ValidationOutput {\n                is_valid: true,\n                validation_type: ValidationType::Syntax,\n                errors: Vec::new(),\n                warnings: Vec::new(),\n                execution_time_ms,\n                memory_usage_bytes: 0, // Simplified for GREEN phase\n            }),\n            Err(e) => {\n                let error_msg = format!(\"Syntax error: {}\", e);\n                Ok(ValidationOutput {\n                    is_valid: false,\n                    validation_type: ValidationType::Syntax,\n                    errors: vec![error_msg],\n                    warnings: Vec::new(),\n                    execution_time_ms,\n                    memory_usage_bytes: 0,\n                })\n            }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "validate_syntax",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_syntax\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":92,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_syntax:__crates_pt04-syntax-preflight-validator_src_validator_rs:92-121",
      "line_number": 0
    },
    {
      "current_code": "    fn validate_temporal_change(&self, change: &TemporalChange) -> Result<()> {\n        // Validate temporal action compatibility\n        let entity = self.entities.get(&change.isgl1_key);\n\n        match (&entity, &change.action) {\n            (None, TemporalAction::Edit | TemporalAction::Delete) => {\n                return Err(ParseltongError::TemporalError {\n                    details: format!(\n                        \"Cannot {} non-existent entity {}\",\n                        match change.action {\n                            TemporalAction::Edit => \"edit\",\n                            TemporalAction::Delete => \"delete\",\n                            _ => unreachable!(),\n                        },\n                        change.isgl1_key\n                    ),\n                });\n            }\n            (Some(entity), TemporalAction::Create) => {\n                if entity.temporal_state.current_ind {\n                    return Err(ParseltongError::TemporalError {\n                        details: format!(\n                            \"Cannot create entity {} that already exists\",\n                            change.isgl1_key\n                        ),\n                    });\n                }\n            }\n            _ => {}\n        }\n\n        Ok(())\n    }",
      "current_ind": 1,
      "entity_name": "validate_temporal_change",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_temporal_change\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":177,\"end\":209},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_temporal_change:__crates_parseltongue-core_src_temporal_rs:177-209",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_tests(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Test))\n    }",
      "current_ind": 1,
      "entity_name": "validate_tests",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":138,\"end\":141},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_tests:__crates_pt04-syntax-preflight-validator_src_validator_rs:138-141",
      "line_number": 0
    },
    {
      "current_code": "    async fn validate_types(&self, _code: &str) -> Result<ValidationOutput> {\n        // GREEN phase: Stub implementation (passes for now)\n        Ok(ValidationOutput::success(ValidationType::Type))\n    }",
      "current_ind": 1,
      "entity_name": "validate_types",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":123,\"end\":126},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_types:__crates_pt04-syntax-preflight-validator_src_validator_rs:123-126",
      "line_number": 0
    },
    {
      "current_code": "    pub fn validate_with_indicators(\n        &self,\n        current_ind: bool,\n        future_ind: bool,\n    ) -> Result<()> {\n        match (current_ind, future_ind, self) {\n            (true, false, TemporalAction::Delete) => Ok(()),\n            (true, true, TemporalAction::Edit) => Ok(()),\n            (false, true, TemporalAction::Create) => Ok(()),\n            _ => Err(ParseltongError::TemporalError {\n                details: format!(\n                    \"Invalid temporal combination: current={}, future={}, action={:?}\",\n                    current_ind, future_ind, self\n                ),\n            }),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "validate_with_indicators",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"validate_with_indicators\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":131,\"end\":147},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:validate_with_indicators:__crates_parseltongue-core_src_entities_rs:131-147",
      "line_number": 0
    },
    {
      "current_code": "    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L0] {}\", message);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "verbose_print",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"verbose_print\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs\",\"line_range\":{\"start\":108,\"end\":112},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:verbose_print:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level00_rs:108-112",
      "line_number": 0
    },
    {
      "current_code": "    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L1] {}\", message);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "verbose_print",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"verbose_print\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs\",\"line_range\":{\"start\":100,\"end\":104},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:verbose_print:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level01_rs:100-104",
      "line_number": 0
    },
    {
      "current_code": "    fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02-L2] {}\", message);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "verbose_print",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"verbose_print\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs\",\"line_range\":{\"start\":105,\"end\":109},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:verbose_print:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level02_rs:105-109",
      "line_number": 0
    },
    {
      "current_code": "    pub fn verbose_print(&self, message: &str) {\n        if self.verbose {\n            eprintln!(\"[PT02] {}\", message);\n        }\n    }",
      "current_ind": 1,
      "entity_name": "verbose_print",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"verbose_print\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":160,\"end\":164},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:verbose_print:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:160-164",
      "line_number": 0
    },
    {
      "current_code": "    pub fn with_edges(edges: Vec<DependencyEdge>, where_filter: String) -> Self {\n        let metadata = ExportMetadata::for_level0(edges.len(), where_filter);\n        Self {\n            export_metadata: metadata,\n            edges: Some(edges),\n            entities: None,\n        }\n    }",
      "current_ind": 1,
      "entity_name": "with_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":264,\"end\":271},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_edges:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:264-271",
      "line_number": 0
    },
    {
      "current_code": "    fn with_edges(edges: Vec<Edge>) -> Self {\n        Self {\n            edges,\n            entities: vec![],\n        }\n    }",
      "current_ind": 1,
      "entity_name": "with_edges",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_edges\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":45,\"end\":50},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_edges:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:45-50",
      "line_number": 0
    },
    {
      "current_code": "    pub fn with_entities(level: u8, entities: serde_json::Value, include_code: bool, where_filter: String) -> Self {\n        let total = if let Some(arr) = entities.as_array() {\n            arr.len()\n        } else {\n            0\n        };\n\n        let metadata = ExportMetadata::for_entities(level, total, include_code, where_filter);\n        Self {\n            export_metadata: metadata,\n            edges: None,\n            entities: Some(entities),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "with_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":274,\"end\":287},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_entities:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:274-287",
      "line_number": 0
    },
    {
      "current_code": "    fn with_entities(entities: Vec<Entity>) -> Self {\n        Self { entities }\n    }",
      "current_ind": 1,
      "entity_name": "with_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":43,\"end\":45},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:43-45",
      "line_number": 0
    },
    {
      "current_code": "    fn with_entities(entities: Vec<Entity>) -> Self {\n        Self { entities }\n    }",
      "current_ind": 1,
      "entity_name": "with_entities",
      "entity_type": "method",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":39,\"end\":41},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_entities:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:39-41",
      "line_number": 0
    },
    {
      "current_code": "        pub fn with_execute_result(mut self, result: Result<ToolOutput>) -> Self {\n            self.execute_result = Some(result);\n            self\n        }",
      "current_ind": 1,
      "entity_name": "with_execute_result",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_execute_result\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":570,\"end\":573},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_execute_result:__crates_parseltongue-core_src_interfaces_rs:570-573",
      "line_number": 0
    },
    {
      "current_code": "        pub fn with_failure(mut self) -> Self {\n            self.should_fail = true;\n            self\n        }",
      "current_ind": 1,
      "entity_name": "with_failure",
      "entity_type": "method",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_failure\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":575,\"end\":578},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_failure:__crates_parseltongue-core_src_interfaces_rs:575-578",
      "line_number": 0
    },
    {
      "current_code": "    pub fn with_message(mut self, message: String) -> Self {\n        self.message = Some(message);\n        self\n    }",
      "current_ind": 1,
      "entity_name": "with_message",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_message\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":39,\"end\":42},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_message:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:39-42",
      "line_number": 0
    },
    {
      "current_code": "    pub fn with_timing(mut self, execution_time_ms: u64, memory_usage_bytes: usize) -> Self {\n        self.execution_time_ms = execution_time_ms;\n        self.memory_usage_bytes = memory_usage_bytes;\n        self\n    }",
      "current_ind": 1,
      "entity_name": "with_timing",
      "entity_type": "method",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"with_timing\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":89,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:with_timing:__crates_pt04-syntax-preflight-validator_src_types_rs:89-93",
      "line_number": 0
    },
    {
      "current_code": "    pub async fn write_entity(&self, entity: &CodeEntity) -> Result<WriteResult> {\n        match &entity.temporal_state.future_action {\n            Some(FutureAction::Create) => self.create_file(entity).await,\n            Some(FutureAction::Edit) => self.modify_file(entity).await,\n            Some(FutureAction::Delete) => self.delete_file(entity).await,\n            None => Ok(WriteResult::no_op()),\n        }\n    }",
      "current_ind": 1,
      "entity_name": "write_entity",
      "entity_type": "method",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Method\",\"name\":\"write_entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":31,\"end\":38},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:method:write_entity:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:31-38",
      "line_number": 0
    },
    {
      "current_code": "pub mod c {\n    use super::*;\n    \n    #[derive(Debug, Clone)]\n    pub struct CAst {\n        pub root: TranslationUnit,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct TranslationUnit {\n        pub declarations: Vec<Declaration>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Declaration {\n        Function(FunctionDecl),\n        Variable(VariableDecl),\n        Typedef(TypedefDecl),\n        Struct(StructDecl),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct FunctionDecl {\n        pub name: String,\n        pub return_type: Type,\n        pub parameters: Vec<Parameter>,\n        pub body: Option<CompoundStatement>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Type {\n        pub base: BaseType,\n        pub qualifiers: Vec<TypeQualifier>,\n        pub pointer_level: usize,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum BaseType {\n        Void,\n        Char,\n        Short,\n        Int,\n        Long,\n        Float,\n        Double,\n        Struct(String),\n        Typedef(String),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum TypeQualifier {\n        Const,\n        Volatile,\n        Restrict,\n    }\n    \n    pub struct CParser {\n        preprocessor: PreprocessorCache,\n        symbol_table: SymbolTable,\n    }\n    \n    impl Parser for CParser {\n        type Input = String;\n        type Output = CAst;\n        type Error = CParseError;\n        type Config = CParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Implementation following Option 1, 2, or 3 from design doc\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }\n    \n    #[derive(Debug, Error)]\n    pub enum CParseError {\n        #[error(\"Lexical error: {0}\")]\n        LexicalError(String),\n        \n        #[error(\"Syntax error: {0}\")]\n        SyntaxError(String),\n        \n        #[error(\"Semantic error: {0}\")]\n        SemanticError(String),\n        \n        #[error(\"Preprocessor error: {0}\")]\n        PreprocessorError(String),\n    }\n    \n    #[derive(Debug, Default)]\n    pub struct CParseConfig {\n        pub standard: CStandard,\n        pub gnu_extensions: bool,\n        pub include_paths: Vec<String>,\n    }\n    \n    #[derive(Debug, Default)]\n    pub enum CStandard {\n        C89,\n        C99,\n        #[default]\n        C11,\n        C17,\n    }\n    \n    pub struct PreprocessorCache {\n        expanded: HashMap<FileId, String>,\n        macros: HashMap<String, Macro>,\n    }\n    \n    pub struct SymbolTable {\n        scopes: Vec<Scope>,\n        current_scope: usize,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Scope {\n        symbols: HashMap<String, Symbol>,\n        parent: Option<usize>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Symbol {\n        Type(Type),\n        Variable(Type),\n        Function(FunctionDecl),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Macro {\n        pub name: String,\n        pub parameters: Option<Vec<String>>,\n        pub body: String,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Parameter {\n        pub name: Option<String>,\n        pub ty: Type,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct CompoundStatement {\n        pub statements: Vec<Statement>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Statement {\n        Expression(Expression),\n        Compound(CompoundStatement),\n        If(IfStatement),\n        While(WhileStatement),\n        Return(Option<Expression>),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Expression {\n        pub kind: ExpressionKind,\n        pub ty: Option<Type>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum ExpressionKind {\n        Binary { op: BinaryOp, left: Box<Expression>, right: Box<Expression> },\n        Unary { op: UnaryOp, operand: Box<Expression> },\n        Call { func: Box<Expression>, args: Vec<Expression> },\n        Identifier(String),\n        Literal(Literal),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum BinaryOp {\n        Add, Sub, Mul, Div, Mod,\n        Eq, Ne, Lt, Le, Gt, Ge,\n        And, Or,\n        Assign,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum UnaryOp {\n        Negate, Not, Address, Deref,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Literal {\n        Integer(i64),\n        Float(f64),\n        String(String),\n        Char(char),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct VariableDecl {\n        pub name: String,\n        pub ty: Type,\n        pub initializer: Option<Expression>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct TypedefDecl {\n        pub name: String,\n        pub ty: Type,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct StructDecl {\n        pub name: Option<String>,\n        pub fields: Vec<Field>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Field {\n        pub name: String,\n        pub ty: Type,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct IfStatement {\n        pub condition: Expression,\n        pub then_branch: Box<Statement>,\n        pub else_branch: Option<Box<Statement>>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct WhileStatement {\n        pub condition: Expression,\n        pub body: Box<Statement>,\n    }\n}",
      "current_ind": 1,
      "entity_name": "c",
      "entity_type": "module",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"c\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":266,\"end\":503},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:c:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:266-503",
      "line_number": 0
    },
    {
      "current_code": "pub mod cli;",
      "current_ind": 1,
      "entity_name": "cli",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":28,\"end\":28},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cli:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:28-28",
      "line_number": 0
    },
    {
      "current_code": "pub mod cli;",
      "current_ind": 1,
      "entity_name": "cli",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":89,\"end\":89},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cli:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:89-89",
      "line_number": 0
    },
    {
      "current_code": "pub mod cli;",
      "current_ind": 1,
      "entity_name": "cli",
      "entity_type": "module",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":19,\"end\":19},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cli:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:19-19",
      "line_number": 0
    },
    {
      "current_code": "mod cli;",
      "current_ind": 1,
      "entity_name": "cli",
      "entity_type": "module",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/main.rs\",\"line_range\":{\"start\":5,\"end\":5},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cli:__crates_pt06-cozodb-make-future-code-current_src_main_rs:5-5",
      "line_number": 0
    },
    {
      "current_code": "pub mod combinators {\n    use super::*;\n    use std::marker::PhantomData;\n    \n    /// Result type for parser combinators\n    pub type ParseResult<'a, T> = Result<(T, &'a str), ParseError>;\n    \n    #[derive(Debug, Clone, Error)]\n    pub enum ParseError {\n        #[error(\"Unexpected end of input\")]\n        UnexpectedEof,\n        \n        #[error(\"Expected {expected}, found {found}\")]\n        Unexpected { expected: String, found: String },\n        \n        #[error(\"Parse failed: {0}\")]\n        Failed(String),\n    }\n    \n    /// Core parser combinator trait\n    pub trait ParserCombinator<'a, T>: Sized {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, T>;\n        \n        /// Map the output of this parser\n        fn map<U, F>(self, f: F) -> Map<Self, F>\n        where\n            F: Fn(T) -> U,\n        {\n            Map { parser: self, mapper: f }\n        }\n        \n        /// Sequence two parsers\n        fn then<U, P>(self, other: P) -> Then<Self, P>\n        where\n            P: ParserCombinator<'a, U>,\n        {\n            Then { first: self, second: other }\n        }\n        \n        /// Try this parser, or fallback to another\n        fn or<P>(self, other: P) -> Or<Self, P>\n        where\n            P: ParserCombinator<'a, T>,\n        {\n            Or { first: self, second: other }\n        }\n        \n        /// Make this parser optional\n        fn optional(self) -> Optional<Self> {\n            Optional { parser: self }\n        }\n        \n        /// Parse zero or more times\n        fn many(self) -> Many<Self> {\n            Many { parser: self }\n        }\n        \n        /// Parse one or more times\n        fn many1(self) -> Many1<Self> {\n            Many1 { parser: self }\n        }\n    }\n    \n    /// Map combinator\n    pub struct Map<P, F> {\n        parser: P,\n        mapper: F,\n    }\n    \n    impl<'a, P, F, T, U> ParserCombinator<'a, U> for Map<P, F>\n    where\n        P: ParserCombinator<'a, T>,\n        F: Fn(T) -> U,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, U> {\n            let (result, rest) = self.parser.parse(input)?;\n            Ok((self.mapper)(result), rest))\n        }\n    }\n    \n    /// Sequence combinator\n    pub struct Then<P1, P2> {\n        first: P1,\n        second: P2,\n    }\n    \n    impl<'a, P1, P2, T1, T2> ParserCombinator<'a, (T1, T2)> for Then<P1, P2>\n    where\n        P1: ParserCombinator<'a, T1>,\n        P2: ParserCombinator<'a, T2>,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, (T1, T2)> {\n            let (result1, rest1) = self.first.parse(input)?;\n            let (result2, rest2) = self.second.parse(rest1)?;\n            Ok(((result1, result2), rest2))\n        }\n    }\n    \n    /// Alternative combinator\n    pub struct Or<P1, P2> {\n        first: P1,\n        second: P2,\n    }\n    \n    impl<'a, P1, P2, T> ParserCombinator<'a, T> for Or<P1, P2>\n    where\n        P1: ParserCombinator<'a, T>,\n        P2: ParserCombinator<'a, T>,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, T> {\n            self.first.parse(input).or_else(|_| self.second.parse(input))\n        }\n    }\n    \n    /// Optional combinator\n    pub struct Optional<P> {\n        parser: P,\n    }\n    \n    impl<'a, P, T> ParserCombinator<'a, Option<T>> for Optional<P>\n    where\n        P: ParserCombinator<'a, T>,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, Option<T>> {\n            match self.parser.parse(input) {\n                Ok((result, rest)) => Ok((Some(result), rest)),\n                Err(_) => Ok((None, input)),\n            }\n        }\n    }\n    \n    /// Zero or more combinator\n    pub struct Many<P> {\n        parser: P,\n    }\n    \n    impl<'a, P, T> ParserCombinator<'a, Vec<T>> for Many<P>\n    where\n        P: ParserCombinator<'a, T>,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {\n            let mut results = Vec::new();\n            let mut rest = input;\n            \n            while let Ok((result, new_rest)) = self.parser.parse(rest) {\n                results.push(result);\n                rest = new_rest;\n            }\n            \n            Ok((results, rest))\n        }\n    }\n    \n    /// One or more combinator\n    pub struct Many1<P> {\n        parser: P,\n    }\n    \n    impl<'a, P, T> ParserCombinator<'a, Vec<T>> for Many1<P>\n    where\n        P: ParserCombinator<'a, T>,\n    {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, Vec<T>> {\n            let (first, mut rest) = self.parser.parse(input)?;\n            let mut results = vec![first];\n            \n            while let Ok((result, new_rest)) = self.parser.parse(rest) {\n                results.push(result);\n                rest = new_rest;\n            }\n            \n            Ok((results, rest))\n        }\n    }\n    \n    /// Basic parsers\n    pub fn tag<'a>(expected: &'a str) -> impl ParserCombinator<'a, &'a str> {\n        Tag { expected }\n    }\n    \n    pub struct Tag<'a> {\n        expected: &'a str,\n    }\n    \n    impl<'a> ParserCombinator<'a, &'a str> for Tag<'a> {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {\n            if input.starts_with(self.expected) {\n                Ok((self.expected, &input[self.expected.len()..]))\n            } else {\n                Err(ParseError::Unexpected {\n                    expected: self.expected.to_string(),\n                    found: input.chars().next().map(|c| c.to_string()).unwrap_or_default(),\n                })\n            }\n        }\n    }\n    \n    /// Parse an identifier\n    pub fn identifier<'a>() -> impl ParserCombinator<'a, &'a str> {\n        Identifier\n    }\n    \n    pub struct Identifier;\n    \n    impl<'a> ParserCombinator<'a, &'a str> for Identifier {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, &'a str> {\n            let end = input\n                .char_indices()\n                .find(|(i, c)| {\n                    if *i == 0 {\n                        !c.is_alphabetic() && *c != '_'\n                    } else {\n                        !c.is_alphanumeric() && *c != '_'\n                    }\n                })\n                .map(|(i, _)| i)\n                .unwrap_or(input.len());\n            \n            if end == 0 {\n                Err(ParseError::Failed(\"Expected identifier\".to_string()))\n            } else {\n                Ok((&input[..end], &input[end..]))\n            }\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "combinators",
      "entity_type": "module",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"combinators\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1125,\"end\":1350},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:combinators:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1125-1350",
      "line_number": 0
    },
    {
      "current_code": "pub mod cozo_client;",
      "current_ind": 1,
      "entity_name": "cozo_client",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/storage/mod.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cozo_client\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/mod.rs\",\"line_range\":{\"start\":6,\"end\":6},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cozo_client:__crates_parseltongue-core_src_storage_mod_rs:6-6",
      "line_number": 0
    },
    {
      "current_code": "pub mod cozodb_adapter;",
      "current_ind": 1,
      "entity_name": "cozodb_adapter",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cozodb_adapter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":90,\"end\":90},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cozodb_adapter:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:90-90",
      "line_number": 0
    },
    {
      "current_code": "pub mod cpp {\n    use super::*;\n    use super::c::*;\n    \n    #[derive(Debug, Clone)]\n    pub struct CppAst {\n        pub root: CppTranslationUnit,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct CppTranslationUnit {\n        pub declarations: Vec<CppDeclaration>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum CppDeclaration {\n        C(Declaration),  // Inherit C declarations\n        Class(ClassDecl),\n        Template(TemplateDecl),\n        Namespace(NamespaceDecl),\n        Using(UsingDecl),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ClassDecl {\n        pub name: String,\n        pub bases: Vec<BaseSpecifier>,\n        pub members: Vec<Member>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct BaseSpecifier {\n        pub access: AccessSpecifier,\n        pub is_virtual: bool,\n        pub base_type: Type,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum AccessSpecifier {\n        Public,\n        Protected,\n        Private,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Member {\n        Field(FieldDecl),\n        Method(MethodDecl),\n        Constructor(ConstructorDecl),\n        Destructor(DestructorDecl),\n        TypeAlias(TypeAlias),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct TemplateDecl {\n        pub parameters: Vec<TemplateParameter>,\n        pub declaration: Box<CppDeclaration>,\n        pub source_range: SourceRange,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum TemplateParameter {\n        Type { name: String, default: Option<Type> },\n        NonType { ty: Type, name: String, default: Option<Expression> },\n        Template { parameters: Vec<TemplateParameter>, name: String },\n    }\n    \n    pub struct CppParser {\n        c_parser: CParser,\n        template_cache: TemplateCache,\n        overload_resolver: OverloadResolver,\n    }\n    \n    impl Parser for CppParser {\n        type Input = String;\n        type Output = CppAst;\n        type Error = CppParseError;\n        type Config = CppParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }\n    \n    #[derive(Debug, Error)]\n    pub enum CppParseError {\n        #[error(\"C parse error: {0}\")]\n        CError(#[from] CParseError),\n        \n        #[error(\"Template error: {0}\")]\n        TemplateError(String),\n        \n        #[error(\"Overload resolution failed: {0}\")]\n        OverloadError(String),\n    }\n    \n    #[derive(Debug, Default)]\n    pub struct CppParseConfig {\n        pub standard: CppStandard,\n        pub c_config: CParseConfig,\n    }\n    \n    #[derive(Debug, Default)]\n    pub enum CppStandard {\n        Cpp98,\n        Cpp03,\n        Cpp11,\n        Cpp14,\n        Cpp17,\n        #[default]\n        Cpp20,\n        Cpp23,\n    }\n    \n    pub struct TemplateCache {\n        instantiations: HashMap<(String, Vec<Type>), CppAst>,\n    }\n    \n    pub struct OverloadResolver {\n        candidates: Vec<FunctionDecl>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct FieldDecl {\n        pub name: String,\n        pub ty: Type,\n        pub access: AccessSpecifier,\n        pub is_static: bool,\n        pub is_mutable: bool,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct MethodDecl {\n        pub name: String,\n        pub return_type: Type,\n        pub parameters: Vec<Parameter>,\n        pub access: AccessSpecifier,\n        pub is_static: bool,\n        pub is_virtual: bool,\n        pub is_const: bool,\n        pub body: Option<CompoundStatement>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ConstructorDecl {\n        pub parameters: Vec<Parameter>,\n        pub initializer_list: Vec<MemberInitializer>,\n        pub body: CompoundStatement,\n        pub access: AccessSpecifier,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct MemberInitializer {\n        pub member: String,\n        pub init: Expression,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct DestructorDecl {\n        pub is_virtual: bool,\n        pub body: CompoundStatement,\n        pub access: AccessSpecifier,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct TypeAlias {\n        pub name: String,\n        pub ty: Type,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct NamespaceDecl {\n        pub name: Option<String>,  // None for anonymous namespace\n        pub declarations: Vec<CppDeclaration>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct UsingDecl {\n        pub name: String,\n        pub target: String,\n    }\n}",
      "current_ind": 1,
      "entity_name": "cpp",
      "entity_type": "module",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"cpp\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":506,\"end\":694},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:cpp:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:506-694",
      "line_number": 0
    },
    {
      "current_code": "pub mod diff_generator;",
      "current_ind": 1,
      "entity_name": "diff_generator",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"diff_generator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs\",\"line_range\":{\"start\":52,\"end\":52},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:diff_generator:__crates_pt05-llm-cozodb-to-diff-writer_src_lib_rs:52-52",
      "line_number": 0
    },
    {
      "current_code": "pub mod diff_types;",
      "current_ind": 1,
      "entity_name": "diff_types",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"diff_types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs\",\"line_range\":{\"start\":53,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:diff_types:__crates_pt05-llm-cozodb-to-diff-writer_src_lib_rs:53-53",
      "line_number": 0
    },
    {
      "current_code": "pub mod entities;",
      "current_ind": 1,
      "entity_name": "entities",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"entities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":11,\"end\":11},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:entities:__crates_parseltongue-core_src_lib_rs:11-11",
      "line_number": 0
    },
    {
      "current_code": "pub mod entity_class_integration_tests;",
      "current_ind": 1,
      "entity_name": "entity_class_integration_tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"entity_class_integration_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":99,\"end\":99},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:entity_class_integration_tests:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:99-99",
      "line_number": 0
    },
    {
      "current_code": "mod entity_class_mandatory_tests {\n    use super::*;\n\n    /// GREEN: Test that CodeEntity creation requires EntityClass\n    #[test]\n    fn test_code_entity_creation_requires_entity_class() {\n        // Arrange: Valid entity creation parameters\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"test.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create entity with mandatory EntityClass\n        let entity = CodeEntity::new(\n            \"test.rs-test_function-fn-abc123\".to_string(),\n            signature,\n            EntityClass::CodeImplementation, // v0.9.0: mandatory parameter\n        );\n\n        // Assert: Entity created successfully with EntityClass\n        assert!(entity.is_ok(), \"Entity creation should succeed with EntityClass\");\n        let entity = entity.unwrap();\n        assert_eq!(entity.entity_class, EntityClass::CodeImplementation);\n        assert_eq!(entity.isgl1_key, \"test.rs-test_function-fn-abc123\");\n    }\n\n    /// GREEN: Test that EntityClass is never None/Optional\n    #[test]\n    fn test_entity_class_is_always_present() {\n        // Arrange: Create entities with different classifications\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"code_fn\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"code.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        let test_signature = InterfaceSignature {\n            entity_type: EntityType::TestFunction,\n            name: \"test_fn\".to_string(),\n            visibility: crate::entities::Visibility::Private,\n            file_path: std::path::PathBuf::from(\"code.rs\"),\n            line_range: crate::entities::LineRange::new(1, 3).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create both code and test entities\n        let code_entity = CodeEntity::new(\n            \"code.rs-code_fn-fn-def456\".to_string(),\n            signature,\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        let test_entity = CodeEntity::new(\n            \"code.rs-test_fn-test-ghi012\".to_string(),\n            test_signature,\n            EntityClass::TestImplementation,\n        ).unwrap();\n\n        // Assert: Both entities have definitive EntityClass (no Option/None)\n        assert_eq!(code_entity.entity_class, EntityClass::CodeImplementation);\n        assert_eq!(test_entity.entity_class, EntityClass::TestImplementation);\n        \n        // Verify EntityClass has Copy trait and can be compared directly\n        assert!(code_entity.entity_class == EntityClass::CodeImplementation);\n        assert!(test_entity.entity_class == EntityClass::TestImplementation);\n    }\n\n    /// GREEN: Test database schema includes entity_class column\n    #[test]\n    fn test_database_schema_includes_entity_class() {\n        // This test verifies the CozoDB schema includes entity_class\n        // The actual schema is tested in storage/cozo_client.rs\n        // Here we verify the entity_class field is part of the struct\n        \n        // Arrange: Create an entity\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Struct,\n            name: \"TestStruct\".to_string(),\n            visibility: crate::entities::Visibility::Public,\n            file_path: std::path::PathBuf::from(\"test.rs\"),\n            line_range: crate::entities::LineRange::new(1, 5).unwrap(),\n            module_path: vec![],\n            documentation: None,\n            language_specific: crate::entities::LanguageSpecificSignature::Rust(\n                crate::entities::RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }\n            ),\n        };\n\n        // Act: Create entity\n        let entity = CodeEntity::new(\n            \"test.rs-TestStruct-struct-jkl012\".to_string(),\n            signature,\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Assert: entity_class field exists and is accessible\n        assert_eq!(entity.entity_class.to_string(), \"CODE\");\n        assert_eq!(format!(\"{}\", entity.entity_class), \"CODE\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "entity_class_mandatory_tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"entity_class_mandatory_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":14,\"end\":156},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:entity_class_mandatory_tests:__crates_parseltongue-core_src_entity_class_specifications_rs:14-156",
      "line_number": 0
    },
    {
      "current_code": "pub mod entity_class_specifications;",
      "current_ind": 1,
      "entity_name": "entity_class_specifications",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"entity_class_specifications\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":12,\"end\":12},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:entity_class_specifications:__crates_parseltongue-core_src_lib_rs:12-12",
      "line_number": 0
    },
    {
      "current_code": "pub mod error;",
      "current_ind": 1,
      "entity_name": "error",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"error\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":13,\"end\":13},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:error:__crates_parseltongue-core_src_lib_rs:13-13",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":29,\"end\":29},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:29-29",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":91,\"end\":91},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:91-91",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":20,\"end\":20},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:20-20",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/lib.rs\",\"line_range\":{\"start\":52,\"end\":52},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt04-syntax-preflight-validator_src_lib_rs:52-52",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs\",\"line_range\":{\"start\":56,\"end\":56},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt05-llm-cozodb-to-diff-writer_src_lib_rs:56-56",
      "line_number": 0
    },
    {
      "current_code": "pub mod errors;",
      "current_ind": 1,
      "entity_name": "errors",
      "entity_type": "module",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"errors\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/lib.rs\",\"line_range\":{\"start\":23,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:errors:__crates_pt06-cozodb-make-future-code-current_src_lib_rs:23-23",
      "line_number": 0
    },
    {
      "current_code": "mod exclusion_patterns_tests {\n    use super::*;\n    use std::path::PathBuf;\n    \n    /// Test contract: Single exclusion pattern works\n    #[test]\n    fn test_single_exclusion_pattern_contract() {\n        // Given: Exclusion pattern \".ref\"\n        let patterns = vec![\".ref\".to_string()];\n        \n        // When: Checking path \".ref/tool-semgrep\"\n        let path = PathBuf::from(\".ref/tool-semgrep\");\n        \n        // Then: Should be excluded\n        assert!(should_exclude_path(&path, &patterns));\n        \n        // And: Normal source code should not be excluded\n        let src_path = PathBuf::from(\"src/main.rs\");\n        assert!(!should_exclude_path(&src_path, &patterns));\n    }\n    \n    /// Test contract: Multiple exclusion patterns work\n    #[test]\n    fn test_multiple_exclusion_patterns_contract() {\n        // Given: Multiple exclusion patterns\n        let patterns = vec![\".ref\".to_string(), \"archive\".to_string(), \"tmp\".to_string()];\n        \n        // When: Checking various paths\n        let ref_path = PathBuf::from(\".ref/tool-semgrep\");\n        let archive_path = PathBuf::from(\"archive/old-project\");\n        let tmp_path = PathBuf::from(\"tmp/cache\");\n        let src_path = PathBuf::from(\"src/main.rs\");\n        \n        // Then: Correct exclusion decisions\n        assert!(should_exclude_path(&ref_path, &patterns));      // .ref excluded\n        assert!(should_exclude_path(&archive_path, &patterns));  // archive excluded\n        assert!(should_exclude_path(&tmp_path, &patterns));      // tmp excluded\n        assert!(!should_exclude_path(&src_path, &patterns));     // src included\n    }\n    \n    /// Performance contract: Pattern matching speed\n    #[test]\n    fn test_pattern_matching_performance_contract() {\n        // Given: 100 exclusion patterns\n        let patterns: Vec<String> = (0..100)\n            .map(|i| format!(\"pattern_{}\", i))\n            .collect();\n        \n        let test_path = PathBuf::from(\"pattern_42/some_file.rs\");\n        \n        // When: Matching pattern\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            should_exclude_path(&test_path, &patterns);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<10s per check)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(10),\n                \"Pattern matching took {:?}, expected <10s\", avg_time_per_check);\n    }\n}",
      "current_ind": 1,
      "entity_name": "exclusion_patterns_tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"exclusion_patterns_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":32,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:exclusion_patterns_tests:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:32-94",
      "line_number": 0
    },
    {
      "current_code": "pub mod export_trait;",
      "current_ind": 1,
      "entity_name": "export_trait",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"export_trait\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":92,\"end\":92},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:export_trait:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:92-92",
      "line_number": 0
    },
    {
      "current_code": "pub mod exporters;",
      "current_ind": 1,
      "entity_name": "exporters",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"exporters\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":93,\"end\":93},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:exporters:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:93-93",
      "line_number": 0
    },
    {
      "current_code": "mod git_subfolder_tests {\n    use super::*;\n    use std::path::PathBuf;\n    \n    /// Test contract: Nested git repository detection\n    #[test]\n    fn test_nested_git_repo_detection_contract() {\n        // Given: Create a temporary directory structure for testing\n        let temp_dir = tempfile::tempdir().unwrap();\n        let project_root = temp_dir.path();\n        \n        // Create nested structure with .git\n        let nested_dir = project_root.join(\".ref\").join(\"tool-semgrep\");\n        std::fs::create_dir_all(&nested_dir).unwrap();\n        let nested_git = nested_dir.join(\".git\");\n        std::fs::create_dir(&nested_git).unwrap();\n        \n        let test_file = nested_dir.join(\"some_file.rs\");\n        \n        // When: Checking if test_file is under git subdirectory\n        let is_nested = is_under_git_subdirectory(&test_file, project_root);\n        \n        // Then: Should detect as nested git repo\n        assert!(is_nested, \"Should detect nested git repository\");\n    }\n    \n    /// Test contract: Project root git is not excluded\n    #[test]\n    fn test_project_root_git_not_excluded_contract() {\n        // Given: Create a temporary directory structure for testing\n        let temp_dir = tempfile::tempdir().unwrap();\n        let project_root = temp_dir.path();\n        \n        // Create project root .git\n        let project_git = project_root.join(\".git\");\n        std::fs::create_dir(&project_git).unwrap();\n        \n        let test_file = project_root.join(\"src/main.rs\");\n        \n        // When: Checking project root file\n        let is_nested = is_under_git_subdirectory(&test_file, project_root);\n        \n        // Then: Should NOT be considered nested (it's the main repo)\n        assert!(!is_nested, \"Project root .git should not be excluded\");\n    }\n    \n    /// Performance contract: Git detection speed\n    #[test]\n    fn test_git_detection_performance_contract() {\n        // Given: Deep path structure\n        let project_root = PathBuf::from(\"/project\");\n        let deep_path = PathBuf::from(\"/project/a/b/c/d/e/f/g/h/i/j/file.rs\");\n        \n        // When: Checking for nested git\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            is_under_git_subdirectory(&deep_path, &project_root);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<50s per check)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(50),\n                \"Git detection took {:?}, expected <50s\", avg_time_per_check);\n    }\n}",
      "current_ind": 1,
      "entity_name": "git_subfolder_tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"git_subfolder_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":122,\"end\":187},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:git_subfolder_tests:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:122-187",
      "line_number": 0
    },
    {
      "current_code": "pub mod interfaces;",
      "current_ind": 1,
      "entity_name": "interfaces",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"interfaces\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":14,\"end\":14},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:interfaces:__crates_parseltongue-core_src_lib_rs:14-14",
      "line_number": 0
    },
    {
      "current_code": "pub mod isgl1_generator;",
      "current_ind": 1,
      "entity_name": "isgl1_generator",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"isgl1_generator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":30,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:isgl1_generator:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:30-30",
      "line_number": 0
    },
    {
      "current_code": "pub mod level0;",
      "current_ind": 1,
      "entity_name": "level0",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"level0\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs\",\"line_range\":{\"start\":13,\"end\":13},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:level0:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_mod_rs:13-13",
      "line_number": 0
    },
    {
      "current_code": "pub mod level1;",
      "current_ind": 1,
      "entity_name": "level1",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"level1\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs\",\"line_range\":{\"start\":14,\"end\":14},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:level1:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_mod_rs:14-14",
      "line_number": 0
    },
    {
      "current_code": "pub mod level2;",
      "current_ind": 1,
      "entity_name": "level2",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"level2\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/mod.rs\",\"line_range\":{\"start\":15,\"end\":15},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:level2:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_mod_rs:15-15",
      "line_number": 0
    },
    {
      "current_code": "pub mod lsp_client;",
      "current_ind": 1,
      "entity_name": "lsp_client",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"lsp_client\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":31,\"end\":31},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:lsp_client:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:31-31",
      "line_number": 0
    },
    {
      "current_code": "pub mod mocks {\n    use super::*;\n\n    /// Mock tool implementation\n    #[derive(Debug)]\n    pub struct MockTool {\n        pub metadata: ToolMetadata,\n        pub execute_result: Option<Result<ToolOutput>>,\n        pub should_fail: bool,\n    }\n\n    impl MockTool {\n        pub fn new(name: &str) -> Self {\n            Self {\n                metadata: ToolMetadata {\n                    id: format!(\"mock-{}\", name),\n                    name: name.to_string(),\n                    version: \"1.0.0\".to_string(),\n                    description: format!(\"Mock implementation of {}\", name),\n                    supported_inputs: vec![],\n                    capabilities: ToolCapabilities {\n                        async_execution: true,\n                        parallel_processing: false,\n                        incremental_processing: false,\n                        requires_network: false,\n                        max_input_size: None,\n                    },\n                },\n                execute_result: None,\n                should_fail: false,\n            }\n        }\n\n        pub fn with_execute_result(mut self, result: Result<ToolOutput>) -> Self {\n            self.execute_result = Some(result);\n            self\n        }\n\n        pub fn with_failure(mut self) -> Self {\n            self.should_fail = true;\n            self\n        }\n    }\n\n    #[async_trait]\n    impl Tool for MockTool {\n        async fn execute(&self, _input: ToolInput) -> Result<ToolOutput> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ConfigurationError {\n                    details: \"Mock tool configured to fail\".to_string(),\n                });\n            }\n\n            self.execute_result\n                .clone()\n                .unwrap_or(Ok(ToolOutput::IndexingComplete {\n                    entities_count: 0,\n                    duration_ms: 0,\n                }))\n        }\n\n        fn validate_input(&self, _input: &ToolInput) -> Result<()> {\n            if self.should_fail {\n                return Err(crate::error::ParseltongError::ValidationError {\n                    field: \"input\".to_string(),\n                    expected: \"valid input\".to_string(),\n                    actual: \"mock failure\".to_string(),\n                });\n            }\n            Ok(())\n        }\n\n        fn metadata(&self) -> ToolMetadata {\n            self.metadata.clone()\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "mocks",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"mocks\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":537,\"end\":613},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:mocks:__crates_parseltongue-core_src_interfaces_rs:537-613",
      "line_number": 0
    },
    {
      "current_code": "pub mod models;",
      "current_ind": 1,
      "entity_name": "models",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"models\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":94,\"end\":94},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:models:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:94-94",
      "line_number": 0
    },
    {
      "current_code": "mod pt01_classification_tests {\n    use super::*;\n\n    /// GREEN: Test PT01 classifies test files correctly\n    #[test]\n    fn test_pt01_classifies_test_files() {\n        // This test verifies the test detector can classify test files\n        // Actual PT01 integration is tested in pt01 crate\n        \n        // Arrange: Test file patterns\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn test_main() {}\", EntityClass::CodeImplementation),\n            (\"tests/integration_test.rs\", \"fn test_integration() {}\", EntityClass::TestImplementation),\n            (\"src/utils_test.rs\", \"fn test_utils() {}\", EntityClass::TestImplementation),\n            (\"test/unit_test.rs\", \"fn test_unit() {}\", EntityClass::TestImplementation),\n        ];\n\n        // Act & Assert: Verify classification logic\n        for (file_path, _content, expected_class) in test_cases {\n            // Simulate PT01 classification logic\n            let is_test_file = file_path.contains(\"test\") || \n                              file_path.starts_with(\"tests/\") || \n                              file_path.starts_with(\"test/\");\n            \n            let actual_class = if is_test_file {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            };\n\n            assert_eq!(actual_class, expected_class, \n                      \"File '{}' should be classified as {:?}\", file_path, expected_class);\n        }\n    }\n\n    /// GREEN: Test PT01 classifies production code correctly\n    #[test]\n    fn test_pt01_classifies_production_code() {\n        // Arrange: Production file patterns\n        let prod_cases = vec![\n            (\"src/lib.rs\", \"pub fn main() {}\", EntityClass::CodeImplementation),\n            (\"src/utils/mod.rs\", \"pub mod utils\", EntityClass::CodeImplementation),\n            (\"src/main.rs\", \"fn main() {}\", EntityClass::CodeImplementation),\n            (\"src/core.rs\", \"struct Core {}\", EntityClass::CodeImplementation),\n        ];\n\n        // Act & Assert: Verify classification logic\n        for (file_path, _content, expected_class) in prod_cases {\n            // Simulate PT01 classification logic\n            let is_test_file = file_path.contains(\"test\") || \n                              file_path.starts_with(\"tests/\") || \n                              file_path.starts_with(\"test/\");\n            \n            let actual_class = if is_test_file {\n                EntityClass::TestImplementation\n            } else {\n                EntityClass::CodeImplementation\n            };\n\n            assert_eq!(actual_class, expected_class, \n                      \"File '{}' should be classified as {:?}\", file_path, expected_class);\n        }\n    }\n\n    /// GREEN: Test classification performance contract\n    #[test]\n    fn test_classification_performance_contract() {\n        // Arrange: Test file for classification\n        let file_path = \"src/test_module.rs\";\n        let start_time = std::time::Instant::now();\n\n        // Act: Perform classification (simulating PT01 logic)\n        let is_test_file = file_path.contains(\"test\") || \n                          file_path.starts_with(\"tests/\") || \n                          file_path.starts_with(\"test/\");\n        \n        let entity_class = if is_test_file {\n            EntityClass::TestImplementation\n        } else {\n            EntityClass::CodeImplementation\n        };\n\n        let elapsed = start_time.elapsed();\n\n        // Assert: Classification completes within performance contract\n        assert!(elapsed.as_micros() < 50, \n               \"Classification should complete within 50s, took {}s\", \n               elapsed.as_micros());\n        \n        assert_eq!(entity_class, EntityClass::TestImplementation);\n    }\n}",
      "current_ind": 1,
      "entity_name": "pt01_classification_tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"pt01_classification_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":164,\"end\":255},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:pt01_classification_tests:__crates_parseltongue-core_src_entity_class_specifications_rs:164-255",
      "line_number": 0
    },
    {
      "current_code": "mod pt02_entity_class_tests {\n    use super::*;\n\n    /// STUB: Test that Entity struct includes entity_class field\n    #[test]\n    fn test_entity_struct_includes_entity_class() {\n        // This test will fail initially - Entity struct missing entity_class\n        let entity = Entity {\n            isgl1_key: \"test\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 1,\n            future_action: None,\n            future_code: None,\n            current_code: None,\n            entity_name: \"test\".to_string(),\n            entity_type: \"Function\".to_string(),\n            file_path: \"test.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"fn test()\".to_string(),\n            doc_comment: None,\n            entity_class: \"CODE\".to_string(), // v0.9.0: This field should exist\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: None,\n            is_async: None,\n            is_unsafe: None,\n        };\n        \n        assert_eq!(entity.entity_class, \"CODE\");\n    }\n\n    /// STUB: Test that database queries select entity_class column\n    #[tokio::test]\n    async fn test_database_query_selects_entity_class() {\n        // This test will fail initially - queries don't select entity_class\n        // Mock the database to verify the query includes entity_class\n        \n        // Arrange: Create mock storage that captures queries\n        // Act: Query entities \n        // Assert: Query includes entity_class in SELECT and FROM clauses\n        \n        // For now, this is a placeholder that will be implemented\n        // when we have the proper mock infrastructure\n        assert!(true, \"Placeholder - will implement actual query verification\");\n    }\n\n    /// STUB: Test that entities can be filtered by EntityClass\n    #[test]\n    fn test_filter_entities_by_entity_class() {\n        // Arrange: Create mixed entities\n        let code_entity = create_test_entity(\"code.rs\", \"CODE\");\n        let test_entity = create_test_entity(\"test.rs\", \"TEST\");\n        let entities = vec![code_entity, test_entity];\n        \n        // Act: Filter by entity_class\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"CODE\")\n            .collect();\n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"TEST\")\n            .collect();\n        \n        // Assert: Proper separation\n        assert_eq!(code_entities.len(), 1);\n        assert_eq!(test_entities.len(), 1);\n        assert_eq!(code_entities[0].entity_class, \"CODE\");\n        assert_eq!(test_entities[0].entity_class, \"TEST\");\n    }\n\n    /// STUB: Test that dual output generation uses EntityClass\n    #[test]\n    fn test_dual_output_uses_entity_class() {\n        // This test will fail initially - dual output logic not implemented\n        // Arrange: Mixed entities\n        let entities = vec![\n            create_test_entity(\"src/main.rs\", \"CODE\"),\n            create_test_entity(\"tests/integration.rs\", \"TEST\"),\n        ];\n        \n        // Act: Separate by entity_class\n        let (code_entities, test_entities) = separate_by_entity_class(entities);\n        \n        // Assert: Proper separation for dual outputs\n        assert_eq!(code_entities.len(), 1);\n        assert_eq!(test_entities.len(), 1);\n        assert!(code_entities[0].file_path.contains(\"src/\"));\n        assert!(test_entities[0].file_path.contains(\"tests/\"));\n    }\n\n    /// STUB: Test performance of EntityClass filtering\n    #[test]\n    fn test_entity_class_filtering_performance() {\n        // This test validates performance contract: <10ms for 10K entities\n        let start = std::time::Instant::now();\n        \n        // Arrange: Create 10K test entities\n        let entities: Vec<Entity> = (0..10000)\n            .map(|i| create_test_entity(&format!(\"file{}.rs\", i), if i % 2 == 0 { \"CODE\" } else { \"TEST\" }))\n            .collect();\n        \n        // Act: Filter by entity_class\n        let _code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == \"CODE\")\n            .collect();\n        \n        let duration = start.elapsed();\n        assert!(duration.as_millis() < 10, \"EntityClass filtering took {:?}, expected <10ms\", duration);\n    }\n}",
      "current_ind": 1,
      "entity_name": "pt02_entity_class_tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"pt02_entity_class_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/entity_class_integration_tests.rs\",\"line_range\":{\"start\":17,\"end\":130},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:pt02_entity_class_tests:__crates_pt02-llm-cozodb-to-context-writer_src_entity_class_integration_tests_rs:17-130",
      "line_number": 0
    },
    {
      "current_code": "mod pt02_filtering_tests {\n    use super::*;\n\n    /// GREEN: Test PT02 can filter code entities\n    #[test]\n    fn test_pt02_filters_code_entities() {\n        // Arrange: Create entities with different classifications\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"code2.rs\", \"fn code2()\", EntityClass::CodeImplementation),\n        ];\n\n        // Act: Filter for code entities (simulating PT02 query)\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::CodeImplementation)\n            .collect();\n\n        // Assert: Only code entities returned\n        assert_eq!(code_entities.len(), 2, \"Should return 2 code entities\");\n        assert!(code_entities.iter().all(|e| e.entity_class == EntityClass::CodeImplementation));\n    }\n\n    /// GREEN: Test PT02 can filter test entities\n    #[test]\n    fn test_pt02_filters_test_entities() {\n        // Arrange: Create entities with different classifications\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"test2.rs\", \"fn test2()\", EntityClass::TestImplementation),\n        ];\n\n        // Act: Filter for test entities (simulating PT02 query)\n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::TestImplementation)\n            .collect();\n\n        // Assert: Only test entities returned\n        assert_eq!(test_entities.len(), 2, \"Should return 2 test entities\");\n        assert!(test_entities.iter().all(|e| e.entity_class == EntityClass::TestImplementation));\n    }\n\n    /// GREEN: Test dual output generation\n    #[test]\n    fn test_pt02_dual_output_generation() {\n        // Arrange: Create mixed entities\n        let entities = vec![\n            create_test_entity(\"code1.rs\", \"fn code1()\", EntityClass::CodeImplementation),\n            create_test_entity(\"test1.rs\", \"fn test1()\", EntityClass::TestImplementation),\n            create_test_entity(\"code2.rs\", \"fn code2()\", EntityClass::CodeImplementation),\n        ];\n\n        // Act: Separate into code and test outputs (simulating PT02 dual output)\n        let code_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::CodeImplementation)\n            .collect();\n        \n        let test_entities: Vec<_> = entities.iter()\n            .filter(|e| e.entity_class == EntityClass::TestImplementation)\n            .collect();\n\n        // Assert: Proper separation for dual outputs\n        assert_eq!(code_entities.len(), 2, \"Code output should have 2 entities\");\n        assert_eq!(test_entities.len(), 1, \"Tests output should have 1 entity\");\n        \n        // Verify no overlap\n        let code_keys: std::collections::HashSet<_> = code_entities.iter()\n            .map(|e| &e.isgl1_key).collect();\n        let test_keys: std::collections::HashSet<_> = test_entities.iter()\n            .map(|e| &e.isgl1_key).collect();\n        \n        assert!(code_keys.intersection(&test_keys).next().is_none(), \n               \"Code and test outputs should not overlap\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "pt02_filtering_tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"pt02_filtering_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":263,\"end\":338},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:pt02_filtering_tests:__crates_parseltongue-core_src_entity_class_specifications_rs:263-338",
      "line_number": 0
    },
    {
      "current_code": "mod pt03_preservation_tests {\n    use super::*;\n\n    /// GREEN: Test PT03 preserves EntityClass during edits\n    #[test]\n    fn test_pt03_preserves_entity_class_during_edits() {\n        // Arrange: Create entity with specific classification\n        let mut entity = create_test_entity(\"code.rs\", \"fn original()\", EntityClass::CodeImplementation);\n        let original_class = entity.entity_class;\n\n        // Act: Simulate PT03 edit operation (update future code)\n        entity.apply_temporal_change(\n            crate::entities::TemporalAction::Edit,\n            Some(\"fn updated() { /* new implementation */ }\".to_string()),\n        ).unwrap();\n\n        // Assert: EntityClass preserved during edit\n        assert_eq!(entity.entity_class, original_class, \n                  \"EntityClass should be preserved during PT03 edits\");\n        assert_eq!(entity.entity_class, EntityClass::CodeImplementation);\n    }\n\n    /// GREEN: Test PT03 cannot change EntityClass\n    #[test]\n    fn test_pt03_cannot_change_entity_class() {\n        // Arrange: Create entity with specific classification\n        let mut entity = create_test_entity(\"test.rs\", \"fn test_fn()\", EntityClass::TestImplementation);\n        let original_class = entity.entity_class;\n\n        // Act: Attempt various PT03 operations\n        entity.apply_temporal_change(crate::entities::TemporalAction::Create, None).unwrap();\n        entity.apply_temporal_change(crate::entities::TemporalAction::Edit, Some(\"new code\".to_string())).unwrap();\n        entity.apply_temporal_change(crate::entities::TemporalAction::Delete, None).unwrap();\n\n        // Assert: EntityClass never changes through PT03 operations\n        assert_eq!(entity.entity_class, original_class, \n                  \"EntityClass should never change through PT03 operations\");\n        assert_eq!(entity.entity_class, EntityClass::TestImplementation);\n    }\n}",
      "current_ind": 1,
      "entity_name": "pt03_preservation_tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/entity_class_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"pt03_preservation_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entity_class_specifications.rs\",\"line_range\":{\"start\":346,\"end\":385},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:pt03_preservation_tests:__crates_parseltongue-core_src_entity_class_specifications_rs:346-385",
      "line_number": 0
    },
    {
      "current_code": "pub mod query_builder;",
      "current_ind": 1,
      "entity_name": "query_builder",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"query_builder\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/lib.rs\",\"line_range\":{\"start\":95,\"end\":95},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:query_builder:__crates_pt02-llm-cozodb-to-context-writer_src_lib_rs:95-95",
      "line_number": 0
    },
    {
      "current_code": "pub mod query_extractor;",
      "current_ind": 1,
      "entity_name": "query_extractor",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"query_extractor\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":15,\"end\":15},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:query_extractor:__crates_parseltongue-core_src_lib_rs:15-15",
      "line_number": 0
    },
    {
      "current_code": "pub mod rails {\n    use super::*;\n    \n    #[derive(Debug, Clone)]\n    pub struct RailsAst {\n        pub root: RailsFile,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum RailsFile {\n        Model(ModelFile),\n        Controller(ControllerFile),\n        View(ViewFile),\n        Migration(MigrationFile),\n        Routes(RoutesFile),\n        Ruby(RubyFile),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ModelFile {\n        pub class_name: String,\n        pub parent: String,\n        pub associations: Vec<Association>,\n        pub validations: Vec<Validation>,\n        pub scopes: Vec<Scope>,\n        pub methods: Vec<Method>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Association {\n        HasMany { name: String, options: HashMap<String, Value> },\n        HasOne { name: String, options: HashMap<String, Value> },\n        BelongsTo { name: String, options: HashMap<String, Value> },\n        HasAndBelongsToMany { name: String, options: HashMap<String, Value> },\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Validation {\n        pub attribute: String,\n        pub kind: ValidationKind,\n        pub options: HashMap<String, Value>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum ValidationKind {\n        Presence,\n        Uniqueness,\n        Length,\n        Format,\n        Inclusion,\n        Custom(String),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Scope {\n        pub name: String,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Method {\n        pub name: String,\n        pub parameters: Vec<Parameter>,\n        pub body: Block,\n        pub visibility: Visibility,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Visibility {\n        Public,\n        Protected,\n        Private,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Block {\n        pub statements: Vec<Statement>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Statement {\n        Expression(Expression),\n        Assignment(Assignment),\n        MethodCall(MethodCall),\n        Return(Option<Expression>),\n        If(IfStatement),\n        Unless(UnlessStatement),\n        While(WhileStatement),\n        For(ForStatement),\n        Block(Block),\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Expression {\n        pub kind: ExpressionKind,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum ExpressionKind {\n        Literal(Value),\n        Variable(String),\n        MethodCall(MethodCall),\n        Binary { op: String, left: Box<Expression>, right: Box<Expression> },\n        Unary { op: String, operand: Box<Expression> },\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Value {\n        Nil,\n        Boolean(bool),\n        Integer(i64),\n        Float(f64),\n        String(String),\n        Symbol(String),\n        Array(Vec<Value>),\n        Hash(HashMap<Value, Value>),\n    }\n    \n    // Make Value hashable for use in HashMap keys\n    impl std::hash::Hash for Value {\n        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n            match self {\n                Value::Nil => 0.hash(state),\n                Value::Boolean(b) => b.hash(state),\n                Value::Integer(i) => i.hash(state),\n                Value::Float(f) => f.to_bits().hash(state),\n                Value::String(s) => s.hash(state),\n                Value::Symbol(s) => s.hash(state),\n                Value::Array(a) => a.hash(state),\n                Value::Hash(_) => 0.hash(state), // Simplified\n            }\n        }\n    }\n    \n    impl Eq for Value {}\n    impl PartialEq for Value {\n        fn eq(&self, other: &Self) -> bool {\n            match (self, other) {\n                (Value::Nil, Value::Nil) => true,\n                (Value::Boolean(a), Value::Boolean(b)) => a == b,\n                (Value::Integer(a), Value::Integer(b)) => a == b,\n                (Value::Float(a), Value::Float(b)) => a == b,\n                (Value::String(a), Value::String(b)) => a == b,\n                (Value::Symbol(a), Value::Symbol(b)) => a == b,\n                (Value::Array(a), Value::Array(b)) => a == b,\n                (Value::Hash(a), Value::Hash(b)) => a == b,\n                _ => false,\n            }\n        }\n    }\n    \n    pub struct RailsParser {\n        ruby_parser: RubyParser,\n        pattern_matcher: PatternMatcher,\n    }\n    \n    impl Parser for RailsParser {\n        type Input = String;\n        type Output = RailsAst;\n        type Error = RailsParseError;\n        type Config = RailsParseConfig;\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n        \n        fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            todo!()\n        }\n    }\n    \n    #[derive(Debug, Error)]\n    pub enum RailsParseError {\n        #[error(\"Ruby parse error: {0}\")]\n        RubyError(String),\n        \n        #[error(\"Rails DSL error: {0}\")]\n        DslError(String),\n        \n        #[error(\"Pattern match failed: {0}\")]\n        PatternError(String),\n    }\n    \n    #[derive(Debug, Default)]\n    pub struct RailsParseConfig {\n        pub rails_version: RailsVersion,\n        pub strict_mode: bool,\n    }\n    \n    #[derive(Debug, Default)]\n    pub enum RailsVersion {\n        Rails5,\n        Rails6,\n        #[default]\n        Rails7,\n    }\n    \n    pub struct RubyParser {\n        lexer: RubyLexer,\n    }\n    \n    pub struct RubyLexer {\n        keywords: HashMap<String, TokenType>,\n    }\n    \n    pub struct PatternMatcher {\n        patterns: Vec<Pattern>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Pattern {\n        pub name: String,\n        pub regex: String,\n        pub captures: Vec<String>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum TokenType {\n        Keyword(Keyword),\n        Identifier,\n        Symbol,\n        String,\n        Integer,\n        Float,\n        Operator,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum Keyword {\n        Class,\n        Module,\n        Def,\n        End,\n        If,\n        Unless,\n        While,\n        For,\n        Return,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Parameter {\n        pub name: String,\n        pub default: Option<Value>,\n        pub kind: ParameterKind,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum ParameterKind {\n        Required,\n        Optional,\n        Rest,\n        Keyword,\n        Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Assignment {\n        pub target: String,\n        pub value: Expression,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct MethodCall {\n        pub receiver: Option<Box<Expression>>,\n        pub method: String,\n        pub arguments: Vec<Expression>,\n        pub block: Option<Block>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct IfStatement {\n        pub condition: Expression,\n        pub then_branch: Block,\n        pub else_branch: Option<Block>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct UnlessStatement {\n        pub condition: Expression,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct WhileStatement {\n        pub condition: Expression,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ForStatement {\n        pub variable: String,\n        pub collection: Expression,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ControllerFile {\n        pub class_name: String,\n        pub parent: String,\n        pub filters: Vec<Filter>,\n        pub actions: Vec<Action>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Filter {\n        pub kind: FilterKind,\n        pub name: String,\n        pub options: HashMap<String, Value>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum FilterKind {\n        Before,\n        After,\n        Around,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Action {\n        pub name: String,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct ViewFile {\n        pub template_type: TemplateType,\n        pub content: String,\n        pub embedded_ruby: Vec<EmbeddedRuby>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum TemplateType {\n        Html,\n        Erb,\n        Haml,\n        Slim,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct EmbeddedRuby {\n        pub kind: ErbKind,\n        pub code: String,\n        pub position: usize,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum ErbKind {\n        Expression,  // <%= %>\n        Statement,   // <% %>\n        Comment,     // <%# %>\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct MigrationFile {\n        pub class_name: String,\n        pub version: String,\n        pub up_method: Option<Block>,\n        pub down_method: Option<Block>,\n        pub change_method: Option<Block>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct RoutesFile {\n        pub routes: Vec<Route>,\n        pub namespaces: Vec<Namespace>,\n        pub resources: Vec<Resource>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Route {\n        pub method: HttpMethod,\n        pub path: String,\n        pub controller_action: String,\n        pub constraints: HashMap<String, String>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub enum HttpMethod {\n        Get,\n        Post,\n        Put,\n        Patch,\n        Delete,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Namespace {\n        pub name: String,\n        pub routes: Vec<Route>,\n        pub resources: Vec<Resource>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Resource {\n        pub name: String,\n        pub only: Option<Vec<String>>,\n        pub except: Option<Vec<String>>,\n        pub nested: Vec<Resource>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct RubyFile {\n        pub classes: Vec<Class>,\n        pub modules: Vec<Module>,\n        pub methods: Vec<Method>,\n        pub statements: Vec<Statement>,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Class {\n        pub name: String,\n        pub parent: Option<String>,\n        pub body: Block,\n    }\n    \n    #[derive(Debug, Clone)]\n    pub struct Module {\n        pub name: String,\n        pub body: Block,\n    }\n}",
      "current_ind": 1,
      "entity_name": "rails",
      "entity_type": "module",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"rails\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":697,\"end\":1119},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:rails:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:697-1119",
      "line_number": 0
    },
    {
      "current_code": "pub mod simple_validator;",
      "current_ind": 1,
      "entity_name": "simple_validator",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"simple_validator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/lib.rs\",\"line_range\":{\"start\":49,\"end\":49},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:simple_validator:__crates_pt04-syntax-preflight-validator_src_lib_rs:49-49",
      "line_number": 0
    },
    {
      "current_code": "pub mod state_reset;",
      "current_ind": 1,
      "entity_name": "state_reset",
      "entity_type": "module",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"state_reset\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/lib.rs\",\"line_range\":{\"start\":24,\"end\":24},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:state_reset:__crates_pt06-cozodb-make-future-code-current_src_lib_rs:24-24",
      "line_number": 0
    },
    {
      "current_code": "pub mod storage;",
      "current_ind": 1,
      "entity_name": "storage",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"storage\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":16,\"end\":16},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:storage:__crates_parseltongue-core_src_lib_rs:16-16",
      "line_number": 0
    },
    {
      "current_code": "pub mod streamer;",
      "current_ind": 1,
      "entity_name": "streamer",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"streamer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":32,\"end\":32},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:streamer:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:32-32",
      "line_number": 0
    },
    {
      "current_code": "mod streamer_lsp_tests;",
      "current_ind": 1,
      "entity_name": "streamer_lsp_tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"streamer_lsp_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":613,\"end\":613},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:streamer_lsp_tests:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:613-613",
      "line_number": 0
    },
    {
      "current_code": "pub mod temporal;",
      "current_ind": 1,
      "entity_name": "temporal",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"temporal\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/lib.rs\",\"line_range\":{\"start\":17,\"end\":17},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:temporal:__crates_parseltongue-core_src_lib_rs:17-17",
      "line_number": 0
    },
    {
      "current_code": "mod test_detection_tests {\n    use super::*;\n    use std::path::PathBuf;\n    \n    /// Test contract: Rust test detection\n    #[test]\n    fn test_rust_test_detection_contract() {\n        // Given: Rust test patterns\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn normal_function() { }\", false),\n            (\"tests/integration_test.rs\", \"#[test] fn test_integration() { }\", true),\n            (\"src/module_test.rs\", \"#[tokio::test] async fn test_async() { }\", true),\n            (\"src/benches/bench.rs\", \"#[test] fn test_unit() { }\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test, \n                      \"File {} with content should be test: {}\", file_path, expected_is_test);\n        }\n    }\n    \n    /// Test contract: Go test detection\n    #[test]\n    fn test_go_test_detection_contract() {\n        // Given: Go test patterns\n        let test_cases = vec![\n            (\"main.go\", \"func main() { }\", false),\n            (\"main_test.go\", \"func TestMain(t *testing.T) { }\", true),\n            (\"integration_test.go\", \"func ExampleUsage() { }\", true),\n            (\"benchmark_test.go\", \"func BenchmarkAlgorithm(b *testing.B) { }\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test,\n                      \"Go file {} should be test: {}\", file_path, expected_is_test);\n        }\n    }\n    \n    /// Test contract: JavaScript/TypeScript test detection\n    #[test]\n    fn test_javascript_test_detection_contract() {\n        // Given: JS/TS test patterns\n        let test_cases = vec![\n            (\"src/app.js\", \"function runApp() { }\", false),\n            (\"src/app.test.js\", \"test('app runs', () => { })\", true),\n            (\"utils.spec.ts\", \"describe('utils', () => { })\", true),\n            (\"__tests__/helper.js\", \"expect(true).toBe(true)\", true),\n        ];\n        \n        for (file_path, content, expected_is_test) in test_cases {\n            // When: Detecting test status\n            let is_test = detect_test_from_content(&PathBuf::from(file_path), content);\n            \n            // Then: Correct classification\n            assert_eq!(is_test, expected_is_test,\n                      \"JS/TS file {} should be test: {}\", file_path, expected_is_test);\n        }\n    }\n    \n    /// Performance contract: Test detection speed\n    #[test]\n    fn test_test_detection_performance_contract() {\n        // Given: Large file content\n        let content = \"fn regular_function() { }\\n\".repeat(1000);\n        let test_path = PathBuf::from(\"src/lib.rs\");\n        \n        // When: Detecting test status\n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            detect_test_from_content(&test_path, &content);\n        }\n        let elapsed = start.elapsed();\n        \n        // Then: Performance contract satisfied (<50s per detection - adjusted for reality)\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(50),\n                \"Test detection took {:?}, expected <50s\", avg_time_per_check);\n    }\n}",
      "current_ind": 1,
      "entity_name": "test_detection_tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"test_detection_tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/v090_specifications.rs\",\"line_range\":{\"start\":221,\"end\":307},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:test_detection_tests:__crates_pt01-folder-to-cozodb-streamer_src_v090_specifications_rs:221-307",
      "line_number": 0
    },
    {
      "current_code": "pub mod test_detector;",
      "current_ind": 1,
      "entity_name": "test_detector",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"test_detector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":33,\"end\":33},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:test_detector:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:33-33",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use quickcheck::{Arbitrary, Gen, QuickCheck};\n    use criterion::{black_box, criterion_group, criterion_main, Criterion};\n    \n    /// Property-based testing for parsers\n    #[test]\n    fn test_parser_roundtrip() {\n        fn prop_roundtrip(ast: TestAst) -> bool {\n            let printed = ast.to_string();\n            let parsed = TestParser.parse(printed.clone());\n            match parsed {\n                Ok(parsed_ast) => parsed_ast == ast,\n                Err(_) => false,\n            }\n        }\n        \n        QuickCheck::new()\n            .tests(1000)\n            .quickcheck(prop_roundtrip as fn(TestAst) -> bool);\n    }\n    \n    /// Performance benchmarks\n    fn benchmark_parsing(c: &mut Criterion) {\n        let input = include_str!(\"../testdata/large_file.c\");\n        \n        c.bench_function(\"parse_c_10k_loc\", |b| {\n            b.iter(|| {\n                let parser = c::CParser::new();\n                black_box(parser.parse(input.to_string()));\n            });\n        });\n    }\n    \n    /// Stub types for testing\n    #[derive(Debug, Clone, PartialEq)]\n    struct TestAst {\n        nodes: Vec<TestNode>,\n    }\n    \n    #[derive(Debug, Clone, PartialEq)]\n    struct TestNode {\n        kind: String,\n        value: String,\n    }\n    \n    impl Arbitrary for TestAst {\n        fn arbitrary(g: &mut Gen) -> Self {\n            TestAst {\n                nodes: Vec::arbitrary(g),\n            }\n        }\n    }\n    \n    impl std::fmt::Display for TestAst {\n        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n            // Simple serialization for testing\n            write!(f, \"{:?}\", self)\n        }\n    }\n    \n    struct TestParser;\n    \n    impl Parser for TestParser {\n        type Input = String;\n        type Output = TestAst;\n        type Error = std::io::Error;\n        type Config = ();\n        \n        fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error> {\n            // Stub implementation\n            Ok(TestAst { nodes: vec![] })\n        }\n        \n        fn parse_with_config(&self, _input: Self::Input, _config: Self::Config) \n            -> Result<Self::Output, Self::Error> {\n            Ok(TestAst { nodes: vec![] })\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1357,\"end\":1436},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1357-1436",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn temporal_state_validation() {\n        let state = TemporalState::unchanged();\n        assert!(state.validate().is_ok());\n        assert!(!state.is_changed());\n\n        let edit_state = TemporalState::edit();\n        assert!(edit_state.validate().is_ok());\n        assert!(edit_state.is_changed());\n    }\n\n    #[test]\n    fn invalid_temporal_state() {\n        let invalid_state = TemporalState {\n            current_ind: false,\n            future_ind: false,\n            future_action: None,\n        };\n\n        assert!(invalid_state.validate().is_err());\n    }\n\n    #[test]\n    fn line_range_validation() {\n        let valid_range = LineRange::new(1, 5).unwrap();\n        assert_eq!(valid_range.span(), 5);\n        assert!(valid_range.contains(3));\n        assert!(!valid_range.contains(6));\n\n        // Invalid range (start > end)\n        assert!(LineRange::new(10, 5).is_err());\n\n        // Invalid range (zero-based)\n        assert!(LineRange::new(0, 5).is_err());\n    }\n\n    #[test]\n    fn language_detection() {\n        let rust_path = PathBuf::from(\"src/main.rs\");\n        assert_eq!(Language::from_file_path(&rust_path), Some(Language::Rust));\n\n        let js_path = PathBuf::from(\"app.js\");\n        assert_eq!(Language::from_file_path(&js_path), Some(Language::JavaScript));\n\n        let unknown_path = PathBuf::from(\"file.xyz\");\n        assert_eq!(Language::from_file_path(&unknown_path), None);\n    }\n\n    #[test]\n    fn code_entity_validation() {\n        let mut entity = CodeEntity::new(\n            \"src/main.rs-main-main\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"main\".to_string(),\n                visibility: Visibility::Public,\n                file_path: PathBuf::from(\"src/main.rs\"),\n                line_range: LineRange::new(1, 10).unwrap(),\n                module_path: vec![\"main\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n        entity.future_code = Some(\"fn main() { println!(\\\"Hello, world!\\\"); }\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        match entity.validate() {\n            Ok(()) => (),\n            Err(e) => {\n                println!(\"Validation error: {:?}\", e);\n                panic!(\"Entity validation failed: {:?}\", e);\n            }\n        }\n\n        // Test temporal change\n        entity.apply_temporal_change(\n            TemporalAction::Edit,\n            Some(\"fn main() { println!(\\\"Hello\\\"); }\".to_string()),\n        ).unwrap();\n\n        assert!(entity.is_modified());\n        assert!(entity.effective_code().is_some());\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_basic() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp\n        );\n\n        // Should follow format: filepath-name-type-hash8\n        assert!(key.contains(\"src_lib_rs\"));\n        assert!(key.contains(\"new_feature\"));\n        assert!(key.contains(\"-fn-\"));\n\n        // Hash should be 8 characters\n        let parts: Vec<&str> = key.split('-').collect();\n        assert!(parts.len() >= 4, \"Key should have at least 4 parts separated by hyphens\");\n        let hash_part = parts.last().unwrap();\n        assert_eq!(hash_part.len(), 8, \"Hash should be exactly 8 characters\");\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_different_types() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test Function type\n        let fn_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_fn\",\n            &EntityType::Function,\n            timestamp\n        );\n        assert!(fn_key.contains(\"-fn-\"));\n\n        // Test Struct type\n        let struct_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestStruct\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(struct_key.contains(\"-struct-\"));\n\n        // Test Enum type\n        let enum_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestEnum\",\n            &EntityType::Enum,\n            timestamp\n        );\n        assert!(enum_key.contains(\"-enum-\"));\n\n        // Test Trait type\n        let trait_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"TestTrait\",\n            &EntityType::Trait,\n            timestamp\n        );\n        assert!(trait_key.contains(\"-trait-\"));\n\n        // Test Module type\n        let mod_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"test_module\",\n            &EntityType::Module,\n            timestamp\n        );\n        assert!(mod_key.contains(\"-mod-\"));\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_path_sanitization() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test forward slashes\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key1.contains(\"src_models_user_rs\"));\n        assert!(!key1.contains('/'));\n\n        // Test dots in filename\n        assert!(key1.contains(\"_rs\"));\n        assert!(!key1.contains(\".rs\"));\n\n        // Test backslashes (Windows paths)\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src\\\\models\\\\user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n        assert!(key2.contains(\"src_models_user_rs\"));\n        assert!(!key2.contains('\\\\'));\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_uniqueness() {\n        use chrono::TimeZone;\n\n        // Same inputs but different timestamps should produce different keys\n        let timestamp1 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let timestamp2 = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 1, 0).unwrap();\n\n        let key1 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp1\n        );\n\n        let key2 = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"new_feature\",\n            &EntityType::Function,\n            timestamp2\n        );\n\n        assert_ne!(key1, key2, \"Different timestamps should produce different keys\");\n\n        // Extract hash parts to verify they're different\n        let hash1 = key1.split('-').last().unwrap();\n        let hash2 = key2.split('-').last().unwrap();\n        assert_ne!(hash1, hash2, \"Hash parts should be different\");\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_format() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n        let key = CodeEntity::generate_new_entity_key(\n            \"src/models/user.rs\",\n            \"UserProfile\",\n            &EntityType::Struct,\n            timestamp\n        );\n\n        // Expected format: src_models_user_rs-UserProfile-struct-abc12345\n        let parts: Vec<&str> = key.split('-').collect();\n\n        // Should have exactly 4 parts: path, name, type, hash\n        assert_eq!(parts.len(), 4, \"Key should have exactly 4 hyphen-separated parts\");\n\n        // Verify each part\n        assert_eq!(parts[0], \"src_models_user_rs\");\n        assert_eq!(parts[1], \"UserProfile\");\n        assert_eq!(parts[2], \"struct\");\n        assert_eq!(parts[3].len(), 8, \"Hash should be 8 characters\");\n\n        // Hash should be lowercase hexadecimal\n        assert!(parts[3].chars().all(|c| c.is_ascii_hexdigit() && !c.is_ascii_uppercase()));\n    }\n\n    #[test]\n    fn test_generate_new_entity_key_impl_block() {\n        use chrono::TimeZone;\n\n        let timestamp = chrono::Utc.with_ymd_and_hms(2025, 10, 30, 12, 0, 0).unwrap();\n\n        // Test ImplBlock type (should default to \"impl\")\n        let impl_key = CodeEntity::generate_new_entity_key(\n            \"src/lib.rs\",\n            \"MyStruct\",\n            &EntityType::ImplBlock {\n                trait_name: Some(\"Display\".to_string()),\n                struct_name: \"MyStruct\".to_string(),\n            },\n            timestamp\n        );\n        assert!(impl_key.contains(\"-impl-\"));\n    }\n\n    #[test]\n    fn test_entity_class_enum() {\n        // Test that EntityClass enum exists with correct variants\n        let test_class = EntityClass::TestImplementation;\n        let code_class = EntityClass::CodeImplementation;\n\n        assert_eq!(test_class, EntityClass::TestImplementation);\n        assert_eq!(code_class, EntityClass::CodeImplementation);\n    }\n\n    #[test]\n    fn test_tdd_classification_has_entity_class_field() {\n        // Test that TddClassification has entity_class field\n        let tdd = TddClassification::default();\n\n        // Default should be CodeImplementation\n        assert_eq!(tdd.entity_class, EntityClass::CodeImplementation);\n    }\n\n    #[test]\n    fn test_entity_class_serialization() {\n        // Test that EntityClass can be serialized/deserialized\n        let test_impl = EntityClass::TestImplementation;\n        let json = serde_json::to_string(&test_impl).unwrap();\n        let deserialized: EntityClass = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, EntityClass::TestImplementation);\n    }\n\n    // ========================================================================\n    // Phase 1, Task 1.1 Tests: Domain Types (RED  GREEN  REFACTOR)\n    // ========================================================================\n\n    #[test]\n    fn test_isgl1_key_validates_non_empty() {\n        // RED: This validates the non-empty invariant\n        let result = Isgl1Key::new(\"\");\n        assert!(result.is_err(), \"Empty key should be rejected\");\n\n        // Valid key\n        let key = Isgl1Key::new(\"rust:fn:main:src_main_rs:1-10\").unwrap();\n        assert_eq!(key.as_str(), \"rust:fn:main:src_main_rs:1-10\");\n    }\n\n    #[test]\n    fn test_isgl1_key_as_ref() {\n        // S77 Pattern A.2: Accept AsRef<str> in APIs\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        let s: &str = key.as_ref();\n        assert_eq!(s, \"test_key\");\n    }\n\n    #[test]\n    fn test_isgl1_key_display() {\n        let key = Isgl1Key::new(\"test_key\").unwrap();\n        assert_eq!(format!(\"{}\", key), \"test_key\");\n    }\n\n    #[test]\n    fn test_edge_type_roundtrip() {\n        use std::str::FromStr;\n\n        // Test all variants\n        for edge_type in [EdgeType::Calls, EdgeType::Uses, EdgeType::Implements] {\n            let s = edge_type.as_str();\n            let parsed = EdgeType::from_str(s).unwrap();\n            assert_eq!(parsed, edge_type);\n\n            // Test String conversion\n            let string: String = edge_type.into();\n            assert_eq!(string, s);\n        }\n\n        // Invalid edge type\n        assert!(EdgeType::from_str(\"Invalid\").is_err());\n    }\n\n    #[test]\n    fn test_edge_type_display() {\n        assert_eq!(format!(\"{}\", EdgeType::Calls), \"Calls\");\n        assert_eq!(format!(\"{}\", EdgeType::Uses), \"Uses\");\n        assert_eq!(format!(\"{}\", EdgeType::Implements), \"Implements\");\n    }\n\n    #[test]\n    fn test_dependency_edge_builder() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n        assert_eq!(edge.source_location, None);\n    }\n\n    #[test]\n    fn test_dependency_edge_builder_with_location() {\n        let edge = DependencyEdge::builder()\n            .from_key(\"rust:fn:main:src_main_rs:1-10\")\n            .to_key(\"rust:fn:helper:src_main_rs:20-30\")\n            .edge_type(EdgeType::Calls)\n            .source_location(\"src/main.rs:5\")\n            .build()\n            .unwrap();\n\n        assert_eq!(edge.source_location, Some(\"src/main.rs:5\".to_string()));\n    }\n\n    #[test]\n    fn test_dependency_edge_builder_missing_field() {\n        // Missing to_key\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when to_key is missing\");\n\n        // Missing from_key\n        let result = DependencyEdge::builder()\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build();\n\n        assert!(result.is_err(), \"Should fail when from_key is missing\");\n\n        // Missing edge_type\n        let result = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .build();\n\n        assert!(result.is_err(), \"Should fail when edge_type is missing\");\n    }\n\n    #[test]\n    fn test_dependency_edge_new() {\n        let edge = DependencyEdge::new(\n            \"from\",\n            \"to\",\n            EdgeType::Uses,\n            Some(\"location\".to_string()),\n        ).unwrap();\n\n        assert_eq!(edge.from_key.as_str(), \"from\");\n        assert_eq!(edge.to_key.as_str(), \"to\");\n        assert_eq!(edge.edge_type, EdgeType::Uses);\n        assert_eq!(edge.source_location, Some(\"location\".to_string()));\n    }\n\n    #[test]\n    fn test_dependency_edge_rejects_empty_keys() {\n        // Empty from_key\n        let result = DependencyEdge::new(\n            \"\",\n            \"to\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty from_key\");\n\n        // Empty to_key\n        let result = DependencyEdge::new(\n            \"from\",\n            \"\",\n            EdgeType::Calls,\n            None,\n        );\n        assert!(result.is_err(), \"Should reject empty to_key\");\n    }\n\n    #[test]\n    fn test_dependency_edge_serialization() {\n        // Test that DependencyEdge can be serialized/deserialized\n        let edge = DependencyEdge::builder()\n            .from_key(\"from\")\n            .to_key(\"to\")\n            .edge_type(EdgeType::Calls)\n            .build()\n            .unwrap();\n\n        let json = serde_json::to_string(&edge).unwrap();\n        let deserialized: DependencyEdge = serde_json::from_str(&json).unwrap();\n\n        assert_eq!(deserialized, edge);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1096,\"end\":1570},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_parseltongue-core_src_entities_rs:1096-1570",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn error_formatting_provides_clear_context() {\n        let error = ParseltongError::ParseError {\n            reason: \"unexpected token\".to_string(),\n            location: \"src/main.rs:42\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Parsing failed\"));\n        assert!(formatted.contains(\"unexpected token\"));\n        assert!(formatted.contains(\"src/main.rs:42\"));\n    }\n\n    #[test]\n    fn error_chain_preserves_context() {\n        let io_error = std::io::Error::new(\n            std::io::ErrorKind::NotFound,\n            \"file not found\"\n        );\n\n        let parseltong_error = ParseltongError::FileSystemError {\n            path: \"test.txt\".to_string(),\n            source: io_error,\n        };\n\n        // The error should contain both the path and the underlying IO error\n        let error_string = parseltong_error.to_string();\n        assert!(error_string.contains(\"test.txt\"));\n        assert!(error_string.contains(\"file not found\"));\n    }\n\n    #[test]\n    fn recovery_action_default_is_sensible() {\n        let default_action = RecoveryAction::default();\n        assert!(matches!(default_action, RecoveryAction::RetryWithBackoff(_)));\n    }\n\n    // ================== Phase 1.2: Dependency Error Tests ==================\n\n    #[test]\n    fn test_dependency_error_formatting() {\n        let error = ParseltongError::DependencyError {\n            operation: \"insert_edge\".to_string(),\n            reason: \"source entity does not exist\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency error\"));\n        assert!(formatted.contains(\"insert_edge\"));\n        assert!(formatted.contains(\"source entity does not exist\"));\n    }\n\n    #[test]\n    fn test_circular_dependency_error() {\n        let error = ParseltongError::CircularDependency {\n            path: \"A -> B -> C -> A\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Circular dependency detected\"));\n        assert!(formatted.contains(\"A -> B -> C -> A\"));\n    }\n\n    #[test]\n    fn test_duplicate_edge_error() {\n        let error = ParseltongError::DuplicateEdge {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:helper:src_helper_rs:5-20\".to_string(),\n            edge_type: \"Calls\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Duplicate dependency edge\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n        assert!(formatted.contains(\"rust:fn:helper:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"Calls\"));\n    }\n\n    #[test]\n    fn test_missing_dependency_target_error() {\n        let error = ParseltongError::MissingDependencyTarget {\n            from_key: \"rust:fn:main:src_main_rs:1-10\".to_string(),\n            to_key: \"rust:fn:nonexistent:src_helper_rs:5-20\".to_string(),\n        };\n\n        let formatted = error.to_string();\n        assert!(formatted.contains(\"Dependency target not found\"));\n        assert!(formatted.contains(\"rust:fn:nonexistent:src_helper_rs:5-20\"));\n        assert!(formatted.contains(\"referenced from\"));\n        assert!(formatted.contains(\"rust:fn:main:src_main_rs:1-10\"));\n    }\n\n    #[test]\n    fn test_dependency_error_is_error_trait() {\n        let error = ParseltongError::DependencyError {\n            operation: \"query_dependencies\".to_string(),\n            reason: \"invalid hop count\".to_string(),\n        };\n\n        // Verify it implements std::error::Error\n        let _: &dyn std::error::Error = &error;\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":165,\"end\":270},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_parseltongue-core_src_error_rs:165-270",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn tool_metadata_creation() {\n        let metadata = ToolMetadata {\n            id: \"test-tool\".to_string(),\n            name: \"Test Tool\".to_string(),\n            version: \"1.0.0\".to_string(),\n            description: \"A test tool\".to_string(),\n            supported_inputs: vec![\"test\".to_string()],\n            capabilities: ToolCapabilities {\n                async_execution: true,\n                parallel_processing: false,\n                incremental_processing: true,\n                requires_network: false,\n                max_input_size: Some(1024),\n            },\n        };\n\n        assert_eq!(metadata.id, \"test-tool\");\n        assert!(metadata.capabilities.async_execution);\n        assert!(!metadata.capabilities.parallel_processing);\n    }\n\n    #[test]\n    fn temporal_query_creation() {\n        let query = TemporalQuery {\n            base_entities: vec![\"test.rs-test-function\".to_string()],\n            hop_depth: 2,\n            future_only: true,\n            entity_type_filter: Some(EntityType::Function),\n            language_filter: Some(Language::Rust),\n        };\n\n        assert_eq!(query.base_entities.len(), 1);\n        assert_eq!(query.hop_depth, 2);\n        assert!(query.future_only);\n    }\n\n    #[cfg(feature = \"test-utils\")]\n    #[tokio::test]\n    async fn mock_tool_implementation() {\n        let mock_tool = MockTool::new(\"test\")\n            .with_execute_result(Ok(ToolOutput::IndexingComplete {\n                entities_count: 42,\n                duration_ms: 1000,\n            }));\n\n        let input = ToolInput::IndexFolder {\n            path: PathBuf::from(\"test\"),\n            language_filter: None,\n        };\n\n        let result = mock_tool.execute(input).await.unwrap();\n        match result {\n            ToolOutput::IndexingComplete { entities_count, .. } => {\n                assert_eq!(entities_count, 42);\n            }\n            _ => panic!(\"Unexpected output type\"),\n        }\n\n        assert!(mock_tool.validate_input(&input).is_ok());\n        assert_eq!(mock_tool.metadata().name, \"test\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":616,\"end\":681},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_parseltongue-core_src_interfaces_rs:616-681",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn temporal_state_validation() {\n        let manager = TemporalVersioningManager::new();\n        assert!(manager.validate_state().is_ok());\n    }\n\n    #[test]\n    fn entity_creation_and_modification() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Create entity\n        let mut entity = CodeEntity::new(\n            \"test.rs-compute_result\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"calculate_value\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange::new(1, 5).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            crate::entities::EntityClass::CodeImplementation,\n        ).unwrap();\n\n        // Set current_code and future_code to satisfy validation requirements\n        entity.current_code = Some(\"fn test() {}\".to_string());\n        entity.future_code = Some(\"fn test() {}\".to_string());\n\n        // Set to unchanged state since both codes are the same\n        entity.temporal_state = TemporalState::unchanged();\n\n        manager.add_entity(entity).unwrap();\n\n        // Apply edit change\n        let changes = vec![TemporalChange {\n            isgl1_key: \"test.rs-compute_result\".to_string(),\n            action: TemporalAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            updated_signature: None,\n        }];\n\n        let affected = manager.apply_changes(changes).unwrap();\n        assert_eq!(affected.len(), 1);\n        assert_eq!(affected[0], \"test.rs-compute_result\");\n\n        let changed_entities = manager.get_changed_entities();\n        assert_eq!(changed_entities.len(), 1);\n    }\n\n    #[test]\n    fn temporal_transition_builder() {\n        let transition = TemporalTransitionBuilder::new(\"test.rs-test\".to_string())\n            .action(TemporalAction::Create)\n            .future_code(\"fn test() {}\".to_string())\n            .build()\n            .unwrap();\n\n        assert_eq!(transition.isgl1_key, \"test.rs-test\");\n        assert_eq!(transition.action, TemporalAction::Create);\n        assert_eq!(transition.future_code, Some(\"fn test() {}\".to_string()));\n    }\n\n    #[test]\n    fn conflict_detection() {\n        let resolver = ConflictResolver::new(ConflictResolutionStrategy::FailFast);\n\n        let changes = vec![\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Edit,\n                future_code: Some(\"fn test() {}\".to_string()),\n                updated_signature: None,\n            },\n            TemporalChange {\n                isgl1_key: \"test.rs-function\".to_string(),\n                action: TemporalAction::Delete,\n                future_code: None,\n                updated_signature: None,\n            },\n        ];\n\n        let conflicts = resolver.detect_conflicts(&changes);\n        assert_eq!(conflicts.len(), 1);\n\n        let result = resolver.resolve_conflicts(changes);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn validation_rules() {\n        let mut manager = TemporalVersioningManager::new();\n\n        // Test with invalid entity (missing code when current_ind=true)\n        let mut invalid_entity = CodeEntity::new(\n            \"invalid.rs-invalid\".to_string(),\n            InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"invalid\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"invalid.rs\"),\n                line_range: LineRange::new(1, 1).unwrap(),\n                module_path: vec![],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            // v0.9.0: Default to CodeImplementation for tests\n            crate::entities::EntityClass::CodeImplementation,\n        ).unwrap();\n\n        invalid_entity.temporal_state.current_ind = true;\n        // current_code is None, which should cause validation to fail\n\n        let result = manager.add_entity(invalid_entity);\n        assert!(result.is_err());\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":587,\"end\":720},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_parseltongue-core_src_temporal_rs:587-720",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_cli_builds() {\n        let cli = build_cli();\n        // Verify all subcommands are present (v0.8.5: PT02 progressive disclosure)\n        let subcommands: Vec<&str> = cli.get_subcommands().map(|cmd| cmd.get_name()).collect();\n        assert!(subcommands.contains(&\"pt01-folder-to-cozodb-streamer\"));\n        assert!(subcommands.contains(&\"pt02-level00\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt02-level01\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt02-level02\")); // NEW: Progressive disclosure\n        assert!(subcommands.contains(&\"pt03-llm-to-cozodb-writer\"));\n        assert!(subcommands.contains(&\"pt04-syntax-preflight-validator\"));\n        assert!(subcommands.contains(&\"pt05-llm-cozodb-to-diff-writer\"));\n        assert!(subcommands.contains(&\"pt06-cozodb-make-future-code-current\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/parseltongue/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue/src/main.rs\",\"line_range\":{\"start\":939,\"end\":956},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_parseltongue_src_main_rs:939-956",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use clap::ArgMatches;\n\n    #[test]\n    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"/test/dir\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"/test/dir\"));\n        assert_eq!(config.db_path, \"test.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }\n\n    #[test]\n    fn test_default_config() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \".\",  // Directory is now required (positional argument)\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI defaults\n        assert_eq!(config.root_dir, PathBuf::from(\".\"));\n        assert_eq!(config.db_path, \"mem\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist - NO artificial limits)\n        assert_eq!(config.max_file_size, 100 * 1024 * 1024);  // 100MB\n        assert_eq!(config.include_patterns, vec![\"*\".to_string()]);  // ALL files\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }\n\n    #[test]\n    fn test_prd_command_format() {\n        // Test ultra-minimalist CLI (S01 principle)\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"folder-to-cozoDB-streamer\",\n            \"./src\",  // Positional argument (matches unified binary)\n            \"--db\",\n            \"./parseltongue.db\",\n        ]);\n\n        assert!(matches.is_ok(), \"Ultra-minimalist command should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        // Check CLI arguments\n        assert_eq!(config.root_dir, PathBuf::from(\"./src\"));\n        assert_eq!(config.db_path, \"./parseltongue.db\");\n\n        // Check hardcoded defaults (S01 ultra-minimalist)\n        assert_eq!(config.parsing_library, \"tree-sitter\");\n        assert_eq!(config.chunking, \"ISGL1\");\n    }\n\n    #[test]\n    fn test_exclusion_patterns_cli_contract() {\n        // Test REQ-V090-001.0: Exclusion patterns CLI support\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"./src\",\n            \"-e\", \".ref\",\n            \"-e\", \"archive\",\n            \"-e\", \"tmp/**\",\n        ]);\n\n        assert!(matches.is_ok(), \"CLI with exclusion patterns should be valid\");\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        \n        // Verify default patterns are present\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert!(config.exclude_patterns.contains(&\".git\".to_string()));\n        \n        // Verify user-specified patterns are added\n        assert!(config.exclude_patterns.contains(&\".ref\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"archive\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"tmp/**\".to_string()));\n        \n        // Verify total count (defaults + user patterns)\n        assert_eq!(config.exclude_patterns.len(), 11); // 8 defaults + 3 user\n    }\n\n    #[test]\n    fn test_no_exclusion_patterns_default() {\n        // Test that defaults work when no -e flags specified\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-01\",\n            \"./src\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        \n        // Should have only default patterns\n        assert_eq!(config.exclude_patterns.len(), 8);\n        assert!(config.exclude_patterns.contains(&\"target\".to_string()));\n        assert!(config.exclude_patterns.contains(&\"node_modules\".to_string()));\n        assert!(!config.exclude_patterns.contains(&\".ref\".to_string()));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":138,\"end\":269},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:138-269",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use parseltongue_core::entities::EdgeType;\n\n    #[test]\n    fn test_isgl1_key_format() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let entity = ParsedEntity {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            language: Language::Rust,\n            line_range: (10, 15),\n            file_path: \"src/main.rs\".to_string(),\n            metadata: HashMap::new(),\n        };\n\n        let key = generator.generate_key(&entity).unwrap();\n        assert!(key.contains(\"rust:fn:test_function\"));\n        assert!(key.contains(\"10-15\"));\n    }\n\n    #[test]\n    fn test_rust_parsing() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn test_function() {\n    println!(\"Hello, world!\");\n}\n\nstruct TestStruct {\n    field: i32,\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        assert!(!entities.is_empty());\n        assert_eq!(entities.len(), 2); // One function, one struct\n\n        let function = &entities[0];\n        assert_eq!(function.entity_type, EntityType::Function);\n        assert_eq!(function.name, \"test_function\");\n\n        // For now, dependencies should be empty (will implement extraction next)\n        assert_eq!(dependencies.len(), 0);\n    }\n\n    #[test]\n    fn test_function_detection() {\n        // v0.8.9: QueryBasedExtractor doesn't parse Rust attributes (#[test])\n        // This is an acceptable trade-off to get all 11 languages working\n        // Future: Add attribute parsing in v0.9.0 for Rust-specific features\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\n#[test]\nfn test_something() {\n    assert_eq!(1, 1);\n}\n\nfn regular_function() {\n    println!(\"Hello\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn another_test() {\n        assert!(true);\n    }\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, _dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Debug: print all entities\n        println!(\"\\nExtracted {} entities:\", entities.len());\n        for (i, entity) in entities.iter().enumerate() {\n            println!(\"  {}. {} (type: {:?})\",\n                i, entity.name, entity.entity_type);\n        }\n\n        // Verify all functions and modules are extracted\n        let test_fn = entities.iter().find(|e| e.name == \"test_something\");\n        let regular_fn = entities.iter().find(|e| e.name == \"regular_function\");\n        let tests_mod = entities.iter().find(|e| e.name == \"tests\");\n        let another_test = entities.iter().find(|e| e.name == \"another_test\");\n\n        assert!(test_fn.is_some(), \"Should find test_something function\");\n        assert!(regular_fn.is_some(), \"Should find regular_function\");\n        assert!(tests_mod.is_some(), \"Should find tests module\");\n        assert!(another_test.is_some(), \"Should find another_test function\");\n\n        // v0.8.9 MVP: No attribute parsing, so no is_test metadata\n        // This is acceptable - test classification can happen at analysis layer\n        // Verify entities are extracted (main goal), metadata is secondary\n        assert_eq!(entities.len(), 4, \"Should extract 2 functions + 1 module + 1 nested function\");\n    }\n\n    // ================== Phase 2: Dependency Extraction Tests ==================\n\n    #[test]\n    fn test_extracts_function_call_dependencies() {\n        // RED PHASE: This test will FAIL until we implement call_expression extraction\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    helper();\n}\n\nfn helper() {\n    println!(\"Helper called\");\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities (main, helper)\n        assert_eq!(entities.len(), 2);\n\n        // Should extract 1 dependency: main -> helper (Calls)\n        assert_eq!(dependencies.len(), 1, \"Expected 1 dependency edge (main calls helper)\");\n\n        let edge = &dependencies[0];\n        assert_eq!(edge.edge_type, EdgeType::Calls);\n\n        // The keys should reference main and helper\n        assert!(\n            edge.from_key.as_ref().contains(\"main\"),\n            \"from_key should contain 'main', got: {:?}\",\n            edge.from_key\n        );\n        assert!(\n            edge.to_key.as_ref().contains(\"helper\"),\n            \"to_key should contain 'helper', got: {:?}\",\n            edge.to_key\n        );\n    }\n\n    #[test]\n    fn test_extracts_multiple_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    foo();\n    bar();\n    baz();\n}\n\nfn foo() {}\nfn bar() {}\nfn baz() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities (main, foo, bar, baz)\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->foo, main->bar, main->baz\n        assert_eq!(dependencies.len(), 3, \"Expected 3 call edges from main\");\n\n        // Verify all are Calls edges from main\n        for edge in &dependencies {\n            assert_eq!(edge.edge_type, EdgeType::Calls);\n            assert!(edge.from_key.as_ref().contains(\"main\"));\n        }\n\n        // Check we have edges to each function\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"foo\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"bar\")));\n        assert!(dependencies.iter().any(|e| e.to_key.as_ref().contains(\"baz\")));\n    }\n\n    #[test]\n    fn test_no_dependencies_when_no_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    let x = 42;\n    println!(\"{}\", x);\n}\n\nfn helper() {\n    // No calls to other local functions\n}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 2 entities\n        assert_eq!(entities.len(), 2);\n\n        // No dependencies to LOCAL functions (println! is external macro, ignored for MVP)\n        assert_eq!(dependencies.len(), 0, \"Expected no dependencies to local functions\");\n    }\n\n    #[test]\n    fn test_chained_function_calls() {\n        let generator = Isgl1KeyGeneratorImpl::new();\n        let source = r#\"\nfn main() {\n    a();\n}\n\nfn a() {\n    b();\n}\n\nfn b() {\n    c();\n}\n\nfn c() {}\n\"#;\n\n        let file_path = Path::new(\"test.rs\");\n        let (entities, dependencies) = generator.parse_source(source, file_path).unwrap();\n\n        // Should extract 4 entities\n        assert_eq!(entities.len(), 4);\n\n        // Should extract 3 dependencies: main->a, a->b, b->c\n        assert_eq!(dependencies.len(), 3);\n\n        // Verify the chain\n        let main_to_a = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"main\") && e.to_key.as_ref().contains(\"a\")\n        );\n        assert!(main_to_a.is_some(), \"Should have main -> a edge\");\n\n        let a_to_b = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:a:\") && e.to_key.as_ref().contains(\"fn:b:\")\n        );\n        assert!(a_to_b.is_some(), \"Should have a -> b edge\");\n\n        let b_to_c = dependencies.iter().find(|e|\n            e.from_key.as_ref().contains(\"fn:b:\") && e.to_key.as_ref().contains(\"fn:c:\")\n        );\n        assert!(b_to_c.is_some(), \"Should have b -> c edge\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":398,\"end\":643},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:398-643",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    #[tokio::test]\n    async fn test_mock_client_returns_configured_response() {\n        let mut mock_client = MockRustAnalyzerClient::new();\n        let test_response = HoverResponse {\n            contents: \"fn test() -> i32\".to_string(),\n            raw_metadata: serde_json::json!({\n                \"type_info\": {\n                    \"resolved_type\": \"i32\"\n                }\n            }),\n        };\n\n        mock_client.add_response(\n            \"test.rs:10:5\".to_string(),\n            test_response.clone(),\n        );\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_some());\n        let response = result.unwrap();\n        assert_eq!(response.contents, \"fn test() -> i32\");\n    }\n\n    #[tokio::test]\n    async fn test_mock_client_returns_none_for_unconfigured_position() {\n        let mock_client = MockRustAnalyzerClient::new();\n\n        let result = mock_client\n            .hover(&PathBuf::from(\"test.rs\"), 99, 99)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_real_client_gracefully_degrades_when_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n\n        // Should not panic, should return None\n        let result = client\n            .hover(&PathBuf::from(\"test.rs\"), 10, 5)\n            .await\n            .unwrap();\n\n        assert!(result.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_real_client_reports_unavailable() {\n        let client = RustAnalyzerClientImpl::new().await;\n        assert!(!client.is_available().await);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":137,\"end\":198},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:137-198",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_main_with_valid_directory() {\n        // Create temporary directory with test files\n        let temp_dir = TempDir::new().unwrap();\n        let test_file_path = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file_path,\n            r#\"fn test_function() {\n    println!(\"Hello, world!\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Verify file was created\n        assert!(test_file_path.exists(), \"Test file should exist\");\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()], // Simplified pattern\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        // Verify entities were actually created\n        let stream_result = result.unwrap();\n        assert!(stream_result.total_files > 0, \"Should have found at least one file\");\n        assert!(stream_result.entities_created > 0, \"Should have created at least one entity\");\n    }\n\n    #[tokio::test]\n    async fn test_main_with_empty_directory() {\n        let temp_dir = TempDir::new().unwrap();\n\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(), // Use in-memory database for tests\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"**/*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let result = run_streamer(&config, false, true).await;\n        assert!(result.is_ok());\n\n        let stream_result = result.unwrap();\n        assert_eq!(stream_result.total_files, 0);\n        assert_eq!(stream_result.processed_files, 0);\n        assert_eq!(stream_result.entities_created, 0);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/main.rs\",\"line_range\":{\"start\":116,\"end\":178},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_main_rs:116-178",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::super::*;\n    use crate::lsp_client::{HoverResponse, MockRustAnalyzerClient};\n    use crate::isgl1_generator::Isgl1KeyGeneratorFactory;\n    use std::path::Path;\n    use tempfile::TempDir;\n\n    #[tokio::test]\n    async fn test_streamer_enriches_entities_with_lsp_metadata() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn calculate_sum(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nstruct Calculator {\n    name: String,\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client with hover responses\n        let mut mock_lsp = MockRustAnalyzerClient::new();\n\n        // Add hover response for function (line 1)\n        mock_lsp.add_response(\n            format!(\"{}:0:0\", test_file.display()),\n            HoverResponse {\n                contents: \"fn calculate_sum(a: i32, b: i32) -> i32\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"function\",\n                    \"signature\": \"fn(i32, i32) -> i32\"\n                }),\n            },\n        );\n\n        // Add hover response for struct (line 5)\n        mock_lsp.add_response(\n            format!(\"{}:4:0\", test_file.display()),\n            HoverResponse {\n                contents: \"struct Calculator\".to_string(),\n                raw_metadata: serde_json::json!({\n                    \"type\": \"struct\",\n                    \"fields\": [\"name: String\"]\n                }),\n            },\n        );\n\n        // Setup: Create streamer with mock LSP client\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n            std::sync::Arc::new(crate::test_detector::DefaultTestDetector::new()),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entities were created\n        assert_eq!(result.entities_created, 2, \"Should create 2 entities (function + struct)\");\n        assert!(result.success, \"Streaming should succeed\");\n\n        // Verify: LSP metadata was stored (we can't easily query DB in this test,\n        // but the fact that no errors occurred means LSP integration works)\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }\n\n    #[tokio::test]\n    async fn test_streamer_gracefully_degrades_without_lsp() {\n        // Setup: Create temp directory with Rust file\n        let temp_dir = TempDir::new().unwrap();\n        let test_file = temp_dir.path().join(\"test.rs\");\n        std::fs::write(\n            &test_file,\n            r#\"fn test_fn() {\n    println!(\"test\");\n}\n\"#,\n        )\n        .unwrap();\n\n        // Setup: Create mock LSP client that returns None (simulating unavailable LSP)\n        let mock_lsp = MockRustAnalyzerClient::new(); // No responses configured\n\n        // Setup: Create streamer\n        let config = StreamerConfig {\n            root_dir: temp_dir.path().to_path_buf(),\n            db_path: \"mem\".to_string(),\n            max_file_size: 1024 * 1024,\n            include_patterns: vec![\"*.rs\".to_string()],\n            exclude_patterns: vec![],\n            parsing_library: \"tree-sitter\".to_string(),\n            chunking: \"ISGL1\".to_string(),\n        };\n\n        let key_generator = Isgl1KeyGeneratorFactory::new();\n        let streamer = FileStreamerImpl::new_with_lsp(\n            config,\n            key_generator,\n            std::sync::Arc::new(mock_lsp),\n            std::sync::Arc::new(crate::test_detector::DefaultTestDetector::new()),\n        )\n        .await\n        .unwrap();\n\n        // Execute: Stream the file\n        let result = streamer.stream_file(&test_file).await.unwrap();\n\n        // Verify: Entity still created despite LSP unavailable (graceful degradation)\n        assert_eq!(result.entities_created, 1, \"Should still create entity without LSP\");\n        assert!(result.success, \"Streaming should succeed without LSP\");\n        assert!(result.error.is_none(), \"Should have no errors\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer_lsp_tests.rs\",\"line_range\":{\"start\":4,\"end\":135},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_streamer_lsp_tests_rs:4-135",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    \n    /// Test contract: Rust test detection\n    #[test]\n    fn test_rust_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        // Test cases: (file_path, content, expected_result)\n        let test_cases = vec![\n            (\"src/lib.rs\", \"fn normal_function() { }\", EntityClass::Code),\n            (\"tests/integration_test.rs\", \"#[test] fn test_integration() { }\", EntityClass::Test),\n            (\"src/module_test.rs\", \"#[tokio::test] async fn test_async() { }\", EntityClass::Test),\n            (\"src/benches/bench.rs\", \"#[test] fn test_unit() { }\", EntityClass::Test),\n            (\"src/main.rs\", \"fn main() { println!(\\\"hello\\\"); }\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected, \n                      \"Rust file {} with content should be {:?}\", file_path, expected);\n        }\n    }\n    \n    /// Test contract: Go test detection\n    #[test]\n    fn test_go_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let test_cases = vec![\n            (\"main.go\", \"func main() { }\", EntityClass::Code),\n            (\"main_test.go\", \"func TestMain(t *testing.T) { }\", EntityClass::Test),\n            (\"integration_test.go\", \"func ExampleUsage() { }\", EntityClass::Test),\n            (\"benchmark_test.go\", \"func BenchmarkAlgorithm(b *testing.B) { }\", EntityClass::Test),\n            (\"utils.go\", \"func helper() { }\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected,\n                      \"Go file {} should be {:?}\", file_path, expected);\n        }\n    }\n    \n    /// Test contract: JavaScript/TypeScript test detection\n    #[test]\n    fn test_javascript_test_detection_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let test_cases = vec![\n            (\"src/app.js\", \"function runApp() { }\", EntityClass::Code),\n            (\"src/app.test.js\", \"test('app runs', () => { })\", EntityClass::Test),\n            (\"utils.spec.ts\", \"describe('utils', () => { })\", EntityClass::Test),\n            (\"__tests__/helper.js\", \"expect(true).toBe(true)\", EntityClass::Test),\n            (\"components/Button.tsx\", \"export Button = () => {}\", EntityClass::Code),\n        ];\n        \n        for (file_path, content, expected) in test_cases {\n            let result = detector.detect_test_from_path_and_name(\n                Path::new(file_path), \n                content\n            );\n            assert_eq!(result, expected,\n                      \"JS/TS file {} should be {:?}\", file_path, expected);\n        }\n    }\n    \n    /// Performance contract: Test detection speed\n    #[test]\n    fn test_test_detection_performance_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        // Large file content to test performance\n        let content = \"fn regular_function() { }\\n\".repeat(1000);\n        let test_path = Path::new(\"src/lib.rs\");\n        \n        let start = std::time::Instant::now();\n        for _ in 0..1000 {\n            detector.detect_test_from_path_and_name(test_path, &content);\n        }\n        let elapsed = start.elapsed();\n        \n        // Performance contract: <20s per detection\n        let avg_time_per_check = elapsed / 1000;\n        assert!(avg_time_per_check < std::time::Duration::from_micros(20),\n                \"Test detection took {:?}, expected <20s\", avg_time_per_check);\n    }\n    \n    /// Test contract: Unknown file extensions\n    #[test]\n    fn test_unknown_file_extensions_contract() {\n        let detector = DefaultTestDetector::new();\n        \n        let result = detector.detect_test_from_path_and_name(\n            Path::new(\"unknown.xyz\"), \n            \"some content\"\n        );\n        \n        // Unknown extensions should be treated as non-test files\n        assert_eq!(result, EntityClass::Code);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":211,\"end\":318},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:211-318",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_level0_minimal() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        assert_eq!(cli.level, 0);\n        assert!(cli.include_code.is_none());\n        assert_eq!(cli.where_clause, \"ALL\");\n\n        let config = cli.validate();\n        assert!(config.is_ok());\n        let config = config.unwrap();\n        assert_eq!(config.level, 0);\n        assert_eq!(config.include_code, false);\n    }\n\n    #[test]\n    fn test_level0_with_include_code_fails() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"0\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let result = cli.validate();\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"Level 0 exports edges only\"));\n    }\n\n    #[test]\n    fn test_level1_without_include_code_fails() {\n        // This should fail at clap parsing level due to required_if_eq\n        let result = Cli::try_parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_level1_signatures_only() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 1);\n        assert_eq!(config.include_code, false);  // 0 = signatures only\n        assert_eq!(config.where_filter, \"ALL\");\n    }\n\n    #[test]\n    fn test_level1_with_code() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"1\",\n            \"--where-clause\", \"future_action != null\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 1);\n        assert_eq!(config.include_code, true);  // 1 = with code\n        assert_eq!(config.where_filter, \"future_action != null\");\n    }\n\n    #[test]\n    fn test_level2_with_complex_where() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"2\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"is_public = true, entity_type = 'fn', is_async = true\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.level, 2);\n        assert_eq!(config.include_code, false);\n        assert!(config.where_filter.contains(\"is_public = true\"));\n        assert!(config.where_filter.contains(\"entity_type = 'fn'\"));\n    }\n\n    #[test]\n    fn test_output_path_default() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.output_path, PathBuf::from(\"ISGLevel01.json\"));\n    }\n\n    #[test]\n    fn test_output_path_custom() {\n        let cli = Cli::parse_from(&[\n            \"pt02\",\n            \"--level\", \"1\",\n            \"--include-code\", \"0\",\n            \"--where-clause\", \"ALL\",\n            \"--output\", \"custom.json\",\n        ]);\n\n        let config = cli.validate().unwrap();\n        assert_eq!(config.output_path, PathBuf::from(\"custom.json\"));\n    }\n\n    #[test]\n    fn test_empty_where_clause_fails() {\n        let cli = Cli {\n            level: 1,\n            include_code: Some(0),\n            where_clause: \"\".to_string(),  // Empty!\n            output: None,\n            db: \"test.db\".to_string(),\n            verbose: false,\n        };\n\n        let result = cli.validate();\n        assert!(result.is_err());\n        let err = result.unwrap_err();\n        assert!(err.to_string().contains(\"WHERE clause cannot be empty\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":168,\"end\":306},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:168-306",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_entity_name() {\n        assert_eq!(\n            parse_entity_name_from_key(\"rust:fn:main:src_main_rs:1\"),\n            \"main\"\n        );\n    }\n\n    #[test]\n    fn test_parse_line_number() {\n        assert_eq!(\n            parse_line_number_from_key(\"rust:fn:main:src_main_rs:42\"),\n            42\n        );\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":265,\"end\":283},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:265-283",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    // Mock exporter for testing trait contract\n    struct MockExporter {\n        level: u8,\n        tokens: usize,\n    }\n\n    #[async_trait]\n    impl LevelExporter for MockExporter {\n        async fn export(&self, _db: &dyn CodeGraphRepository, _config: &ExportConfig) -> Result<ExportOutput> {\n            todo!(\"Mock implementation\")\n        }\n\n        fn level(&self) -> u8 {\n            self.level\n        }\n\n        fn estimated_tokens(&self) -> usize {\n            self.tokens\n        }\n    }\n\n    #[test]\n    fn test_mock_exporter_level() {\n        let exporter = MockExporter { level: 0, tokens: 5000 };\n        assert_eq!(exporter.level(), 0);\n        assert_eq!(exporter.estimated_tokens(), 5000);\n    }\n\n    #[test]\n    fn test_entity_debug() {\n        let entity = Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: None,\n            entity_name: \"test\".to_string(),\n            entity_type: \"Function\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"fn test()\".to_string(),\n            doc_comment: None,\n            entity_class: \"CODE\".to_string(),\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: None,\n            is_async: None,\n            is_unsafe: None,\n        };\n\n        let debug_str = format!(\"{:?}\", entity);\n        assert!(debug_str.contains(\"rust:fn:test\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":156,\"end\":218},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:156-218",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use crate::export_trait::Edge;\n\n    // Mock database for unit tests\n    struct MockDatabase {\n        edges: Vec<Edge>,\n    }\n\n    #[async_trait]\n    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }\n\n        async fn query_entities(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Entity>> {\n            Ok(vec![])\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<Edge>> {\n            Ok(self.edges.clone())\n        }\n\n        async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>> {\n            if where_clause == \"ALL\" {\n                Ok(self.edges.clone())\n            } else if where_clause.contains(\"edge_type = 'depends_on'\") {\n                Ok(self.edges.iter()\n                    .filter(|e| e.edge_type == \"depends_on\")\n                    .cloned()\n                    .collect())\n            } else {\n                Ok(self.edges.clone())\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_level0_exporter_basic() {\n        // Arrange\n        let edges = vec![\n            Edge {\n                from_key: \"rust:fn:foo:src_lib_rs:10\".to_string(),\n                to_key: \"rust:fn:bar:src_lib_rs:20\".to_string(),\n                edge_type: \"depends_on\".to_string(),\n            },\n        ];\n\n        let db = MockDatabase { edges };\n        let config = ExportConfig {\n            level: 0,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level0Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 0);\n        assert_eq!(output.export_metadata.total_edges, Some(1));\n        assert!(output.edges.is_some());\n        assert!(output.entities.is_none());\n\n        let exported_edges = output.edges.unwrap();\n        assert_eq!(exported_edges.len(), 1);\n        assert_eq!(exported_edges[0].from_key, \"rust:fn:foo:src_lib_rs:10\");\n    }\n\n    #[test]\n    fn test_level0_exporter_metadata() {\n        let exporter = Level0Exporter::new();\n        assert_eq!(exporter.level(), 0);\n        assert_eq!(exporter.estimated_tokens(), 5_000);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":100,\"end\":185},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:100-185",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use crate::export_trait::Entity;\n\n    // Mock database for unit tests\n    struct MockDatabase {\n        entities: Vec<Entity>,\n    }\n\n    #[async_trait]\n    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }\n\n        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else if where_clause.contains(\"future_action != null\") {\n                        e.future_action.is_some()\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n\n        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n    }\n\n    fn create_test_entity() -> Entity {\n        Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![\"rust:fn:helper:src_lib_rs:20\".to_string()],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: Some(\"pub fn test() { }\".to_string()),\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub fn test()\".to_string(),\n            doc_comment: Some(\"Test function\".to_string()),\n            // v0.9.0: EntityClass for code/test separation\n            entity_class: \"CODE\".to_string(),\n            // Level 2 fields (not used in Level 1, but present in Entity)\n            return_type: None,\n            param_types: None,\n            param_names: None,\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: Some(true),\n            is_async: None,\n            is_unsafe: None,\n        }\n    }\n\n    #[tokio::test]\n    async fn test_level1_exporter_basic() {\n        // Arrange\n        let entities = vec![create_test_entity()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 1,\n            include_code: false,  // Signatures only\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level1Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 1);\n        assert_eq!(output.export_metadata.total_entities, Some(1));\n        assert_eq!(output.export_metadata.include_code, Some(false));\n        assert!(output.entities.is_some());\n        assert!(output.edges.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_level1_include_code_flag() {\n        // Arrange\n        let entities = vec![create_test_entity()];\n        let db = MockDatabase { entities };\n\n        // Test with include_code = true\n        let config_with_code = ExportConfig {\n            level: 1,\n            include_code: true,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level1Exporter::new();\n        let output = exporter.export(&db, &config_with_code).await.unwrap();\n        let json = serde_json::to_string(&output).unwrap();\n\n        // Should contain current_code\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"pub fn test()\"));\n\n        // Test with include_code = false\n        let db2 = MockDatabase {\n            entities: vec![create_test_entity()],\n        };\n        let config_no_code = ExportConfig {\n            level: 1,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let output2 = exporter.export(&db2, &config_no_code).await.unwrap();\n        let json2 = serde_json::to_string(&output2).unwrap();\n\n        // Should NOT contain current_code (null-skipped)\n        assert!(!json2.contains(\"\\\"current_code\\\"\"));\n    }\n\n    #[test]\n    fn test_level1_exporter_metadata() {\n        let exporter = Level1Exporter::new();\n        assert_eq!(exporter.level(), 1);\n        assert_eq!(exporter.estimated_tokens(), 30_000);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":189,\"end\":353},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:189-353",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use crate::export_trait::Entity;\n\n    // Mock database for unit tests\n    struct MockDatabase {\n        entities: Vec<Entity>,\n    }\n\n    #[async_trait]\n    impl CodeGraphRepository for MockDatabase {\n        async fn get_all_entities(&self) -> Result<Vec<Entity>> {\n            Ok(self.entities.clone())\n        }\n\n        async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>> {\n            if where_clause == \"ALL\" {\n                return Ok(self.entities.clone());\n            }\n\n            // Simple filter for testing\n            let filtered: Vec<Entity> = self.entities\n                .iter()\n                .filter(|e| {\n                    if where_clause.contains(\"is_async = true\") {\n                        e.is_async == Some(true)\n                    } else if where_clause.contains(\"is_public = true\") {\n                        e.is_public == Some(true)\n                    } else {\n                        true\n                    }\n                })\n                .cloned()\n                .collect();\n\n            Ok(filtered)\n        }\n\n        async fn get_all_edges(&self) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n\n        async fn query_edges(&self, _where_clause: &str) -> Result<Vec<crate::export_trait::Edge>> {\n            Ok(vec![])\n        }\n    }\n\n    fn create_test_entity_with_types() -> Entity {\n        Entity {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],\n            reverse_deps: vec![],\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,\n            future_code: None,\n            current_code: Some(\"pub async fn test(name: &str) -> Result<()> { Ok(()) }\".to_string()),\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub async fn test(name: &str) -> Result<()>\".to_string(),\n            doc_comment: Some(\"Test function\".to_string()),\n            // v0.9.0: EntityClass for code/test separation\n            entity_class: \"CODE\".to_string(),\n            // Level 2 type system fields\n            return_type: Some(\"Result<()>\".to_string()),\n            param_types: Some(vec![\"&str\".to_string()]),\n            param_names: Some(vec![\"name\".to_string()]),\n            generic_constraints: None,\n            trait_impls: None,\n            is_public: Some(true),\n            is_async: Some(true),\n            is_unsafe: Some(false),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_level2_exporter_basic() {\n        // Arrange\n        let entities = vec![create_test_entity_with_types()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 2,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level2Exporter::new();\n\n        // Act\n        let result = exporter.export(&db, &config).await;\n\n        // Assert\n        assert!(result.is_ok());\n        let output = result.unwrap();\n\n        assert_eq!(output.export_metadata.level, 2);\n        assert_eq!(output.export_metadata.total_entities, Some(1));\n        assert!(output.entities.is_some());\n        assert!(output.edges.is_none());\n    }\n\n    #[tokio::test]\n    async fn test_level2_type_system_fields() {\n        // Arrange\n        let entities = vec![create_test_entity_with_types()];\n        let db = MockDatabase { entities };\n\n        let config = ExportConfig {\n            level: 2,\n            include_code: false,\n            where_filter: \"ALL\".to_string(),\n            output_path: std::path::PathBuf::from(\"test.json\"),\n            // v0.9.0: Dual outputs for code/test separation (None for tests)\n            code_output_path: None,\n            tests_output_path: None,\n            db_path: \"mem\".to_string(),\n        };\n\n        let exporter = Level2Exporter::new();\n\n        // Act\n        let output = exporter.export(&db, &config).await.unwrap();\n        let json = serde_json::to_string(&output).unwrap();\n\n        // Assert: Type system fields present\n        assert!(json.contains(\"\\\"return_type\\\"\"));\n        assert!(json.contains(\"Result<()>\"));\n        assert!(json.contains(\"\\\"param_types\\\"\"));\n        assert!(json.contains(\"\\\"&str\\\"\"));\n        assert!(json.contains(\"\\\"is_async\\\"\"));\n        assert!(json.contains(\"\\\"is_public\\\"\"));\n    }\n\n    #[test]\n    fn test_level2_exporter_metadata() {\n        let exporter = Level2Exporter::new();\n        assert_eq!(exporter.level(), 2);\n        assert_eq!(exporter.estimated_tokens(), 60_000);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":164,\"end\":311},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:164-311",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_dependency_edge_serialization() {\n        let edge = DependencyEdge {\n            from_key: \"rust:fn:foo:src_lib_rs:10\".to_string(),\n            to_key: \"rust:fn:bar:src_lib_rs:20\".to_string(),\n            edge_type: \"depends_on\".to_string(),\n        };\n\n        let json = serde_json::to_string(&edge).unwrap();\n        assert!(json.contains(\"rust:fn:foo\"));\n        assert!(json.contains(\"depends_on\"));\n    }\n\n    #[test]\n    fn test_entity_level1_null_skipping() {\n        let entity = EntityExportLevel1 {\n            isgl1_key: \"rust:fn:test:src_lib_rs:10\".to_string(),\n            forward_deps: vec![],  // Should be skipped\n            reverse_deps: vec![],  // Should be skipped\n            current_ind: 1,\n            future_ind: 0,\n            future_action: None,  // Should be skipped\n            future_code: None,    // Should be skipped\n            current_code: None,   // Should be skipped\n            entity_name: \"test\".to_string(),\n            entity_type: \"fn\".to_string(),\n            file_path: \"src/lib.rs\".to_string(),\n            line_number: 10,\n            interface_signature: \"pub fn test()\".to_string(),\n            doc_comment: None,  // Should be skipped\n        };\n\n        let json = serde_json::to_string(&entity).unwrap();\n\n        // Verify null-skipping works (field names should NOT appear)\n        assert!(!json.contains(\"future_action\"));\n        assert!(!json.contains(\"future_code\"));\n        assert!(!json.contains(\"doc_comment\"));\n    }\n\n    #[test]\n    fn test_export_metadata_for_level0() {\n        let metadata = ExportMetadata::for_level0(100, \"ALL\".to_string());\n\n        assert_eq!(metadata.level, 0);\n        assert_eq!(metadata.total_edges, Some(100));\n        assert_eq!(metadata.total_entities, None);\n        assert_eq!(metadata.include_code, None);\n    }\n\n    #[test]\n    fn test_export_metadata_for_level1() {\n        let metadata = ExportMetadata::for_entities(1, 590, false, \"ALL\".to_string());\n\n        assert_eq!(metadata.level, 1);\n        assert_eq!(metadata.total_edges, None);\n        assert_eq!(metadata.total_entities, Some(590));\n        assert_eq!(metadata.include_code, Some(false));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":291,\"end\":353},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:291-353",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_cli_config_parsing() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[a] := [[1]]\",\n            \"--db\",\n            \"test.db\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[a] := [[1]]\");\n        assert_eq!(config.db_path, \"test.db\");\n    }\n\n    #[test]\n    fn test_default_db_path() {\n        let cli = CliConfig::build_cli();\n        let matches = cli.try_get_matches_from(&[\n            \"parseltongue-02\",\n            \"--query\",\n            \"?[b] := [[2]]\",\n        ]);\n\n        assert!(matches.is_ok());\n        let matches = matches.unwrap();\n\n        let config = CliConfig::parse_config(&matches);\n        assert_eq!(config.query, \"?[b] := [[2]]\");\n        assert_eq!(config.db_path, \"parseltongue.db\"); // Default value\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":183,\"end\":221},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:183-221",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use pt03_llm_to_cozodb_writer::{AdvancedQueryConfig, EntityAction, SimpleUpdateConfig};\n\n    #[test]\n    fn test_simple_interface_mode() {\n        let config = SimpleUpdateConfig {\n            entity_key: \"rust:fn:test:lib_rs:1-5\".to_string(),\n            action: EntityAction::Edit,\n            future_code: Some(\"fn test() {}\".to_string()),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Simple(config.clone());\n\n        match mode {\n            InterfaceMode::Simple(c) => {\n                assert_eq!(c.entity_key, \"rust:fn:test:lib_rs:1-5\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Simple mode\"),\n        }\n    }\n\n    #[test]\n    fn test_advanced_interface_mode() {\n        let config = AdvancedQueryConfig {\n            query: \"?[a] := [[1]]\".to_string(),\n            db_path: \"test.db\".to_string(),\n        };\n\n        let mode = InterfaceMode::Advanced(config);\n\n        match mode {\n            InterfaceMode::Advanced(c) => {\n                assert_eq!(c.query, \"?[a] := [[1]]\");\n                assert_eq!(c.db_path, \"test.db\");\n            }\n            _ => panic!(\"Expected Advanced mode\"),\n        }\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/main.rs\",\"line_range\":{\"start\":99,\"end\":140},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt03-llm-to-cozodb-writer_src_main_rs:99-140",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_cli_validation_requires_input() {\n        // Create CLI without code snippet or file\n        let cli = Cli {\n            code_snippet: None,\n            file: None,\n            validation_type: ValidationTypeArg::All,\n            verbose: false,\n            output_format: OutputFormat::Text,\n        };\n\n        assert!(cli.validate().is_err());\n    }\n\n    #[test]\n    fn test_cli_validation_with_code_snippet() {\n        let cli = Cli {\n            code_snippet: Some(\"fn main() {}\".to_string()),\n            file: None,\n            validation_type: ValidationTypeArg::Syntax,\n            verbose: false,\n            output_format: OutputFormat::Json,\n        };\n\n        assert!(cli.validate().is_ok());\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":69,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt04-syntax-preflight-validator_src_cli_rs:69-98",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_severity() {\n        let syntax_err = ValidationError::SyntaxError {\n            line: 1,\n            column: 5,\n            message: \"unexpected token\".to_string(),\n            code_snippet: None,\n        };\n        assert_eq!(syntax_err.severity(), Severity::Error);\n    }\n\n    #[test]\n    fn test_error_line_extraction() {\n        let type_err = ValidationError::TypeError {\n            line: 42,\n            column: 10,\n            expected: \"i32\".to_string(),\n            found: \"String\".to_string(),\n            message: \"type mismatch\".to_string(),\n        };\n        assert_eq!(type_err.line(), Some(42));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/errors.rs\",\"line_range\":{\"start\":92,\"end\":117},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt04-syntax-preflight-validator_src_errors_rs:92-117",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_validator_creation() {\n        let validator = SimpleSyntaxValidator::new();\n        assert!(validator.is_ok(), \"Should create validator successfully\");\n    }\n\n    #[test]\n    fn test_simple_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main() {}\";\n        let result = validator.validate_syntax(code, Language::Rust).unwrap();\n        assert!(result.is_valid);\n    }\n\n    #[test]\n    fn test_simple_invalid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"fn main( {\"; // Missing closing paren\n        let result = validator.validate_syntax(code, Language::Rust).unwrap();\n        assert!(!result.is_valid);\n        assert!(!result.errors.is_empty());\n    }\n\n    #[test]\n    fn test_python_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"def hello():\\n    print('world')\";\n        let result = validator.validate_syntax(code, Language::Python).unwrap();\n        assert!(result.is_valid);\n    }\n\n    #[test]\n    fn test_javascript_valid_code() {\n        let mut validator = SimpleSyntaxValidator::new().unwrap();\n        let code = \"function hello() { console.log('world'); }\";\n        let result = validator.validate_syntax(code, Language::JavaScript).unwrap();\n        assert!(result.is_valid);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":174,\"end\":215},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:174-215",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_validation_type_all() {\n        let types = ValidationType::all();\n        assert_eq!(types.len(), 5);\n        assert_eq!(types[0], ValidationType::Syntax);\n        assert_eq!(types[4], ValidationType::Test);\n    }\n\n    #[test]\n    fn test_validation_type_up_to() {\n        let up_to_compilation = ValidationType::Compilation.up_to();\n        assert_eq!(up_to_compilation.len(), 4);\n        assert!(!up_to_compilation.contains(&ValidationType::Test));\n    }\n\n    #[test]\n    fn test_validation_output_success() {\n        let output = ValidationOutput::success(ValidationType::Syntax);\n        assert!(output.is_valid);\n        assert_eq!(output.errors.len(), 0);\n    }\n\n    #[test]\n    fn test_validation_report_overall_status() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        // Add successful result\n        report.add_result(ValidationOutput::success(ValidationType::Syntax));\n        assert!(report.overall_valid);\n\n        // Add failed result\n        let error = crate::errors::ValidationError::Parse(\"test error\".to_string());\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error));\n        assert!(!report.overall_valid);\n    }\n\n    #[test]\n    fn test_validation_report_aggregates_errors() {\n        let mut report = ValidationReport::new(None, \"fn main() {}\".to_string());\n\n        let error1 = crate::errors::ValidationError::Parse(\"error 1\".to_string());\n        let error2 = crate::errors::ValidationError::Parse(\"error 2\".to_string());\n\n        report.add_result(ValidationOutput::failure(ValidationType::Syntax, error1));\n        report.add_result(ValidationOutput::failure(ValidationType::Compilation, error2));\n\n        let all_errors = report.all_errors();\n        assert_eq!(all_errors.len(), 2);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":155,\"end\":207},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt04-syntax-preflight-validator_src_types_rs:155-207",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    // RED PHASE: These tests will fail initially\n\n    #[tokio::test]\n    async fn test_validate_syntax_valid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main() {\n                println!(\"Hello, world!\");\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(output.is_valid);\n        assert_eq!(output.validation_type, ValidationType::Syntax);\n        assert_eq!(output.errors.len(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_validate_syntax_invalid_code() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn main( {\n                // Missing closing parenthesis\n            }\n        \"#;\n\n        let result = validator.validate_syntax(code).await;\n        assert!(result.is_ok());\n        let output = result.unwrap();\n        assert!(!output.is_valid);\n        assert!(output.errors.len() > 0);\n    }\n\n    #[tokio::test]\n    async fn test_validate_all_stops_on_first_failure() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn broken_function( {\n                // Syntax error - should stop early\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(!report.overall_valid);\n        // Should only have syntax validation result (fail-fast)\n        assert_eq!(report.individual_results.len(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_validate_all_success() {\n        let validator = DefaultRustValidator::new();\n        let code = r#\"\n            fn add(a: i32, b: i32) -> i32 {\n                a + b\n            }\n        \"#;\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n        assert!(report.overall_valid);\n        // Should have all 5 validation results\n        assert_eq!(report.individual_results.len(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_validation_report_tracks_timing() {\n        let validator = DefaultRustValidator::new();\n        let code = \"fn main() {}\";\n\n        let result = validator.validate_all(code).await;\n        assert!(result.is_ok());\n        let report = result.unwrap();\n\n        // Timing should be tracked (even if zero for now)\n        assert!(report.total_execution_time_ms >= 0);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":145,\"end\":229},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt04-syntax-preflight-validator_src_validator_rs:145-229",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_cli_parsing() {\n        let cli = Cli {\n            database: PathBuf::from(\"./parseltongue.db\"),\n            root: PathBuf::from(\"./project\"),\n            dry_run: false,\n            verbose: false,\n        };\n\n        assert_eq!(cli.database, PathBuf::from(\"./parseltongue.db\"));\n        assert_eq!(cli.root, PathBuf::from(\"./project\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs\",\"line_range\":{\"start\":33,\"end\":48},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:33-48",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_empty_code_diff() {\n        let diff = CodeDiff::new();\n        assert_eq!(diff.changes.len(), 0);\n        assert_eq!(diff.metadata.total_changes, 0);\n    }\n\n    #[test]\n    fn test_add_change_updates_metadata() {\n        let mut diff = CodeDiff::new();\n\n        let change = Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None, // Create operations have no current code\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None, // Hash-based keys have no line range\n            interface_signature: \"fn test()\".to_string(),\n        };\n\n        diff.add_change(change);\n\n        assert_eq!(diff.changes.len(), 1);\n        assert_eq!(diff.metadata.total_changes, 1);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 0);\n        assert_eq!(diff.metadata.delete_count, 0);\n    }\n\n    #[test]\n    fn test_operation_counts() {\n        let mut diff = CodeDiff::new();\n\n        // Add create\n        diff.add_change(Change {\n            isgl1_key: \"create-key\".to_string(),\n            file_path: PathBuf::from(\"src/new.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn new() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn new()\".to_string(),\n        });\n\n        // Add edit\n        diff.add_change(Change {\n            isgl1_key: \"edit-key\".to_string(),\n            file_path: PathBuf::from(\"src/old.rs\"),\n            operation: Operation::Edit,\n            current_code: Some(\"fn old() {}\".to_string()),\n            future_code: Some(\"fn updated() {}\".to_string()),\n            line_range: Some(LineRange { start: 10, end: 20 }),\n            interface_signature: \"fn updated()\".to_string(),\n        });\n\n        // Add delete\n        diff.add_change(Change {\n            isgl1_key: \"delete-key\".to_string(),\n            file_path: PathBuf::from(\"src/gone.rs\"),\n            operation: Operation::Delete,\n            current_code: Some(\"fn gone() {}\".to_string()),\n            future_code: None,\n            line_range: Some(LineRange { start: 30, end: 40 }),\n            interface_signature: \"fn gone()\".to_string(),\n        });\n\n        assert_eq!(diff.metadata.total_changes, 3);\n        assert_eq!(diff.metadata.create_count, 1);\n        assert_eq!(diff.metadata.edit_count, 1);\n        assert_eq!(diff.metadata.delete_count, 1);\n    }\n\n    #[test]\n    fn test_json_serialization() {\n        let mut diff = CodeDiff::new();\n\n        diff.add_change(Change {\n            isgl1_key: \"test-key\".to_string(),\n            file_path: PathBuf::from(\"src/test.rs\"),\n            operation: Operation::Create,\n            current_code: None,\n            future_code: Some(\"fn test() {}\".to_string()),\n            line_range: None,\n            interface_signature: \"fn test()\".to_string(),\n        });\n\n        let json = diff.to_json_pretty().expect(\"JSON serialization failed\");\n        assert!(json.contains(\"\\\"changes\\\"\"));\n        assert!(json.contains(\"\\\"metadata\\\"\"));\n        assert!(json.contains(\"\\\"CREATE\\\"\"));\n        // Enhanced schema includes these fields\n        assert!(json.contains(\"\\\"current_code\\\"\"));\n        assert!(json.contains(\"\\\"future_code\\\"\"));\n        assert!(json.contains(\"\\\"line_range\\\"\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":168,\"end\":267},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:168-267",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_display() {\n        let err = FileWriterError::file_already_exists(PathBuf::from(\"test.rs\"));\n        assert!(err.to_string().contains(\"test.rs\"));\n    }\n\n    #[test]\n    fn test_invalid_isgl1_key_error() {\n        let err = FileWriterError::invalid_isgl1_key(\"invalid-key\".to_string());\n        assert!(err.to_string().contains(\"invalid-key\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/errors.rs\",\"line_range\":{\"start\":47,\"end\":61},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt05-llm-cozodb-to-diff-writer_src_errors_rs:47-61",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_write_result_success() {\n        let result = WriteResult::success(\n            PathBuf::from(\"test.rs\"),\n            WriteOperation::Create,\n        );\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n    }\n\n    #[test]\n    fn test_write_summary() {\n        let mut summary = WriteSummary::new();\n\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file1.rs\"),\n            WriteOperation::Create,\n        ));\n        summary.add_result(&WriteResult::success(\n            PathBuf::from(\"file2.rs\"),\n            WriteOperation::Edit,\n        ));\n\n        assert_eq!(summary.created, 1);\n        assert_eq!(summary.edited, 1);\n        assert_eq!(summary.total, 2);\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":109,\"end\":139},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:109-139",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use parseltongue_core::entities::*;\n    use tempfile::TempDir;\n    use chrono::Utc;\n    use std::collections::HashMap;\n\n    // Helper to create test entity\n    fn create_test_entity(isgl1_key: &str, future_code: Option<String>, temporal_state: TemporalState) -> CodeEntity {\n        CodeEntity {\n            isgl1_key: isgl1_key.to_string(),\n            temporal_state,\n            interface_signature: InterfaceSignature {\n                entity_type: EntityType::Function,\n                name: \"test_func\".to_string(),\n                visibility: Visibility::Public,\n                file_path: std::path::PathBuf::from(\"test.rs\"),\n                line_range: LineRange { start: 1, end: 10 },\n                module_path: vec![\"test\".to_string()],\n                documentation: None,\n                language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                    generics: vec![],\n                    lifetimes: vec![],\n                    where_clauses: vec![],\n                    attributes: vec![],\n                    trait_impl: None,\n                }),\n            },\n            current_code: None,\n            future_code,\n            tdd_classification: TddClassification {\n                entity_class: parseltongue_core::EntityClass::CodeImplementation,\n                testability: TestabilityLevel::High,\n                complexity: ComplexityLevel::Simple,\n                dependencies: 0,\n                test_coverage_estimate: 0.0,\n                critical_path: false,\n                change_risk: RiskLevel::Low,\n            },\n            lsp_metadata: None,\n            metadata: EntityMetadata {\n                created_at: Utc::now(),\n                modified_at: Utc::now(),\n                content_hash: \"test_hash\".to_string(),\n                additional: HashMap::new(),\n            },\n            // v0.9.0: Add mandatory entity_class field\n            entity_class: parseltongue_core::EntityClass::CodeImplementation,\n        }\n    }\n\n    // RED PHASE: These tests will fail initially\n\n    #[tokio::test]\n    async fn test_create_new_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n\n        let entity = create_test_entity(\n            \"src-utils-rs-helper_function\",\n            Some(\"fn helper() {}\".to_string()),\n            TemporalState::create(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Create);\n\n        let file_path = temp_dir.path().join(\"src/utils.rs\");\n        assert!(file_path.exists());\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn helper() {}\");\n    }\n\n    #[tokio::test]\n    async fn test_edit_existing_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/existing.rs\");\n\n        // Create directory and file\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn old() {}\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-existing-rs-NewFunc\",\n            Some(\"fn new() {}\".to_string()),\n            TemporalState::edit(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Edit);\n\n        let content = tokio::fs::read_to_string(&file_path).await.unwrap();\n        assert_eq!(content, \"fn new() {}\");\n    }\n\n    #[tokio::test]\n    async fn test_delete_file() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/delete_me.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"fn to_delete() {}\")\n            .await\n            .unwrap();\n        assert!(file_path.exists());\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-delete_me-rs-ToDelete\",\n            None,\n            TemporalState::delete(),\n        );\n\n        let result = writer.write_entity(&entity).await.unwrap();\n        assert!(result.success);\n        assert_eq!(result.operation, WriteOperation::Delete);\n        assert!(!file_path.exists());\n    }\n\n    #[tokio::test]\n    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let file_path = temp_dir.path().join(\"src/file.rs\");\n\n        tokio::fs::create_dir_all(file_path.parent().unwrap())\n            .await\n            .unwrap();\n        tokio::fs::write(&file_path, \"old content\")\n            .await\n            .unwrap();\n\n        let writer = FileWriter::new(temp_dir.path().to_path_buf());\n        let entity = create_test_entity(\n            \"src-file-rs-Func\",\n            Some(\"new content\".to_string()),\n            TemporalState::edit(),\n        );\n\n        writer.write_entity(&entity).await.unwrap();\n\n        // Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path().join(\"src\"))\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(!name_str.ends_with(\".bak\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".backup\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\"~\"), \"Found backup file: {}\", name_str);\n            assert!(!name_str.ends_with(\".old\"), \"Found backup file: {}\", name_str);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_resolve_file_path() {\n        let writer = FileWriter::new(PathBuf::from(\"/tmp\"));\n\n        let path = writer.resolve_file_path(\"src-models-rs-User\").unwrap();\n        assert_eq!(path, PathBuf::from(\"/tmp/src/models.rs\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":111,\"end\":284},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:111-284",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n\n    #[test]\n    fn test_error_display() {\n        let err = StateResetError::Database(\"connection failed\".to_string());\n        assert!(err.to_string().contains(\"Database error\"));\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/errors.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/errors.rs\",\"line_range\":{\"start\":17,\"end\":25},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt06-cozodb-make-future-code-current_src_errors_rs:17-25",
      "line_number": 0
    },
    {
      "current_code": "mod tests {\n    use super::*;\n    use parseltongue_core::entities::*;\n    use std::path::PathBuf;\n    use tempfile::TempDir;\n\n    // Helper to create test entity\n    fn create_test_entity(key: &str) -> CodeEntity {\n        let signature = InterfaceSignature {\n            entity_type: EntityType::Function,\n            name: \"test_function\".to_string(),\n            visibility: Visibility::Public,\n            file_path: PathBuf::from(\"test.rs\"),\n            line_range: LineRange { start: 1, end: 10 },\n            module_path: vec![],\n            documentation: None,\n            language_specific: LanguageSpecificSignature::Rust(RustSignature {\n                generics: vec![],\n                lifetimes: vec![],\n                where_clauses: vec![],\n                attributes: vec![],\n                trait_impl: None,\n            }),\n        };\n\n        CodeEntity::new(key.to_string(), signature, parseltongue_core::EntityClass::CodeImplementation).unwrap()\n    }\n\n    /// Executable Specification: Table deletion must remove ALL entities\n    ///\n    /// Preconditions:\n    /// - Database contains N entities\n    /// - Schema exists\n    ///\n    /// Postconditions:\n    /// - Database contains 0 entities\n    /// - No errors occur\n    ///\n    /// Error Conditions:\n    /// - Database unavailable  DatabaseError\n    #[tokio::test]\n    async fn test_delete_codegraph_table_removes_all_entities() {\n        // Setup: Create database with test entities\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Insert 3 test entities\n        let entities = vec![\n            create_test_entity(\"test-1\"),\n            create_test_entity(\"test-2\"),\n            create_test_entity(\"test-3\"),\n        ];\n        for entity in &entities {\n            storage.insert_entity(entity).await.unwrap();\n        }\n\n        let before_count = storage.get_all_entities().await.unwrap().len();\n        assert_eq!(before_count, 3, \"Precondition: Should have 3 entities\");\n\n        // Execute: Delete table\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n        assert!(result.is_ok(), \"Delete operation should succeed\");\n\n        // Postcondition: Verify ALL entities deleted\n        let after_count = manager.storage.get_all_entities().await.unwrap().len();\n        assert_eq!(\n            after_count, 0,\n            \"Postcondition: Should have 0 entities after deletion, found {}\",\n            after_count\n        );\n    }\n\n    /// Executable Specification: Reset must work with empty database\n    ///\n    /// Preconditions:\n    /// - Database is empty (0 entities)\n    ///\n    /// Postconditions:\n    /// - No errors occur\n    /// - Schema still exists and is valid\n    #[tokio::test]\n    async fn test_delete_empty_table_succeeds() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Verify empty\n        let before = storage.get_all_entities().await.unwrap();\n        assert_eq!(before.len(), 0, \"Precondition: Database should be empty\");\n\n        // Execute\n        let manager = StateResetManager::new(storage);\n        let result = manager.delete_table().await;\n\n        // Postcondition: Should succeed\n        assert!(result.is_ok(), \"Delete on empty table should succeed\");\n    }\n\n    /// Executable Specification: NO backup metadata files created\n    ///\n    /// Preconditions:\n    /// - Clean temporary directory\n    ///\n    /// Postconditions:\n    /// - NO .backup files exist\n    /// - NO .snapshot files exist\n    /// - NO .meta files exist\n    #[tokio::test]\n    async fn test_no_backup_files_created() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        let _result = manager.reset(&project_path).await;\n\n        // Postcondition: Verify NO backup files exist\n        let entries: Vec<_> = std::fs::read_dir(temp_dir.path())\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .collect();\n\n        for entry in entries {\n            let name = entry.file_name();\n            let name_str = name.to_string_lossy();\n            assert!(\n                !name_str.contains(\".backup\"),\n                \"Found backup file: {}\",\n                name_str\n            );\n            assert!(\n                !name_str.contains(\".snapshot\"),\n                \"Found snapshot file: {}\",\n                name_str\n            );\n            assert!(!name_str.contains(\".meta\"), \"Found metadata file: {}\", name_str);\n        }\n    }\n\n    /// Executable Specification: Schema recreation after deletion\n    ///\n    /// Preconditions:\n    /// - Table with entities exists\n    ///\n    /// Postconditions:\n    /// - Table is empty\n    /// - Schema is valid (can insert new entities)\n    #[tokio::test]\n    async fn test_schema_recreation_after_deletion() {\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Insert test entity\n        storage.insert_entity(&create_test_entity(\"before\")).await.unwrap();\n\n        // Reset\n        let manager = StateResetManager::new(storage);\n        manager.delete_table().await.unwrap();\n        manager.recreate_schema().await.unwrap();\n\n        // Postcondition: Can insert new entity (schema is valid)\n        let result = manager.storage.insert_entity(&create_test_entity(\"after\")).await;\n        assert!(\n            result.is_ok(),\n            \"Should be able to insert after schema recreation\"\n        );\n\n        // Verify only new entity exists\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 1, \"Should have exactly 1 entity\");\n        assert_eq!(\n            entities[0].isgl1_key, \"after\",\n            \"Should be the new entity, not old one\"\n        );\n    }\n\n    /// Executable Specification: Complete reset cycle\n    ///\n    /// Preconditions:\n    /// - Database with entities\n    /// - Valid project path\n    ///\n    /// Postconditions:\n    /// - All entities deleted\n    /// - Schema recreated\n    /// - Result indicates success\n    #[tokio::test]\n    async fn test_complete_reset_cycle() {\n        let temp_dir = TempDir::new().unwrap();\n        let storage = CozoDbStorage::new(\"mem\").await.unwrap();\n        storage.create_schema().await.unwrap();\n\n        // Precondition: Add entities\n        storage.insert_entity(&create_test_entity(\"entity-1\")).await.unwrap();\n        storage.insert_entity(&create_test_entity(\"entity-2\")).await.unwrap();\n\n        let manager = StateResetManager::new(storage);\n        let project_path = temp_dir.path().join(\"project\");\n        std::fs::create_dir_all(&project_path).unwrap();\n\n        // Execute reset\n        let result = manager.reset(&project_path).await.unwrap();\n\n        // Postconditions\n        assert!(result.success, \"Reset should succeed\");\n        assert!(result.schema_recreated, \"Schema should be recreated\");\n\n        // Verify entities deleted\n        let entities = manager.storage.get_all_entities().await.unwrap();\n        assert_eq!(entities.len(), 0, \"All entities should be deleted\");\n    }\n}",
      "current_ind": 1,
      "entity_name": "tests",
      "entity_type": "module",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"tests\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":94,\"end\":307},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:tests:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:94-307",
      "line_number": 0
    },
    {
      "current_code": "pub mod types;",
      "current_ind": 1,
      "entity_name": "types",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/lib.rs\",\"line_range\":{\"start\":53,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:types:__crates_pt04-syntax-preflight-validator_src_lib_rs:53-53",
      "line_number": 0
    },
    {
      "current_code": "pub mod types;",
      "current_ind": 1,
      "entity_name": "types",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"types\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs\",\"line_range\":{\"start\":57,\"end\":57},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:types:__crates_pt05-llm-cozodb-to-diff-writer_src_lib_rs:57-57",
      "line_number": 0
    },
    {
      "current_code": "pub mod v090_specifications;",
      "current_ind": 1,
      "entity_name": "v090_specifications",
      "entity_type": "module",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"v090_specifications\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":34,\"end\":34},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:v090_specifications:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:34-34",
      "line_number": 0
    },
    {
      "current_code": "pub mod validator;",
      "current_ind": 1,
      "entity_name": "validator",
      "entity_type": "module",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"validator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/lib.rs\",\"line_range\":{\"start\":54,\"end\":54},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:validator:__crates_pt04-syntax-preflight-validator_src_lib_rs:54-54",
      "line_number": 0
    },
    {
      "current_code": "pub mod writer;",
      "current_ind": 1,
      "entity_name": "writer",
      "entity_type": "module",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Module\",\"name\":\"writer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/lib.rs\",\"line_range\":{\"start\":58,\"end\":58},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:mod:writer:__crates_pt05-llm-cozodb-to-diff-writer_src_lib_rs:58-58",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Action {\n        pub name: String,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "Action",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Action\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1017,\"end\":1020},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Action:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1017-1020",
      "line_number": 0
    },
    {
      "current_code": "pub struct AdvancedQueryConfig {\n    pub query: String,\n    pub db_path: String,\n}",
      "current_ind": 1,
      "entity_name": "AdvancedQueryConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"AdvancedQueryConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":157,\"end\":160},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:AdvancedQueryConfig:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:157-160",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Assignment {\n        pub target: String,\n        pub value: Expression,\n    }",
      "current_ind": 1,
      "entity_name": "Assignment",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Assignment\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":955,\"end\":958},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Assignment:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:955-958",
      "line_number": 0
    },
    {
      "current_code": "    pub struct BaseSpecifier {\n        pub access: AccessSpecifier,\n        pub is_virtual: bool,\n        pub base_type: Type,\n    }",
      "current_ind": 1,
      "entity_name": "BaseSpecifier",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"BaseSpecifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":539,\"end\":543},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:BaseSpecifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:539-543",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Block {\n        pub statements: Vec<Statement>,\n    }",
      "current_ind": 1,
      "entity_name": "Block",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Block\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":772,\"end\":774},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Block:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:772-774",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CAst {\n        pub root: TranslationUnit,\n    }",
      "current_ind": 1,
      "entity_name": "CAst",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":270,\"end\":272},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:270-272",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CParseConfig {\n        pub standard: CStandard,\n        pub gnu_extensions: bool,\n        pub include_paths: Vec<String>,\n    }",
      "current_ind": 1,
      "entity_name": "CParseConfig",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CParseConfig\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":362,\"end\":366},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CParseConfig:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:362-366",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CParser {\n        preprocessor: PreprocessorCache,\n        symbol_table: SymbolTable,\n    }",
      "current_ind": 1,
      "entity_name": "CParser",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":324,\"end\":327},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:324-327",
      "line_number": 0
    },
    {
      "current_code": "pub struct Change {\n    /// ISGL1 key of the entity\n    pub isgl1_key: String,\n\n    /// File path relative to project root\n    pub file_path: PathBuf,\n\n    /// Operation to perform\n    pub operation: Operation,\n\n    /// Current code content (Some for Edit/Delete, None for Create)\n    /// Enables LLM to know exactly what code to replace\n    pub current_code: Option<String>,\n\n    /// Future code content (Some for Create/Edit, None for Delete)\n    pub future_code: Option<String>,\n\n    /// Line range for entity-level operations (extracted from ISGL1 key)\n    /// None for hash-based keys (Create operations)\n    pub line_range: Option<LineRange>,\n\n    /// Interface signature for reference\n    pub interface_signature: String,\n}",
      "current_ind": 1,
      "entity_name": "Change",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Change\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":68,\"end\":91},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Change:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:68-91",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Class {\n        pub name: String,\n        pub parent: Option<String>,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "Class",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Class\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1108,\"end\":1112},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Class:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1108-1112",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ClassDecl {\n        pub name: String,\n        pub bases: Vec<BaseSpecifier>,\n        pub members: Vec<Member>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "ClassDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ClassDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":531,\"end\":536},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ClassDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:531-536",
      "line_number": 0
    },
    {
      "current_code": "struct Cli {\n    /// Datalog WHERE clause or \"ALL\" (MANDATORY)\n    ///\n    /// Examples:\n    ///   --where \"ALL\"\n    ///   --where \"edge_type = 'depends_on'\"\n    ///   --where \"edge_type = 'implements'\"\n    ///\n    /// Datalog syntax:\n    ///   - AND: Use comma (,)     NOT &&\n    ///   - OR: Use semicolon (;)  NOT ||\n    ///   - Equality: Use =        NOT ==\n    #[arg(long)]\n    where_clause: String,\n\n    /// Output JSON file path\n    ///\n    /// Default: ISGLevel00.json\n    /// v0.9.0: Creates dual outputs - level00-code.json and level00-tests.json\n    #[arg(short, long)]\n    output: Option<PathBuf>,\n\n    /// Database file path\n    #[arg(long, default_value = \"parseltongue.db\")]\n    db: String,\n\n    /// Verbose output (show progress, token estimates)\n    #[arg(short, long)]\n    verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level00.rs\",\"line_range\":{\"start\":33,\"end\":62},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level00_rs:33-62",
      "line_number": 0
    },
    {
      "current_code": "struct Cli {\n    /// Include current_code field: 0=signatures only, 1=with code\n    ///\n    /// MANDATORY for Level 1\n    ///\n    /// Cost impact:\n    /// - 0 (signatures): ~30K tokens (cheap)\n    /// - 1 (with code): ~500-700K tokens (expensive - 100 more)\n    #[arg(long, value_parser = clap::value_parser!(u8).range(0..=1))]\n    include_code: u8,\n\n    /// Datalog WHERE clause or \"ALL\" (MANDATORY)\n    ///\n    /// Examples:\n    ///   --where \"ALL\"\n    ///   --where \"is_public = true, entity_type = 'fn'\"\n    ///   --where \"future_action != null\"\n    ///\n    /// Datalog syntax:\n    ///   - AND: Use comma (,)     NOT &&\n    ///   - OR: Use semicolon (;)  NOT ||\n    ///   - Equality: Use =        NOT ==\n    #[arg(long)]\n    where_clause: String,\n\n    /// Output JSON file path\n    ///\n    /// Default: ISGLevel01.json\n    #[arg(short, long)]\n    output: Option<PathBuf>,\n\n    /// Database file path\n    #[arg(long, default_value = \"parseltongue.db\")]\n    db: String,\n\n    /// Verbose output (show progress, token estimates)\n    #[arg(short, long)]\n    verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level01.rs\",\"line_range\":{\"start\":36,\"end\":74},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level01_rs:36-74",
      "line_number": 0
    },
    {
      "current_code": "struct Cli {\n    /// Include current_code field: 0=signatures only, 1=with code\n    ///\n    /// MANDATORY for Level 2\n    ///\n    /// Cost impact:\n    /// - 0 (signatures): ~60K tokens (cheap)\n    /// - 1 (with code): ~500-700K tokens (expensive - 100 more)\n    #[arg(long, value_parser = clap::value_parser!(u8).range(0..=1))]\n    include_code: u8,\n\n    /// Datalog WHERE clause or \"ALL\" (MANDATORY)\n    ///\n    /// Examples:\n    ///   --where \"ALL\"\n    ///   --where \"is_public = true\"\n    ///   --where \"is_async = true\"\n    ///   --where \"is_unsafe = true\"\n    ///   --where \"entity_type = 'fn', is_public = true\"\n    ///\n    /// Datalog syntax:\n    ///   - AND: Use comma (,)     NOT &&\n    ///   - OR: Use semicolon (;)  NOT ||\n    ///   - Equality: Use =        NOT ==\n    #[arg(long)]\n    where_clause: String,\n\n    /// Output JSON file path\n    ///\n    /// Default: ISGLevel02.json\n    #[arg(short, long)]\n    output: Option<PathBuf>,\n\n    /// Database file path\n    #[arg(long, default_value = \"parseltongue.db\")]\n    db: String,\n\n    /// Verbose output (show progress, token estimates)\n    #[arg(short, long)]\n    verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/bin/level02.rs\",\"line_range\":{\"start\":39,\"end\":79},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_bin_level02_rs:39-79",
      "line_number": 0
    },
    {
      "current_code": "pub struct Cli {\n    /// Export level (0=edges, 1=entities+ISG, 2=+types)\n    #[arg(long, value_parser = clap::value_parser!(u8).range(0..=2))]\n    pub level: u8,\n\n    /// Include current_code field: 0=signatures only, 1=with code\n    ///\n    /// MANDATORY for Level 1-2 (N/A for Level 0)\n    ///\n    /// Cost impact:\n    /// - 0 (signatures): ~5-60K tokens depending on level\n    /// - 1 (with code): ~500-700K tokens (100 more expensive)\n    #[arg(\n        long,\n        value_parser = clap::value_parser!(u8).range(0..=1),\n        required_if_eq(\"level\", \"1\"),\n        required_if_eq(\"level\", \"2\")\n    )]\n    pub include_code: Option<u8>,\n\n    /// Datalog WHERE clause or \"ALL\" (MANDATORY)\n    ///\n    /// IMPORTANT: Uses Datalog syntax (CozoDB native), NOT SQL!\n    ///\n    /// Examples:\n    ///   --where \"ALL\"\n    ///   --where \"is_public = true, entity_type = 'fn'\"\n    ///   --where \"line_number > 100, line_number < 500\"\n    ///\n    /// Datalog syntax:\n    ///   - AND: Use comma (,)     NOT &&\n    ///   - OR: Use semicolon (;)  NOT ||\n    ///   - Equality: Use =        NOT ==\n    #[arg(long)]\n    pub where_clause: String,\n\n    /// Output JSON file path\n    ///\n    /// Defaults: ISGLevel00.json, ISGLevel01.json, ISGLevel02.json\n    #[arg(short, long)]\n    pub output: Option<PathBuf>,\n\n    /// Database file path\n    #[arg(long, default_value = \"parseltongue.db\")]\n    pub db: String,\n\n    /// Verbose output (show progress, token estimates)\n    #[arg(short, long)]\n    pub verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cli.rs\",\"line_range\":{\"start\":47,\"end\":96},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt02-llm-cozodb-to-context-writer_src_cli_rs:47-96",
      "line_number": 0
    },
    {
      "current_code": "pub struct Cli {\n    /// Code snippet to validate (alternative to --file)\n    #[arg(long, conflicts_with = \"file\")]\n    pub code_snippet: Option<String>,\n\n    /// File containing code to validate (alternative to --code-snippet)\n    #[arg(long, conflicts_with = \"code_snippet\")]\n    pub file: Option<PathBuf>,\n\n    /// Type of validation to perform\n    #[arg(long, default_value = \"all\")]\n    pub validation_type: ValidationTypeArg,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Output format (json or text)\n    #[arg(long, default_value = \"text\")]\n    pub output_format: OutputFormat,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/cli.rs\",\"line_range\":{\"start\":7,\"end\":27},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt04-syntax-preflight-validator_src_cli_rs:7-27",
      "line_number": 0
    },
    {
      "current_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"mem\")]\n    database: String,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/main.rs\",\"line_range\":{\"start\":15,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt04-syntax-preflight-validator_src_main_rs:15-23",
      "line_number": 0
    },
    {
      "current_code": "pub struct Cli {\n    /// Path to CozoDB database\n    #[arg(long)]\n    pub database: PathBuf,\n\n    /// Root directory for file operations\n    #[arg(long)]\n    pub root: PathBuf,\n\n    /// Dry-run mode (show what would be written without actually writing)\n    #[arg(long)]\n    pub dry_run: bool,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/cli.rs\",\"line_range\":{\"start\":7,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt05-llm-cozodb-to-diff-writer_src_cli_rs:7-23",
      "line_number": 0
    },
    {
      "current_code": "struct Cli {\n    /// Path to CozoDB database\n    #[arg(long, default_value = \"./parseltongue.db\")]\n    database: String,\n\n    /// Output path for CodeDiff.json\n    #[arg(long, default_value = \"./CodeDiff.json\")]\n    output: PathBuf,\n\n    /// Verbose output\n    #[arg(short, long)]\n    verbose: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/main.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/main.rs\",\"line_range\":{\"start\":16,\"end\":28},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt05-llm-cozodb-to-diff-writer_src_main_rs:16-28",
      "line_number": 0
    },
    {
      "current_code": "pub struct Cli {\n    /// CozoDB connection string (e.g., \"rocksdb:parseltongue.db\" or \"sqlite:db.sqlite\")\n    #[arg(long)]\n    pub database: String,\n\n    /// Project root directory for re-indexing\n    #[arg(long)]\n    pub project_path: PathBuf,\n\n    /// Enable verbose output\n    #[arg(short, long)]\n    pub verbose: bool,\n\n    /// Automatically re-index after reset (PRD-compliant)\n    #[arg(long, default_value_t = true)]\n    pub reindex: bool,\n}",
      "current_ind": 1,
      "entity_name": "Cli",
      "entity_type": "struct",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Cli\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/cli.rs\",\"line_range\":{\"start\":7,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Cli:__crates_pt06-cozodb-make-future-code-current_src_cli_rs:7-23",
      "line_number": 0
    },
    {
      "current_code": "pub struct CliConfig;",
      "current_ind": 1,
      "entity_name": "CliConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CliConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/cli.rs\",\"line_range\":{\"start\":28,\"end\":28},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CliConfig:__crates_pt01-folder-to-cozodb-streamer_src_cli_rs:28-28",
      "line_number": 0
    },
    {
      "current_code": "pub struct CliConfig;",
      "current_ind": 1,
      "entity_name": "CliConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/cli.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CliConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/cli.rs\",\"line_range\":{\"start\":52,\"end\":52},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CliConfig:__crates_pt03-llm-to-cozodb-writer_src_cli_rs:52-52",
      "line_number": 0
    },
    {
      "current_code": "pub struct CodeChange {\n    pub file_path: PathBuf,\n    pub entity_name: String,\n    pub change_type: TemporalAction,\n    pub old_content: Option<String>,\n    pub new_content: String,\n    pub line_range: LineRange,\n}",
      "current_ind": 1,
      "entity_name": "CodeChange",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CodeChange\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":483,\"end\":490},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CodeChange:__crates_parseltongue-core_src_interfaces_rs:483-490",
      "line_number": 0
    },
    {
      "current_code": "pub struct CodeDiff {\n    /// List of changes to apply\n    pub changes: Vec<Change>,\n\n    /// Metadata about the diff generation\n    pub metadata: DiffMetadata,\n}",
      "current_ind": 1,
      "entity_name": "CodeDiff",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CodeDiff\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":58,\"end\":64},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CodeDiff:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:58-64",
      "line_number": 0
    },
    {
      "current_code": "pub struct CodeEntity {\n    /// Unique ISGL1 key\n    pub isgl1_key: String,\n\n    /// Temporal state\n    pub temporal_state: TemporalState,\n\n    /// Interface signature\n    pub interface_signature: InterfaceSignature,\n\n    /// Current code content\n    pub current_code: Option<String>,\n\n    /// Future code content\n    pub future_code: Option<String>,\n\n    /// TDD classification\n    pub tdd_classification: TddClassification,\n\n    /// LSP metadata (Rust-enhanced)\n    pub lsp_metadata: Option<LspMetadata>,\n\n    /// Entity metadata\n    pub metadata: EntityMetadata,\n\n    /// Entity classification (v0.9.0: mandatory field)\n    pub entity_class: EntityClass,\n}",
      "current_ind": 1,
      "entity_name": "CodeEntity",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CodeEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":454,\"end\":481},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CodeEntity:__crates_parseltongue-core_src_entities_rs:454-481",
      "line_number": 0
    },
    {
      "current_code": "pub struct CodeGraphContext {\n    pub version: String,\n    pub generated_at: chrono::DateTime<chrono::Utc>,\n    pub token_count: usize,\n    pub entities: Vec<ContextEntity>,\n    pub relationships: Vec<ContextRelationship>,\n    pub optimization_info: OptimizationInfo,\n}",
      "current_ind": 1,
      "entity_name": "CodeGraphContext",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CodeGraphContext\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":416,\"end\":423},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CodeGraphContext:__crates_parseltongue-core_src_interfaces_rs:416-423",
      "line_number": 0
    },
    {
      "current_code": "struct CodeGraphContext {\n    /// Entities from CozoDB (current_ind=1 only)\n    entities: Vec<ContextEntity>,\n    /// Count of entities\n    entity_count: usize,\n    /// Estimated token count\n    token_count: usize,\n    /// Generation timestamp\n    generated_at: String,\n}",
      "current_ind": 1,
      "entity_name": "CodeGraphContext",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CodeGraphContext\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool3_prd_compliance.rs\",\"line_range\":{\"start\":22,\"end\":31},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CodeGraphContext:__crates_parseltongue-core_tests_tool3_prd_compliance_rs:22-31",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CompoundStatement {\n        pub statements: Vec<Statement>,\n    }",
      "current_ind": 1,
      "entity_name": "CompoundStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CompoundStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":414,\"end\":416},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CompoundStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:414-416",
      "line_number": 0
    },
    {
      "current_code": "pub struct ConflictResolver {\n    strategy: ConflictResolutionStrategy,\n}",
      "current_ind": 1,
      "entity_name": "ConflictResolver",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ConflictResolver\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":464,\"end\":466},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ConflictResolver:__crates_parseltongue-core_src_temporal_rs:464-466",
      "line_number": 0
    },
    {
      "current_code": "pub struct ConsistentStateRule {\n    _private: (),\n}",
      "current_ind": 1,
      "entity_name": "ConsistentStateRule",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ConsistentStateRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":308,\"end\":310},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ConsistentStateRule:__crates_parseltongue-core_src_temporal_rs:308-310",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ConstructorDecl {\n        pub parameters: Vec<Parameter>,\n        pub initializer_list: Vec<MemberInitializer>,\n        pub body: CompoundStatement,\n        pub access: AccessSpecifier,\n    }",
      "current_ind": 1,
      "entity_name": "ConstructorDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ConstructorDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":657,\"end\":662},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ConstructorDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:657-662",
      "line_number": 0
    },
    {
      "current_code": "pub struct ContextEntity {\n    pub isgl1_key: String,\n    pub interface_signature: InterfaceSignature,\n    pub tdd_classification: TddClassification,\n    pub lsp_metadata: Option<LspMetadata>,\n    pub relevance_score: f64,\n    pub dependency_level: u32,\n}",
      "current_ind": 1,
      "entity_name": "ContextEntity",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ContextEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":427,\"end\":434},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ContextEntity:__crates_parseltongue-core_src_interfaces_rs:427-434",
      "line_number": 0
    },
    {
      "current_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value,\n    entity_class: String, // \"Test\" or \"CodeImplementation\"\n    lsp_metadata: Option<serde_json::Value>,\n}",
      "current_ind": 1,
      "entity_name": "ContextEntity",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/tests/end_to_end_workflow.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ContextEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/end_to_end_workflow.rs\",\"line_range\":{\"start\":26,\"end\":31},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ContextEntity:__crates_parseltongue-core_tests_end_to_end_workflow_rs:26-31",
      "line_number": 0
    },
    {
      "current_code": "struct ContextEntity {\n    isgl1_key: String,\n    interface_signature: serde_json::Value, // Serialized InterfaceSignature\n    entity_class: String,  // Simplified TDD Classification: \"Test\" or \"Code\"\n    lsp_metadata: Option<serde_json::Value>, // Serialized LspMetadata\n    // temporal_state removed - not in PRD requirements (P01:128)\n    // Full tdd_classification removed - only entity_class needed for Test vs Code distinction\n}",
      "current_ind": 1,
      "entity_name": "ContextEntity",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/tests/tool3_prd_compliance.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ContextEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/tests/tool3_prd_compliance.rs\",\"line_range\":{\"start\":38,\"end\":45},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ContextEntity:__crates_parseltongue-core_tests_tool3_prd_compliance_rs:38-45",
      "line_number": 0
    },
    {
      "current_code": "pub struct ContextQuery {\n    pub base_entities: Vec<String>,\n    pub hop_depth: u32,\n    pub change_type: ChangeType,\n    pub size_limit: usize,\n    pub optimization_strategy: OptimizationStrategy,\n}",
      "current_ind": 1,
      "entity_name": "ContextQuery",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ContextQuery\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":388,\"end\":394},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ContextQuery:__crates_parseltongue-core_src_interfaces_rs:388-394",
      "line_number": 0
    },
    {
      "current_code": "pub struct ContextRelationship {\n    pub dependent: String,\n    pub dependency: String,\n    pub relationship_type: String,\n    pub strength: f64,\n}",
      "current_ind": 1,
      "entity_name": "ContextRelationship",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ContextRelationship\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":438,\"end\":443},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ContextRelationship:__crates_parseltongue-core_src_interfaces_rs:438-443",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ControllerFile {\n        pub class_name: String,\n        pub parent: String,\n        pub filters: Vec<Filter>,\n        pub actions: Vec<Action>,\n    }",
      "current_ind": 1,
      "entity_name": "ControllerFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ControllerFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":995,\"end\":1000},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ControllerFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:995-1000",
      "line_number": 0
    },
    {
      "current_code": "pub struct CozoDbAdapter {\n    storage: CozoDbStorage,\n}",
      "current_ind": 1,
      "entity_name": "CozoDbAdapter",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CozoDbAdapter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/cozodb_adapter.rs\",\"line_range\":{\"start\":22,\"end\":24},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CozoDbAdapter:__crates_pt02-llm-cozodb-to-context-writer_src_cozodb_adapter_rs:22-24",
      "line_number": 0
    },
    {
      "current_code": "pub struct CozoDbStorage {\n    db: DbInstance,\n}",
      "current_ind": 1,
      "entity_name": "CozoDbStorage",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/storage/cozo_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CozoDbStorage\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/storage/cozo_client.rs\",\"line_range\":{\"start\":19,\"end\":21},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CozoDbStorage:__crates_parseltongue-core_src_storage_cozo_client_rs:19-21",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CppAst {\n        pub root: CppTranslationUnit,\n    }",
      "current_ind": 1,
      "entity_name": "CppAst",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CppAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":511,\"end\":513},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CppAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:511-513",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CppParseConfig {\n        pub standard: CppStandard,\n        pub c_config: CParseConfig,\n    }",
      "current_ind": 1,
      "entity_name": "CppParseConfig",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CppParseConfig\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":610,\"end\":613},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CppParseConfig:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:610-613",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CppParser {\n        c_parser: CParser,\n        template_cache: TemplateCache,\n        overload_resolver: OverloadResolver,\n    }",
      "current_ind": 1,
      "entity_name": "CppParser",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CppParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":575,\"end\":579},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CppParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:575-579",
      "line_number": 0
    },
    {
      "current_code": "    pub struct CppTranslationUnit {\n        pub declarations: Vec<CppDeclaration>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "CppTranslationUnit",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"CppTranslationUnit\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":516,\"end\":519},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:CppTranslationUnit:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:516-519",
      "line_number": 0
    },
    {
      "current_code": "pub struct DefaultRustValidator;",
      "current_ind": 1,
      "entity_name": "DefaultRustValidator",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DefaultRustValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":76,\"end\":76},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DefaultRustValidator:__crates_pt04-syntax-preflight-validator_src_validator_rs:76-76",
      "line_number": 0
    },
    {
      "current_code": "pub struct DefaultTestDetector;",
      "current_ind": 1,
      "entity_name": "DefaultTestDetector",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DefaultTestDetector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":26,\"end\":26},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DefaultTestDetector:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:26-26",
      "line_number": 0
    },
    {
      "current_code": "pub struct DependencyEdge {\n    /// Source entity ISGL1 key\n    pub from_key: Isgl1Key,\n    /// Target entity ISGL1 key\n    pub to_key: Isgl1Key,\n    /// Type of dependency relationship\n    pub edge_type: EdgeType,\n    /// Source code location where relationship occurs (optional)\n    pub source_location: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "DependencyEdge",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DependencyEdge\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1001,\"end\":1010},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DependencyEdge:__crates_parseltongue-core_src_entities_rs:1001-1010",
      "line_number": 0
    },
    {
      "current_code": "pub struct DependencyEdge {\n    pub from_key: String,\n    pub to_key: String,\n    pub edge_type: String,\n}",
      "current_ind": 1,
      "entity_name": "DependencyEdge",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DependencyEdge\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":106,\"end\":110},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DependencyEdge:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:106-110",
      "line_number": 0
    },
    {
      "current_code": "pub struct DependencyEdgeBuilder {\n    from_key: Option<String>,\n    to_key: Option<String>,\n    edge_type: Option<EdgeType>,\n    source_location: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "DependencyEdgeBuilder",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DependencyEdgeBuilder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":1036,\"end\":1041},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DependencyEdgeBuilder:__crates_parseltongue-core_src_entities_rs:1036-1041",
      "line_number": 0
    },
    {
      "current_code": "    pub struct DestructorDecl {\n        pub is_virtual: bool,\n        pub body: CompoundStatement,\n        pub access: AccessSpecifier,\n    }",
      "current_ind": 1,
      "entity_name": "DestructorDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DestructorDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":671,\"end\":675},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DestructorDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:671-675",
      "line_number": 0
    },
    {
      "current_code": "pub struct DiffGenerator {\n    storage: Arc<CozoDbStorage>,\n}",
      "current_ind": 1,
      "entity_name": "DiffGenerator",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DiffGenerator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_generator.rs\",\"line_range\":{\"start\":49,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DiffGenerator:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_generator_rs:49-51",
      "line_number": 0
    },
    {
      "current_code": "pub struct DiffMetadata {\n    /// Number of changes\n    pub total_changes: usize,\n\n    /// Breakdown by operation\n    pub create_count: usize,\n    pub edit_count: usize,\n    pub delete_count: usize,\n\n    /// Generation timestamp (ISO 8601)\n    pub generated_at: String,\n}",
      "current_ind": 1,
      "entity_name": "DiffMetadata",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"DiffMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":116,\"end\":127},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:DiffMetadata:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:116-127",
      "line_number": 0
    },
    {
      "current_code": "pub struct Edge {\n    pub from_key: String,\n    pub to_key: String,\n    pub edge_type: String,\n}",
      "current_ind": 1,
      "entity_name": "Edge",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Edge\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":149,\"end\":153},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Edge:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:149-153",
      "line_number": 0
    },
    {
      "current_code": "pub struct EdgeId(pub u64);",
      "current_ind": 1,
      "entity_name": "EdgeId",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"EdgeId\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":192,\"end\":192},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:EdgeId:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:192-192",
      "line_number": 0
    },
    {
      "current_code": "    pub struct EmbeddedRuby {\n        pub kind: ErbKind,\n        pub code: String,\n        pub position: usize,\n    }",
      "current_ind": 1,
      "entity_name": "EmbeddedRuby",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"EmbeddedRuby\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1038,\"end\":1042},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:EmbeddedRuby:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1038-1042",
      "line_number": 0
    },
    {
      "current_code": "pub struct Entity {\n    pub isgl1_key: String,\n    pub forward_deps: Vec<String>,\n    pub reverse_deps: Vec<String>,\n    pub current_ind: u8,\n    pub future_ind: u8,\n    pub future_action: Option<String>,\n    pub future_code: Option<String>,\n    pub current_code: Option<String>,\n    pub entity_name: String,\n    pub entity_type: String,\n    pub file_path: String,\n    pub line_number: u32,\n    pub interface_signature: String,\n    pub doc_comment: Option<String>,\n    \n    // v0.9.0: EntityClass for code/test separation\n    pub entity_class: String, // \"CODE\" or \"TEST\"\n\n    // Level 2 fields (optional, may not exist in database yet)\n    pub return_type: Option<String>,\n    pub param_types: Option<Vec<String>>,\n    pub param_names: Option<Vec<String>>,\n    pub generic_constraints: Option<Vec<String>>,\n    pub trait_impls: Option<Vec<String>>,\n    pub is_public: Option<bool>,\n    pub is_async: Option<bool>,\n    pub is_unsafe: Option<bool>,\n}",
      "current_ind": 1,
      "entity_name": "Entity",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Entity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":115,\"end\":143},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Entity:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:115-143",
      "line_number": 0
    },
    {
      "current_code": "pub struct EntityExportLevel1 {\n    pub isgl1_key: String,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub forward_deps: Vec<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub reverse_deps: Vec<String>,\n\n    pub current_ind: u8,\n    pub future_ind: u8,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub future_action: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub future_code: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub current_code: Option<String>,\n\n    pub entity_name: String,\n    pub entity_type: String,\n    pub file_path: String,\n    pub line_number: u32,\n    pub interface_signature: String,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_comment: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "EntityExportLevel1",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"EntityExportLevel1\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":133,\"end\":162},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:EntityExportLevel1:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:133-162",
      "line_number": 0
    },
    {
      "current_code": "pub struct EntityExportLevel2 {\n    // Level 1 fields (flattened for LLM readability, NOT nested)\n    pub isgl1_key: String,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub forward_deps: Vec<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub reverse_deps: Vec<String>,\n\n    pub current_ind: u8,\n    pub future_ind: u8,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub future_action: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub future_code: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub current_code: Option<String>,\n\n    pub entity_name: String,\n    pub entity_type: String,\n    pub file_path: String,\n    pub line_number: u32,\n    pub interface_signature: String,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub doc_comment: Option<String>,\n\n    // Level 2 additions: Type system essentials\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub return_type: Option<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub param_types: Vec<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub param_names: Vec<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub generic_constraints: Vec<String>,\n\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub trait_impls: Vec<String>,\n\n    pub is_public: bool,\n    pub is_async: bool,\n    pub is_unsafe: bool,\n}",
      "current_ind": 1,
      "entity_name": "EntityExportLevel2",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"EntityExportLevel2\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":180,\"end\":230},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:EntityExportLevel2:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:180-230",
      "line_number": 0
    },
    {
      "current_code": "pub struct EntityMetadata {\n    /// Creation timestamp\n    pub created_at: chrono::DateTime<chrono::Utc>,\n    /// Last modification timestamp\n    pub modified_at: chrono::DateTime<chrono::Utc>,\n    /// Hash of entity content\n    pub content_hash: String,\n    /// Additional key-value metadata\n    pub additional: HashMap<String, String>,\n}",
      "current_ind": 1,
      "entity_name": "EntityMetadata",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"EntityMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":598,\"end\":607},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:EntityMetadata:__crates_parseltongue-core_src_entities_rs:598-607",
      "line_number": 0
    },
    {
      "current_code": "pub struct ExportConfig {\n    /// Export level (0, 1, 2)\n    pub level: u8,\n\n    /// Include current_code field (N/A for Level 0, required for Level 1-2)\n    pub include_code: bool,\n\n    /// Datalog WHERE clause or \"ALL\"\n    pub where_filter: String,\n\n    /// Output JSON file path\n    pub output_path: PathBuf,\n\n    /// Database connection string\n    pub db_path: String,\n\n    // v0.9.0: Dual outputs for code/test separation\n    /// Code entities output path (when entity_class filtering is enabled)\n    pub code_output_path: Option<PathBuf>,\n\n    /// Test entities output path (when entity_class filtering is enabled)\n    pub tests_output_path: Option<PathBuf>,\n}",
      "current_ind": 1,
      "entity_name": "ExportConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ExportConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":25,\"end\":47},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ExportConfig:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:25-47",
      "line_number": 0
    },
    {
      "current_code": "pub struct ExportMetadata {\n    pub level: u8,\n    pub timestamp: String,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub total_edges: Option<usize>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub total_entities: Option<usize>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub include_code: Option<bool>,\n\n    pub where_filter: String,\n}",
      "current_ind": 1,
      "entity_name": "ExportMetadata",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ExportMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":67,\"end\":81},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ExportMetadata:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:67-81",
      "line_number": 0
    },
    {
      "current_code": "pub struct ExportOutput {\n    pub export_metadata: ExportMetadata,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub edges: Option<Vec<DependencyEdge>>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub entities: Option<serde_json::Value>,\n}",
      "current_ind": 1,
      "entity_name": "ExportOutput",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/models.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ExportOutput\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/models.rs\",\"line_range\":{\"start\":55,\"end\":63},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ExportOutput:__crates_pt02-llm-cozodb-to-context-writer_src_models_rs:55-63",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Expression {\n        pub kind: ExpressionKind,\n        pub ty: Option<Type>,\n    }",
      "current_ind": 1,
      "entity_name": "Expression",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Expression\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":428,\"end\":431},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Expression:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:428-431",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Expression {\n        pub kind: ExpressionKind,\n    }",
      "current_ind": 1,
      "entity_name": "Expression",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Expression\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":790,\"end\":792},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Expression:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:790-792",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Field {\n        pub name: String,\n        pub ty: Type,\n    }",
      "current_ind": 1,
      "entity_name": "Field",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Field\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":486,\"end\":489},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Field:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:486-489",
      "line_number": 0
    },
    {
      "current_code": "    pub struct FieldDecl {\n        pub name: String,\n        pub ty: Type,\n        pub access: AccessSpecifier,\n        pub is_static: bool,\n        pub is_mutable: bool,\n    }",
      "current_ind": 1,
      "entity_name": "FieldDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FieldDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":636,\"end\":642},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FieldDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:636-642",
      "line_number": 0
    },
    {
      "current_code": "pub struct FileId(pub u32);",
      "current_ind": 1,
      "entity_name": "FileId",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FileId\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":40,\"end\":40},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FileId:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:40-40",
      "line_number": 0
    },
    {
      "current_code": "pub struct FileResult {\n    pub file_path: String,\n    pub entities_created: usize,\n    pub success: bool,\n    pub error: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "FileResult",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FileResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":48,\"end\":53},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FileResult:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:48-53",
      "line_number": 0
    },
    {
      "current_code": "pub struct FileStreamerImpl {\n    config: StreamerConfig,\n    key_generator: Arc<dyn Isgl1KeyGenerator>,\n    lsp_client: Arc<dyn RustAnalyzerClient>,\n    test_detector: Arc<dyn TestDetector>,\n    db: Arc<CozoDbStorage>,\n    stats: std::sync::Mutex<StreamStats>,\n}",
      "current_ind": 1,
      "entity_name": "FileStreamerImpl",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FileStreamerImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":64,\"end\":71},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FileStreamerImpl:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:64-71",
      "line_number": 0
    },
    {
      "current_code": "pub struct FileWriter {\n    /// Root directory for file operations\n    root_path: PathBuf,\n}",
      "current_ind": 1,
      "entity_name": "FileWriter",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FileWriter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/writer.rs\",\"line_range\":{\"start\":14,\"end\":17},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FileWriter:__crates_pt05-llm-cozodb-to-diff-writer_src_writer_rs:14-17",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Filter {\n        pub kind: FilterKind,\n        pub name: String,\n        pub options: HashMap<String, Value>,\n    }",
      "current_ind": 1,
      "entity_name": "Filter",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Filter\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1003,\"end\":1007},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Filter:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1003-1007",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ForStatement {\n        pub variable: String,\n        pub collection: Expression,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "ForStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ForStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":988,\"end\":992},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ForStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:988-992",
      "line_number": 0
    },
    {
      "current_code": "    pub struct FunctionDecl {\n        pub name: String,\n        pub return_type: Type,\n        pub parameters: Vec<Parameter>,\n        pub body: Option<CompoundStatement>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "FunctionDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"FunctionDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":289,\"end\":295},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:FunctionDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:289-295",
      "line_number": 0
    },
    {
      "current_code": "pub struct HoverParams {\n    /// The document to query\n    pub text_document: TextDocumentIdentifier,\n    /// Position within the document\n    pub position: Position,\n}",
      "current_ind": 1,
      "entity_name": "HoverParams",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"HoverParams\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":29,\"end\":34},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:HoverParams:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:29-34",
      "line_number": 0
    },
    {
      "current_code": "pub struct HoverResponse {\n    /// Markdown content from hover\n    pub contents: String,\n    /// Raw JSON metadata for storage\n    pub raw_metadata: serde_json::Value,\n}",
      "current_ind": 1,
      "entity_name": "HoverResponse",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"HoverResponse\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":38,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:HoverResponse:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:38-43",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Identifier;",
      "current_ind": 1,
      "entity_name": "Identifier",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Identifier\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1327,\"end\":1327},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Identifier:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1327-1327",
      "line_number": 0
    },
    {
      "current_code": "    pub struct IfStatement {\n        pub condition: Expression,\n        pub then_branch: Box<Statement>,\n        pub else_branch: Option<Box<Statement>>,\n    }",
      "current_ind": 1,
      "entity_name": "IfStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"IfStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":492,\"end\":496},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:IfStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:492-496",
      "line_number": 0
    },
    {
      "current_code": "    pub struct IfStatement {\n        pub condition: Expression,\n        pub then_branch: Block,\n        pub else_branch: Option<Block>,\n    }",
      "current_ind": 1,
      "entity_name": "IfStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"IfStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":969,\"end\":973},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:IfStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:969-973",
      "line_number": 0
    },
    {
      "current_code": "pub struct IncrementalSemanticGraph {\n    nodes: Arc<HashMap<NodeId, SemanticNode>>,\n    edges: Arc<HashMap<EdgeId, SemanticEdge>>,\n    indices: Arc<SemanticIndices>,\n    version: Version,\n}",
      "current_ind": 1,
      "entity_name": "IncrementalSemanticGraph",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"IncrementalSemanticGraph\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":135,\"end\":140},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:IncrementalSemanticGraph:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:135-140",
      "line_number": 0
    },
    {
      "current_code": "struct IntegrationMockDatabase {\n    entities: Vec<Entity>,\n    edges: Vec<Edge>,\n}",
      "current_ind": 1,
      "entity_name": "IntegrationMockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"IntegrationMockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/integration_tests.rs\",\"line_range\":{\"start\":31,\"end\":34},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:IntegrationMockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_integration_tests_rs:31-34",
      "line_number": 0
    },
    {
      "current_code": "pub struct InterfaceChunk {\n    /// ISGL1 key\n    pub isgl1_key: String,\n    /// Entity type\n    pub entity_type: EntityType,\n    /// Entity name\n    pub name: String,\n    /// Interface signature\n    pub signature: InterfaceSignature,\n    /// Source code\n    pub source_code: String,\n    /// Dependencies\n    pub dependencies: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "InterfaceChunk",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"InterfaceChunk\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":201,\"end\":214},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:InterfaceChunk:__crates_parseltongue-core_src_interfaces_rs:201-214",
      "line_number": 0
    },
    {
      "current_code": "pub struct InterfaceSignature {\n    /// Type of entity\n    pub entity_type: EntityType,\n    /// Name of the entity\n    pub name: String,\n    /// Visibility level\n    pub visibility: Visibility,\n    /// File path containing this entity\n    pub file_path: PathBuf,\n    /// Line range where entity is defined\n    pub line_range: LineRange,\n    /// Module path for this entity\n    pub module_path: Vec<String>,\n    /// Documentation comment if available\n    pub documentation: Option<String>,\n    /// Language-specific signature data\n    pub language_specific: LanguageSpecificSignature,\n}",
      "current_ind": 1,
      "entity_name": "InterfaceSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"InterfaceSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":246,\"end\":263},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:InterfaceSignature:__crates_parseltongue-core_src_entities_rs:246-263",
      "line_number": 0
    },
    {
      "current_code": "pub struct Isgl1Key(String);",
      "current_ind": 1,
      "entity_name": "Isgl1Key",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Isgl1Key\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":863,\"end\":863},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Isgl1Key:__crates_parseltongue-core_src_entities_rs:863-863",
      "line_number": 0
    },
    {
      "current_code": "pub struct Isgl1KeyGeneratorFactory;",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorFactory",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Isgl1KeyGeneratorFactory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":388,\"end\":388},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Isgl1KeyGeneratorFactory:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:388-388",
      "line_number": 0
    },
    {
      "current_code": "pub struct Isgl1KeyGeneratorImpl {\n    parsers: HashMap<Language, Arc<Mutex<Parser>>>,\n    query_extractor: Mutex<QueryBasedExtractor>,  // v0.8.9: Multi-language entity extraction\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGeneratorImpl",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Isgl1KeyGeneratorImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":95,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Isgl1KeyGeneratorImpl:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:95-98",
      "line_number": 0
    },
    {
      "current_code": "pub struct JavaParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub is_varargs: bool,\n}",
      "current_ind": 1,
      "entity_name": "JavaParameter",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"JavaParameter\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":437,\"end\":441},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:JavaParameter:__crates_parseltongue-core_src_entities_rs:437-441",
      "line_number": 0
    },
    {
      "current_code": "pub struct JavaSignature {\n    /// Access modifier\n    pub access_modifier: AccessModifier,\n    /// Method parameters with types\n    pub parameters: Vec<JavaParameter>,\n    /// Return type\n    pub return_type: String,\n    /// Exception types thrown\n    pub throws: Vec<String>,\n    /// Static method\n    pub is_static: bool,\n    /// Generic parameters\n    pub generics: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "JavaSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"JavaSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":398,\"end\":411},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:JavaSignature:__crates_parseltongue-core_src_entities_rs:398-411",
      "line_number": 0
    },
    {
      "current_code": "pub struct JavascriptSignature {\n    /// Function parameters\n    pub parameters: Vec<Parameter>,\n    /// Return type annotation (if available)\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Arrow function\n    pub is_arrow: bool,\n}",
      "current_ind": 1,
      "entity_name": "JavascriptSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"JavascriptSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":359,\"end\":368},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:JavascriptSignature:__crates_parseltongue-core_src_entities_rs:359-368",
      "line_number": 0
    },
    {
      "current_code": "pub struct Level0Exporter;",
      "current_ind": 1,
      "entity_name": "Level0Exporter",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Level0Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":27,\"end\":27},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Level0Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:27-27",
      "line_number": 0
    },
    {
      "current_code": "pub struct Level1Exporter;",
      "current_ind": 1,
      "entity_name": "Level1Exporter",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Level1Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":49,\"end\":49},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Level1Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:49-49",
      "line_number": 0
    },
    {
      "current_code": "pub struct Level2Exporter;",
      "current_ind": 1,
      "entity_name": "Level2Exporter",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Level2Exporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":46,\"end\":46},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Level2Exporter:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:46-46",
      "line_number": 0
    },
    {
      "current_code": "pub struct LineRange {\n    /// Start line (1-based, inclusive)\n    pub start: u32,\n    /// End line (1-based, inclusive)\n    pub end: u32,\n}",
      "current_ind": 1,
      "entity_name": "LineRange",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LineRange\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":277,\"end\":282},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LineRange:__crates_parseltongue-core_src_entities_rs:277-282",
      "line_number": 0
    },
    {
      "current_code": "pub struct LineRange {\n    /// Start line number (inclusive)\n    pub start: u32,\n    /// End line number (inclusive)\n    pub end: u32,\n}",
      "current_ind": 1,
      "entity_name": "LineRange",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LineRange\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/diff_types.rs\",\"line_range\":{\"start\":95,\"end\":100},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LineRange:__crates_pt05-llm-cozodb-to-diff-writer_src_diff_types_rs:95-100",
      "line_number": 0
    },
    {
      "current_code": "pub struct LlmRequest {\n    pub request_id: Uuid,\n    pub context: CodeGraphContext,\n    pub task: TaskSpecification,\n    pub constraints: RequestConstraints,\n}",
      "current_ind": 1,
      "entity_name": "LlmRequest",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LlmRequest\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":279,\"end\":284},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LlmRequest:__crates_parseltongue-core_src_interfaces_rs:279-284",
      "line_number": 0
    },
    {
      "current_code": "pub struct LlmResponse {\n    pub request_id: Uuid,\n    pub reasoning: String,\n    pub proposed_changes: Vec<ProposedChange>,\n    pub confidence_score: f64,\n    pub validation_status: ValidationStatus,\n}",
      "current_ind": 1,
      "entity_name": "LlmResponse",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LlmResponse\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":288,\"end\":294},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LlmResponse:__crates_parseltongue-core_src_interfaces_rs:288-294",
      "line_number": 0
    },
    {
      "current_code": "pub struct LlmWriterConfig {\n    /// Datalog query to execute\n    pub query: String,\n    /// Database connection string\n    pub db_path: String,\n}",
      "current_ind": 1,
      "entity_name": "LlmWriterConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LlmWriterConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":167,\"end\":172},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LlmWriterConfig:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:167-172",
      "line_number": 0
    },
    {
      "current_code": "pub struct Location {\n    pub file_path: PathBuf,\n    pub line: u32,\n    pub character: u32,\n}",
      "current_ind": 1,
      "entity_name": "Location",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Location\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":581,\"end\":585},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Location:__crates_parseltongue-core_src_entities_rs:581-585",
      "line_number": 0
    },
    {
      "current_code": "pub struct LspMetadata {\n    /// Type information\n    pub type_information: TypeInformation,\n    /// Usage analysis\n    pub usage_analysis: UsageAnalysis,\n    /// Semantic tokens\n    pub semantic_tokens: Vec<SemanticToken>,\n}",
      "current_ind": 1,
      "entity_name": "LspMetadata",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"LspMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":546,\"end\":553},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:LspMetadata:__crates_parseltongue-core_src_entities_rs:546-553",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Macro {\n        pub name: String,\n        pub parameters: Option<Vec<String>>,\n        pub body: String,\n    }",
      "current_ind": 1,
      "entity_name": "Macro",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Macro\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":401,\"end\":405},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Macro:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:401-405",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Many1<P> {\n        parser: P,\n    }",
      "current_ind": 1,
      "entity_name": "Many1",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Many1\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1279,\"end\":1281},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Many1:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1279-1281",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Many<P> {\n        parser: P,\n    }",
      "current_ind": 1,
      "entity_name": "Many",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Many\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1257,\"end\":1259},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Many:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1257-1259",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Map<P, F> {\n        parser: P,\n        mapper: F,\n    }",
      "current_ind": 1,
      "entity_name": "Map",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Map\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1189,\"end\":1192},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Map:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1189-1192",
      "line_number": 0
    },
    {
      "current_code": "    pub struct MemberInitializer {\n        pub member: String,\n        pub init: Expression,\n    }",
      "current_ind": 1,
      "entity_name": "MemberInitializer",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MemberInitializer\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":665,\"end\":668},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MemberInitializer:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:665-668",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Method {\n        pub name: String,\n        pub parameters: Vec<Parameter>,\n        pub body: Block,\n        pub visibility: Visibility,\n    }",
      "current_ind": 1,
      "entity_name": "Method",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Method\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":757,\"end\":762},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Method:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:757-762",
      "line_number": 0
    },
    {
      "current_code": "    pub struct MethodCall {\n        pub receiver: Option<Box<Expression>>,\n        pub method: String,\n        pub arguments: Vec<Expression>,\n        pub block: Option<Block>,\n    }",
      "current_ind": 1,
      "entity_name": "MethodCall",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MethodCall\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":961,\"end\":966},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MethodCall:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:961-966",
      "line_number": 0
    },
    {
      "current_code": "    pub struct MethodDecl {\n        pub name: String,\n        pub return_type: Type,\n        pub parameters: Vec<Parameter>,\n        pub access: AccessSpecifier,\n        pub is_static: bool,\n        pub is_virtual: bool,\n        pub is_const: bool,\n        pub body: Option<CompoundStatement>,\n    }",
      "current_ind": 1,
      "entity_name": "MethodDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MethodDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":645,\"end\":654},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MethodDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:645-654",
      "line_number": 0
    },
    {
      "current_code": "    pub struct MigrationFile {\n        pub class_name: String,\n        pub version: String,\n        pub up_method: Option<Block>,\n        pub down_method: Option<Block>,\n        pub change_method: Option<Block>,\n    }",
      "current_ind": 1,
      "entity_name": "MigrationFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MigrationFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1052,\"end\":1058},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MigrationFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1052-1058",
      "line_number": 0
    },
    {
      "current_code": "    struct MockDatabase {\n        edges: Vec<Edge>,\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level0.rs\",\"line_range\":{\"start\":105,\"end\":107},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level0_rs:105-107",
      "line_number": 0
    },
    {
      "current_code": "    struct MockDatabase {\n        entities: Vec<Entity>,\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level1.rs\",\"line_range\":{\"start\":194,\"end\":196},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level1_rs:194-196",
      "line_number": 0
    },
    {
      "current_code": "    struct MockDatabase {\n        entities: Vec<Entity>,\n    }",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/exporters/level2.rs\",\"line_range\":{\"start\":169,\"end\":171},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_src_exporters_level2_rs:169-171",
      "line_number": 0
    },
    {
      "current_code": "struct MockDatabase {\n    edges: Vec<Edge>,\n    entities: Vec<Entity>,\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level0_tests.rs\",\"line_range\":{\"start\":32,\"end\":35},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level0_tests_rs:32-35",
      "line_number": 0
    },
    {
      "current_code": "struct MockDatabase {\n    entities: Vec<Entity>,\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level1_tests.rs\",\"line_range\":{\"start\":38,\"end\":40},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level1_tests_rs:38-40",
      "line_number": 0
    },
    {
      "current_code": "struct MockDatabase {\n    entities: Vec<Entity>,\n}",
      "current_ind": 1,
      "entity_name": "MockDatabase",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockDatabase\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/tests/level2_tests.rs\",\"line_range\":{\"start\":34,\"end\":36},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockDatabase:__crates_pt02-llm-cozodb-to-context-writer_tests_level2_tests_rs:34-36",
      "line_number": 0
    },
    {
      "current_code": "    struct MockExporter {\n        level: u8,\n        tokens: usize,\n    }",
      "current_ind": 1,
      "entity_name": "MockExporter",
      "entity_type": "struct",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockExporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":160,\"end\":163},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockExporter:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:160-163",
      "line_number": 0
    },
    {
      "current_code": "pub struct MockRustAnalyzerClient {\n    responses: std::collections::HashMap<String, HoverResponse>,\n}",
      "current_ind": 1,
      "entity_name": "MockRustAnalyzerClient",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockRustAnalyzerClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":101,\"end\":103},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockRustAnalyzerClient:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:101-103",
      "line_number": 0
    },
    {
      "current_code": "    pub struct MockTool {\n        pub metadata: ToolMetadata,\n        pub execute_result: Option<Result<ToolOutput>>,\n        pub should_fail: bool,\n    }",
      "current_ind": 1,
      "entity_name": "MockTool",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"MockTool\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":542,\"end\":546},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:MockTool:__crates_parseltongue-core_src_interfaces_rs:542-546",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ModelFile {\n        pub class_name: String,\n        pub parent: String,\n        pub associations: Vec<Association>,\n        pub validations: Vec<Validation>,\n        pub scopes: Vec<Scope>,\n        pub methods: Vec<Method>,\n    }",
      "current_ind": 1,
      "entity_name": "ModelFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ModelFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":716,\"end\":723},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ModelFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:716-723",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Module {\n        pub name: String,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "Module",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Module\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1115,\"end\":1118},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Module:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1115-1118",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Namespace {\n        pub name: String,\n        pub routes: Vec<Route>,\n        pub resources: Vec<Resource>,\n    }",
      "current_ind": 1,
      "entity_name": "Namespace",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Namespace\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1085,\"end\":1089},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Namespace:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1085-1089",
      "line_number": 0
    },
    {
      "current_code": "    pub struct NamespaceDecl {\n        pub name: Option<String>,  // None for anonymous namespace\n        pub declarations: Vec<CppDeclaration>,\n    }",
      "current_ind": 1,
      "entity_name": "NamespaceDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"NamespaceDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":684,\"end\":687},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:NamespaceDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:684-687",
      "line_number": 0
    },
    {
      "current_code": "pub struct NoCircularDependenciesRule {\n    _private: (),\n}",
      "current_ind": 1,
      "entity_name": "NoCircularDependenciesRule",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"NoCircularDependenciesRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":266,\"end\":268},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:NoCircularDependenciesRule:__crates_parseltongue-core_src_temporal_rs:266-268",
      "line_number": 0
    },
    {
      "current_code": "pub struct NodeId(pub u64);",
      "current_ind": 1,
      "entity_name": "NodeId",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"NodeId\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":127,\"end\":127},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:NodeId:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:127-127",
      "line_number": 0
    },
    {
      "current_code": "pub struct OptimizationInfo {\n    pub excluded_entities: Vec<String>,\n    pub truncation_applied: bool,\n    pub prioritization_strategy: String,\n}",
      "current_ind": 1,
      "entity_name": "OptimizationInfo",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"OptimizationInfo\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":447,\"end\":451},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:OptimizationInfo:__crates_parseltongue-core_src_interfaces_rs:447-451",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Optional<P> {\n        parser: P,\n    }",
      "current_ind": 1,
      "entity_name": "Optional",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Optional\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1240,\"end\":1242},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Optional:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1240-1242",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Or<P1, P2> {\n        first: P1,\n        second: P2,\n    }",
      "current_ind": 1,
      "entity_name": "Or",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Or\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1224,\"end\":1227},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Or:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1224-1227",
      "line_number": 0
    },
    {
      "current_code": "    pub struct OverloadResolver {\n        candidates: Vec<FunctionDecl>,\n    }",
      "current_ind": 1,
      "entity_name": "OverloadResolver",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"OverloadResolver\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":631,\"end\":633},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:OverloadResolver:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:631-633",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Parameter {\n        pub name: Option<String>,\n        pub ty: Type,\n    }",
      "current_ind": 1,
      "entity_name": "Parameter",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Parameter\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":408,\"end\":411},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Parameter:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:408-411",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Parameter {\n        pub name: String,\n        pub default: Option<Value>,\n        pub kind: ParameterKind,\n    }",
      "current_ind": 1,
      "entity_name": "Parameter",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Parameter\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":939,\"end\":943},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Parameter:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:939-943",
      "line_number": 0
    },
    {
      "current_code": "pub struct Parameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "Parameter",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Parameter\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":415,\"end\":418},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Parameter:__crates_parseltongue-core_src_entities_rs:415-418",
      "line_number": 0
    },
    {
      "current_code": "pub struct ParsedEntity {\n    pub entity_type: EntityType,\n    pub name: String,\n    pub language: Language,\n    pub line_range: (usize, usize),\n    pub file_path: String,\n    pub metadata: HashMap<String, String>,\n}",
      "current_ind": 1,
      "entity_name": "ParsedEntity",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ParsedEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":36,\"end\":43},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ParsedEntity:__crates_parseltongue-core_src_query_extractor_rs:36-43",
      "line_number": 0
    },
    {
      "current_code": "pub struct ParsedEntity {\n    pub entity_type: EntityType,\n    pub name: String,\n    pub language: Language,\n    pub line_range: (usize, usize),\n    pub file_path: String,\n    pub metadata: HashMap<String, String>,\n}",
      "current_ind": 1,
      "entity_name": "ParsedEntity",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ParsedEntity\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":44,\"end\":51},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ParsedEntity:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:44-51",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Pattern {\n        pub name: String,\n        pub regex: String,\n        pub captures: Vec<String>,\n    }",
      "current_ind": 1,
      "entity_name": "Pattern",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Pattern\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":908,\"end\":912},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Pattern:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:908-912",
      "line_number": 0
    },
    {
      "current_code": "    pub struct PatternMatcher {\n        patterns: Vec<Pattern>,\n    }",
      "current_ind": 1,
      "entity_name": "PatternMatcher",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PatternMatcher\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":903,\"end\":905},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PatternMatcher:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:903-905",
      "line_number": 0
    },
    {
      "current_code": "pub struct PerformanceMetrics {\n    pub operation_count: u64,\n    pub total_duration: std::time::Duration,\n    pub average_duration: std::time::Duration,\n    pub success_rate: f64,\n    pub min_duration: std::time::Duration,\n    pub max_duration: std::time::Duration,\n}",
      "current_ind": 1,
      "entity_name": "PerformanceMetrics",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PerformanceMetrics\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":517,\"end\":524},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PerformanceMetrics:__crates_parseltongue-core_src_interfaces_rs:517-524",
      "line_number": 0
    },
    {
      "current_code": "pub struct PerformanceViolation {\n    pub operation_type: String,\n    pub constraint: String,\n    pub actual_value: String,\n    pub expected_value: String,\n}",
      "current_ind": 1,
      "entity_name": "PerformanceViolation",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PerformanceViolation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":528,\"end\":533},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PerformanceViolation:__crates_parseltongue-core_src_interfaces_rs:528-533",
      "line_number": 0
    },
    {
      "current_code": "pub struct Position {\n    pub file_path: String,\n    pub line: u32,\n    pub character: u32,\n}",
      "current_ind": 1,
      "entity_name": "Position",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Position\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":245,\"end\":249},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Position:__crates_parseltongue-core_src_interfaces_rs:245-249",
      "line_number": 0
    },
    {
      "current_code": "pub struct Position {\n    /// Line number (0-indexed)\n    pub line: u32,\n    /// Character offset on the line (0-indexed)\n    pub character: u32,\n}",
      "current_ind": 1,
      "entity_name": "Position",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Position\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":13,\"end\":18},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Position:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:13-18",
      "line_number": 0
    },
    {
      "current_code": "    pub struct PreprocessorCache {\n        expanded: HashMap<FileId, String>,\n        macros: HashMap<String, Macro>,\n    }",
      "current_ind": 1,
      "entity_name": "PreprocessorCache",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PreprocessorCache\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":377,\"end\":380},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PreprocessorCache:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:377-380",
      "line_number": 0
    },
    {
      "current_code": "pub struct ProposedChange {\n    pub target_entity: String,\n    pub change_type: TemporalAction,\n    pub new_content: String,\n    pub justification: String,\n    pub affected_dependencies: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "ProposedChange",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ProposedChange\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":338,\"end\":344},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ProposedChange:__crates_parseltongue-core_src_interfaces_rs:338-344",
      "line_number": 0
    },
    {
      "current_code": "pub struct PythonParameter {\n    pub name: String,\n    pub type_annotation: Option<String>,\n    pub default_value: Option<String>,\n    pub is_varargs: bool,\n    pub is_kwargs: bool,\n}",
      "current_ind": 1,
      "entity_name": "PythonParameter",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PythonParameter\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":428,\"end\":434},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PythonParameter:__crates_parseltongue-core_src_entities_rs:428-434",
      "line_number": 0
    },
    {
      "current_code": "pub struct PythonSignature {\n    /// Function parameters\n    pub parameters: Vec<PythonParameter>,\n    /// Return type annotation\n    pub return_type: Option<String>,\n    /// Async function\n    pub is_async: bool,\n    /// Decorators\n    pub decorators: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "PythonSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"PythonSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":385,\"end\":394},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:PythonSignature:__crates_parseltongue-core_src_entities_rs:385-394",
      "line_number": 0
    },
    {
      "current_code": "pub struct QueryBasedExtractor {\n    queries: HashMap<Language, String>,\n    dependency_queries: HashMap<Language, String>,  // v0.9.0: Dependency extraction\n    parsers: HashMap<Language, Parser>,\n}",
      "current_ind": 1,
      "entity_name": "QueryBasedExtractor",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/query_extractor.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"QueryBasedExtractor\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/query_extractor.rs\",\"line_range\":{\"start\":62,\"end\":66},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:QueryBasedExtractor:__crates_parseltongue-core_src_query_extractor_rs:62-66",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RailsAst {\n        pub root: RailsFile,\n    }",
      "current_ind": 1,
      "entity_name": "RailsAst",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RailsAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":701,\"end\":703},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RailsAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:701-703",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RailsParseConfig {\n        pub rails_version: RailsVersion,\n        pub strict_mode: bool,\n    }",
      "current_ind": 1,
      "entity_name": "RailsParseConfig",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RailsParseConfig\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":882,\"end\":885},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RailsParseConfig:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:882-885",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RailsParser {\n        ruby_parser: RubyParser,\n        pattern_matcher: PatternMatcher,\n    }",
      "current_ind": 1,
      "entity_name": "RailsParser",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RailsParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":848,\"end\":851},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RailsParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:848-851",
      "line_number": 0
    },
    {
      "current_code": "pub struct RateLimitStatus {\n    pub requests_remaining: u32,\n    pub reset_time: std::time::SystemTime,\n    pub limit: u32,\n}",
      "current_ind": 1,
      "entity_name": "RateLimitStatus",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RateLimitStatus\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":365,\"end\":369},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RateLimitStatus:__crates_parseltongue-core_src_interfaces_rs:365-369",
      "line_number": 0
    },
    {
      "current_code": "pub struct RequestConstraints {\n    pub max_tokens: usize,\n    pub temperature: f64,\n    pub min_confidence: f64,\n}",
      "current_ind": 1,
      "entity_name": "RequestConstraints",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RequestConstraints\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":330,\"end\":334},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RequestConstraints:__crates_parseltongue-core_src_interfaces_rs:330-334",
      "line_number": 0
    },
    {
      "current_code": "pub struct ResetResult {\n    /// Whether reset succeeded\n    pub success: bool,\n    /// Number of entities before reset\n    pub entities_deleted: usize,\n    /// Whether schema was recreated\n    pub schema_recreated: bool,\n}",
      "current_ind": 1,
      "entity_name": "ResetResult",
      "entity_type": "struct",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ResetResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":73,\"end\":80},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ResetResult:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:73-80",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Resource {\n        pub name: String,\n        pub only: Option<Vec<String>>,\n        pub except: Option<Vec<String>>,\n        pub nested: Vec<Resource>,\n    }",
      "current_ind": 1,
      "entity_name": "Resource",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Resource\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1092,\"end\":1097},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Resource:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1092-1097",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Route {\n        pub method: HttpMethod,\n        pub path: String,\n        pub controller_action: String,\n        pub constraints: HashMap<String, String>,\n    }",
      "current_ind": 1,
      "entity_name": "Route",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Route\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1068,\"end\":1073},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Route:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1068-1073",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RoutesFile {\n        pub routes: Vec<Route>,\n        pub namespaces: Vec<Namespace>,\n        pub resources: Vec<Resource>,\n    }",
      "current_ind": 1,
      "entity_name": "RoutesFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RoutesFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1061,\"end\":1065},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RoutesFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1061-1065",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RubyFile {\n        pub classes: Vec<Class>,\n        pub modules: Vec<Module>,\n        pub methods: Vec<Method>,\n        pub statements: Vec<Statement>,\n    }",
      "current_ind": 1,
      "entity_name": "RubyFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RubyFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1100,\"end\":1105},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RubyFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1100-1105",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RubyLexer {\n        keywords: HashMap<String, TokenType>,\n    }",
      "current_ind": 1,
      "entity_name": "RubyLexer",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RubyLexer\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":899,\"end\":901},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RubyLexer:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:899-901",
      "line_number": 0
    },
    {
      "current_code": "    pub struct RubyParser {\n        lexer: RubyLexer,\n    }",
      "current_ind": 1,
      "entity_name": "RubyParser",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RubyParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":895,\"end\":897},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RubyParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:895-897",
      "line_number": 0
    },
    {
      "current_code": "pub struct RustAnalyzerClientImpl {\n    // TODO: Add LSP process handle and communication channel\n    enabled: bool,\n}",
      "current_ind": 1,
      "entity_name": "RustAnalyzerClientImpl",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RustAnalyzerClientImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":62,\"end\":65},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RustAnalyzerClientImpl:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:62-65",
      "line_number": 0
    },
    {
      "current_code": "pub struct RustSignature {\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Lifetime parameters\n    pub lifetimes: Vec<String>,\n    /// Where clauses\n    pub where_clauses: Vec<String>,\n    /// Attributes\n    pub attributes: Vec<String>,\n    /// Trait implementations if this is an impl block\n    pub trait_impl: Option<TraitImpl>,\n}",
      "current_ind": 1,
      "entity_name": "RustSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"RustSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":335,\"end\":346},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:RustSignature:__crates_parseltongue-core_src_entities_rs:335-346",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Scope {\n        symbols: HashMap<String, Symbol>,\n        parent: Option<usize>,\n    }",
      "current_ind": 1,
      "entity_name": "Scope",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Scope\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":388,\"end\":391},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Scope:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:388-391",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Scope {\n        pub name: String,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "Scope",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Scope\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":751,\"end\":754},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Scope:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:751-754",
      "line_number": 0
    },
    {
      "current_code": "pub struct SemanticEdge {\n    pub id: EdgeId,\n    pub kind: EdgeKind,\n    pub from: NodeId,\n    pub to: NodeId,\n    pub attributes: HashMap<String, AttributeValue>,\n}",
      "current_ind": 1,
      "entity_name": "SemanticEdge",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SemanticEdge\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":183,\"end\":189},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SemanticEdge:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:183-189",
      "line_number": 0
    },
    {
      "current_code": "pub struct SemanticIndices {\n    by_name: HashMap<String, Vec<NodeId>>,\n    by_kind: HashMap<SemanticKind, Vec<NodeId>>,\n    by_source: HashMap<FileId, Vec<NodeId>>,\n    edges_from: HashMap<NodeId, Vec<EdgeId>>,\n    edges_to: HashMap<NodeId, Vec<EdgeId>>,\n}",
      "current_ind": 1,
      "entity_name": "SemanticIndices",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SemanticIndices\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":236,\"end\":242},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SemanticIndices:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:236-242",
      "line_number": 0
    },
    {
      "current_code": "pub struct SemanticNode {\n    pub id: NodeId,\n    pub kind: SemanticKind,\n    pub name: String,\n    pub source: SourceRange,\n    pub attributes: HashMap<String, AttributeValue>,\n}",
      "current_ind": 1,
      "entity_name": "SemanticNode",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SemanticNode\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":143,\"end\":149},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SemanticNode:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:143-149",
      "line_number": 0
    },
    {
      "current_code": "pub struct SemanticToken {\n    pub position: Location,\n    pub length: u32,\n    pub token_type: String,\n    pub modifiers: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "SemanticToken",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SemanticToken\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":589,\"end\":594},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SemanticToken:__crates_parseltongue-core_src_entities_rs:589-594",
      "line_number": 0
    },
    {
      "current_code": "pub struct SimpleSyntaxValidator {\n    parsers: HashMap<Language, Parser>,\n}",
      "current_ind": 1,
      "entity_name": "SimpleSyntaxValidator",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SimpleSyntaxValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":42,\"end\":44},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SimpleSyntaxValidator:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:42-44",
      "line_number": 0
    },
    {
      "current_code": "pub struct SimpleUpdateConfig {\n    pub entity_key: String,\n    pub action: EntityAction,\n    pub future_code: Option<String>,\n    pub db_path: String,\n}",
      "current_ind": 1,
      "entity_name": "SimpleUpdateConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt03-llm-to-cozodb-writer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SimpleUpdateConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt03-llm-to-cozodb-writer/src/lib.rs\",\"line_range\":{\"start\":59,\"end\":64},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SimpleUpdateConfig:__crates_pt03-llm-to-cozodb-writer_src_lib_rs:59-64",
      "line_number": 0
    },
    {
      "current_code": "pub struct SourceRange {\n    pub start: usize,\n    pub end: usize,\n    pub file_id: FileId,\n}",
      "current_ind": 1,
      "entity_name": "SourceRange",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SourceRange\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":33,\"end\":37},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SourceRange:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:33-37",
      "line_number": 0
    },
    {
      "current_code": "pub struct StateResetManager {\n    pub(crate) storage: CozoDbStorage,\n}",
      "current_ind": 1,
      "entity_name": "StateResetManager",
      "entity_type": "struct",
      "file_path": "./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"StateResetManager\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt06-cozodb-make-future-code-current/src/state_reset.rs\",\"line_range\":{\"start\":10,\"end\":12},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:StateResetManager:__crates_pt06-cozodb-make-future-code-current_src_state_reset_rs:10-12",
      "line_number": 0
    },
    {
      "current_code": "pub struct StreamResult {\n    pub total_files: usize,\n    pub processed_files: usize,\n    pub entities_created: usize,\n    pub errors: Vec<String>,\n    pub duration: std::time::Duration,\n}",
      "current_ind": 1,
      "entity_name": "StreamResult",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"StreamResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":38,\"end\":44},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:StreamResult:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:38-44",
      "line_number": 0
    },
    {
      "current_code": "pub struct StreamStats {\n    pub files_processed: usize,\n    pub entities_created: usize,\n    pub errors_encountered: usize,\n}",
      "current_ind": 1,
      "entity_name": "StreamStats",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"StreamStats\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":57,\"end\":61},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:StreamStats:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:57-61",
      "line_number": 0
    },
    {
      "current_code": "pub struct StreamerConfig {\n    /// Root directory to scan for code files\n    pub root_dir: PathBuf,\n    /// Database connection string\n    pub db_path: String,\n    /// Maximum file size to process (bytes)\n    pub max_file_size: usize,\n    /// File patterns to include\n    pub include_patterns: Vec<String>,\n    /// File patterns to exclude\n    pub exclude_patterns: Vec<String>,\n    /// Parsing library to use (default: \"tree-sitter\")\n    pub parsing_library: String,\n    /// Chunking strategy to use (default: \"ISGL1\")\n    pub chunking: String,\n}",
      "current_ind": 1,
      "entity_name": "StreamerConfig",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"StreamerConfig\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":45,\"end\":60},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:StreamerConfig:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:45-60",
      "line_number": 0
    },
    {
      "current_code": "    pub struct StructDecl {\n        pub name: Option<String>,\n        pub fields: Vec<Field>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "StructDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"StructDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":479,\"end\":483},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:StructDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:479-483",
      "line_number": 0
    },
    {
      "current_code": "pub struct SuccessCriteria {\n    pub min_confidence: f64,\n    pub max_duration: std::time::Duration,\n    pub validation_rules: Vec<ValidationRule>,\n}",
      "current_ind": 1,
      "entity_name": "SuccessCriteria",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SuccessCriteria\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":315,\"end\":319},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SuccessCriteria:__crates_parseltongue-core_src_interfaces_rs:315-319",
      "line_number": 0
    },
    {
      "current_code": "    pub struct SymbolTable {\n        scopes: Vec<Scope>,\n        current_scope: usize,\n    }",
      "current_ind": 1,
      "entity_name": "SymbolTable",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"SymbolTable\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":382,\"end\":385},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:SymbolTable:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:382-385",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Tag<'a> {\n        expected: &'a str,\n    }",
      "current_ind": 1,
      "entity_name": "Tag",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Tag\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1305,\"end\":1307},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Tag:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1305-1307",
      "line_number": 0
    },
    {
      "current_code": "pub struct TaskSpecification {\n    pub task_type: TaskType,\n    pub instruction: String,\n    pub success_criteria: SuccessCriteria,\n}",
      "current_ind": 1,
      "entity_name": "TaskSpecification",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TaskSpecification\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":298,\"end\":302},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TaskSpecification:__crates_parseltongue-core_src_interfaces_rs:298-302",
      "line_number": 0
    },
    {
      "current_code": "pub struct TddClassification {\n    /// Entity classification (test vs production code)\n    pub entity_class: EntityClass,\n    /// Testability level\n    pub testability: TestabilityLevel,\n    /// Complexity assessment\n    pub complexity: ComplexityLevel,\n    /// Number of dependencies\n    pub dependencies: usize,\n    /// Estimated test coverage\n    pub test_coverage_estimate: f64,\n    /// Whether this is on critical path\n    pub critical_path: bool,\n    /// Change risk assessment\n    pub change_risk: RiskLevel,\n}",
      "current_ind": 1,
      "entity_name": "TddClassification",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TddClassification\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":503,\"end\":518},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TddClassification:__crates_parseltongue-core_src_entities_rs:503-518",
      "line_number": 0
    },
    {
      "current_code": "    pub struct TemplateCache {\n        instantiations: HashMap<(String, Vec<Type>), CppAst>,\n    }",
      "current_ind": 1,
      "entity_name": "TemplateCache",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemplateCache\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":627,\"end\":629},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemplateCache:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:627-629",
      "line_number": 0
    },
    {
      "current_code": "    pub struct TemplateDecl {\n        pub parameters: Vec<TemplateParameter>,\n        pub declaration: Box<CppDeclaration>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "TemplateDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemplateDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":562,\"end\":566},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemplateDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:562-566",
      "line_number": 0
    },
    {
      "current_code": "pub struct TemporalChange {\n    pub isgl1_key: String,\n    pub action: TemporalAction,\n    pub future_code: Option<String>,\n    pub updated_signature: Option<InterfaceSignature>,\n}",
      "current_ind": 1,
      "entity_name": "TemporalChange",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemporalChange\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":455,\"end\":460},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemporalChange:__crates_parseltongue-core_src_interfaces_rs:455-460",
      "line_number": 0
    },
    {
      "current_code": "pub struct TemporalQuery {\n    /// Base entities to start from\n    pub base_entities: Vec<String>,\n    /// Hop depth for dependency analysis\n    pub hop_depth: u32,\n    /// Include future changes only\n    pub future_only: bool,\n    /// Entity type filter\n    pub entity_type_filter: Option<EntityType>,\n    /// Language filter\n    pub language_filter: Option<Language>,\n}",
      "current_ind": 1,
      "entity_name": "TemporalQuery",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemporalQuery\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":168,\"end\":179},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemporalQuery:__crates_parseltongue-core_src_interfaces_rs:168-179",
      "line_number": 0
    },
    {
      "current_code": "pub struct TemporalState {\n    /// Entity exists in current state\n    pub current_ind: bool,\n    /// Entity will exist in future state\n    pub future_ind: bool,\n    /// Action to transition from current to future\n    pub future_action: Option<TemporalAction>,\n}",
      "current_ind": 1,
      "entity_name": "TemporalState",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemporalState\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":152,\"end\":159},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemporalState:__crates_parseltongue-core_src_entities_rs:152-159",
      "line_number": 0
    },
    {
      "current_code": "pub struct TemporalTransitionBuilder {\n    isgl1_key: String,\n    action: Option<TemporalAction>,\n    future_code: Option<String>,\n    updated_signature: Option<InterfaceSignature>,\n}",
      "current_ind": 1,
      "entity_name": "TemporalTransitionBuilder",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemporalTransitionBuilder\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":398,\"end\":403},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemporalTransitionBuilder:__crates_parseltongue-core_src_temporal_rs:398-403",
      "line_number": 0
    },
    {
      "current_code": "pub struct TemporalVersioningManager {\n    /// Current state of all entities\n    entities: HashMap<String, CodeEntity>,\n    /// Pending changes not yet applied\n    #[allow(dead_code)]\n    pending_changes: Vec<TemporalChange>,\n    /// Validation rules\n    validation_rules: Vec<Box<dyn TemporalValidationRule>>,\n}",
      "current_ind": 1,
      "entity_name": "TemporalVersioningManager",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TemporalVersioningManager\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":17,\"end\":25},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TemporalVersioningManager:__crates_parseltongue-core_src_temporal_rs:17-25",
      "line_number": 0
    },
    {
      "current_code": "    struct TestAst {\n        nodes: Vec<TestNode>,\n    }",
      "current_ind": 1,
      "entity_name": "TestAst",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TestAst\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1393,\"end\":1395},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TestAst:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1393-1395",
      "line_number": 0
    },
    {
      "current_code": "    struct TestNode {\n        kind: String,\n        value: String,\n    }",
      "current_ind": 1,
      "entity_name": "TestNode",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TestNode\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1398,\"end\":1401},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TestNode:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1398-1401",
      "line_number": 0
    },
    {
      "current_code": "    struct TestParser;",
      "current_ind": 1,
      "entity_name": "TestParser",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TestParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1418,\"end\":1418},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TestParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1418-1418",
      "line_number": 0
    },
    {
      "current_code": "pub struct TextDocumentIdentifier {\n    /// The document's URI (file:// path)\n    pub uri: String,\n}",
      "current_ind": 1,
      "entity_name": "TextDocumentIdentifier",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TextDocumentIdentifier\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":22,\"end\":25},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TextDocumentIdentifier:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:22-25",
      "line_number": 0
    },
    {
      "current_code": "pub struct TextEdit {\n    pub range: SourceRange,\n    pub new_text: String,\n}",
      "current_ind": 1,
      "entity_name": "TextEdit",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TextEdit\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":112,\"end\":115},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TextEdit:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:112-115",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Then<P1, P2> {\n        first: P1,\n        second: P2,\n    }",
      "current_ind": 1,
      "entity_name": "Then",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Then\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1206,\"end\":1209},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Then:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1206-1209",
      "line_number": 0
    },
    {
      "current_code": "pub struct ToolCapabilities {\n    /// Supports async execution\n    pub async_execution: bool,\n    /// Supports parallel processing\n    pub parallel_processing: bool,\n    /// Supports incremental processing\n    pub incremental_processing: bool,\n    /// Requires network access\n    pub requires_network: bool,\n    /// Maximum supported input size\n    pub max_input_size: Option<usize>,\n}",
      "current_ind": 1,
      "entity_name": "ToolCapabilities",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ToolCapabilities\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":125,\"end\":136},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ToolCapabilities:__crates_parseltongue-core_src_interfaces_rs:125-136",
      "line_number": 0
    },
    {
      "current_code": "pub struct ToolFactory;",
      "current_ind": 1,
      "entity_name": "ToolFactory",
      "entity_type": "struct",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lib.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ToolFactory\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lib.rs\",\"line_range\":{\"start\":77,\"end\":77},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ToolFactory:__crates_pt01-folder-to-cozodb-streamer_src_lib_rs:77-77",
      "line_number": 0
    },
    {
      "current_code": "pub struct ToolMetadata {\n    /// Tool identifier\n    pub id: String,\n    /// Tool name\n    pub name: String,\n    /// Tool version\n    pub version: String,\n    /// Tool description\n    pub description: String,\n    /// Supported input types\n    pub supported_inputs: Vec<String>,\n    /// Tool capabilities\n    pub capabilities: ToolCapabilities,\n}",
      "current_ind": 1,
      "entity_name": "ToolMetadata",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ToolMetadata\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":108,\"end\":121},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ToolMetadata:__crates_parseltongue-core_src_interfaces_rs:108-121",
      "line_number": 0
    },
    {
      "current_code": "pub struct TraitImpl {\n    /// Trait being implemented\n    pub trait_name: String,\n    /// Type implementing the trait\n    pub for_type: String,\n}",
      "current_ind": 1,
      "entity_name": "TraitImpl",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TraitImpl\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":350,\"end\":355},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TraitImpl:__crates_parseltongue-core_src_entities_rs:350-355",
      "line_number": 0
    },
    {
      "current_code": "    pub struct TranslationUnit {\n        pub declarations: Vec<Declaration>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "TranslationUnit",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TranslationUnit\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":275,\"end\":278},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TranslationUnit:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:275-278",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Type {\n        pub base: BaseType,\n        pub qualifiers: Vec<TypeQualifier>,\n        pub pointer_level: usize,\n    }",
      "current_ind": 1,
      "entity_name": "Type",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Type\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":298,\"end\":302},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Type:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:298-302",
      "line_number": 0
    },
    {
      "current_code": "    pub struct TypeAlias {\n        pub name: String,\n        pub ty: Type,\n    }",
      "current_ind": 1,
      "entity_name": "TypeAlias",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TypeAlias\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":678,\"end\":681},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TypeAlias:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:678-681",
      "line_number": 0
    },
    {
      "current_code": "pub struct TypeInformation {\n    /// Resolved type\n    pub resolved_type: String,\n    /// Module path\n    pub module_path: Vec<String>,\n    /// Generic parameters\n    pub generic_parameters: Vec<String>,\n    /// Definition location\n    pub definition_location: Option<Location>,\n}",
      "current_ind": 1,
      "entity_name": "TypeInformation",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TypeInformation\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":557,\"end\":566},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TypeInformation:__crates_parseltongue-core_src_entities_rs:557-566",
      "line_number": 0
    },
    {
      "current_code": "pub struct TypeScriptSignature {\n    /// Function parameters with types\n    pub parameters: Vec<TypedParameter>,\n    /// Return type\n    pub return_type: Option<String>,\n    /// Generic parameters\n    pub generics: Vec<String>,\n    /// Async function\n    pub is_async: bool,\n}",
      "current_ind": 1,
      "entity_name": "TypeScriptSignature",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TypeScriptSignature\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":372,\"end\":381},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TypeScriptSignature:__crates_parseltongue-core_src_entities_rs:372-381",
      "line_number": 0
    },
    {
      "current_code": "pub struct TypedParameter {\n    pub name: String,\n    pub type_annotation: String,\n    pub optional: bool,\n}",
      "current_ind": 1,
      "entity_name": "TypedParameter",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TypedParameter\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":421,\"end\":425},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TypedParameter:__crates_parseltongue-core_src_entities_rs:421-425",
      "line_number": 0
    },
    {
      "current_code": "    pub struct TypedefDecl {\n        pub name: String,\n        pub ty: Type,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "TypedefDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"TypedefDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":472,\"end\":476},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:TypedefDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:472-476",
      "line_number": 0
    },
    {
      "current_code": "    pub struct UnlessStatement {\n        pub condition: Expression,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "UnlessStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"UnlessStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":976,\"end\":979},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:UnlessStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:976-979",
      "line_number": 0
    },
    {
      "current_code": "pub struct UsageAnalysis {\n    /// Total references\n    pub total_references: usize,\n    /// Usage locations\n    pub usage_locations: Vec<Location>,\n    /// Dependent entities\n    pub dependents: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "UsageAnalysis",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/entities.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"UsageAnalysis\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/entities.rs\",\"line_range\":{\"start\":570,\"end\":577},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:UsageAnalysis:__crates_parseltongue-core_src_entities_rs:570-577",
      "line_number": 0
    },
    {
      "current_code": "    pub struct UsingDecl {\n        pub name: String,\n        pub target: String,\n    }",
      "current_ind": 1,
      "entity_name": "UsingDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"UsingDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":690,\"end\":693},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:UsingDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:690-693",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidTransitionsRule {\n    _private: (),\n}",
      "current_ind": 1,
      "entity_name": "ValidTransitionsRule",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidTransitionsRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":356,\"end\":358},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidTransitionsRule:__crates_parseltongue-core_src_temporal_rs:356-358",
      "line_number": 0
    },
    {
      "current_code": "    pub struct Validation {\n        pub attribute: String,\n        pub kind: ValidationKind,\n        pub options: HashMap<String, Value>,\n    }",
      "current_ind": 1,
      "entity_name": "Validation",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Validation\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":734,\"end\":738},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Validation:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:734-738",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationError {\n    pub field: String,\n    pub expected: String,\n    pub actual: String,\n    pub message: String,\n}",
      "current_ind": 1,
      "entity_name": "ValidationError",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationError\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":356,\"end\":361},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationError:__crates_parseltongue-core_src_interfaces_rs:356-361",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationOutput {\n    /// Whether the validation passed\n    pub is_valid: bool,\n    /// Type of validation performed\n    pub validation_type: ValidationType,\n    /// Errors encountered during validation\n    pub errors: Vec<String>,\n    /// Warnings (non-blocking issues)\n    pub warnings: Vec<String>,\n    /// Execution time in milliseconds\n    pub execution_time_ms: u64,\n    /// Memory usage in bytes\n    pub memory_usage_bytes: usize,\n}",
      "current_ind": 1,
      "entity_name": "ValidationOutput",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationOutput\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":48,\"end\":61},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationOutput:__crates_pt04-syntax-preflight-validator_src_types_rs:48-61",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationReport {\n    /// Path to file being validated (if applicable)\n    pub file_path: Option<PathBuf>,\n    /// Code snippet that was validated\n    pub code_snippet: String,\n    /// Individual validation results\n    pub individual_results: Vec<ValidationOutput>,\n    /// Overall validation status (all checks must pass)\n    pub overall_valid: bool,\n    /// Total execution time across all validations\n    pub total_execution_time_ms: u64,\n    /// Total memory usage across all validations\n    pub total_memory_usage_bytes: usize,\n    /// When this report was generated\n    pub generated_at: DateTime<Utc>,\n}",
      "current_ind": 1,
      "entity_name": "ValidationReport",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationReport\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/types.rs\",\"line_range\":{\"start\":98,\"end\":113},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationReport:__crates_pt04-syntax-preflight-validator_src_types_rs:98-113",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationResult {\n    pub entity: String,\n    pub level: ValidationLevel,\n    pub passed: bool,\n    pub errors: Vec<String>,\n    pub warnings: Vec<String>,\n    pub duration_ms: u64,\n}",
      "current_ind": 1,
      "entity_name": "ValidationResult",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":472,\"end\":479},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationResult:__crates_parseltongue-core_src_interfaces_rs:472-479",
      "line_number": 0
    },
    {
      "current_code": "struct ValidationResult {\n    is_valid: bool,\n    errors: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "ValidationResult",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-e2e-tests/tests/complete_workflow_test.rs\",\"line_range\":{\"start\":285,\"end\":288},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationResult:__crates_parseltongue-e2e-tests_tests_complete_workflow_test_rs:285-288",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationResult {\n    /// Whether syntax is valid\n    pub is_valid: bool,\n    /// List of error messages (empty if valid)\n    pub errors: Vec<String>,\n}",
      "current_ind": 1,
      "entity_name": "ValidationResult",
      "entity_type": "struct",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/simple_validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/simple_validator.rs\",\"line_range\":{\"start\":148,\"end\":153},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationResult:__crates_pt04-syntax-preflight-validator_src_simple_validator_rs:148-153",
      "line_number": 0
    },
    {
      "current_code": "pub struct ValidationRule {\n    pub field: String,\n    pub constraint: String,\n}",
      "current_ind": 1,
      "entity_name": "ValidationRule",
      "entity_type": "struct",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ValidationRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":323,\"end\":326},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ValidationRule:__crates_parseltongue-core_src_interfaces_rs:323-326",
      "line_number": 0
    },
    {
      "current_code": "    pub struct VariableDecl {\n        pub name: String,\n        pub ty: Type,\n        pub initializer: Option<Expression>,\n        pub source_range: SourceRange,\n    }",
      "current_ind": 1,
      "entity_name": "VariableDecl",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"VariableDecl\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":464,\"end\":469},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:VariableDecl:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:464-469",
      "line_number": 0
    },
    {
      "current_code": "pub struct Version(pub u64);",
      "current_ind": 1,
      "entity_name": "Version",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"Version\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":245,\"end\":245},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:Version:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:245-245",
      "line_number": 0
    },
    {
      "current_code": "    pub struct ViewFile {\n        pub template_type: TemplateType,\n        pub content: String,\n        pub embedded_ruby: Vec<EmbeddedRuby>,\n    }",
      "current_ind": 1,
      "entity_name": "ViewFile",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"ViewFile\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1023,\"end\":1027},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:ViewFile:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1023-1027",
      "line_number": 0
    },
    {
      "current_code": "    pub struct WhileStatement {\n        pub condition: Expression,\n        pub body: Box<Statement>,\n    }",
      "current_ind": 1,
      "entity_name": "WhileStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"WhileStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":499,\"end\":502},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:WhileStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:499-502",
      "line_number": 0
    },
    {
      "current_code": "    pub struct WhileStatement {\n        pub condition: Expression,\n        pub body: Block,\n    }",
      "current_ind": 1,
      "entity_name": "WhileStatement",
      "entity_type": "struct",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"WhileStatement\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":982,\"end\":985},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:WhileStatement:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:982-985",
      "line_number": 0
    },
    {
      "current_code": "pub struct WriteResult {\n    /// Whether the operation succeeded\n    pub success: bool,\n    /// Path to the file that was written/deleted\n    pub file_path: PathBuf,\n    /// Type of operation performed\n    pub operation: WriteOperation,\n    /// Optional message describing the result\n    pub message: Option<String>,\n}",
      "current_ind": 1,
      "entity_name": "WriteResult",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"WriteResult\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":6,\"end\":15},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:WriteResult:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:6-15",
      "line_number": 0
    },
    {
      "current_code": "pub struct WriteSummary {\n    /// Number of files created\n    pub created: usize,\n    /// Number of files edited\n    pub edited: usize,\n    /// Number of files deleted\n    pub deleted: usize,\n    /// Total number of operations\n    pub total: usize,\n    /// Number of errors encountered\n    pub errors: usize,\n}",
      "current_ind": 1,
      "entity_name": "WriteSummary",
      "entity_type": "struct",
      "file_path": "./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Struct\",\"name\":\"WriteSummary\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt05-llm-cozodb-to-diff-writer/src/types.rs\",\"line_range\":{\"start\":60,\"end\":71},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:struct:WriteSummary:__crates_pt05-llm-cozodb-to-diff-writer_src_types_rs:60-71",
      "line_number": 0
    },
    {
      "current_code": "pub trait Ast: std::fmt::Debug + Clone {\n    fn node_type(&self) -> NodeType;\n    fn children(&self) -> Vec<&dyn Ast>;\n    fn source_range(&self) -> SourceRange;\n    fn accept<V: AstVisitor>(&self, visitor: &mut V) -> V::Output;\n}",
      "current_ind": 1,
      "entity_name": "Ast",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"Ast\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":15,\"end\":20},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:Ast:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:15-20",
      "line_number": 0
    },
    {
      "current_code": "pub trait AstDelta {\n    type Node: Ast;\n    \n    fn additions(&self) -> &[Self::Node];\n    fn deletions(&self) -> &[NodeId];\n    fn modifications(&self) -> &[(NodeId, Self::Node)];\n}",
      "current_ind": 1,
      "entity_name": "AstDelta",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"AstDelta\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":118,\"end\":124},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:AstDelta:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:118-124",
      "line_number": 0
    },
    {
      "current_code": "pub trait AstVisitor {\n    type Output;\n    \n    fn visit_node(&mut self, node: &dyn Ast) -> Self::Output;\n    fn visit_children(&mut self, node: &dyn Ast) -> Vec<Self::Output> {\n        node.children().iter().map(|child| child.accept(self)).collect()\n    }\n}",
      "current_ind": 1,
      "entity_name": "AstVisitor",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"AstVisitor\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":23,\"end\":30},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:AstVisitor:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:23-30",
      "line_number": 0
    },
    {
      "current_code": "pub trait CodeGraphRepository: Send + Sync {\n    /// Store a code entity\n    async fn store_entity(&mut self, entity: CodeEntity) -> Result<()>;\n\n    /// Retrieve an entity by ISGL1 key\n    async fn get_entity(&self, isgl1_key: &str) -> Result<Option<CodeEntity>>;\n\n    /// Update an entity\n    async fn update_entity(&mut self, entity: CodeEntity) -> Result<()>;\n\n    /// Delete an entity\n    async fn delete_entity(&mut self, isgl1_key: &str) -> Result<()>;\n\n    /// Query entities with temporal filters\n    async fn query_entities(&self, query: &TemporalQuery) -> Result<Vec<CodeEntity>>;\n\n    /// Get all entities that will change\n    async fn get_changed_entities(&self) -> Result<Vec<CodeEntity>>;\n\n    /// Reset temporal state (Tool 6 operation)\n    async fn reset_temporal_state(&mut self) -> Result<()>;\n}",
      "current_ind": 1,
      "entity_name": "CodeGraphRepository",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"CodeGraphRepository\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":143,\"end\":164},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:CodeGraphRepository:__crates_parseltongue-core_src_interfaces_rs:143-164",
      "line_number": 0
    },
    {
      "current_code": "pub trait CodeGraphRepository: Send + Sync {\n    /// Get all entities from CodeGraph relation\n    async fn get_all_entities(&self) -> Result<Vec<Entity>>;\n\n    /// Query entities with Datalog WHERE clause\n    async fn query_entities(&self, where_clause: &str) -> Result<Vec<Entity>>;\n\n    /// Get all dependency edges from DependencyEdges relation\n    async fn get_all_edges(&self) -> Result<Vec<Edge>>;\n\n    /// Query edges with Datalog WHERE clause\n    async fn query_edges(&self, where_clause: &str) -> Result<Vec<Edge>>;\n}",
      "current_ind": 1,
      "entity_name": "CodeGraphRepository",
      "entity_type": "trait",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"CodeGraphRepository\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":96,\"end\":108},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:CodeGraphRepository:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:96-108",
      "line_number": 0
    },
    {
      "current_code": "pub trait CodeValidator: Send + Sync {\n    /// Validate syntax only\n    async fn validate_syntax(&self, code: &str) -> Result<ValidationOutput>;\n\n    /// Validate types (requires compilation context)\n    async fn validate_types(&self, code: &str) -> Result<ValidationOutput>;\n\n    /// Validate borrow checker rules (Rust-specific)\n    async fn validate_borrow_checker(&self, code: &str) -> Result<ValidationOutput>;\n\n    /// Validate compilation\n    async fn validate_compilation(&self, code: &str) -> Result<ValidationOutput>;\n\n    /// Run tests\n    async fn validate_tests(&self, code: &str) -> Result<ValidationOutput>;\n\n    /// Run all validations and generate comprehensive report\n    async fn validate_all(&self, code: &str) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        // Run validations in order, stop on first failure\n        for validation_type in ValidationType::all() {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            // Stop on first failure (fail-fast for efficiency)\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }\n\n    /// Validate specific types only\n    async fn validate_specific(&self, code: &str, types: Vec<ValidationType>) -> Result<ValidationReport> {\n        let mut report = ValidationReport::new(None, code.to_string());\n\n        for validation_type in types {\n            let result = match validation_type {\n                ValidationType::Syntax => self.validate_syntax(code).await?,\n                ValidationType::Type => self.validate_types(code).await?,\n                ValidationType::BorrowChecker => self.validate_borrow_checker(code).await?,\n                ValidationType::Compilation => self.validate_compilation(code).await?,\n                ValidationType::Test => self.validate_tests(code).await?,\n            };\n\n            let is_valid = result.is_valid;\n            report.add_result(result);\n\n            if !is_valid {\n                break;\n            }\n        }\n\n        Ok(report)\n    }\n}",
      "current_ind": 1,
      "entity_name": "CodeValidator",
      "entity_type": "trait",
      "file_path": "./crates/pt04-syntax-preflight-validator/src/validator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"CodeValidator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt04-syntax-preflight-validator/src/validator.rs\",\"line_range\":{\"start\":8,\"end\":73},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:CodeValidator:__crates_pt04-syntax-preflight-validator_src_validator_rs:8-73",
      "line_number": 0
    },
    {
      "current_code": "pub trait ContextGenerator: Send + Sync {\n    /// Generate context from entities\n    async fn generate_context(&self, entities: Vec<CodeEntity>, query: &ContextQuery) -> Result<CodeGraphContext>;\n\n    /// Optimize context for token limits\n    fn optimize_context(&self, context: &mut CodeGraphContext, token_limit: usize) -> Result<()>;\n\n    /// Calculate token count\n    fn estimate_tokens(&self, context: &CodeGraphContext) -> usize;\n}",
      "current_ind": 1,
      "entity_name": "ContextGenerator",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"ContextGenerator\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":375,\"end\":384},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:ContextGenerator:__crates_parseltongue-core_src_interfaces_rs:375-384",
      "line_number": 0
    },
    {
      "current_code": "pub trait ErrorRecovery {\n    /// Attempt to recover from the given error\n    fn recover(&self, error: &ParseltongError) -> Result<RecoveryAction>;\n}",
      "current_ind": 1,
      "entity_name": "ErrorRecovery",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/error.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"ErrorRecovery\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/error.rs\",\"line_range\":{\"start\":138,\"end\":141},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:ErrorRecovery:__crates_parseltongue-core_src_error_rs:138-141",
      "line_number": 0
    },
    {
      "current_code": "pub trait FileStreamer: Send + Sync {\n    /// Stream all files from the configured directory to database\n    async fn stream_directory(&self) -> Result<StreamResult>;\n\n    /// Stream a single file to database\n    async fn stream_file(&self, file_path: &Path) -> Result<FileResult>;\n\n    /// Get current streaming statistics\n    fn get_stats(&self) -> StreamStats;\n}",
      "current_ind": 1,
      "entity_name": "FileStreamer",
      "entity_type": "trait",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"FileStreamer\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/streamer.rs\",\"line_range\":{\"start\":25,\"end\":34},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:FileStreamer:__crates_pt01-folder-to-cozodb-streamer_src_streamer_rs:25-34",
      "line_number": 0
    },
    {
      "current_code": "pub trait IncrementalParser: Parser {\n    type Cache: ParseCache;\n    type Delta: AstDelta;\n    \n    fn parse_incremental(\n        &self,\n        input: Self::Input,\n        cache: &mut Self::Cache,\n        edits: &[TextEdit],\n    ) -> Result<Self::Delta, Self::Error>;\n    \n    fn apply_delta(&self, ast: &Self::Output, delta: Self::Delta) \n        -> Result<Self::Output, Self::Error>;\n}",
      "current_ind": 1,
      "entity_name": "IncrementalParser",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"IncrementalParser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":85,\"end\":98},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:IncrementalParser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:85-98",
      "line_number": 0
    },
    {
      "current_code": "pub trait IsgBuilder {\n    type Ast: Ast;\n    type Error: std::error::Error;\n    \n    fn build(&mut self, ast: &Self::Ast) -> Result<IncrementalSemanticGraph, Self::Error>;\n    fn update(&mut self, graph: &IncrementalSemanticGraph, delta: &dyn AstDelta) \n        -> Result<IncrementalSemanticGraph, Self::Error>;\n}",
      "current_ind": 1,
      "entity_name": "IsgBuilder",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"IsgBuilder\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":252,\"end\":259},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:IsgBuilder:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:252-259",
      "line_number": 0
    },
    {
      "current_code": "pub trait Isgl1KeyGenerator: Send + Sync {\n    /// Generate ISGL1 key from parsed code entity\n    fn generate_key(&self, entity: &ParsedEntity) -> Result<String>;\n\n    /// Parse source code into structured entities AND dependency edges\n    ///\n    /// Returns (entities, dependencies) where dependencies contains function calls,\n    /// type usages, and trait implementations extracted during the same tree-sitter pass.\n    ///\n    /// # Performance\n    /// Single-pass extraction: adds ~5-10% overhead vs entity-only extraction\n    fn parse_source(&self, source: &str, file_path: &Path) -> Result<(Vec<ParsedEntity>, Vec<DependencyEdge>)>;\n\n    /// Get supported language for file extension\n    fn get_language_type(&self, file_path: &Path) -> Result<Language>;\n}",
      "current_ind": 1,
      "entity_name": "Isgl1KeyGenerator",
      "entity_type": "trait",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"Isgl1KeyGenerator\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/isgl1_generator.rs\",\"line_range\":{\"start\":25,\"end\":40},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:Isgl1KeyGenerator:__crates_pt01-folder-to-cozodb-streamer_src_isgl1_generator_rs:25-40",
      "line_number": 0
    },
    {
      "current_code": "pub trait LanguageParser: Send + Sync {\n    /// Parse a file and extract entities\n    async fn parse_file(&self, file_path: &PathBuf) -> Result<Vec<InterfaceChunk>>;\n\n    /// Extract interfaces from source code\n    async fn extract_interfaces(&self, code: &str, language: Language) -> Result<Vec<InterfaceChunk>>;\n\n    /// Detect language from content\n    fn detect_language(&self, content: &str) -> Option<Language>;\n\n    /// Get supported languages\n    fn supported_languages(&self) -> Vec<Language>;\n}",
      "current_ind": 1,
      "entity_name": "LanguageParser",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"LanguageParser\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":185,\"end\":197},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:LanguageParser:__crates_parseltongue-core_src_interfaces_rs:185-197",
      "line_number": 0
    },
    {
      "current_code": "pub trait LevelExporter: Send + Sync {\n    /// Export entities at this level\n    ///\n    /// # Arguments\n    /// - `db`: Database connection (trait object for testability)\n    /// - `config`: Export configuration (level, filters, output path)\n    ///\n    /// # Returns\n    /// `ExportOutput` with metadata + data (edges OR entities)\n    ///\n    /// # Errors\n    /// - Database query failures\n    /// - Invalid WHERE clause syntax\n    /// - Missing required fields in database\n    ///\n    /// # Example\n    /// ```rust,ignore\n    /// let db = CozoDbClient::new(\"parseltongue.db\").await?;\n    /// let config = ExportConfig { level: 0, where_filter: \"ALL\".to_string(), ... };\n    /// let output = exporter.export(&db, &config).await?;\n    /// ```\n    async fn export(&self, db: &dyn CodeGraphRepository, config: &ExportConfig) -> Result<ExportOutput>;\n\n    /// Get level number (0, 1, 2)\n    ///\n    /// Used for validation and metadata generation.\n    fn level(&self) -> u8;\n\n    /// Get estimated token count (without code)\n    ///\n    /// Based on Challenge03 token analysis:\n    /// - Level 0: ~2-5K tokens (edge list)\n    /// - Level 1: ~30K tokens (node-centric + ISG)\n    /// - Level 2: ~60K tokens (+ type system)\n    ///\n    /// # Note\n    /// With `--include-code 1`, multiply by ~10-100 depending on code size.\n    fn estimated_tokens(&self) -> usize;\n}",
      "current_ind": 1,
      "entity_name": "LevelExporter",
      "entity_type": "trait",
      "file_path": "./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"LevelExporter\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt02-llm-cozodb-to-context-writer/src/export_trait.rs\",\"line_range\":{\"start\":45,\"end\":83},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:LevelExporter:__crates_pt02-llm-cozodb-to-context-writer_src_export_trait_rs:45-83",
      "line_number": 0
    },
    {
      "current_code": "pub trait LlmClient: Send + Sync {\n    /// Send request to LLM\n    async fn send_request(&self, request: LlmRequest) -> Result<LlmResponse>;\n\n    /// Validate response format\n    fn validate_response(&self, response: &LlmResponse, request: &LlmRequest) -> Result<()>;\n\n    /// Get rate limit status\n    async fn get_rate_limit_status(&self) -> Result<RateLimitStatus>;\n\n    /// Estimate token count\n    fn estimate_tokens(&self, content: &str) -> usize;\n}",
      "current_ind": 1,
      "entity_name": "LlmClient",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"LlmClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":263,\"end\":275},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:LlmClient:__crates_parseltongue-core_src_interfaces_rs:263-275",
      "line_number": 0
    },
    {
      "current_code": "pub trait LspClient: Send + Sync {\n    /// Start the LSP server\n    async fn start_server(&mut self) -> Result<()>;\n\n    /// Get semantic tokens for a file\n    async fn get_semantic_tokens(&self, file_path: &str) -> Result<Vec<SemanticToken>>;\n\n    /// Get type information for a position\n    async fn get_type_info(&self, position: &Position) -> Result<TypeInformation>;\n\n    /// Get usage analysis for an entity\n    async fn get_usage_analysis(&self, isgl1_key: &str) -> Result<UsageAnalysis>;\n\n    /// Get implementation locations\n    async fn get_implementations(&self, position: &Position) -> Result<Vec<Location>>;\n\n    /// Shutdown the LSP server\n    async fn shutdown_server(&mut self) -> Result<()>;\n\n    /// Health check\n    async fn health_check(&self) -> Result<HealthStatus>;\n}",
      "current_ind": 1,
      "entity_name": "LspClient",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"LspClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":220,\"end\":241},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:LspClient:__crates_parseltongue-core_src_interfaces_rs:220-241",
      "line_number": 0
    },
    {
      "current_code": "pub trait ParseCache: Default {\n    type Key: Eq + std::hash::Hash;\n    type Value: Clone;\n    \n    fn get(&self, key: &Self::Key) -> Option<&Self::Value>;\n    fn insert(&mut self, key: Self::Key, value: Self::Value);\n    fn invalidate(&mut self, key: &Self::Key);\n    fn clear(&mut self);\n}",
      "current_ind": 1,
      "entity_name": "ParseCache",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"ParseCache\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":101,\"end\":109},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:ParseCache:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:101-109",
      "line_number": 0
    },
    {
      "current_code": "pub trait Parser: Send + Sync {\n    type Input: AsRef<str>;\n    type Output: Ast;\n    type Error: std::error::Error + Send + Sync + 'static;\n    type Config: Default;\n    \n    fn parse(&self, input: Self::Input) -> Result<Self::Output, Self::Error>;\n    fn parse_with_config(&self, input: Self::Input, config: Self::Config) \n        -> Result<Self::Output, Self::Error>;\n}",
      "current_ind": 1,
      "entity_name": "Parser",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"Parser\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":73,\"end\":82},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:Parser:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:73-82",
      "line_number": 0
    },
    {
      "current_code": "    pub trait ParserCombinator<'a, T>: Sized {\n        fn parse(&self, input: &'a str) -> ParseResult<'a, T>;\n        \n        /// Map the output of this parser\n        fn map<U, F>(self, f: F) -> Map<Self, F>\n        where\n            F: Fn(T) -> U,\n        {\n            Map { parser: self, mapper: f }\n        }\n        \n        /// Sequence two parsers\n        fn then<U, P>(self, other: P) -> Then<Self, P>\n        where\n            P: ParserCombinator<'a, U>,\n        {\n            Then { first: self, second: other }\n        }\n        \n        /// Try this parser, or fallback to another\n        fn or<P>(self, other: P) -> Or<Self, P>\n        where\n            P: ParserCombinator<'a, T>,\n        {\n            Or { first: self, second: other }\n        }\n        \n        /// Make this parser optional\n        fn optional(self) -> Optional<Self> {\n            Optional { parser: self }\n        }\n        \n        /// Parse zero or more times\n        fn many(self) -> Many<Self> {\n            Many { parser: self }\n        }\n        \n        /// Parse one or more times\n        fn many1(self) -> Many1<Self> {\n            Many1 { parser: self }\n        }\n    }",
      "current_ind": 1,
      "entity_name": "ParserCombinator",
      "entity_type": "trait",
      "file_path": "./.journalDocs/randomLogs/isg_ingestion_interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"ParserCombinator\",\"visibility\":\"Public\",\"file_path\":\"./.journalDocs/randomLogs/isg_ingestion_interfaces.rs\",\"line_range\":{\"start\":1145,\"end\":1186},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:ParserCombinator:___journalDocs_randomLogs_isg_ingestion_interfaces_rs:1145-1186",
      "line_number": 0
    },
    {
      "current_code": "pub trait PerformanceMonitor: Send + Sync {\n    /// Record operation start\n    async fn start_operation(&self, operation_id: &str, operation_type: &str);\n\n    /// Record operation completion\n    async fn complete_operation(\n        &self,\n        operation_id: &str,\n        duration: std::time::Duration,\n        success: bool,\n    );\n\n    /// Get performance metrics\n    async fn get_metrics(&self, operation_type: &str) -> Result<PerformanceMetrics>;\n\n    /// Check performance contracts\n    async fn check_contracts(&self) -> Result<Vec<PerformanceViolation>>;\n}",
      "current_ind": 1,
      "entity_name": "PerformanceMonitor",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"PerformanceMonitor\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":496,\"end\":513},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:PerformanceMonitor:__crates_parseltongue-core_src_interfaces_rs:496-513",
      "line_number": 0
    },
    {
      "current_code": "pub trait RustAnalyzerClient: Send + Sync {\n    /// Request hover metadata for a position in a Rust file\n    /// Returns None if rust-analyzer is unavailable or request fails (graceful degradation)\n    async fn hover(\n        &self,\n        file_path: &Path,\n        line: u32,\n        character: u32,\n    ) -> Result<Option<HoverResponse>>;\n\n    /// Check if rust-analyzer is available\n    async fn is_available(&self) -> bool;\n}",
      "current_ind": 1,
      "entity_name": "RustAnalyzerClient",
      "entity_type": "trait",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"RustAnalyzerClient\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/lsp_client.rs\",\"line_range\":{\"start\":47,\"end\":59},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:RustAnalyzerClient:__crates_pt01-folder-to-cozodb-streamer_src_lsp_client_rs:47-59",
      "line_number": 0
    },
    {
      "current_code": "pub trait TemporalValidationRule: Send + Sync + fmt::Debug {\n    /// Validate the current state\n    fn validate(&self, entities: &HashMap<String, CodeEntity>) -> Result<()>;\n}",
      "current_ind": 1,
      "entity_name": "TemporalValidationRule",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/temporal.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"TemporalValidationRule\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/temporal.rs\",\"line_range\":{\"start\":259,\"end\":262},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:TemporalValidationRule:__crates_parseltongue-core_src_temporal_rs:259-262",
      "line_number": 0
    },
    {
      "current_code": "pub trait TestDetector: Send + Sync {\n    /// Detect if file contains test code based on language and patterns\n    /// \n    /// # Performance Contract\n    /// - Completes in <20s per file\n    /// - Language detection cached for repeated operations\n    /// - Parse errors default to \"non-test\" classification\n    fn detect_test_from_path_and_name(&self, file_path: &Path, content: &str) -> EntityClass;\n}",
      "current_ind": 1,
      "entity_name": "TestDetector",
      "entity_type": "trait",
      "file_path": "./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"TestDetector\",\"visibility\":\"Public\",\"file_path\":\"./crates/pt01-folder-to-cozodb-streamer/src/test_detector.rs\",\"line_range\":{\"start\":15,\"end\":23},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:TestDetector:__crates_pt01-folder-to-cozodb-streamer_src_test_detector_rs:15-23",
      "line_number": 0
    },
    {
      "current_code": "pub trait Tool: Send + Sync {\n    /// Execute the tool with given input\n    async fn execute(&self, input: ToolInput) -> Result<ToolOutput>;\n\n    /// Validate input before execution\n    fn validate_input(&self, input: &ToolInput) -> Result<()>;\n\n    /// Get tool metadata\n    fn metadata(&self) -> ToolMetadata;\n}",
      "current_ind": 1,
      "entity_name": "Tool",
      "entity_type": "trait",
      "file_path": "./crates/parseltongue-core/src/interfaces.rs",
      "future_ind": 0,
      "interface_signature": "{\"entity_type\":\"Trait\",\"name\":\"Tool\",\"visibility\":\"Public\",\"file_path\":\"./crates/parseltongue-core/src/interfaces.rs\",\"line_range\":{\"start\":17,\"end\":26},\"module_path\":[],\"documentation\":null,\"language_specific\":{\"language\":\"rust\",\"generics\":[],\"lifetimes\":[],\"where_clauses\":[],\"attributes\":[],\"trait_impl\":null}}",
      "isgl1_key": "rust:trait:Tool:__crates_parseltongue-core_src_interfaces_rs:17-26",
      "line_number": 0
    }
  ]
}